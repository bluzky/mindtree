(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["mindtree"] = factory();
	else
		root["mindtree"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/non-layered-tidy-tree-layout/src/algorithm.js":
/*!*********************************************************************!*\
  !*** ../node_modules/non-layered-tidy-tree-layout/src/algorithm.js ***!
  \*********************************************************************/
/*! exports provided: Tree, layout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tree", function() { return Tree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "layout", function() { return layout; });
class Tree {
  constructor(width, height, y, children) {
    this.w = width
    this.h = height
    this.y = y
    this.c = children
    this.cs = children.length

    this.x = 0
    this.prelim = 0
    this.mod = 0
    this.shift = 0
    this.change = 0
    this.tl = null // Left thread
    this.tr = null // Right thread
    this.el = null // extreme left nodes
    this.er = null // extreme right nodes
    //sum of modifiers at the extreme nodes
    this.msel = 0
    this.mser = 0
  }
}

function setExtremes(tree) {
  if (tree.cs === 0) {
    tree.el = tree
    tree.er = tree
    tree.msel = tree.mser = 0
  } else {
    tree.el = tree.c[0].el
    tree.msel = tree.c[0].msel
    tree.er = tree.c[tree.cs - 1].er
    tree.mser = tree.c[tree.cs - 1].mser
  }
}

function bottom(tree) {
  return tree.y + tree.h
}

/* A linked list of the indexes of left siblings and their lowest vertical coordinate.
 */
class IYL {
  constructor(lowY, index, next) {
    this.lowY = lowY
    this.index = index
    this.next = next
  }
}

function updateIYL(minY, i, ih) {
  // Remove siblings that are hidden by the new subtree.
  while (ih !== null && minY >= ih.lowY) {
    // Prepend the new subtree
    ih = ih.next
  }
  return new IYL(minY, i, ih)
}

function distributeExtra(tree, i, si, distance) {
  // Are there intermediate children?
  if (si !== i - 1) {
    const nr = i - si
    tree.c[si + 1].shift += distance / nr
    tree.c[i].shift -= distance / nr
    tree.c[i].change -= distance - distance / nr
  }
}

function moveSubtree(tree, i, si, distance) {
  // Move subtree by changing mod.
  tree.c[i].mod += distance
  tree.c[i].msel += distance
  tree.c[i].mser += distance
  distributeExtra(tree, i, si, distance)
}

function nextLeftContour(tree) {
  return tree.cs === 0 ? tree.tl : tree.c[0]
}

function nextRightContour(tree) {
  return tree.cs === 0 ? tree.tr : tree.c[tree.cs - 1]
}

function setLeftThread(tree, i, cl, modsumcl) {
  const li = tree.c[0].el
  li.tl = cl
  // Change mod so that the sum of modifier after following thread is correct.
  const diff = (modsumcl - cl.mod) - tree.c[0].msel
  li.mod += diff
  // Change preliminary x coordinate so that the node does not move.
  li.prelim -= diff
  // Update extreme node and its sum of modifiers.
  tree.c[0].el = tree.c[i].el
  tree.c[0].msel = tree.c[i].msel
}

// Symmetrical to setLeftThread
function setRightThread(tree, i, sr, modsumsr) {
  const ri = tree.c[i].er
  ri.tr = sr
  const diff = (modsumsr - sr.mod) - tree.c[i].mser
  ri.mod += diff
  ri.prelim -= diff
  tree.c[i].er = tree.c[i - 1].er
  tree.c[i].mser = tree.c[i - 1].mser
}

function seperate(tree, i, ih) {
  // Right contour node of left siblings and its sum of modifiers.
  let sr = tree.c[i - 1]
  let mssr = sr.mod
  // Left contour node of right siblings and its sum of modifiers.
  let cl = tree.c[i]
  let mscl = cl.mod
  while (sr !== null && cl !== null) {
    if (bottom(sr) > ih.lowY) {
      ih = ih.next
    }
    // How far to the left of the right side of sr is the left side of cl.
    const distance = mssr + sr.prelim + sr.w - (mscl + cl.prelim)
    if (distance > 0) {
      mscl += distance
      moveSubtree(tree, i, ih.index, distance)
    }

    const sy = bottom(sr)
    const cy = bottom(cl)
    if (sy <= cy) {
      sr = nextRightContour(sr)
      if (sr !== null) {
        mssr += sr.mod
      }
    }
    if (sy >= cy) {
      cl = nextLeftContour(cl)
      if (cl !== null) {
        mscl += cl.mod
      }
    }
  }

  // Set threads and update extreme nodes.
  // In the first case, the current subtree must be taller than the left siblings.
  if (sr === null && cl !== null) {
    setLeftThread(tree, i, cl, mscl)
  } else if (sr !== null && cl === null) {
    setRightThread(tree, i, sr, mssr)
  }
}

function positionRoot(tree) {
  // Position root between children, taking into account their mod.
  tree.prelim =
    (tree.c[0].prelim +
      tree.c[0].mod +
      tree.c[tree.cs - 1].mod +
      tree.c[tree.cs - 1].prelim +
      tree.c[tree.cs - 1].w) /
      2 -
    tree.w / 2
}

function firstWalk(tree) {
  if (tree.cs === 0) {
    setExtremes(tree)
    return
  }

  firstWalk(tree.c[0])
  let ih = updateIYL(bottom(tree.c[0].el), 0, null)
  for (let i = 1; i < tree.cs; i++) {
    firstWalk(tree.c[i])
    const minY = bottom(tree.c[i].er)
    seperate(tree, i, ih)
    ih = updateIYL(minY, i, ih)
  }
  positionRoot(tree)
  setExtremes(tree)
}

function addChildSpacing(tree) {
  let d = 0
  let modsumdelta = 0
  for (let i = 0; i < tree.cs; i++) {
    d += tree.c[i].shift
    modsumdelta += d + tree.c[i].change
    tree.c[i].mod += modsumdelta
  }
}

function secondWalk(tree, modsum) {
  modsum += tree.mod
  // Set absolute (no-relative) horizontal coordinates.
  tree.x = tree.prelim + modsum
  addChildSpacing(tree)
  for (let i = 0; i < tree.cs; i++) {
    secondWalk(tree.c[i], modsum)
  }
}

function layout(tree) {
  firstWalk(tree)
  secondWalk(tree, 0)
}




/***/ }),

/***/ "../node_modules/non-layered-tidy-tree-layout/src/helpers.js":
/*!*******************************************************************!*\
  !*** ../node_modules/non-layered-tidy-tree-layout/src/helpers.js ***!
  \*******************************************************************/
/*! exports provided: Layout, BoundingBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layout", function() { return Layout; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoundingBox", function() { return BoundingBox; });
/* harmony import */ var _algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algorithm */ "../node_modules/non-layered-tidy-tree-layout/src/algorithm.js");


class BoundingBox {
  /**
   * @param {number} gap - the gap between sibling nodes
   * @param {number} bottomPadding - the height reserved for connection drawing
   */
  constructor(gap, bottomPadding) {
    this.gap = gap
    this.bottomPadding = bottomPadding
  }

  addBoundingBox(width, height) {
    return { width: width + this.gap, height: height + this.bottomPadding }
  }

  /**
   * Return the coordinate without the bounding box for a node
   */
  removeBoundingBox(x, y) {
    return { x: x + this.gap / 2, y }
  }
}

class Layout {
  constructor(boundingBox) {
    this.bb = boundingBox
  }

  /**
   * Layout treeData.
   * Return modified treeData and the bounding box encompassing all the nodes.
   * 
   * See getSize() for more explanation.
   */
  layout(treeData) {
    const tree = this.convert(treeData)
    Object(_algorithm__WEBPACK_IMPORTED_MODULE_0__["layout"])(tree)
    const { boundingBox, result } = this.assignLayout(tree, treeData)

    return { result, boundingBox }
  }

  /**
   * Returns Tree to layout, with bounding boxes added to each node.
   */
  convert(treeData, y = 0) {
    if (treeData === null) return null

    const { width, height } = this.bb.addBoundingBox(
      treeData.width,
      treeData.height
    )
    let children = []
    if (treeData.children && treeData.children.length) {
      for (let i = 0; i < treeData.children.length; i++) {
        children[i] = this.convert(treeData.children[i], y + height)
      }
    }

    return new _algorithm__WEBPACK_IMPORTED_MODULE_0__["Tree"](width, height, y, children)
  }

  /**
   * Assign layout tree x, y coordinates back to treeData,
   * with bounding boxes removed.
   */
  assignCoordinates(tree, treeData) {
    const { x, y } = this.bb.removeBoundingBox(tree.x, tree.y)
    treeData.x = x
    treeData.y = y
    for (let i = 0; i < tree.c.length; i++) {
      this.assignCoordinates(tree.c[i], treeData.children[i])
    }
  }

  /**
   * Return the bounding box that encompasses all the nodes.
   * The result has a structure of
   * { left: number, right: number, top: number, bottom: nubmer}.
   * This is not the same bounding box concept as the `BoundingBox` class
   * used to construct `Layout` class.
   */
  getSize(treeData, box = null) {
    const { x, y, width, height } = treeData
    if (box === null) {
      box = { left: x, right: x + width, top: y, bottom: y + height }
    }
    box.left = Math.min(box.left, x)
    box.right = Math.max(box.right, x + width)
    box.top = Math.min(box.top, y)
    box.bottom = Math.max(box.bottom, y + height)

    if (treeData.children) {
      for (const child of treeData.children) {
        this.getSize(child, box)
      }
    }

    return box
  }

  /**
   * This function does assignCoordinates and getSize in one pass.
   */
  assignLayout(tree, treeData, box = null) {
    const { x, y } = this.bb.removeBoundingBox(tree.x, tree.y)
    treeData.x = x
    treeData.y = y

    const { width, height } = treeData
    if (box === null) {
      box = { left: x, right: x + width, top: y, bottom: y + height }
    }
    box.left = Math.min(box.left, x)
    box.right = Math.max(box.right, x + width)
    box.top = Math.min(box.top, y)
    box.bottom = Math.max(box.bottom, y + height)

    for (let i = 0; i < tree.c.length; i++) {
      this.assignLayout(tree.c[i], treeData.children[i], box)
    }

    return { result: treeData, boundingBox: box }
  }
}




/***/ }),

/***/ "../node_modules/non-layered-tidy-tree-layout/src/index.js":
/*!*****************************************************************!*\
  !*** ../node_modules/non-layered-tidy-tree-layout/src/index.js ***!
  \*****************************************************************/
/*! exports provided: layout, Tree, BoundingBox, Layout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _algorithm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algorithm */ "../node_modules/non-layered-tidy-tree-layout/src/algorithm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "layout", function() { return _algorithm__WEBPACK_IMPORTED_MODULE_0__["layout"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tree", function() { return _algorithm__WEBPACK_IMPORTED_MODULE_0__["Tree"]; });

/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "../node_modules/non-layered-tidy-tree-layout/src/helpers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BoundingBox", function() { return _helpers__WEBPACK_IMPORTED_MODULE_1__["BoundingBox"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Layout", function() { return _helpers__WEBPACK_IMPORTED_MODULE_1__["Layout"]; });






/***/ }),

/***/ "../node_modules/two.js/build/two.module.js":
/*!**************************************************!*\
  !*** ../node_modules/two.js/build/two.module.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, module) {/**

MIT License

Copyright (c) 2012 - 2020 jonobr1 / http://jonobr1.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

(undefined || self || window).Two = (function(previousTwo) {

  var root;
  if (typeof window !== 'undefined') {
    root = window;
  } else if (typeof global !== 'undefined') {
    root = global;
  } else if (typeof self !== 'undefined') {
    root = self;
  } else {
    root = this;
  }

  var toString = Object.prototype.toString;
  /**
   * @name _
   * @interface
   * @private
   * @description A collection of useful functions borrowed and repurposed from Underscore.js.
   * @see {@link http://underscorejs.org/}
   */
  var _ = {
    // http://underscorejs.org/ â€¢ 1.8.3
    _indexAmount: 0,
    natural: {
      slice: Array.prototype.slice,
      indexOf: Array.prototype.indexOf,
      keys: Object.keys,
      bind: Function.prototype.bind,
      create: Object.create
    },
    identity: function(value) {
      return value;
    },
    isArguments: function(obj) {
      return toString.call(obj) === '[object Arguments]';
    },
    isFunction: function(obj) {
      return toString.call(obj) === '[object Function]';
    },
    isString: function(obj) {
      return toString.call(obj) === '[object String]';
    },
    isNumber: function(obj) {
      return toString.call(obj) === '[object Number]';
    },
    isDate: function(obj) {
      return toString.call(obj) === '[object Date]';
    },
    isRegExp: function(obj) {
      return toString.call(obj) === '[object RegExp]';
    },
    isError: function(obj) {
      return toString.call(obj) === '[object Error]';
    },
    isFinite: function(obj) {
      return isFinite(obj) && !isNaN(parseFloat(obj));
    },
    isNaN: function(obj) {
      return _.isNumber(obj) && obj !== +obj;
    },
    isBoolean: function(obj) {
      return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
    },
    isNull: function(obj) {
      return obj === null;
    },
    isUndefined: function(obj) {
      return obj === void 0;
    },
    isEmpty: function(obj) {
      if (obj == null) return true;
      if (isArrayLike && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
      return _.keys(obj).length === 0;
    },
    isElement: function(obj) {
      return !!(obj && obj.nodeType === 1);
    },
    isArray: Array.isArray || function(obj) {
      return toString.call(obj) === '[object Array]';
    },
    isObject: function(obj) {
      var type = typeof obj;
      return type === 'function' || type === 'object' && !!obj;
    },
    toArray: function(obj) {
      if (!obj) {
        return [];
      }
      if (_.isArray(obj)) {
        return slice.call(obj);
      }
      if (isArrayLike(obj)) {
        return _.map(obj, _.identity);
      }
      return _.values(obj);
    },
    range: function(start, stop, step) {
      if (stop == null) {
        stop = start || 0;
        start = 0;
      }
      step = step || 1;

      var length = Math.max(Math.ceil((stop - start) / step), 0);
      var range = Array(length);

      for (var idx = 0; idx < length; idx++, start += step) {
        range[idx] = start;
      }

      return range;
    },
    indexOf: function(list, item) {
      if (_.natural.indexOf) {
        return _.natural.indexOf.call(list, item);
      }
      for (var i = 0; i < list.length; i++) {
        if (list[i] === item) {
          return i;
        }
      }
      return -1;
    },
    has: function(obj, key) {
      return obj != null && hasOwnProperty.call(obj, key);
    },
    bind: function(func, ctx) {
      var natural = _.natural.bind;
      if (natural && func.bind === natural) {
        return natural.apply(func, slice.call(arguments, 1));
      }
      var args = slice.call(arguments, 2);
      return function() {
        func.apply(ctx, args);
      };
    },
    extend: function(base) {
      var sources = slice.call(arguments, 1);
      for (var i = 0; i < sources.length; i++) {
        var obj = sources[i];
        for (var k in obj) {
          base[k] = obj[k];
        }
      }
      return base;
    },
    defaults: function(base) {
      var sources = slice.call(arguments, 1);
      for (var i = 0; i < sources.length; i++) {
        var obj = sources[i];
        for (var k in obj) {
          if (base[k] === void 0) {
            base[k] = obj[k];
          }
        }
      }
      return base;
    },
    keys: function(obj) {
      if (!_.isObject(obj)) {
        return [];
      }
      if (_.natural.keys) {
        return _.natural.keys(obj);
      }
      var keys = [];
      for (var k in obj) {
        if (_.has(obj, k)) {
          keys.push(k);
        }
      }
      return keys;
    },
    values: function(obj) {
      var keys = _.keys(obj);
      var values = [];
      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        values.push(obj[k]);
      }
      return values;
    },
    each: function(obj, iteratee, context) {
      var ctx = context || this;
      var keys = !isArrayLike(obj) && _.keys(obj);
      var length = (keys || obj).length;
      for (var i = 0; i < length; i++) {
        var k = keys ? keys[i] : i;
        iteratee.call(ctx, obj[k], k, obj);
      }
      return obj;
    },
    map: function(obj, iteratee, context) {
      var ctx = context || this;
      var keys = !isArrayLike(obj) && _.keys(obj);
      var length = (keys || obj).length;
      var result = [];
      for (var i = 0; i < length; i++) {
        var k = keys ? keys[i] : i;
        result[i] = iteratee.call(ctx, obj[k], k, obj);
      }
      return result;
    },
    once: function(func) {
      var init = false;
      return function() {
        if (init) {
          return func;
        }
        init = true;
        return func.apply(this, arguments);
      };
    },
    after: function(times, func) {
      return function() {
        while (--times < 1) {
          return func.apply(this, arguments);
        }
      };
    },
    uniqueId: function(prefix) {
      var id = ++_._indexAmount + '';
      return prefix ? prefix + id : id;
    }
  };

  // Constants

  var sin = Math.sin,
    cos = Math.cos,
    acos = Math.acos,
    atan2 = Math.atan2,
    sqrt = Math.sqrt,
    round = Math.round,
    abs = Math.abs,
    PI = Math.PI,
    TWO_PI = PI * 2,
    HALF_PI = PI / 2,
    pow = Math.pow,
    min = Math.min,
    max = Math.max;

  // Localized variables

  var count = 0;
  var slice = _.natural.slice;
  var perf = ((root.performance && root.performance.now) ? root.performance : Date);
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = function(obj) {
    return obj == null ? void 0 : obj['length'];
  };
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Cross browser dom events.

  var dom = {

    temp: (root.document ? root.document.createElement('div') : {}),

    hasEventListeners: _.isFunction(root.addEventListener),

    bind: function(elem, event, func, bool) {
      if (this.hasEventListeners) {
        elem.addEventListener(event, func, !!bool);
      } else {
        elem.attachEvent('on' + event, func);
      }
      return dom;
    },

    unbind: function(elem, event, func, bool) {
      if (dom.hasEventListeners) {
        elem.removeEventListeners(event, func, !!bool);
      } else {
        elem.detachEvent('on' + event, func);
      }
      return dom;
    },

    getRequestAnimationFrame: function() {

      var lastTime = 0;
      var vendors = ['ms', 'moz', 'webkit', 'o'];
      var request = root.requestAnimationFrame, cancel;

      if(!request) {
        for (var i = 0; i < vendors.length; i++) {
          request = root[vendors[i] + 'RequestAnimationFrame'] || request;
          cancel = root[vendors[i] + 'CancelAnimationFrame']
            || root[vendors[i] + 'CancelRequestAnimationFrame'] || cancel;
        }

        request = request || function(callback, element) {
          var currTime = new Date().getTime();
          var timeToCall = Math.max(0, 16 - (currTime - lastTime));
          var id = root.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);
          lastTime = currTime + timeToCall;
          return id;
        };
        // cancel = cancel || function(id) {
        //   clearTimeout(id);
        // };
      }

      request.init = _.once(loop);

      return request;

    }

  };

  /**
   * @name Two
   * @class
   * @global
   * @param {Object} [options]
   * @param {Boolean} [options.fullscreen=false] - Set to `true` to automatically make the stage adapt to the width and height of the parent document. This parameter overrides `width` and `height` parameters if set to `true`.
   * @param {Number} [options.width=640] - The width of the stage on construction. This can be set at a later time.
   * @param {Number} [options.height=480] - The height of the stage on construction. This can be set at a later time.
   * @param {String} [options.type=Two.Types.svg] - The type of renderer to setup drawing with. See {@link  Two.Types} for available options.
   * @param {Boolean} [options.autostart=false] - Set to `true` to add the instance to draw on `requestAnimationFrame`. This is a convenient substitute for {@link Two#play}.
   * @description The entrypoint for Two.js. Instantiate a `new Two` in order to setup a scene to render to. `Two` is also the publicly accessible namespace that all other sub-classes, functions, and utilities attach to.
   */
  var Two = root.Two = function(options) {

    // Determine what Renderer to use and setup a scene.

    var params = _.defaults(options || {}, {
      fullscreen: false,
      width: 640,
      height: 480,
      type: Two.Types.svg,
      autostart: false
    });

    _.each(params, function(v, k) {
      if (/fullscreen/i.test(k) || /autostart/i.test(k)) {
        return;
      }
      this[k] = v;
    }, this);

    // Specified domElement overrides type declaration only if the element does not support declared renderer type.
    if (_.isElement(params.domElement)) {
      var tagName = params.domElement.tagName.toLowerCase();
      // TODO: Reconsider this if statement's logic.
      if (!/^(CanvasRenderer-canvas|WebGLRenderer-canvas|SVGRenderer-svg)$/.test(this.type+'-'+tagName)) {
        this.type = Two.Types[tagName];
      }
    }

    this.renderer = new Two[this.type](this);
    Two.Utils.setPlaying.call(this, params.autostart);
    this.frameCount = 0;

    if (params.fullscreen) {

      var fitted = _.bind(fitToWindow, this);
      _.extend(document.body.style, {
        overflow: 'hidden',
        margin: 0,
        padding: 0,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        position: 'fixed'
      });
      _.extend(this.renderer.domElement.style, {
        display: 'block',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        position: 'fixed'
      });
      dom.bind(root, 'resize', fitted);
      fitted();


    } else if (!_.isElement(params.domElement)) {

      this.renderer.setSize(params.width, params.height, this.ratio);
      this.width = params.width;
      this.height = params.height;

    }

    this.renderer.bind(Two.Events.resize, _.bind(updateDimensions, this));
    this.scene = this.renderer.scene;

    Two.Instances.push(this);
    if (params.autostart) {
      raf.init();
    }

  };

  _.extend(Two, {

    // Access to root in other files.

    /**
     * @name Two.root
     * @description The root of the session context. In the browser this is the `window` variable. This varies in headless environments.
     */
    root: root,

    /**
     * @name Two.nextFrameID
     * @property {Integer}
     * @description The id of the next requestAnimationFrame function.
     */
    nextFrameID: null,

    // Primitive

    /**
     * @name Two.Array
     * @description A simple polyfill for Float32Array.
     */
    Array: root.Float32Array || Array,

    /**
     * @name Two.Types
     * @property {Object} - The different rendering types availabe in the library.
     */
    Types: {
      webgl: 'WebGLRenderer',
      svg: 'SVGRenderer',
      canvas: 'CanvasRenderer'
    },

    /**
     * @name Two.Version
     * @property {String} - The current working version of the library.
     */
    Version: 'v0.7.0',

    /**
     * @name Two.PublishDate
     * @property {String} - The automatically generated publish date in the build process to verify version release candidates.
     */
    PublishDate: '2020-01-22T21:17:28.421Z',

    /**
     * @name Two.Identifier
     * @property {String} - String prefix for all Two.js object's ids. This trickles down to SVG ids.
     */
    Identifier: 'two-',

    /**
     * @name Two.Events
     * @property {Object} - Map of possible events in Two.js.
     */
    Events: {
      play: 'play',
      pause: 'pause',
      update: 'update',
      render: 'render',
      resize: 'resize',
      change: 'change',
      remove: 'remove',
      insert: 'insert',
      order: 'order',
      load: 'load'
    },

    /**
     * @name Two.Commands
     * @property {Object} - Map of possible path commands. Taken from the SVG specification.
     */
    Commands: {
      move: 'M',
      line: 'L',
      curve: 'C',
      arc: 'A',
      close: 'Z'
    },

    /**
     * @name Two.Resolution
     * @property {Number} - Default amount of vertices to be used for interpreting Arcs and ArcSegments.
     */
    Resolution: 12,

    /**
     * @name Two.Instances
     * @property {Two[]} - Registered list of all Two.js instances in the current session.
     */
    Instances: [],

    /**
     * @function Two.noConflict
     * @description A function to revert the global namespaced `Two` variable to its previous incarnation.
     * @returns {Two} Returns access to the top-level Two.js library for local use.
     */
    noConflict: function() {
      root.Two = previousTwo;
      return Two;
    },

    /**
     * @function Two.uniqueId
     * @description Simple method to access an incrementing value. Used for `id` allocation on all Two.js objects.
     * @returns {Number} Ever increasing integer.
     */
    uniqueId: function() {
      var id = count;
      count++;
      return id;
    },

    /**
     * @name Two.Utils
     * @interface
     * @implements {_}
     * @description A hodgepodge of handy functions, math, and properties are stored here.
     */
    Utils: _.extend(_, {

      /**
       * @name Two.Utils.performance
       * @property {Date} - A special `Date` like object to get the current millis of the session. Used internally to calculate time between frames.
       * e.g: `Two.Utils.performance.now() // milliseconds since epoch`
       */
      performance: perf,

      /**
       * @name Two.Utils.defineProperty
       * @function
       * @this Two#
       * @param {String} property - The property to add an enumerable getter / setter to.
       * @description Convenience function to setup the flag based getter / setter that most properties are defined as in Two.js.
       */
      defineProperty: function(property) {

        var object = this;
        var secret = '_' + property;
        var flag = '_flag' + property.charAt(0).toUpperCase() + property.slice(1);

        Object.defineProperty(object, property, {
          enumerable: true,
          get: function() {
            return this[secret];
          },
          set: function(v) {
            this[secret] = v;
            this[flag] = true;
          }
        });

      },

      Image: null,

      isHeadless: false,

      /**
       * @name Two.Utils.shim
       * @function
       * @param {canvas} canvas - The instanced `Canvas` object provided by `node-canvas`.
       * @param {Image} [Image] - The prototypical `Image` object provided by `node-canvas`. This is only necessary to pass if you're going to load bitmap imagery.
       * @returns {canvas} Returns the instanced canvas object you passed from with additional attributes needed for Two.js.
       * @description Convenience method for defining all the dependencies from the npm package `node-canvas`. See [node-canvas]{@link https://github.com/Automattic/node-canvas} for additional information on setting up HTML5 `<canvas />` drawing in a node.js environment.
       */
      shim: function(canvas, Image) {
        Two.CanvasRenderer.Utils.shim(canvas);
        if (!_.isUndefined(Image)) {
          Two.Utils.Image = Image;
        }
        Two.Utils.isHeadless = true;
        return canvas;
      },

      /**
       * @name Two.Utils.release
       * @function
       * @param {Object} obj
       * @returns {Object} The object passed for event deallocation.
       * @description Release an arbitrary class' events from the Two.js corpus and recurse through its children and or vertices.
       */
      release: function(obj) {

        if (!_.isObject(obj)) {
          return;
        }

        if (_.isFunction(obj.unbind)) {
          obj.unbind();
        }

        if (obj.vertices) {
          if (_.isFunction(obj.vertices.unbind)) {
            obj.vertices.unbind();
          }
          _.each(obj.vertices, function(v) {
            if (_.isFunction(v.unbind)) {
              v.unbind();
            }
          });
        }

        if (obj.children) {
          _.each(obj.children, function(obj) {
            Two.Utils.release(obj);
          });
        }

        return obj;

      },

      /**
       * @name Two.Utils.xhr
       * @function
       * @param {String} path
       * @param {Function} callback
       * @returns {XMLHttpRequest} The constructed and called XHR request.
       * @description Canonical method to initiate `GET` requests in the browser. Mainly used by {@link Two#load} method.
       */
      xhr: function(path, callback) {

        var xhr = new XMLHttpRequest();
        xhr.open('GET', path);

        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4 && xhr.status === 200) {
            callback(xhr.responseText);
          }
        };

        xhr.send();
        return xhr;

      },

      /**
       * @name Two.Utils.Curve
       * @property {Object} - Additional utility constant variables related to curve math and calculations.
       */
      Curve: {

        CollinearityEpsilon: pow(10, -30),

        RecursionLimit: 16,

        CuspLimit: 0,

        Tolerance: {
          distance: 0.25,
          angle: 0,
          epsilon: Number.EPSILON
        },

        // Lookup tables for abscissas and weights with values for n = 2 .. 16.
        // As values are symmetric, only store half of them and adapt algorithm
        // to factor in symmetry.
        abscissas: [
          [  0.5773502691896257645091488],
          [0,0.7745966692414833770358531],
          [  0.3399810435848562648026658,0.8611363115940525752239465],
          [0,0.5384693101056830910363144,0.9061798459386639927976269],
          [  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
          [0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
          [  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
          [0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
          [  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
          [0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
          [  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
          [0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
          [  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
          [0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
          [  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
        ],

        weights: [
          [1],
          [0.8888888888888888888888889,0.5555555555555555555555556],
          [0.6521451548625461426269361,0.3478548451374538573730639],
          [0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
          [0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
          [0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
          [0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
          [0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
          [0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
          [0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
          [0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
          [0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
          [0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
          [0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
          [0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
        ]

      },

      devicePixelRatio: root.devicePixelRatio || 1,

      getBackingStoreRatio: function(ctx) {
        return ctx.webkitBackingStorePixelRatio ||
          ctx.mozBackingStorePixelRatio ||
          ctx.msBackingStorePixelRatio ||
          ctx.oBackingStorePixelRatio ||
          ctx.backingStorePixelRatio || 1;
      },

      /**
       * @name Two.Utils.getRatio
       * @function
       * @param {Canvas.context2D} ctx
       * @returns {Number} The ratio of a unit in Two.js to the pixel density of a session's screen.
       * @see [High DPI Rendering]{@link http://www.html5rocks.com/en/tutorials/canvas/hidpi/}
       */
      getRatio: function(ctx) {
        return Two.Utils.devicePixelRatio / getBackingStoreRatio(ctx);
      },

      /**
       * @name Two.Utils.setPlaying
       * @function
       * @this Two#
       * @returns {Two} The instance called with for potential chaining.
       * @description Internal convenience method to properly defer play calling until after all objects have been updated with their newest styles.
       */
      setPlaying: function(b) {

        this.playing = !!b;
        return this;

      },

      /**
       * @name Two.Utils.getComputedMatrix
       * @function
       * @param {Two.Shape} object - The Two.js object that has a matrix property to calculate from.
       * @param {Two.Matrix} [matrix] - The matrix to apply calculated transformations to if available.
       * @returns {Two.Matrix} The computed matrix of a nested object. If no `matrix` was passed in arguments then a `new Two.Matrix` is returned.
       * @description Method to get the world space transformation of a given object in a Two.js scene.
       */
      getComputedMatrix: function(object, matrix) {

        matrix = (matrix && matrix.identity()) || new Two.Matrix();
        var parent = object, matrices = [];

        while (parent && parent._matrix) {
          matrices.push(parent._matrix);
          parent = parent.parent;
        }

        matrices.reverse();

        for (var i = 0; i < matrices.length; i++) {

          var m = matrices[i];
          var e = m.elements;
          matrix.multiply(
            e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9]);

        }

        return matrix;

      },

      /**
       * @name Two.Utils.decomposeMatrix
       * @function
       * @param {Two.Matrix} matrix - The matrix to decompose.
       * @returns {Object} An object containing relevant skew values.
       * @description Decompose a 2D 3x3 Matrix to find the skew.
       */
      decomposeMatrix: function(matrix) {

        // TODO: Include skewX, skewY

        return {
            translateX: matrix.e,
            translateY: matrix.f,
            scaleX: matrix.a,
            scaleY: matrix.d,
            rotation: Math.asin(- matrix.b)
        };

      },

      /**
       * @name Two.Utils.extractCSSText
       * @function
       * @param {String} text - The CSS text body to be parsed and extracted.
       * @param {Object} [styles] - The styles object to apply CSS key values to.
       * @returns {Object} styles
       * @description Parse CSS text body and apply them as key value pairs to a JavaScript object.
       */
      extractCSSText: function(text, styles) {

        var commands, command, name, value;

        if (!styles) {
          styles = {};
        }

        commands = text.split(';');

        for (var i = 0; i < commands.length; i++) {
          command = commands[i].split(':');
          name = command[0];
          value = command[1];
          if (_.isUndefined(name) || _.isUndefined(value)) {
            continue;
          }
          styles[name] = value.replace(/\s/, '');
        }

        return styles;

      },

      /**
       * @name Two.Utils.getSvgStyles
       * @function
       * @param {SvgNode} node - The SVG node to parse.
       * @returns {Object} styles
       * @description Get the CSS comands from the `style` attribute of an SVG node and apply them as key value pairs to a JavaScript object.
       */
      getSvgStyles: function(node) {

        var styles = {};
        var attributes = Two.Utils.getSvgAttributes(node);
        var length = Math.max(attributes.length, node.style.length);

        for (var i = 0; i < length; i++) {

          var command = node.style[i];
          var attribute = attributes[i];

          if (command) {
            styles[command] = node.style[command];
          }
          if (attribute) {
            styles[attribute] = node.getAttribute(attribute);
          }

        }

        return styles;

      },

      getSvgAttributes: function(node) {

        var attributes = node.getAttributeNames();

        // Reserved attributes to remove
        var keywords = ['id', 'class', 'transform', 'xmlns', 'viewBox'];

        for (var i = 0; i < keywords.length; i++) {
          var keyword = keywords[i];
          var index = _.indexOf(attributes, keyword);
          if (index >= 0) {
            attributes.splice(index, 1);
          }
        }

        return attributes;

      },

      /**
       * @name Two.Utils.applySvgViewBox
       * @function
       * @param {Two.Shape} node - The Two.js object to apply viewbox matrix to
       * @param {String} value - The viewBox value from the SVG attribute
       * @returns {Two.Shape} node
       @ @description
       */
      applySvgViewBox: function(node, value) {

        var elements = value.split(/\s/);

        var x = parseFloat(elements[0]);
        var y = parseFloat(elements[1]);
        var width = parseFloat(elements[2]);
        var height = parseFloat(elements[3]);

        var s = Math.min(this.width / width, this.height / height);

        node.translation.x -= x * s;
        node.translation.y -= y * s;
        node.scale = s;

        return node;

      },

      /**
       * @name Two.Utils.applySvgAttributes
       * @function
       * @param {SvgNode} node - An SVG Node to extrapolate attributes from.
       * @param {Two.Shape} elem - The Two.js object to apply extrapolated attributes to.
       * @returns {Two.Shape} The Two.js object passed now with applied attributes.
       * @description This function iterates through an SVG Node's properties and stores ones of interest. It tries to resolve styles applied via CSS as well.
       * @TODO Reverse calculate {@link Two.Gradient}s for fill / stroke of any given path.
       */
      applySvgAttributes: function(node, elem, parentStyles) {

        var  styles = {}, attributes = {}, extracted = {}, i, key, value, attr;

        // Not available in non browser environments
        if (root.getComputedStyle) {
          // Convert CSSStyleDeclaration to a normal object
          var computedStyles = root.getComputedStyle(node);
          i = computedStyles.length;

          while (i--) {
            key = computedStyles[i];
            value = computedStyles[key];
            // Gecko returns undefined for unset properties
            // Webkit returns the default value
            if (!_.isUndefined(value)) {
              styles[key] = value;
            }
          }
        }

        // Convert NodeMap to a normal object
        for (i = 0; i < node.attributes.length; i++) {
          attr = node.attributes[i];
          if (/style/i.test(attr.nodeName)) {
            Two.Utils.extractCSSText(attr.value, extracted);
          } else {
            attributes[attr.nodeName] = attr.value;
          }
        }

        // Getting the correct opacity is a bit tricky, since SVG path elements don't
        // support opacity as an attribute, but you can apply it via CSS.
        // So we take the opacity and set (stroke/fill)-opacity to the same value.
        if (!_.isUndefined(styles.opacity)) {
          styles['stroke-opacity'] = styles.opacity;
          styles['fill-opacity'] = styles.opacity;
          delete styles.opacity;
        }

        // Merge attributes and applied styles (attributes take precedence)
        if (parentStyles) {
          _.defaults(styles, parentStyles);
        }
        _.extend(styles, attributes, extracted);

        // Similarly visibility is influenced by the value of both display and visibility.
        // Calculate a unified value here which defaults to `true`.
        styles.visible = !(_.isUndefined(styles.display) && /none/i.test(styles.display))
          || (_.isUndefined(styles.visibility) && /hidden/i.test(styles.visibility));

        // Now iterate the whole thing
        for (key in styles) {
          value = styles[key];

          switch (key) {
            case 'transform':
              // TODO: Check this out https://github.com/paperjs/paper.js/blob/develop/src/svg/SvgImport.js#L315
              if (/none/i.test(value)) break;
              var m = (node.transform && node.transform.baseVal && node.transform.baseVal.length > 0)
                ? node.transform.baseVal[0].matrix
                : (node.getCTM ? node.getCTM() : null);

              // Might happen when transform string is empty or not valid.
              if (_.isNull(m)) break;

              // // Option 1: edit the underlying matrix and don't force an auto calc.
              // var m = node.getCTM();
              // elem._matrix.manual = true;
              // elem._matrix.set(m.a, m.b, m.c, m.d, m.e, m.f);

              // Option 2: Decompose and infer Two.js related properties.
              var transforms = Two.Utils.decomposeMatrix(m);

              elem.translation.set(transforms.translateX, transforms.translateY);
              elem.rotation = Math.PI * (transforms.rotation / 180);
              elem.scale = new Two.Vector(transforms.scaleX, transforms.scaleY);

              var x = parseFloat((styles.x + '').replace('px'));
              var y = parseFloat((styles.y + '').replace('px'));

              // Override based on attributes.
              if (x) {
                elem.translation.x = x;
              }

              if (y) {
                elem.translation.y = y;
              }

              break;
            case 'viewBox':
              Two.Utils.applySvgViewBox.call(this, elem, value);
              break;
            case 'visible':
              if (elem instanceof Two.Group) {
                elem._visible = value;
                break;
              }
              elem.visible = value;
              break;
            case 'stroke-linecap':
              if (elem instanceof Two.Group) {
                elem._cap = value;
                break;
              }
              elem.cap = value;
              break;
            case 'stroke-linejoin':
              if (elem instanceof Two.Group) {
                elem._join = value;
                break;
              }
              elem.join = value;
              break;
            case 'stroke-miterlimit':
              if (elem instanceof Two.Group) {
                elem._miter = value;
                break;
              }
              elem.miter = value;
              break;
            case 'stroke-width':
              if (elem instanceof Two.Group) {
                elem._linewidth = parseFloat(value);
                break;
              }
              elem.linewidth = parseFloat(value);
              break;
            case 'opacity':
            case 'stroke-opacity':
            case 'fill-opacity':
              // Only apply styles to rendered shapes
              // in the scene.
              if (elem instanceof Two.Group) {
                elem._opacity = parseFloat(value);
                break;
              }
              elem.opacity = parseFloat(value);
              break;
            case 'fill':
            case 'stroke':
              if (elem instanceof Two.Group) {
                key = '_' + key;
              }
              if (/url\(#.*\)/i.test(value)) {
                var scene = Two.Utils.getScene(this);
                elem[key] = scene.getById(
                  value.replace(/url\(#(.*)\)/i, '$1'));
              } else {
                elem[key] = (/none/i.test(value)) ? 'transparent' : value;
              }
              break;
            case 'id':
              elem.id = value;
              // Overwritten id for non-conflicts on same page SVG documents
              // TODO: Make this non-descructive
              node.id = value + '-' + Two.Identifier + 'applied';
              break;
            case 'class':
            case 'className':
              elem.classList = value.split(' ');
              break;
          }
        }

        return styles;

      },

      /**
       * @name two.Utils.getScene
       * @param {Two.Shape} node - The currently available object in the scenegraph.
       * @returns {Two.Group} - The highest order {@link Two.Group} in the scenegraph.
       * @property {Function}
       */
      getScene: function(node) {

        while (node.parent) {
          node = node.parent;
        }

        return node.scene;

      },

      /**
       * @name Two.Utils.read
       * @property {Object} read - A map of functions to read any number of SVG node types and create Two.js equivalents of them. Primarily used by the {@link Two#interpret} method.
       */
      read: {

        svg: function(node) {

          var svg = Two.Utils.read.g.call(this, node);
          var viewBox = node.getAttribute('viewBox');
          // Two.Utils.applySvgViewBox(svg, viewBox);

          return svg;

        },

        defs: function(node) {
          var error = new Two.Utils.Error('interpret <defs /> not supported.');
          console.warn(error.name, error.message);
          return null;
        },

        use: function(node) {
          var error = new Two.Utils.Error('interpret <use /> not supported.');
          console.warn(error.name, error.message);
          return null;
        },

        g: function(node, parentStyles) {

          var styles, attrs;
          var group = new Two.Group();

          Two.Utils.applySvgAttributes.call(this, node, group, parentStyles);

          this.add(group);

          // Switched up order to inherit more specific styles
          styles = Two.Utils.getSvgStyles.call(this, node);

          for (var i = 0, l = node.childNodes.length; i < l; i++) {
            var n = node.childNodes[i];
            var tag = n.nodeName;
            if (!tag) return;

            var tagName = tag.replace(/svg:/ig, '').toLowerCase();

            if (tagName in Two.Utils.read) {
              var o = Two.Utils.read[tagName].call(group, n, styles);
              if (!!o && !o.parent) {
                group.add(o);
              }
            }
          }

          return group;

        },

        polygon: function(node, parentStyles) {

          var points = node.getAttribute('points');

          var verts = [];
          points.replace(/(-?[\d.?]+)[,|\s](-?[\d.?]+)/g, function(match, p1, p2) {
            verts.push(new Two.Anchor(parseFloat(p1), parseFloat(p2)));
          });

          var poly = new Two.Path(verts, true).noStroke();
          poly.fill = 'black';

          Two.Utils.applySvgAttributes.call(this, node, poly, parentStyles);

          return poly;

        },

        polyline: function(node, parentStyles) {
          var poly = Two.Utils.read.polygon.call(this, node, parentStyles);
          poly.closed = false;
          return poly;
        },

        path: function(node, parentStyles) {

          var path = node.getAttribute('d');
          var points = [];
          var closed = false, relative = false;

          if (path) {

            // Create a Two.Path from the paths.

            var coord = new Two.Anchor();
            var control, coords;
            var commands = path.match(/[a-df-z][^a-df-z]*/ig);
            var last = commands.length - 1;

            // Split up polybeziers

            _.each(commands.slice(0), function(command, i) {

              var number, fid, lid, numbers, first, s;
              var j, k, ct, l, times;

              var type = command[0];
              var lower = type.toLowerCase();
              var items = command.slice(1).trim().split(/[\s,]+|(?=\s?[+-])/);
              var pre, post, result = [], bin;
              var hasDoubleDecimals = false;

              // Handle double decimal values e.g: 48.6037.71.8
              // Like: https://m.abcsofchinese.com/images/svg/äº¼ji2.svg
              for (j = 0; j < items.length; j++) {

                number = items[j];
                fid = number.indexOf('.');
                lid = number.lastIndexOf('.');

                if (fid !== lid) {

                  numbers = number.split('.');
                  first = numbers[0] + '.' + numbers[1];

                  items.splice(j, 1, first);

                  for (s = 2; s < numbers.length; s++) {
                    items.splice(j + s - 1, 0, '0.' + numbers[s]);
                  }

                  hasDoubleDecimals = true;

                }

              }

              if (hasDoubleDecimals) {
                command = type + items.join(',');
              }

              if (i <= 0) {
                commands = [];
              }

              switch (lower) {
                case 'h':
                case 'v':
                  if (items.length > 1) {
                    bin = 1;
                  }
                  break;
                case 'm':
                case 'l':
                case 't':
                  if (items.length > 2) {
                    bin = 2;
                  }
                  break;
                case 's':
                case 'q':
                  if (items.length > 4) {
                    bin = 4;
                  }
                  break;
                case 'c':
                  if (items.length > 6) {
                    bin = 6;
                  }
                  break;
                case 'a':
                  if (items.length > 7) {
                    bin = 7;
                  }
                  break;
              }

              // This means we have a polybezier.
              if (bin) {

                for (j = 0, l = items.length, times = 0; j < l; j+=bin) {

                  ct = type;
                  if (times > 0) {

                    switch (type) {
                      case 'm':
                        ct = 'l';
                        break;
                      case 'M':
                        ct = 'L';
                        break;
                    }

                  }

                  result.push(ct + items.slice(j, j + bin).join(' '));
                  times++;

                }

                commands = Array.prototype.concat.apply(commands, result);

              } else {

                commands.push(command);

              }

            });

            // Create the vertices for our Two.Path

            _.each(commands, function(command, i) {

              var result, x, y;
              var type = command[0];
              var lower = type.toLowerCase();

              coords = command.slice(1).trim();
              coords = coords.replace(/(-?\d+(?:\.\d*)?)[eE]([+-]?\d+)/g, function(match, n1, n2) {
                return parseFloat(n1) * pow(10, n2);
              });
              coords = coords.split(/[\s,]+|(?=\s?[+-])/);
              relative = type === lower;

              var x1, y1, x2, y2, x3, y3, x4, y4, reflection;

              switch (lower) {

                case 'z':
                  if (i >= last) {
                    closed = true;
                  } else {
                    x = coord.x;
                    y = coord.y;
                    result = new Two.Anchor(
                      x, y,
                      undefined, undefined,
                      undefined, undefined,
                      Two.Commands.close
                    );
                    // Make coord be the last `m` command
                    for (var j = points.length - 1; j >= 0; j--) {
                      var point = points[j];
                      if (/m/i.test(point.command)) {
                        coord = point;
                        break;
                      }
                    }
                  }
                  break;

                case 'm':
                case 'l':

                  control = undefined;

                  x = parseFloat(coords[0]);
                  y = parseFloat(coords[1]);

                  result = new Two.Anchor(
                    x, y,
                    undefined, undefined,
                    undefined, undefined,
                    /m/i.test(lower) ? Two.Commands.move : Two.Commands.line
                  );

                  if (relative) {
                    result.addSelf(coord);
                  }

                  // result.controls.left.copy(result);
                  // result.controls.right.copy(result);

                  coord = result;
                  break;

                case 'h':
                case 'v':

                  var a = /h/i.test(lower) ? 'x' : 'y';
                  var b = /x/i.test(a) ? 'y' : 'x';

                  result = new Two.Anchor(
                    undefined, undefined,
                    undefined, undefined,
                    undefined, undefined,
                    Two.Commands.line
                  );
                  result[a] = parseFloat(coords[0]);
                  result[b] = coord[b];

                  if (relative) {
                    result[a] += coord[a];
                  }

                  // result.controls.left.copy(result);
                  // result.controls.right.copy(result);

                  coord = result;
                  break;

                case 'c':
                case 's':

                  x1 = coord.x;
                  y1 = coord.y;

                  if (!control) {
                    control = new Two.Vector();//.copy(coord);
                  }

                  if (/c/i.test(lower)) {

                    x2 = parseFloat(coords[0]);
                    y2 = parseFloat(coords[1]);
                    x3 = parseFloat(coords[2]);
                    y3 = parseFloat(coords[3]);
                    x4 = parseFloat(coords[4]);
                    y4 = parseFloat(coords[5]);

                  } else {

                    // Calculate reflection control point for proper x2, y2
                    // inclusion.

                    reflection = getReflection(coord, control, relative);

                    x2 = reflection.x;
                    y2 = reflection.y;
                    x3 = parseFloat(coords[0]);
                    y3 = parseFloat(coords[1]);
                    x4 = parseFloat(coords[2]);
                    y4 = parseFloat(coords[3]);

                  }

                  if (relative) {
                    x2 += x1;
                    y2 += y1;
                    x3 += x1;
                    y3 += y1;
                    x4 += x1;
                    y4 += y1;
                  }

                  if (!_.isObject(coord.controls)) {
                    Two.Anchor.AppendCurveProperties(coord);
                  }

                  coord.controls.right.set(x2 - coord.x, y2 - coord.y);
                  result = new Two.Anchor(
                    x4, y4,
                    x3 - x4, y3 - y4,
                    undefined, undefined,
                    Two.Commands.curve
                  );

                  coord = result;
                  control = result.controls.left;

                  break;

                case 't':
                case 'q':

                  x1 = coord.x;
                  y1 = coord.y;

                  if (!control) {
                    control = new Two.Vector();
                  }

                  if (/q/i.test(lower)) {

                    x2 = parseFloat(coords[0]);
                    y2 = parseFloat(coords[1]);
                    x3 = parseFloat(coords[0]);
                    y3 = parseFloat(coords[1]);
                    x4 = parseFloat(coords[2]);
                    y4 = parseFloat(coords[3]);

                  } else {

                    reflection = getReflection(coord, control, relative);

                    x2 = reflection.x;
                    y2 = reflection.y;
                    x3 = reflection.x;
                    y3 = reflection.y;
                    x4 = parseFloat(coords[0]);
                    y4 = parseFloat(coords[1]);

                  }

                  if (relative) {
                    x2 += x1;
                    y2 += y1;
                    x3 += x1;
                    y3 += y1;
                    x4 += x1;
                    y4 += y1;
                  }

                  if (!_.isObject(coord.controls)) {
                    Two.Anchor.AppendCurveProperties(coord);
                  }

                  coord.controls.right.set(
                    (x2 - coord.x) * 0.33, (y2 - coord.y) * 0.33);
                  result = new Two.Anchor(
                    x4, y4,
                    x3 - x4, y3 - y4,
                    undefined, undefined,
                    Two.Commands.curve
                  );

                  coord = result;
                  control = result.controls.left;

                  break;

                case 'a':

                  x1 = coord.x;
                  y1 = coord.y;

                  var rx = parseFloat(coords[0]);
                  var ry = parseFloat(coords[1]);
                  var xAxisRotation = parseFloat(coords[2]);// * PI / 180;
                  var largeArcFlag = parseFloat(coords[3]);
                  var sweepFlag = parseFloat(coords[4]);

                  x4 = parseFloat(coords[5]);
                  y4 = parseFloat(coords[6]);

                  if (relative) {
                    x4 += x1;
                    y4 += y1;
                  }

                  var anchor = new Two.Anchor(x4, y4);
                  anchor.command = Two.Commands.arc;
                  anchor.rx = rx;
                  anchor.ry = ry;
                  anchor.xAxisRotation = xAxisRotation;
                  anchor.largeArcFlag = largeArcFlag;
                  anchor.sweepFlag = sweepFlag;

                  result = anchor;

                  coord = anchor;
                  control = undefined;

                  break;

              }

              if (result) {
                if (_.isArray(result)) {
                  points = points.concat(result);
                } else {
                  points.push(result);
                }
              }

            });

          }

          path = new Two.Path(points, closed, undefined, true).noStroke();
          path.fill = 'black';

          var rect = path.getBoundingClientRect(true);

          // Center objects to stay consistent
          // with the rest of the Two.js API.
          rect.centroid = {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
          };

          _.each(path.vertices, function(v) {
            v.subSelf(rect.centroid);
          });

          Two.Utils.applySvgAttributes.call(this, node, path, parentStyles);

          path.translation.addSelf(rect.centroid);

          return path;

        },

        circle: function(node, parentStyles) {

          var x = parseFloat(node.getAttribute('cx'));
          var y = parseFloat(node.getAttribute('cy'));
          var r = parseFloat(node.getAttribute('r'));

          var circle = new Two.Circle(x, y, r).noStroke();
          circle.fill = 'black';

          Two.Utils.applySvgAttributes.call(this, node, circle, parentStyles);

          return circle;

        },

        ellipse: function(node, parentStyles) {

          var x = parseFloat(node.getAttribute('cx'));
          var y = parseFloat(node.getAttribute('cy'));
          var width = parseFloat(node.getAttribute('rx'));
          var height = parseFloat(node.getAttribute('ry'));

          var ellipse = new Two.Ellipse(x, y, width, height).noStroke();
          ellipse.fill = 'black';

          Two.Utils.applySvgAttributes.call(this, node, ellipse, parentStyles);

          return ellipse;

        },

        rect: function(node, parentStyles) {

          var rx = parseFloat(node.getAttribute('rx'));
          var ry = parseFloat(node.getAttribute('ry'));

          if (!_.isNaN(rx) || !_.isNaN(ry)) {
            return Two.Utils.read['rounded-rect'](node);
          }

          var x = parseFloat(node.getAttribute('x')) || 0;
          var y = parseFloat(node.getAttribute('y')) || 0;
          var width = parseFloat(node.getAttribute('width'));
          var height = parseFloat(node.getAttribute('height'));

          var w2 = width / 2;
          var h2 = height / 2;

          var rect = new Two.Rectangle(x + w2, y + h2, width, height)
            .noStroke();
          rect.fill = 'black';

          Two.Utils.applySvgAttributes.call(this, node, rect, parentStyles);

          return rect;

        },

        'rounded-rect': function(node, parentStyles) {

          var x = parseFloat(node.getAttribute('x')) || 0;
          var y = parseFloat(node.getAttribute('y')) || 0;
          var rx = parseFloat(node.getAttribute('rx')) || 0;
          var ry = parseFloat(node.getAttribute('ry')) || 0;

          var width = parseFloat(node.getAttribute('width'));
          var height = parseFloat(node.getAttribute('height'));

          var w2 = width / 2;
          var h2 = height / 2;
          var radius = new Two.Vector(rx, ry);

          var rect = new Two.RoundedRectangle(x + w2, y + h2, width, height, radius)
            .noStroke();
          rect.fill = 'black';

          Two.Utils.applySvgAttributes.call(this, node, rect, parentStyles);

          return rect;

        },

        line: function(node, parentStyles) {

          var x1 = parseFloat(node.getAttribute('x1'));
          var y1 = parseFloat(node.getAttribute('y1'));
          var x2 = parseFloat(node.getAttribute('x2'));
          var y2 = parseFloat(node.getAttribute('y2'));

          var line = new Two.Line(x1, y1, x2, y2).noFill();

          Two.Utils.applySvgAttributes.call(this, node, line, parentStyles);

          return line;

        },

        lineargradient: function(node, parentStyles) {

          var x1 = parseFloat(node.getAttribute('x1'));
          var y1 = parseFloat(node.getAttribute('y1'));
          var x2 = parseFloat(node.getAttribute('x2'));
          var y2 = parseFloat(node.getAttribute('y2'));

          var ox = (x2 + x1) / 2;
          var oy = (y2 + y1) / 2;

          var stops = [];
          for (var i = 0; i < node.children.length; i++) {

            var child = node.children[i];

            var offset = child.getAttribute('offset');
            if (/%/ig.test(offset)) {
              offset = parseFloat(offset.replace(/%/ig, '')) / 100;
            }
            offset = parseFloat(offset);

            var color = child.getAttribute('stop-color');
            var opacity = child.getAttribute('stop-opacity');
            var style = child.getAttribute('style');

            var matches;
            if (_.isNull(color)) {
              matches = style ? style.match(/stop-color:\s?([#a-fA-F0-9]*)/) : false;
              color = matches && matches.length > 1 ? matches[1] : undefined;
            }

            if (_.isNull(opacity)) {
              matches = style ? style.match(/stop-opacity:\s?([0-9.-]*)/) : false;
              opacity = matches && matches.length > 1 ? parseFloat(matches[1]) : 1;
            } else {
              opacity = parseFloat(opacity);
            }

            stops.push(new Two.Gradient.Stop(offset, color, opacity));

          }

          var gradient = new Two.LinearGradient(x1 - ox, y1 - oy, x2 - ox,
            y2 - oy, stops);

          Two.Utils.applySvgAttributes.call(this, node, gradient, parentStyles);

          return gradient;

        },

        radialgradient: function(node, parentStyles) {

          var cx = parseFloat(node.getAttribute('cx')) || 0;
          var cy = parseFloat(node.getAttribute('cy')) || 0;
          var r = parseFloat(node.getAttribute('r'));

          var fx = parseFloat(node.getAttribute('fx'));
          var fy = parseFloat(node.getAttribute('fy'));

          if (_.isNaN(fx)) {
            fx = cx;
          }

          if (_.isNaN(fy)) {
            fy = cy;
          }

          var ox = abs(cx + fx) / 2;
          var oy = abs(cy + fy) / 2;

          var stops = [];
          for (var i = 0; i < node.children.length; i++) {

            var child = node.children[i];

            var offset = child.getAttribute('offset');
            if (/%/ig.test(offset)) {
              offset = parseFloat(offset.replace(/%/ig, '')) / 100;
            }
            offset = parseFloat(offset);

            var color = child.getAttribute('stop-color');
            var opacity = child.getAttribute('stop-opacity');
            var style = child.getAttribute('style');

            var matches;
            if (_.isNull(color)) {
              matches = style ? style.match(/stop-color:\s?([#a-fA-F0-9]*)/) : false;
              color = matches && matches.length > 1 ? matches[1] : undefined;
            }

            if (_.isNull(opacity)) {
              matches = style ? style.match(/stop-opacity:\s?([0-9.-]*)/) : false;
              opacity = matches && matches.length > 1 ? parseFloat(matches[1]) : 1;
            } else {
              opacity = parseFloat(opacity);
            }

            stops.push(new Two.Gradient.Stop(offset, color, opacity));

          }

          var gradient = new Two.RadialGradient(cx - ox, cy - oy, r,
            stops, fx - ox, fy - oy);

          Two.Utils.applySvgAttributes.call(this, node, gradient, parentStyles);

          return gradient;

        }

      },

      /**
       * @name Two.Utils.subdivide
       * @function
       * @param {Number} x1 - x position of first anchor point.
       * @param {Number} y1 - y position of first anchor point.
       * @param {Number} x2 - x position of first anchor point's "right" bezier handle.
       * @param {Number} y2 - y position of first anchor point's "right" bezier handle.
       * @param {Number} x3 - x position of second anchor point's "left" bezier handle.
       * @param {Number} y3 - y position of second anchor point's "left" bezier handle.
       * @param {Number} x4 - x position of second anchor point.
       * @param {Number} y4 - y position of second anchor point.
       * @param {Number} [limit=Two.Utils.Curve.RecursionLimit] - The amount of vertices to create by subdividing.
       * @returns {Two.Anchor[]} A list of anchor points ordered in between `x1`, `y1` and `x4`, `y4`
       * @description Given 2 points (a, b) and corresponding control point for each return an array of points that represent points plotted along the curve. The number of returned points is determined by `limit`.
       */
      subdivide: function(x1, y1, x2, y2, x3, y3, x4, y4, limit) {

        limit = limit || Two.Utils.Curve.RecursionLimit;
        var amount = limit + 1;

        // TODO: Abstract 0.001 to a limiting variable
        // Don't recurse if the end points are identical
        if (abs(x1 - x4) < 0.001 && abs(y1 - y4) < 0.001) {
          return [new Two.Anchor(x4, y4)];
        }

        var result = [];

        for (var i = 0; i < amount; i++) {
          var t = i / amount;
          var x = getComponentOnCubicBezier(t, x1, x2, x3, x4);
          var y = getComponentOnCubicBezier(t, y1, y2, y3, y4);
          result.push(new Two.Anchor(x, y));
        }

        return result;

      },

      /**
       * @name Two.Utils.getComponentOnCubicBezier
       * @function
       * @param {Number} t - Zero-to-one value describing what percentage to calculate.
       * @param {Number} a - The firt point's component value.
       * @param {Number} b - The first point's bezier component value.
       * @param {Number} c - The second point's bezier component value.
       * @param {Number} d - The second point's component value.
       * @returns {Number} The coordinate value for a specific component along a cubic bezier curve by `t`.
       */
      getComponentOnCubicBezier: function(t, a, b, c, d) {
        var k = 1 - t;
        return (k * k * k * a) + (3 * k * k * t * b) + (3 * k * t * t * c) +
           (t * t * t * d);
      },

      /**
       * @name Two.Utils.getCurveLength
       * @function
       * @param {Number} x1 - x position of first anchor point.
       * @param {Number} y1 - y position of first anchor point.
       * @param {Number} x2 - x position of first anchor point's "right" bezier handle.
       * @param {Number} y2 - y position of first anchor point's "right" bezier handle.
       * @param {Number} x3 - x position of second anchor point's "left" bezier handle.
       * @param {Number} y3 - y position of second anchor point's "left" bezier handle.
       * @param {Number} x4 - x position of second anchor point.
       * @param {Number} y4 - y position of second anchor point.
       * @param {Number} [limit=Two.Utils.Curve.RecursionLimit] - The amount of vertices to create by subdividing.
       * @returns {Number} The length of a curve.
       * @description Given 2 points (a, b) and corresponding control point for each, return a float that represents the length of the curve using Gauss-Legendre algorithm. Limit iterations of calculation by `limit`.
       */
      getCurveLength: function(x1, y1, x2, y2, x3, y3, x4, y4, limit) {

        // TODO: Better / fuzzier equality check
        // Linear calculation
        if (x1 === x2 && y1 === y2 && x3 === x4 && y3 === y4) {
          var dx = x4 - x1;
          var dy = y4 - y1;
          return sqrt(dx * dx + dy * dy);
        }

        // Calculate the coefficients of a Bezier derivative.
        var ax = 9 * (x2 - x3) + 3 * (x4 - x1),
          bx = 6 * (x1 + x3) - 12 * x2,
          cx = 3 * (x2 - x1),

          ay = 9 * (y2 - y3) + 3 * (y4 - y1),
          by = 6 * (y1 + y3) - 12 * y2,
          cy = 3 * (y2 - y1);

        var integrand = function(t) {
          // Calculate quadratic equations of derivatives for x and y
          var dx = (ax * t + bx) * t + cx,
            dy = (ay * t + by) * t + cy;
          return sqrt(dx * dx + dy * dy);
        };

        return integrate(
          integrand, 0, 1, limit || Two.Utils.Curve.RecursionLimit
        );

      },

      /**
       * @name Two.Utils.getCurveBoundingBox
       * @function
       * @param {Number} x1 - x position of first anchor point.
       * @param {Number} y1 - y position of first anchor point.
       * @param {Number} x2 - x position of first anchor point's "right" bezier handle.
       * @param {Number} y2 - y position of first anchor point's "right" bezier handle.
       * @param {Number} x3 - x position of second anchor point's "left" bezier handle.
       * @param {Number} y3 - y position of second anchor point's "left" bezier handle.
       * @param {Number} x4 - x position of second anchor point.
       * @param {Number} y4 - y position of second anchor point.
       * @returns {Object} Object contains min and max `x` / `y` bounds.
       * @see {@link https://github.com/adobe-webplatform/Snap.svg/blob/master/src/path.js#L856}
       */
      getCurveBoundingBox: function(x1, y1, x2, y2, x3, y3, x4, y4) {

        var tvalues = [];
        var bounds = [[], []];
        var a, b, c, t, t1, t2, b2ac, sqrtb2ac;

        for (var i = 0; i < 2; ++i) {
            if (i == 0) {
              b = 6 * x1 - 12 * x2 + 6 * x3;
              a = -3 * x1 + 9 * x2 - 9 * x3 + 3 * x4;
              c = 3 * x2 - 3 * x1;
            } else {
              b = 6 * y1 - 12 * y2 + 6 * y3;
              a = -3 * y1 + 9 * y2 - 9 * y3 + 3 * y4;
              c = 3 * y2 - 3 * y1;
            }
            if (abs(a) < 1e-12) {
              if (abs(b) < 1e-12) {
                continue;
              }
              t = -c / b;
              if (0 < t && t < 1) {
                tvalues.push(t);
              }
              continue;
            }
            b2ac = b * b - 4 * c * a;
            sqrtb2ac = Math.sqrt(b2ac);
            if (b2ac < 0) {
              continue;
            }
            t1 = (-b + sqrtb2ac) / (2 * a);
            if (0 < t1 && t1 < 1) {
              tvalues.push(t1);
            }
            t2 = (-b - sqrtb2ac) / (2 * a);
            if (0 < t2 && t2 < 1) {
              tvalues.push(t2);
            }
        }

        var x, y, j = tvalues.length;
        var jlen = j;
        var mt;

        while (j--) {
          t = tvalues[j];
          mt = 1 - t;
          bounds[0][j] = mt * mt * mt * x1 + 3 * mt * mt * t * x2 + 3 * mt * t * t * x3 + t * t * t * x4;
          bounds[1][j] = mt * mt * mt * y1 + 3 * mt * mt * t * y2 + 3 * mt * t * t * y3 + t * t * t * y4;
        }

        bounds[0][jlen] = x1;
        bounds[1][jlen] = y1;
        bounds[0][jlen + 1] = x4;
        bounds[1][jlen + 1] = y4;
        bounds[0].length = bounds[1].length = jlen + 2;

        return {
          min: { x: Math.min.apply(0, bounds[0]), y: Math.min.apply(0, bounds[1]) },
          max: { x: Math.max.apply(0, bounds[0]), y: Math.max.apply(0, bounds[1]) }
        };

      },

      /**
       * @name Two.Utils.integrate
       * @function
       * @param {Function} f
       * @param {Number} a
       * @param {Number} b
       * @param {Integer} n
       * @description Integration for `getCurveLength` calculations.
       * @see [Paper.js]{@link https://github.com/paperjs/paper.js/blob/master/src/util/Numerical.js#L101}
       */
      integrate: function(f, a, b, n) {
        var x = Two.Utils.Curve.abscissas[n - 2],
          w = Two.Utils.Curve.weights[n - 2],
          A = 0.5 * (b - a),
          B = A + a,
          i = 0,
          m = (n + 1) >> 1,
          sum = n & 1 ? w[i++] * f(B) : 0; // Handle odd n
        while (i < m) {
          var Ax = A * x[i];
          sum += w[i++] * (f(B + Ax) + f(B - Ax));
        }
        return A * sum;
      },

      /**
       * @name Two.Utils.getCurveFromPoints
       * @function
       * @param {Two.Anchor[]} points
       * @param {Boolean} closed
       * @description Sets the bezier handles on {@link Two.Anchor}s in the `points` list with estimated values to create a catmull-rom like curve. Used by {@link Two.Path#plot}.
       */
      getCurveFromPoints: function(points, closed) {

        var l = points.length, last = l - 1;

        for (var i = 0; i < l; i++) {

          var point = points[i];

          if (!_.isObject(point.controls)) {
            Two.Anchor.AppendCurveProperties(point);
          }

          var prev = closed ? mod(i - 1, l) : max(i - 1, 0);
          var next = closed ? mod(i + 1, l) : min(i + 1, last);

          var a = points[prev];
          var b = point;
          var c = points[next];
          getControlPoints(a, b, c);

          b.command = i === 0 ? Two.Commands.move : Two.Commands.curve;

        }

      },

      /**
       * @name Two.Utils.getControlPoints
       * @function
       * @param {Two.Anchor} a
       * @param {Two.Anchor} b
       * @param {Two.Anchor} c
       * @returns {Two.Anchor} Returns the passed middle point `b`.
       * @description Given three coordinates set the control points for the middle, b, vertex based on its position with the adjacent points.
       */
      getControlPoints: function(a, b, c) {

        var a1 = Two.Vector.angleBetween(a, b);
        var a2 = Two.Vector.angleBetween(c, b);

        var d1 = Two.Vector.distanceBetween(a, b);
        var d2 = Two.Vector.distanceBetween(c, b);

        var mid = (a1 + a2) / 2;

        // TODO: Issue 73
        if (d1 < 0.0001 || d2 < 0.0001) {
          if (_.isBoolean(b.relative) && !b.relative) {
            b.controls.left.copy(b);
            b.controls.right.copy(b);
          }
          return b;
        }

        d1 *= 0.33; // Why 0.33?
        d2 *= 0.33;

        if (a2 < a1) {
          mid += HALF_PI;
        } else {
          mid -= HALF_PI;
        }

        b.controls.left.x = cos(mid) * d1;
        b.controls.left.y = sin(mid) * d1;

        mid -= PI;

        b.controls.right.x = cos(mid) * d2;
        b.controls.right.y = sin(mid) * d2;

        if (_.isBoolean(b.relative) && !b.relative) {
          b.controls.left.x += b.x;
          b.controls.left.y += b.y;
          b.controls.right.x += b.x;
          b.controls.right.y += b.y;
        }

        return b;

      },

      /**
       * @name Two.Utils.getReflection
       * @function
       * @param {Two.Vector} a
       * @param {Two.Vector} b
       * @param {Boolean} [relative=false]
       * @returns {Two.Vector} New {@link Two.Vector} that represents the reflection point.
       * @description Get the reflection of a point `b` about point `a`. Where `a` is in absolute space and `b` is relative to `a`.
       * @see {@link http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes}
       */
      getReflection: function(a, b, relative) {

        return new Two.Vector(
          2 * a.x - (b.x + a.x) - (relative ? a.x : 0),
          2 * a.y - (b.y + a.y) - (relative ? a.y : 0)
        );

      },

      /**
       * @name Two.Utils.getAnchorsFromArcData
       * @function
       * @param {Two.Vector} center
       * @param {Radians} xAxisRotation
       * @param {Number} rx - x radius
       * @param {Number} ry - y radius
       * @param {Radians} ts
       * @param {Radians} td
       * @param {Boolean} [ccw=false] - Set path traversal to counter-clockwise
       */
      getAnchorsFromArcData: function(center, xAxisRotation, rx, ry, ts, td, ccw) {

        var l = Two.Resolution;

        return _.map(_.range(l), function(i) {

          var pct = (i + 1) / l;
          if (ccw) {
            pct = 1 - pct;
          }

          var theta = pct * td + ts;
          var x = rx * Math.cos(theta);
          var y = ry * Math.sin(theta);

          // x += center.x;
          // y += center.y;

          var anchor = new Two.Anchor(x, y);
          Two.Anchor.AppendCurveProperties(anchor);
          anchor.command = Two.Commands.line;

          // TODO: Calculate control points here...

          return anchor;

        });

      },

      /**
       * @name Two.Utils.lerp
       * @function
       * @param {Number} a - Start value.
       * @param {Number} b - End value.
       * @param {Number} t - Zero-to-one value describing percentage between a and b.
       * @returns {Number}
       * @description Linear interpolation between two values `a` and `b` by an amount `t`.
       */
      lerp: function(a, b, t) {
        return t * (b - a) + a;
      },

      /**
       * @name Two.Utils.toFixed
       * @function
       * @param {Number} v - Any float
       * @returns {Number} That float trimmed to the third decimal place.
       * @description A pretty fast toFixed(3) alternative.
       * @see {@link http://jsperf.com/parsefloat-tofixed-vs-math-round/18}
       */
      toFixed: function(v) {
        return Math.floor(v * 1000) / 1000;
      },

      /**
       * @name Two.Utils.mod
       * @param {Number} v - The value to modulo
       * @param {Number} l - The value to modulo by
       * @returns {Number}
       * @description Modulo with added functionality to handle negative values in a positive manner.
       */
      mod: function(v, l) {

        while (v < 0) {
          v += l;
        }

        return v % l;

      },

      /**
       * @name Two.Utils.Collection
       * @class
       * @extends Two.Utils.Events
       * @description An `Array` like object with additional event propagation on actions. `pop`, `shift`, and `splice` trigger `removed` events. `push`, `unshift`, and `splice` with more than 2 arguments trigger 'inserted'. Finally, `sort` and `reverse` trigger `order` events.
       */
      Collection: function() {

        Array.call(this);

        if (arguments.length > 1) {
          Array.prototype.push.apply(this, arguments);
        } else if (arguments[0] && Array.isArray(arguments[0])) {
          Array.prototype.push.apply(this, arguments[0]);
        }

      },

      /**
       * @name Two.Utils.Error
       * @class
       * @description Custom error throwing for Two.js specific identification.
       */
      Error: function(message) {
        this.name = 'Two.js';
        this.message = message;
      },

      /**
       * @name Two.Utils.Events
       * @interface
       * @description Object inherited by many Two.js objects in order to facilitate custom events.
       */
      Events: {

        /**
         * @name Two.Utils.Events.on
         * @function
         * @param {String} name - The name of the event to bind a function to.
         * @param {Function} handler - The function to be invoked when the event is dispatched.
         * @description Call to add a listener to a specific event name.
         */
        on: function(name, handler) {

          this._events || (this._events = {});
          var list = this._events[name] || (this._events[name] = []);

          list.push(handler);

          return this;

        },

        /**
         * @name Two.Utils.Events.off
         * @function
         * @param {String} [name] - The name of the event intended to be removed.
         * @param {Function} [handler] - The handler intended to be reomved.
         * @description Call to remove listeners from a specific event. If only `name` is passed then all the handlers attached to that `name` will be removed. If no arguments are passed then all handlers for every event on the obejct are removed.
         */
        off: function(name, handler) {

          if (!this._events) {
            return this;
          }
          if (!name && !handler) {
            this._events = {};
            return this;
          }

          var names = name ? [name] : _.keys(this._events);
          for (var i = 0, l = names.length; i < l; i++) {

            name = names[i];
            var list = this._events[name];

            if (list) {
              var events = [];
              if (handler) {
                for (var j = 0, k = list.length; j < k; j++) {
                  var ev = list[j];
                  ev = ev.handler ? ev.handler : ev;
                  if (handler && handler !== ev) {
                    events.push(ev);
                  }
                }
              }
              this._events[name] = events;
            }
          }

          return this;
        },

        /**
         * @name Two.Utils.Events.trigger
         * @function
         * @param {String} name - The name of the event to dispatch.
         * @param arguments - Anything can be passed after the name and those will be passed on to handlers attached to the event in the order they are passed.
         * @description Call to trigger a custom event. Any additional arguments passed after the name will be passed along to the attached handlers.
         */
        trigger: function(name) {
          if (!this._events) return this;
          var args = slice.call(arguments, 1);
          var events = this._events[name];
          if (events) trigger(this, events, args);
          return this;
        },

        listen: function(obj, name, handler) {

          var bound = this;

          if (obj) {

            var event = function () {
              handler.apply(bound, arguments);
            };

            // Add references about the object that assigned this listener
            event.obj = obj;
            event.name = name;
            event.handler = handler;

            obj.on(name, event);

          }

          return this;

        },

        ignore: function(obj, name, handler) {

          obj.off(name, handler);
          return this;

        }

      }

    })

  });

  /**
   * @name Two.Utils.Events.bind
   * @borrows Two.Utils.Events.on as Two.Utils.Events.bind
   */
  Two.Utils.Events.bind = Two.Utils.Events.on;

  /**
   * @name Two.Utils.Events.unbind
   * @borrows Two.Utils.Events.off as Two.Utils.Events.unbind
   */
  Two.Utils.Events.unbind = Two.Utils.Events.off;

  var trigger = function(obj, events, args) {
    var method;
    switch (args.length) {
    case 0:
      method = function(i) {
        events[i].call(obj, args[0]);
      };
      break;
    case 1:
      method = function(i) {
        events[i].call(obj, args[0], args[1]);
      };
      break;
    case 2:
      method = function(i) {
        events[i].call(obj, args[0], args[1], args[2]);
      };
      break;
    case 3:
      method = function(i) {
        events[i].call(obj, args[0], args[1], args[2], args[3]);
      };
      break;
    default:
      method = function(i) {
        events[i].apply(obj, args);
      };
    }
    for (var i = 0; i < events.length; i++) {
      method(i);
    }
  };

  Two.Utils.Error.prototype = new Error();
  Two.Utils.Error.prototype.constructor = Two.Utils.Error;

  Two.Utils.Collection.prototype = new Array();
  Two.Utils.Collection.prototype.constructor = Two.Utils.Collection;

  _.extend(Two.Utils.Collection.prototype, Two.Utils.Events, {

    pop: function() {
      var popped = Array.prototype.pop.apply(this, arguments);
      this.trigger(Two.Events.remove, [popped]);
      return popped;
    },

    shift: function() {
      var shifted = Array.prototype.shift.apply(this, arguments);
      this.trigger(Two.Events.remove, [shifted]);
      return shifted;
    },

    push: function() {
      var pushed = Array.prototype.push.apply(this, arguments);
      this.trigger(Two.Events.insert, arguments);
      return pushed;
    },

    unshift: function() {
      var unshifted = Array.prototype.unshift.apply(this, arguments);
      this.trigger(Two.Events.insert, arguments);
      return unshifted;
    },

    splice: function() {
      var spliced = Array.prototype.splice.apply(this, arguments);
      var inserted;

      this.trigger(Two.Events.remove, spliced);

      if (arguments.length > 2) {
        inserted = this.slice(arguments[0], arguments[0] + arguments.length - 2);
        this.trigger(Two.Events.insert, inserted);
        this.trigger(Two.Events.order);
      }
      return spliced;
    },

    sort: function() {
      Array.prototype.sort.apply(this, arguments);
      this.trigger(Two.Events.order);
      return this;
    },

    reverse: function() {
      Array.prototype.reverse.apply(this, arguments);
      this.trigger(Two.Events.order);
      return this;
    }

  });

  // Localize utils

  var getAnchorsFromArcData = Two.Utils.getAnchorsFromArcData,
    getControlPoints = Two.Utils.getControlPoints,
    getCurveFromPoints = Two.Utils.getCurveFromPoints,
    solveSegmentIntersection = Two.Utils.solveSegmentIntersection,
    decoupleShapes = Two.Utils.decoupleShapes,
    mod = Two.Utils.mod,
    getBackingStoreRatio = Two.Utils.getBackingStoreRatio,
    getComponentOnCubicBezier = Two.Utils.getComponentOnCubicBezier,
    getCurveLength = Two.Utils.getCurveLength,
    integrate = Two.Utils.integrate,
    getReflection = Two.Utils.getReflection;

  _.extend(Two.prototype, Two.Utils.Events, {

    constructor: Two,

    /**
     * @name Two#appendTo
     * @function
     * @param {Element} elem - The DOM element to append the Two.js stage to.
     * @description Shorthand method to append your instance of Two.js to the `document`.
     */
    appendTo: function(elem) {

      elem.appendChild(this.renderer.domElement);
      return this;

    },

    /**
     * @name Two#play
     * @function
     * @fires Two.Events.play event
     * @description Call to start an internal animation loop.
     * @nota-bene This function initiates a `requestAnimationFrame` loop.
     */
    play: function() {

      Two.Utils.setPlaying.call(this, true);
      raf.init();
      return this.trigger(Two.Events.play);

    },

    /**
     * @name Two#pause
     * @function
     * @fires Two.Events.pause event
     * @description Call to stop the internal animation loop for a specific instance of Two.js.
     */
    pause: function() {

      this.playing = false;
      return this.trigger(Two.Events.pause);

    },

    /**
     * @name Two#update
     * @fires Two.Events.update event
     * @description Update positions and calculations in one pass before rendering. Then render to the canvas.
     * @nota-bene This function is called automatically if using {@link Two#play} or the `autostart` parameter in construction.
     */
    update: function() {

      var animated = !!this._lastFrame;
      var now = perf.now();

      if (animated) {
        this.timeDelta = parseFloat((now - this._lastFrame).toFixed(3));
      }
      this._lastFrame = now;

      var width = this.width;
      var height = this.height;
      var renderer = this.renderer;

      // Update width / height for the renderer
      if (width !== renderer.width || height !== renderer.height) {
        renderer.setSize(width, height, this.ratio);
      }

      this.trigger(Two.Events.update, this.frameCount, this.timeDelta);

      return this.render();

    },

    /**
     * @name Two#render
     * @fires Two.Events.render event
     * @description Render all drawable and visible objects of the scene.
     */
    render: function() {

      this.renderer.render();
      return this.trigger(Two.Events.render, this.frameCount++);

    },

    // Convenience Methods

    /**
     * @name Two#add
     * @function
     * @param {(Two.Shape[]|...Two.Shape)}} [objects] - An array of Two.js objects. Alternatively can add objects as individual arguments.
     * @description A shorthand method to add specific Two.js objects to the scene.
     */
    add: function(o) {

      var objects = o;
      if (!(objects instanceof Array)) {
        objects = _.toArray(arguments);
      }

      this.scene.add(objects);
      return this;

    },

    /**
     * @name Two#remove
     * @function
     * @param {(Two.Shape[]|...Two.Shape)} [objects] - An array of Two.js objects.
     * @description A shorthand method to remove specific Two.js objects from the scene.
     */
    remove: function(o) {

      var objects = o;
      if (!(objects instanceof Array)) {
        objects = _.toArray(arguments);
      }

      this.scene.remove(objects);

      return this;

    },

    /**
     * @name Two#clear
     * @function
     * @description Remove all all Two.js objects from the scene.
     */
    clear: function() {

      this.scene.remove(this.scene.children);
      return this;

    },

    /**
     * @name Two#makeLine
     * @function
     * @param {Number} x1
     * @param {Number} y1
     * @param {Number} x2
     * @param {Number} y2
     * @returns {Two.Line}
     * @description Creates a Two.js line and adds it to the scene.
     */
    makeLine: function(x1, y1, x2, y2) {

      var line = new Two.Line(x1, y1, x2, y2);
      this.scene.add(line);

      return line;

    },

    /**
     * @name Two#makeArrow
     * @function
     * @param {Number} x1
     * @param {Number} y1
     * @param {Number} x2
     * @param {Number} y2
     * @returns {Two.Path}
     * @description Creates a Two.js arrow and adds it to the scene.
     */
    makeArrow: function(x1, y1, x2, y2, size) {

      var headlen = _.isNumber(size ) ? size : 10;

      var angle = Math.atan2(y2 - y1, x2 - x1);

      var vertices = [

        new Two.Anchor(x1, y1, undefined, undefined, undefined, undefined, Two.Commands.move),
        new Two.Anchor(x2, y2, undefined, undefined, undefined, undefined, Two.Commands.line),
        new Two.Anchor(
          x2 - headlen * Math.cos(angle - Math.PI / 4),
          y2 - headlen * Math.sin(angle - Math.PI / 4),
          undefined, undefined, undefined, undefined, Two.Commands.line
        ),

        new Two.Anchor(x2, y2, undefined, undefined, undefined, undefined, Two.Commands.move),
        new Two.Anchor(
          x2 - headlen * Math.cos(angle + Math.PI / 4),
          y2 - headlen * Math.sin(angle + Math.PI / 4),
          undefined, undefined, undefined, undefined, Two.Commands.line
        )

      ];

      var path = new Two.Path(vertices, false, false, true);
      path.noFill();
      path.cap = 'round';
      path.join = 'round';

      this.scene.add(path);

      return path;
    },

    /**
     * @name Two#makeRectangle
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} width
     * @param {Number} height
     * @returns {Two.Rectangle}
     * @description Creates a Two.js rectangle and adds it to the scene.
     */
    makeRectangle: function(x, y, width, height) {

      var rect = new Two.Rectangle(x, y, width, height);
      this.scene.add(rect);

      return rect;

    },

    /**
     * @name Two#makeRoundedRectangle
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} width
     * @param {Number} height
     * @param {Number} sides
     * @returns {Two.Rectangle}
     * @description Creates a Two.js rounded rectangle and adds it to the scene.
     */
    makeRoundedRectangle: function(x, y, width, height, sides) {

      var rect = new Two.RoundedRectangle(x, y, width, height, sides);
      this.scene.add(rect);

      return rect;

    },

    /**
     * @name Two#makeCircle
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} radius
     * @param {Number} [resolution=4]
     * @returns {Two.Circle}
     * @description Creates a Two.js circle and adds it to the scene.
     */
    makeCircle: function(x, y, radius, resolution) {

      var circle = new Two.Circle(x, y, radius, resolution);
      this.scene.add(circle);

      return circle;

    },

    /**
     * @name Two#makeEllipse
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} rx
     * @param {Number} ry
     * @param {Number} [resolution=4]
     * @returns {Two.Ellipse}
     * @description Creates a Two.js ellipse and adds it to the scene.
     */
    makeEllipse: function(x, y, rx, ry, resolution) {

      var ellipse = new Two.Ellipse(x, y, rx, ry, resolution);
      this.scene.add(ellipse);

      return ellipse;

    },

    /**
     * @name Two#makeStar
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} outerRadius
     * @param {Number} innerRadius
     * @param {Number} sides
     * @returns {Two.Star}
     * @description Creates a Two.js star and adds it to the scene.
     */
    makeStar: function(ox, oy, outerRadius, innerRadius, sides) {

      var star = new Two.Star(ox, oy, outerRadius, innerRadius, sides);
      this.scene.add(star);

      return star;

    },

    /**
     * @name Two#makeCurve
     * @function
     * @param {Two.Anchor[]} [points] - An array of {@link Two.Anchor} points.
     * @param {...Number} - Alternatively you can pass alternating `x` / `y` coordinate values as individual arguments. These will be combined into {@link Two.Anchor}s for use in the path.
     * @returns {Two.Path} - Where `path.curved` is set to `true`.
     * @description Creates a Two.js path that is curved and adds it to the scene.
     * @nota-bene In either case of passing an array or passing numbered arguments the last argument is an optional `Boolean` that defines whether the path should be open or closed.
     */
    makeCurve: function(p) {

      var l = arguments.length, points = p;
      if (!_.isArray(p)) {
        points = [];
        for (var i = 0; i < l; i+=2) {
          var x = arguments[i];
          if (!_.isNumber(x)) {
            break;
          }
          var y = arguments[i + 1];
          points.push(new Two.Anchor(x, y));
        }
      }

      var last = arguments[l - 1];
      var curve = new Two.Path(points, !(_.isBoolean(last) ? last : undefined), true);
      var rect = curve.getBoundingClientRect();
      curve.center().translation
        .set(rect.left + rect.width / 2, rect.top + rect.height / 2);

      this.scene.add(curve);

      return curve;

    },

    /**
     * @name Two#makePolygon
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} radius
     * @param {Number} sides
     * @returns {Two.Polygon}
     * @description Creates a Two.js polygon and adds it to the scene.
     */
    makePolygon: function(x, y, radius, sides) {

      var poly = new Two.Polygon(x, y, radius, sides);
      this.scene.add(poly);

      return poly;

    },

    /**
     * @name Two#makeArcSegment
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} innerRadius
     * @param {Number} outerRadius
     * @param {Number} startAngle
     * @param {Number} endAngle
     * @param {Number} [resolution=Two.Resolution] - The number of vertices that should comprise the arc segment.
     */
    makeArcSegment: function(ox, oy, ir, or, sa, ea, res) {
      var arcSegment = new Two.ArcSegment(ox, oy, ir, or, sa, ea, res);
      this.scene.add(arcSegment);
      return arcSegment;
    },

    /**
     * @name Two#makePath
     * @function
     * @param {Two.Anchor[]} [points] - An array of {@link Two.Anchor} points.
     * @param {...Number} - Alternatively you can pass alternating `x` / `y` coordinate values as individual arguments. These will be combined into {@link Two.Anchor}s for use in the path.
     * @returns {Two.Path}
     * @description Creates a Two.js path and adds it to the scene.
     * @nota-bene In either case of passing an array or passing numbered arguments the last argument is an optional `Boolean` that defines whether the path should be open or closed.
     */
    makePath: function(p) {

      var l = arguments.length, points = p;
      if (!_.isArray(p)) {
        points = [];
        for (var i = 0; i < l; i+=2) {
          var x = arguments[i];
          if (!_.isNumber(x)) {
            break;
          }
          var y = arguments[i + 1];
          points.push(new Two.Anchor(x, y));
        }
      }

      var last = arguments[l - 1];
      var path = new Two.Path(points, !(_.isBoolean(last) ? last : undefined));
      var rect = path.getBoundingClientRect();

      if (_.isNumber(rect.top)   && _.isNumber(rect.left)   &&
          _.isNumber(rect.right) && _.isNumber(rect.bottom)) {
        path.center().translation
          .set(rect.left + rect.width / 2, rect.top + rect.height / 2);
      }

      this.scene.add(path);

      return path;

    },

    /**
     * @name Two#makeText
     * @function
     * @param {String} message
     * @param {Number} x
     * @param {Number} y
     * @param {Object} [styles] - An object to describe any of the {@link Two.Text.Properties} including `fill`, `stroke`, `linewidth`, `family`, `alignment`, `leading`, `opacity`, etc..
     * @returns {Two.Text}
     * @description Creates a Two.js text object and adds it to the scene.
     */
    makeText: function(message, x, y, styles) {
      var text = new Two.Text(message, x, y, styles);
      this.add(text);
      return text;
    },

    /**
     * @name Two#makeLinearGradient
     * @function
     * @param {Number} x1
     * @param {Number} y1
     * @param {Number} x2
     * @param {Number} y2
     * @param {...Two.Stop} [stops] - Any number of color stops sometimes reffered to as ramp stops. If none are supplied then the default black-to-white two stop gradient is applied.
     * @returns {Two.LinearGradient}
     * @description Creates a Two.js linear gradient and ads it to the scene. In the case of an effect it's added to an invisible "definitions" group.
     */
    makeLinearGradient: function(x1, y1, x2, y2 /* stops */) {

      var stops = slice.call(arguments, 4);
      var gradient = new Two.LinearGradient(x1, y1, x2, y2, stops);

      this.add(gradient);

      return gradient;

    },

    /**
     * @name Two#makeRadialGradient
     * @function
     * @param {Number} x1
     * @param {Number} y1
     * @param {Number} radius
     * @param {...Two.Stop} [stops] - Any number of color stops sometimes reffered to as ramp stops. If none are supplied then the default black-to-white two stop gradient is applied.
     * @returns {Two.RadialGradient}
     * @description Creates a Two.js linear-gradient object and ads it to the scene. In the case of an effect it's added to an invisible "definitions" group.
     */
    makeRadialGradient: function(x1, y1, r /* stops */) {

      var stops = slice.call(arguments, 3);
      var gradient = new Two.RadialGradient(x1, y1, r, stops);

      this.add(gradient);

      return gradient;

    },

    /**
     * @name Two#makeSprite
     * @function
     * @param {(String|Two.Texture)} pathOrTexture - The URL path to an image or an already created {@link Two.Texture}.
     * @param {Number} x
     * @param {Number} y
     * @param {Number} [columns=1]
     * @param {Number} [rows=1]
     * @param {Integer} [frameRate=0]
     * @param {Boolean} [autostart=false]
     * @returns {Two.Sprite}
     * @description Creates a Two.js sprite object and adds it to the scene. Sprites can be used for still images as well as animations.
     */
    makeSprite: function(path, x, y, cols, rows, frameRate, autostart) {

      var sprite = new Two.Sprite(path, x, y, cols, rows, frameRate);
      if (autostart) {
        sprite.play();
      }
      this.add(sprite);

      return sprite;

    },

    /**
     * @name Two#makeImageSequence
     * @function
     * @param {(String[]|Two.Texture[])} pathsOrTextures - An array of paths or of {@link Two.Textures}.
     * @param {Number} x
     * @param {Number} y
     * @param {Number} [frameRate=0]
     * @param {Boolean} [autostart=false]
     * @returns {Two.ImageSequence}
     * @description Creates a Two.js image sequence object and adds it to the scene.
     */
    makeImageSequence: function(paths, x, y, frameRate, autostart) {

      var imageSequence = new Two.ImageSequence(paths, x, y, frameRate);
      if (autostart) {
        imageSequence.play();
      }
      this.add(imageSequence);

      return imageSequence;

    },

    /**
     * @name Two#makeTexture
     * @function
     * @param {(String|Image|Canvas|Video)} [pathOrSource] - The URL path to an image or a DOM image-like element.
     * @param {Function} [callback] - Function to be invoked when the image is loaded.
     * @returns {Two.Texture}
     * @description Creates a Two.js texture object.
     */
    makeTexture: function(path, callback) {

      var texture = new Two.Texture(path, callback);
      return texture;

    },

    /**
     * @name Two#makeGroup
     * @function
     * @param {(Two.Shape[]|...Two.Shape)} [objects] - Two.js objects to be added to the group in the form of an array or as individual arguments.
     * @returns {Two.Group}
     * @description Creates a Two.js group object and adds it to the scene.
     */
    makeGroup: function(o) {

      var objects = o;
      if (!(objects instanceof Array)) {
        objects = _.toArray(arguments);
      }

      var group = new Two.Group();
      this.scene.add(group);
      group.add(objects);

      return group;

    },

    /**
     * @name Two#interpret
     * @function
     * @param {SvgNode} svgNode - The SVG node to be parsed.
     * @param {Boolean} shallow - Don't create a top-most group but append all content directly.
     * @param {Boolean} add â€“ Automatically add the reconstructed SVG node to scene.
     * @returns {Two.Group}
     * @description Interpret an SVG Node and add it to this instance's scene. The distinction should be made that this doesn't `import` svg's, it solely interprets them into something compatible for Two.js - this is slightly different than a direct transcription.
     */
    interpret: function(svgNode, shallow, add) {

      var tag = svgNode.tagName.toLowerCase();

      add = (typeof add !== 'undefined') ? add : true;

      if (!(tag in Two.Utils.read)) {
        return null;
      }

      var node = Two.Utils.read[tag].call(this, svgNode);

      if (add) {
        this.add(shallow && node instanceof Two.Group ? node.children : node);
      }

      return node;

    },

    /**
     * @name Two#load
     * @function
     * @param {String|SvgNode} pathOrSVGContent - The URL path of an SVG file or an SVG document as text.
     * @param {Function} callback - Function to call once loading has completed.
     * @returns {Two.Group}
     * @description Load an SVG file or SVG text and interpret it into Two.js legible objects.
     */
    load: function(text, callback) {

      var group = new Two.Group();
      var elem, i, j;

      var attach = _.bind(function(data) {

        dom.temp.innerHTML = data;

        for (i = 0; i < dom.temp.children.length; i++) {
          elem = dom.temp.children[i];
          if (/svg/i.test(elem.nodeName)) {
            // Two.Utils.applySvgViewBox.call(this, group, elem.getAttribute('viewBox'));
            for (j = 0; j < elem.children.length; j++) {
              group.add(this.interpret(elem.children[j]));
            }
          } else {
            group.add(this.interpret(elem));
          }
        }

        if (_.isFunction(callback)) {
          var svg = dom.temp.children.length <= 1
            ? dom.temp.children[0] : dom.temp.children;
          callback(group, svg);
        }

      }, this);

      if (/.*\.svg$/ig.test(text)) {

        Two.Utils.xhr(text, attach);

        return group;

      }

      attach(text);

      return group;

    }

  });

  function fitToWindow() {

    var wr = document.body.getBoundingClientRect();

    var width = this.width = wr.width;
    var height = this.height = wr.height;

    this.renderer.setSize(width, height, this.ratio);

  }

  function updateDimensions(width, height) {
    this.width = width;
    this.height = height;
    this.trigger(Two.Events.resize, width, height);
  }

  // Request Animation Frame

  var raf = dom.getRequestAnimationFrame();

  function loop() {

    for (var i = 0; i < Two.Instances.length; i++) {
      var t = Two.Instances[i];
      if (t.playing) {
        t.update();
      }
    }

    Two.nextFrameID = raf(loop);

  }

  if ( true && module.exports) {
    module.exports = Two;
  } else if (typeof define === 'function' && __webpack_require__(/*! !webpack amd options */ "../node_modules/webpack/buildin/amd-options.js")) {
    define('two', [], function() {
      return Two;
    });
  }

  return Two;

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var _ = Two.Utils;

  /**
   * @name Two.Registry
   * @class
   * @description An arbitrary class to manage a directory of things. Mainly used for keeping tabs of textures in Two.js.
   */
  var Registry = Two.Registry = function() {

    this.map = {};

  };

  _.extend(Registry.prototype, {

    constructor: Registry,

    /**
     * @name Two.Registry#add
     * @function
     * @param {String} id - A unique identifier.
     * @param value - Any type of variable to be registered to the directory.
     * @description Adds any value to the directory. Assigned by the `id`.
     */
    add: function(id, obj) {
      this.map[id] = obj;
      return this;
    },

    /**
     * @name Two.Registry#remove
     * @function
     * @param {String} id - A unique identifier.
     * @description Remove any value from the directory by its `id`.
     */
    remove: function(id) {
      delete this.map[id];
      return this;
    },

    /**
     * @name Two.Registry#get
     * @function
     * @param {String} id - A unique identifier.
     * @returns value - The associated value. If unavailable then `undefined` is returned.
     * @description Get a registered value by its `id`.
     */
    get: function(id) {
      return this.map[id];
    },

    /**
     * @name Two.Registry#contains
     * @function
     * @param {String} id - A unique identifier.
     * @returns {Boolean}
     * @description Convenience method to see if a value is registered to an `id` already.
     */
    contains: function(id) {
      return id in this.map;
    }

  });

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var _ = Two.Utils;

  /**
   * @name Two.Vector
   * @class
   * @param {Number} [x=0] - Any number to represent the horizontal x-component of the vector.
   * @param {Number} [y=0] - Any number to represent the vertical y-component of the vector.
   * @description A class to store x / y component vector data. In addition to storing data `Two.Vector` has suped up methods for commonplace mathematical operations.
   */
  var Vector = Two.Vector = function(x, y) {

    /**
     * @name Two.Vector#x
     * @property {Number} - The horizontal x-component of the vector.
     */
    this.x = x || 0;

    /**
     * @name Two.Vector#y
     * @property {Number} - The vertical y-component of the vector.
     */
    this.y = y || 0;

  };

  _.extend(Vector, {

    /**
     * @name Two.Vector.zero
     * @readonly
     * @property {Two.Vector} - Handy reference to a vector with component values 0, 0 at all times.
     */
    zero: new Two.Vector(),

    /**
     * @name Two.Vector.add
     * @function
     * @param {Two.Vector} v1
     * @param {Two.Vector} v2
     * @returns {Two.Vector}
     * @description Add two vectors together.
     */
    add: function(v1, v2) {
      return new Vector(v1.x + v2.x, v1.y + v2.y);
    },

    /**
     * @name Two.Vector.sub
     * @function
     * @param {Two.Vector} v1
     * @param {Two.Vector} v2
     * @returns {Two.Vector}
     * @description Subtract two vectors: `v2` from `v1`.
     */
    sub: function(v1, v2) {
      return new Vector(v1.x - v2.x, v1.y - v2.y);
    },

    /**
     * @name Two.Vector.subtract
     * @borrows Two.Vector.sub as Two.Vector.subtract
     */
    subtract: function(v1, v2) {
      return Vector.sub(v1, v2);
    },

    /**
     * @name Two.Vector.ratioBetween
     * @function
     * @param {Two.Vector} A
     * @param {Two.Vector} B
     * @returns {Number} The ratio betwen two points `v1` and `v2`.
     */
    ratioBetween: function(v1, v2) {

      return (v1.x * v2.x + v1.y * v2.y) / (v1.length() * v2.length());

    },

    /**
     * @name Two.Vector.angleBetween
     * @function
     * @param {Two.Vector} v1
     * @param {Two.Vector} v2
     * @returns {Radians} The angle between points `v1` and `v2`.
     */
    angleBetween: function(v1, v2) {

      var dx, dy;

      if (arguments.length >= 4) {

        dx = arguments[0] - arguments[2];
        dy = arguments[1] - arguments[3];

        return Math.atan2(dy, dx);

      }

      dx = v1.x - v2.x;
      dy = v1.y - v2.y;

      return Math.atan2(dy, dx);

    },

    /**
     * @name Two.Vector.distanceBetween
     * @function
     * @param {Two.Vector} v1
     * @param {Two.Vector} v2
     * @returns {Number} The distance between points `v1` and `v2`. Distance is always positive.
     */
    distanceBetween: function(v1, v2) {

      return Math.sqrt(Vector.distanceBetweenSquared(v1, v2));

    },

    /**
     * @name Two.Vector.distanceBetweenSquared
     * @function
     * @param {Two.Vector} v1
     * @param {Two.Vector} v2
     * @returns {Number} The squared distance between points `v1` and `v2`.
     */
    distanceBetweenSquared: function(v1, v2) {

      var dx = v1.x - v2.x;
      var dy = v1.y - v2.y;

      return dx * dx + dy * dy;

    },

    /**
     * @name Two.Vector.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Vector} to any object. Handy if you'd like to extend the {@link Two.Vector} class on a custom class.
     */
    MakeObservable: function(object) {

      // /**
      //  * Override Backbone bind / on in order to add properly broadcasting.
      //  * This allows Two.Vector to not broadcast events unless event listeners
      //  * are explicity bound to it.
      //  */

      object.bind = object.on = function() {

        if (!this._bound) {
          this._x = this.x;
          this._y = this.y;
          Object.defineProperty(this, 'x', xgs);
          Object.defineProperty(this, 'y', ygs);
          _.extend(this, BoundProto);
          this._bound = true; // Reserved for event initialization check
        }

        Two.Utils.Events.bind.apply(this, arguments);

        return this;

      };

    }

  });

  _.extend(Vector.prototype, Two.Utils.Events, {

    constructor: Vector,

    /**
     * @name Two.Vector#set
     * @function
     * @param {Number} x
     * @param {Number} y
     * @returns {Two.Vector} - An instance of itself for the purpose of chaining.
     * @description Set the x / y components of a vector to specific number values.
     */
    set: function(x, y) {
      this.x = x;
      this.y = y;
      return this;
    },

    /**
     * @name Two.Vector#copy
     * @function
     * @param {Two.Vector} v
     * @returns {Two.Vector} - An instance of itself for the purpose of chaining.
     * @description Copy the x / y components of another object `v`.
     */
    copy: function(v) {
      this.x = v.x;
      this.y = v.y;
      return this;
    },

    /**
     * @name Two.Vector#clear
     * @function
     * @returns {Two.Vector} - An instance of itself for the purpose of chaining.
     * @description Set the x / y component values of the vector to zero.
     */
    clear: function() {
      this.x = 0;
      this.y = 0;
      return this;
    },

    /**
     * @name Two.Vector#clone
     * @function
     * @returns {Two.Vector} - A new instance of {@link Two.Vector}.
     * @description Create a new vector and copy the existing values onto the newly created instance.
     */
    clone: function() {
      return new Vector(this.x, this.y);
    },

    /**
     * @name Two.Vector#add
     * @function
     * @param {Two.Vector} v
     * @returns {Two.Vector} - An instance of itself for the purpose of chaining.
     * @description Add an object with x / y component values to the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#add
     * @function
     * @param {Number} v
     * @returns {Two.Vector} - An instance of itself for the purpose of chaining.
     * @description Add the **same** number to both x / y component values of the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#add
     * @function
     * @param {Number} x
     * @param {Number} y
     * @returns {Two.Vector} - An instance of itself for the purpose of chaining.
     * @description Add `x` / `y` values to their respective component value on the instance.
     * @overloaded
     */
    add: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (_.isNumber(x)) {
          this.x += x;
          this.y += x;
        } else if (x && _.isNumber(x.x) && _.isNumber(x.y)) {
          this.x += x.x;
          this.y += x.y;
        }
      } else {
        this.x += x;
        this.y += y;
      }
      return this;
    },

    /**
     * @name Two.Vector#addSelf
     * @borrows Two.Vector#add as Two.Vector#addSelf
     */
    addSelf: function(v) {
      return this.add.apply(this, arguments);
    },

    /**
     * @name Two.Vector#sub
     * @function
     * @param {Two.Vector} v
     * @returns {Two.Vector} - An instance of itself for the purpose of chaining.
     * @description Subtract an object with x / y component values to the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#sub
     * @function
     * @param {Number} v
     * @returns {Two.Vector} - An instance of itself for the purpose of chaining.
     * @description Subtract the **same** number to both x / y component values of the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#sub
     * @function
     * @param {Number} x
     * @param {Number} y
     * @returns {Two.Vector} - An instance of itself for the purpose of chaining.
     * @description Subtract `x` / `y` values to their respective component value on the instance.
     * @overloaded
     */
    sub: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (_.isNumber(x)) {
          this.x -= x;
          this.y -= x;
        } else if (x && _.isNumber(x.x) && _.isNumber(x.y)) {
          this.x -= x.x;
          this.y -= x.y;
        }
      } else {
        this.x -= x;
        this.y -= y;
      }
      return this;
    },

    /**
     * @name Two.Vector#subtract
     * @borrows Two.Vector#sub as Two.Vector#subtract
     */
    subtract: function() {
      return this.sub.apply(this, arguments);
    },

    /**
     * @name Two.Vector#subSelf
     * @borrows Two.Vector#sub as Two.Vector#subSelf
     */
    subSelf: function(v) {
      return this.sub.apply(this, arguments);
    },

    /**
     * @name Two.Vector#subtractSelf
     * @borrows Two.Vector#sub as Two.Vector#subtractSelf
     */
    subtractSelf: function(v) {
      return this.sub.apply(this, arguments);
    },

    /**
     * @name Two.Vector#multiply
     * @function
     * @param {Two.Vector} v
     * @returns {Two.Vector} - An instance of itself for the purpose of chaining.
     * @description Multiply an object with x / y component values to the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#multiply
     * @function
     * @param {Number} v
     * @returns {Two.Vector} - An instance of itself for the purpose of chaining.
     * @description Multiply the **same** number to both x / y component values of the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#multiply
     * @function
     * @param {Number} x
     * @param {Number} y
     * @returns {Two.Vector} - An instance of itself for the purpose of chaining.
     * @description Multiply `x` / `y` values to their respective component value on the instance.
     * @overloaded
     */
    multiply: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (_.isNumber(x)) {
          this.x *= x;
          this.y *= x;
        } else if (x && _.isNumber(x.x) && _.isNumber(x.y)) {
          this.x *= x.x;
          this.y *= x.y;
        }
      } else {
        this.x *= x;
        this.y *= y;
      }
      return this;
    },

    /**
     * @name Two.Vector#multiplySelf
     * @borrows Two.Vector#multiply as Two.Vector#multiplySelf
     */
    multiplySelf: function(v) {
      return this.multiply.apply(this, arguments);
    },

    /**
     * @name Two.Vector#multiplyScalar
     * @function
     * @param {Number} s - The scalar to multiply by.
     * @description Mulitiply the vector by a single number. Shorthand to call {@link Two.Vector#multiply} directly.
     */
    multiplyScalar: function(s) {
      return this.multiply(s);
    },

    /**
     * @name Two.Vector#divide
     * @function
     * @param {Two.Vector} v
     * @returns {Two.Vector} - An instance of itself for the purpose of chaining.
     * @description Divide an object with x / y component values to the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#divide
     * @function
     * @param {Number} v
     * @returns {Two.Vector} - An instance of itself for the purpose of chaining.
     * @description Divide the **same** number to both x / y component values of the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#divide
     * @function
     * @param {Number} x
     * @param {Number} y
     * @returns {Two.Vector} - An instance of itself for the purpose of chaining.
     * @description Divide `x` / `y` values to their respective component value on the instance.
     * @overloaded
     */
    divide: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (_.isNumber(x)) {
          this.x /= x;
          this.y /= x;
        } else if (x && _.isNumber(x.x) && _.isNumber(x.y)) {
          this.x /= x.x;
          this.y /= x.y;
        }
      } else {
        this.x /= x;
        this.y /= y;
      }
      if (_.isNaN(this.x)) {
        this.x = 0;
      }
      if (_.isNaN(this.y)) {
        this.y = 0;
      }
      return this;
    },

    /**
     * @name Two.Vector#divideSelf
     * @borrows Two.Vector#divide as Two.Vector#divideSelf
     */
    divideSelf: function(v) {
      return this.divide.apply(this, arguments);
    },

    /**
     * @name Two.Vector#divideScalar
     * @function
     * @param {Number} s - The scalar to divide by.
     * @description Divide the vector by a single number. Shorthand to call {@link Two.Vector#divide} directly.
     */
    divideScalar: function(s) {
      return this.divide(s);
    },

    /**
     * @name Two.Vector#negate
     * @function
     * @description Invert each component's sign value.
     */
    negate: function() {
      return this.multiply(-1);
    },

    /**
     * @name Two.Vector#negate
     * @function
     * @returns {Number}
     * @description Get the [dot product]{@link https://en.wikipedia.org/wiki/Dot_product} of the vector.
     */
    dot: function(v) {
      return this.x * v.x + this.y * v.y;
    },

    /**
     * @name Two.Vector#length
     * @function
     * @returns {Number}
     * @description Get the length of a vector.
     */
    length: function() {
      return Math.sqrt(this.lengthSquared());
    },

    /**
     * @name Two.Vector#lengthSquared
     * @function
     * @returns {Number}
     * @description Get the length of the vector to the power of two. Widely used as less expensive than {@link Two.Vector#length}, because it isn't square-rooting any numbers.
     */
    lengthSquared: function() {
      return this.x * this.x + this.y * this.y;
    },

    /**
     * @name Two.Vector#normalize
     * @function
     * @description Normalize the vector from negative one to one.
     */
    normalize: function() {
      return this.divideScalar(this.length());
    },

    /**
     * @name Two.Vector#distanceTo
     * @function
     * @returns {Number}
     * @description Get the distance between two vectors.
     */
    distanceTo: function(v) {
      return Math.sqrt(this.distanceToSquared(v));
    },

    /**
     * @name Two.Vector#distanceToSquared
     * @function
     * @returns {Number}
     * @description Get the distance between two vectors to the power of two. Widely used as less expensive than {@link Two.Vector#distanceTo}, because it isn't square-rooting any numbers.
     */
    distanceToSquared: function(v) {
      var dx = this.x - v.x,
          dy = this.y - v.y;
      return dx * dx + dy * dy;
    },

    /**
     * @name Two.Vector#setLength
     * @function
     * @param {Number} l - length to set vector to.
     * @description Set the length of a vector.
     */
    setLength: function(l) {
      return this.normalize().multiplyScalar(l);
    },

    /**
     * @name Two.Vector#equals
     * @function
     * @param {Two.Vector} v - The vector to compare against.
     * @param {Number} [eps=0.0001] - An options epsilon for precision.
     * @returns {Boolean}
     * @description Qualify if one vector roughly equal another. With a margin of error defined by epsilon.
     */
    equals: function(v, eps) {
      eps = (typeof eps === 'undefined') ?  0.0001 : eps;
      return (this.distanceTo(v) < eps);
    },

    /**
     * @name Two.Vector#lerp
     * @function
     * @param {Two.Vector} v - The destination vector to step towards.
     * @param {Number} t - The zero to one value of how close the current vector gets to the destination vector.
     * @description Linear interpolate one vector to another by an amount `t` defined as a zero to one number.
     * @see [Matt DesLauriers]{@link https://twitter.com/mattdesl/status/1031305279227478016} has a good thread about this.
     */
    lerp: function(v, t) {
      var x = (v.x - this.x) * t + this.x;
      var y = (v.y - this.y) * t + this.y;
      return this.set(x, y);
    },

    /**
     * @name Two.Vector#isZero
     * @function
     * @param {Number} [eps=0.0001] - Optional precision amount to check against.
     * @returns {Boolean}
     * @description Check to see if vector is roughly zero, based on the `epsilon` precision value.
     */
    isZero: function(eps) {
      eps = (typeof eps === 'undefined') ?  0.0001 : eps;
      return (this.length() < eps);
    },

    /**
     * @name Two.Vector#toString
     * @function
     * @returns {String}
     * @description Return a comma-separated string of x, y value. Great for storing in a database.
     */
    toString: function() {
      return this.x + ', ' + this.y;
    },

    /**
     * @name Two.Vector#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the vector.
     */
    toObject: function() {
      return { x: this.x, y: this.y };
    },

    /**
     * @name Two.Vector#rotate
     * @function
     * @param {Radians} radians - The amoun to rotate the vector by.
     * @description Rotate a vector.
     */
    rotate: function(radians) {
      var cos = Math.cos(radians);
      var sin = Math.sin(radians);
      this.x = this.x * cos - this.y * sin;
      this.y = this.x * sin + this.y * cos;
      return this;
    }

  });

  // The same set of prototypical functions, but using the underlying
  // getter or setter for `x` and `y` values. This set of functions
  // is used instead of the previously documented ones above when
  // Two.Vector#bind is invoked and there is event dispatching processed
  // on x / y property changes.
  var BoundProto = {

    constructor: Vector,

    set: function(x, y) {
      this._x = x;
      this._y = y;
      return this.trigger(Two.Events.change);
    },

    copy: function(v) {
      this._x = v.x;
      this._y = v.y;
      return this.trigger(Two.Events.change);
    },

    clear: function() {
      this._x = 0;
      this._y = 0;
      return this.trigger(Two.Events.change);
    },

    clone: function() {
      return new Vector(this._x, this._y);
    },

    add: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (_.isNumber(x)) {
          this._x += x;
          this._y += x;
        }  else if (x && _.isNumber(x.x) && _.isNumber(x.y)) {
          this._x += x.x;
          this._y += x.y;
        }
      } else {
        this._x += x;
        this._y += y;
      }
      return this.trigger(Two.Events.change);
    },

    sub: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (_.isNumber(x)) {
          this._x -= x;
          this._y -= x;
        } else if (x && _.isNumber(x.x) && _.isNumber(x.y)) {
          this._x -= x.x;
          this._y -= x.y;
        }
      } else {
        this._x -= x;
        this._y -= y;
      }
      return this.trigger(Two.Events.change);
    },

    multiply: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (_.isNumber(x)) {
          this._x *= x;
          this._y *= x;
        } else if (x && _.isNumber(x.x) && _.isNumber(x.y)) {
          this._x *= x.x;
          this._y *= x.y;
        }
      } else {
        this._x *= x;
        this._y *= y;
      }
      return this.trigger(Two.Events.change);
    },

    divide: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (_.isNumber(x)) {
          this._x /= x;
          this._y /= x;
        } else if (x && _.isNumber(x.x) && _.isNumber(x.y)) {
          this._x /= x.x;
          this._y /= x.y;
        }
      } else {
        this._x /= x;
        this._y /= y;
      }
      if (_.isNaN(this._x)) {
        this._x = 0;
      }
      if (_.isNaN(this._y)) {
        this._y = 0;
      }
      return this.trigger(Two.Events.change);
    },

    dot: function(v) {
      return this._x * v.x + this._y * v.y;
    },

    lengthSquared: function() {
      return this._x * this._x + this._y * this._y;
    },

    distanceToSquared: function(v) {
      var dx = this._x - v.x,
          dy = this._y - v.y;
      return dx * dx + dy * dy;
    },

    lerp: function(v, t) {
      var x = (v.x - this._x) * t + this._x;
      var y = (v.y - this._y) * t + this._y;
      return this.set(x, y);
    },

    toString: function() {
      return this._x + ', ' + this._y;
    },

    toObject: function() {
      return { x: this._x, y: this._y };
    },

    rotate: function (radians) {
      var cos = Math.cos(radians);
      var sin = Math.sin(radians);
      this._x = this._x * cos - this._y * sin;
      this._y = this._x * sin + this._y * cos;
      return this;
    }

  };

  var xgs = {
    enumerable: true,
    get: function() {
      return this._x;
    },
    set: function(v) {
      this._x = v;
      this.trigger(Two.Events.change, 'x');
    }
  };

  var ygs = {
    enumerable: true,
    get: function() {
      return this._y;
    },
    set: function(v) {
      this._y = v;
      this.trigger(Two.Events.change, 'y');
    }
  };

  Vector.MakeObservable(Vector.prototype);

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  // Localized variables
  var commands = Two.Commands;
  var _ = Two.Utils;

  /**
   * @class
   * @name Two.Anchor
   * @param {Number} [x=0] - The x position of the root anchor point.
   * @param {Number} [y=0] - The y position of the root anchor point.
   * @param {Number} [lx=0] - The x position of the left handle point.
   * @param {Number} [ly=0] - The y position of the left handle point.
   * @param {Number} [rx=0] - The x position of the right handle point.
   * @param {Number} [ry=0] - The y position of the right handle point.
   * @param {String} [command=Two.Commands.move] - The command to describe how to render. Applicable commands are {@link Two.Commands}
   * @extends Two.Vector
   * @description An object that holds 3 {@link Two.Vector}s, the anchor point and its corresponding handles: `left` and `right`. In order to properly describe the bezier curve about the point there is also a command property to describe what type of drawing should occur when Two.js renders the anchors.
   */
  var Anchor = Two.Anchor = function(x, y, lx, ly, rx, ry, command) {

    Two.Vector.call(this, x, y);

    this._broadcast = _.bind(function() {
      this.trigger(Two.Events.change);
    }, this);

    this._command = command || commands.move;
    this._relative = true;

    var ilx = _.isNumber(lx);
    var ily = _.isNumber(ly);
    var irx = _.isNumber(rx);
    var iry = _.isNumber(ry);

    // Append the `controls` object only if control points are specified,
    // keeping the Two.Anchor inline with a Two.Vector until it needs to
    // evolve beyond those functions - e.g: a simple 2 component vector.
    if (ilx || ily || irx || iry) {
      Two.Anchor.AppendCurveProperties(this);
    }

    if (ilx) {
      this.controls.left.x = lx;
    }
    if (ily) {
      this.controls.left.y = ly;
    }
    if (irx) {
      this.controls.right.x = rx;
    }
    if (iry) {
      this.controls.right.y = ry;
    }

  };

  _.extend(Two.Anchor, {

    /**
     * @name Two.Anchor.AppendCurveProperties
     * @function
     * @param {Two.Anchor} anchor - The instance to append the `control`object to.
     * @description Adds the `controls` property as an object with `left` and `right` properties to access the bezier control handles that define how the curve is drawn. It also sets the `relative` property to `true` making vectors in the `controls` object relative to their corresponding root anchor point.
     */
    AppendCurveProperties: function(anchor) {

      anchor.relative = true;

      /**
       * @name Two.Anchor#controls
       * @property {Object} controls
       * @description An plain object that holds the controls handles for a {@link Two.Anchor}.
       */
      anchor.controls = {};

      /**
       * @name Two.Anchor#controls#left
       * @property {Two.Vector} left
       * @description The "left" control point to define handles on a bezier curve.
       */
      anchor.controls.left = new Two.Vector(0, 0);

      /**
       * @name Two.Anchor#controls#right
       * @property {Two.Vector} right
       * @description The "left" control point to define handles on a bezier curve.
       */
      anchor.controls.right = new Two.Vector(0, 0);

    },

    /**
     * @name Two.Anchor.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Anchor} to any object. Handy if you'd like to extend the {@link Two.Anchor} class on a custom class.
     */
    MakeObservable: function(object) {

      /**
       * @name Two.Anchor#command
       * @property {Two.Commands}
       * @description A draw command associated with the anchor point.
       */
      Object.defineProperty(object, 'command', {

        enumerable: true,

        get: function() {
          return this._command;
        },

        set: function(c) {
          this._command = c;
          if (this._command === commands.curve && !_.isObject(this.controls)) {
            Anchor.AppendCurveProperties(this);
          }
          return this.trigger(Two.Events.change);
        }

      });

      /**
       * @name Two.Anchor#relative
       * @property {Boolean}
       * @description A boolean to render control points relative to the root anchor point or in global coordinate-space to the rest of the scene.
       */
      Object.defineProperty(object, 'relative', {

        enumerable: true,

        get: function() {
          return this._relative;
        },

        set: function(b) {
          if (this._relative == b) {
            return this;
          }
          this._relative = !!b;
          return this.trigger(Two.Events.change);
        }

      });

      _.extend(object, Two.Vector.prototype, AnchorProto);

      // Make it possible to bind and still have the Anchor specific
      // inheritance from Two.Vector. In this case relying on `Two.Vector`
      // to do much of the heavy event-listener binding / unbinding.
      object.bind = object.on = function() {
        var bound = this._bound;
        Two.Vector.prototype.bind.apply(this, arguments);
        if (!bound) {
          _.extend(this, AnchorProto);
        }
      };

    }

  });

  var AnchorProto = {

    constructor: Two.Anchor,

    /**
     * @name Two.Anchor#listen
     * @function
     * @description Convenience method used mainly by {@link Two.Path#vertices} to listen and propagate changes from control points up to their respective anchors and further if necessary.
     */
    listen: function() {

      if (!_.isObject(this.controls)) {
        Two.Anchor.AppendCurveProperties(this);
      }

      this.controls.left.bind(Two.Events.change, this._broadcast);
      this.controls.right.bind(Two.Events.change, this._broadcast);

      return this;

    },

    /**
     * @name Two.Anchor#ignore
     * @function
     * @description Convenience method used mainly by {@link Two.Path#vertices} to ignore changes from a specific anchor's control points.
     */
    ignore: function() {

      this.controls.left.unbind(Two.Events.change, this._broadcast);
      this.controls.right.unbind(Two.Events.change, this._broadcast);

      return this;

    },

    /**
     * @name Two.Anchor#copy
     * @function
     * @param {Two.Anchor} v - The anchor to apply values to.
     * @description Copy the properties of one {@link Two.Anchor} onto another.
     */
    copy: function(v) {

      this.x = v.x;
      this.y = v.y;

      if (_.isString(v.command)) {
        this.command = v.command;
      }
      if (_.isObject(v.controls)) {
        if (!_.isObject(this.controls)) {
          Two.Anchor.AppendCurveProperties(this);
        }
        // TODO: Do we need to listen here?
        this.controls.left.copy(v.controls.left);
        this.controls.right.copy(v.controls.right);
      }
      if (_.isBoolean(v.relative)) {
        this.relative = v.relative;
      }

      // TODO: Hack for `Two.Commands.arc`
      if (this.command === Two.Commands.arc) {
        this.rx = v.rx;
        this.ry = v.ry;
        this.xAxisRotation = v.xAxisRotation;
        this.largeArcFlag = v.largeArcFlag;
        this.sweepFlag = v.sweepFlag;
      }

      return this;

    },

    /**
     * @name Two.Anchor#clone
     * @function
     * @returns {Two.Anchor}
     * @description Create a new {@link Two.Anchor}, set all its values to the current instance and return it for use.
     */
    clone: function() {

      var controls = this.controls;

      var clone = new Two.Anchor(
        this.x,
        this.y,
        controls && controls.left.x,
        controls && controls.left.y,
        controls && controls.right.x,
        controls && controls.right.y,
        this.command
      );
      clone.relative = this._relative;
      return clone;

    },

    /**
     * @name Two.Anchor#toObject
     * @function
     * @returns {Object} - An object with properties filled out to mirror {@link Two.Anchor}.
     * @description Create a JSON compatible plain object of the current instance. Intended for use with storing values in a database.
     */
    toObject: function() {
      var o = {
        x: this.x,
        y: this.y
      };
      if (this._command) {
        o.command = this._command;
      }
      if (this._relative) {
        o.relative = this._relative;
      }
      if (this.controls) {
        o.controls = {
          left: this.controls.left.toObject(),
          right: this.controls.right.toObject()
        };
      }
      return o;
    },

    /**
     * @name Two.Anchor#toString
     * @function
     * @returns {String} - A String with comma-separated values reflecting the various values on the current instance.
     * @description Create a string form of the current instance. Intended for use with storing values in a database. This is lighter to store than the JSON compatible {@link Two.Anchor#toObject}.
     */
    toString: function() {
      if (!this.controls) {
        return [this._x, this._y].join(', ');
      }
      return [this._x, this._y, this.controls.left.x, this.controls.left.y,
        this.controls.right.x, this.controls.right.y, this._command,
        this._relative ? 1 : 0].join(', ');
    }

  };

  Two.Anchor.MakeObservable(Two.Anchor.prototype);

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  // Constants

  var cos = Math.cos, sin = Math.sin, tan = Math.tan;
  var _ = Two.Utils;
  var array = [];

  /**
   * @name Two.Matrix
   * @class
   * @param {Number} [a=1] - The value for element at the first column and first row.
   * @param {Number} [b=0] - The value for element at the second column and first row.
   * @param {Number} [c=0] - The value for element at the third column and first row.
   * @param {Number} [d=0] - The value for element at the first column and second row.
   * @param {Number} [e=1] - The value for element at the second column and second row.
   * @param {Number} [f=0] - The value for element at the third column and second row.
   * @param {Number} [g=0] - The value for element at the first column and third row.
   * @param {Number} [h=0] - The value for element at the second column and third row.
   * @param {Number} [i=1] - The value for element at the third column and third row.
   * @description A class to store 3 x 3 transformation matrix information. In addition to storing data `Two.Matrix` has suped up methods for commonplace mathematical operations.
   * @nota-bene Order is based on how to construct transformation strings for the browser.
   */
  var Matrix = Two.Matrix = function(a, b, c, d, e, f) {

    /**
     * @name Two.Matrix#elements
     * @property {Number[]} - The underlying data stored as an array.
     */
    this.elements = new Two.Array(9);

    var elements = a;
    if (!_.isArray(elements)) {
      elements = _.toArray(arguments);
    }

    // initialize the elements with default values.
    this.identity();

    if (elements.length > 0) {
      this.set(elements);
    }

  };

  _.extend(Matrix, {

    /**
     * @name Two.Matrix.Identity
     * @property {Number[]} - A stored reference to the default value of a 3 x 3 matrix.
     */
    Identity: [
      1, 0, 0,
      0, 1, 0,
      0, 0, 1
    ],

    /**
     * @name Two.Matrix.Multiply
     * @function
     * @param {Two.Matrix} A
     * @param {Two.Matrix} B
     * @param {Two.Matrix} [C] - An optional matrix to apply the multiplication to.
     * @returns {Two.Matrix} - If an optional `C` matrix isn't passed then a new one is created and returned.
     * @description Multiply two matrices together and return the result.
     */
    Multiply: function(A, B, C) {

      if (B.length <= 3) { // Multiply Vector

        var x, y, z, e = A;

        var a = B[0] || 0,
            b = B[1] || 0,
            c = B[2] || 0;

        // Go down rows first
        // a, d, g, b, e, h, c, f, i

        x = e[0] * a + e[1] * b + e[2] * c;
        y = e[3] * a + e[4] * b + e[5] * c;
        z = e[6] * a + e[7] * b + e[8] * c;

        return { x: x, y: y, z: z };

      }

      var A0 = A[0], A1 = A[1], A2 = A[2];
      var A3 = A[3], A4 = A[4], A5 = A[5];
      var A6 = A[6], A7 = A[7], A8 = A[8];

      var B0 = B[0], B1 = B[1], B2 = B[2];
      var B3 = B[3], B4 = B[4], B5 = B[5];
      var B6 = B[6], B7 = B[7], B8 = B[8];

      C = C || new Two.Array(9);

      C[0] = A0 * B0 + A1 * B3 + A2 * B6;
      C[1] = A0 * B1 + A1 * B4 + A2 * B7;
      C[2] = A0 * B2 + A1 * B5 + A2 * B8;
      C[3] = A3 * B0 + A4 * B3 + A5 * B6;
      C[4] = A3 * B1 + A4 * B4 + A5 * B7;
      C[5] = A3 * B2 + A4 * B5 + A5 * B8;
      C[6] = A6 * B0 + A7 * B3 + A8 * B6;
      C[7] = A6 * B1 + A7 * B4 + A8 * B7;
      C[8] = A6 * B2 + A7 * B5 + A8 * B8;

      return C;

    }

  });

  _.extend(Matrix.prototype, Two.Utils.Events, {

    constructor: Matrix,

    /**
     * @name Two.Matrix#manual
     * @property {Boolean} - Determines whether Two.js automatically calculates the values for the matrix or if the developer intends to manage the matrix.
     * @nota-bene - Setting to `true` nullifies {@link Two.Shape#translation}, {@link Two.Shape#rotation}, and {@link Two.Shape#scale}.
     */
    manual: false,

    /**
     * @name Two.Matrix#set
     * @function
     * @param {Number} a - The value for element at the first column and first row.
     * @param {Number} b - The value for element at the second column and first row.
     * @param {Number} c - The value for element at the third column and first row.
     * @param {Number} d - The value for element at the first column and second row.
     * @param {Number} e - The value for element at the second column and second row.
     * @param {Number} f - The value for element at the third column and second row.
     * @param {Number} g - The value for element at the first column and third row.
     * @param {Number} h - The value for element at the second column and third row.
     * @param {Number} i - The value for element at the third column and third row.
     * @description Set an array of values onto the matrix. Order described in {@link Two.Matrix}.
     */

     /**
      * @name Two.Matrix#set
      * @function
      * @param {Number[]} a - The array of elements to apply.
      * @description Set an array of values onto the matrix. Order described in {@link Two.Matrix}.
      */
    set: function(a, b, c, d, e, f, g, h, i) {

      var elements;

      if (_.isUndefined(b)) {
        elements = a;
        a = elements[0];
        b = elements[1];
        c = elements[2];
        d = elements[3];
        e = elements[4];
        f = elements[5];
        g = elements[6];
        h = elements[7];
        i = elements[8];
      }

      this.elements[0] = a;
      this.elements[1] = b;
      this.elements[2] = c;
      this.elements[3] = d;
      this.elements[4] = e;
      this.elements[5] = f;
      this.elements[6] = g;
      this.elements[7] = h;
      this.elements[8] = i;

      return this.trigger(Two.Events.change);

    },

    /**
     * @name Two.Matrix#copy
     * @function
     * @description Copy the matrix of one to the current instance.
     */
    copy: function(m) {

      this.elements[0] = m.elements[0];
      this.elements[1] = m.elements[1];
      this.elements[2] = m.elements[2];
      this.elements[3] = m.elements[3];
      this.elements[4] = m.elements[4];
      this.elements[5] = m.elements[5];
      this.elements[6] = m.elements[6];
      this.elements[7] = m.elements[7];
      this.elements[8] = m.elements[8];

      this.manual = m.manual;

      return this.trigger(Two.Events.change);

    },

    /**
     * @name Two.Matrix#identity
     * @function
     * @description Turn matrix to the identity, like resetting.
     */
    identity: function() {

      this.elements[0] = Matrix.Identity[0];
      this.elements[1] = Matrix.Identity[1];
      this.elements[2] = Matrix.Identity[2];
      this.elements[3] = Matrix.Identity[3];
      this.elements[4] = Matrix.Identity[4];
      this.elements[5] = Matrix.Identity[5];
      this.elements[6] = Matrix.Identity[6];
      this.elements[7] = Matrix.Identity[7];
      this.elements[8] = Matrix.Identity[8];

      return this.trigger(Two.Events.change);

    },

    /**
     * @name Two.Matrix.multiply
     * @function
     * @param {Number} a - The scalar to be multiplied.
     * @description Multiply all components of the matrix against a single scalar value.
     */

    /**
     * @name Two.Matrix.multiply
     * @function
     * @param {Number} a - The x component to be multiplied.
     * @param {Number} b - The y component to be multiplied.
     * @param {Number} c - The z component to be multiplied.
     * @description Multiply all components of a matrix against a 3 component vector.
     */

    /**
     * @name Two.Matrix.multiply
     * @function
     * @param {Number} a - The value at the first column and first row of the matrix to be multiplied.
     * @param {Number} b - The value at the second column and first row of the matrix to be multiplied.
     * @param {Number} c - The value at the third column and first row of the matrix to be multiplied.
     * @param {Number} d - The value at the first column and second row of the matrix to be multiplied.
     * @param {Number} e - The value at the second column and second row of the matrix to be multiplied.
     * @param {Number} f - The value at the third column and second row of the matrix to be multiplied.
     * @param {Number} g - The value at the first column and third row of the matrix to be multiplied.
     * @param {Number} h - The value at the second column and third row of the matrix to be multiplied.
     * @param {Number} i - The value at the third column and third row of the matrix to be multiplied.
     * @description Multiply all components of a matrix against another matrix.
     */
    multiply: function(a, b, c, d, e, f, g, h, i) {

      // Multiply scalar

      if (_.isUndefined(b)) {

        this.elements[0] *= a;
        this.elements[1] *= a;
        this.elements[2] *= a;
        this.elements[3] *= a;
        this.elements[4] *= a;
        this.elements[5] *= a;
        this.elements[6] *= a;
        this.elements[7] *= a;
        this.elements[8] *= a;

        return this.trigger(Two.Events.change);

      }

      if (_.isUndefined(d)) { // Multiply Vector

        var x, y, z;
        a = a || 0;
        b = b || 0;
        c = c || 0;
        e = this.elements;

        // Go down rows first
        // a, d, g, b, e, h, c, f, i

        x = e[0] * a + e[1] * b + e[2] * c;
        y = e[3] * a + e[4] * b + e[5] * c;
        z = e[6] * a + e[7] * b + e[8] * c;

        return { x: x, y: y, z: z };

      }

      // Multiple matrix

      var A = this.elements;
      var B = [a, b, c, d, e, f, g, h, i];

      var A0 = A[0], A1 = A[1], A2 = A[2];
      var A3 = A[3], A4 = A[4], A5 = A[5];
      var A6 = A[6], A7 = A[7], A8 = A[8];

      var B0 = B[0], B1 = B[1], B2 = B[2];
      var B3 = B[3], B4 = B[4], B5 = B[5];
      var B6 = B[6], B7 = B[7], B8 = B[8];

      this.elements[0] = A0 * B0 + A1 * B3 + A2 * B6;
      this.elements[1] = A0 * B1 + A1 * B4 + A2 * B7;
      this.elements[2] = A0 * B2 + A1 * B5 + A2 * B8;

      this.elements[3] = A3 * B0 + A4 * B3 + A5 * B6;
      this.elements[4] = A3 * B1 + A4 * B4 + A5 * B7;
      this.elements[5] = A3 * B2 + A4 * B5 + A5 * B8;

      this.elements[6] = A6 * B0 + A7 * B3 + A8 * B6;
      this.elements[7] = A6 * B1 + A7 * B4 + A8 * B7;
      this.elements[8] = A6 * B2 + A7 * B5 + A8 * B8;

      return this.trigger(Two.Events.change);

    },

    /**
     * @name Two.Matrix#inverse
     * @function
     * @param {Two.Matrix} [out] - The optional matrix to apply the inversion to.
     * @description Return an inverted version of the matrix. If no optional one is passed a new matrix is created and returned.
     */
    inverse: function(out) {

      var a = this.elements;
      out = out || new Two.Matrix();

      var a00 = a[0], a01 = a[1], a02 = a[2];
      var a10 = a[3], a11 = a[4], a12 = a[5];
      var a20 = a[6], a21 = a[7], a22 = a[8];

      var b01 = a22 * a11 - a12 * a21;
      var b11 = -a22 * a10 + a12 * a20;
      var b21 = a21 * a10 - a11 * a20;

      // Calculate the determinant
      var det = a00 * b01 + a01 * b11 + a02 * b21;

      if (!det) {
        return null;
      }

      det = 1.0 / det;

      out.elements[0] = b01 * det;
      out.elements[1] = (-a22 * a01 + a02 * a21) * det;
      out.elements[2] = (a12 * a01 - a02 * a11) * det;
      out.elements[3] = b11 * det;
      out.elements[4] = (a22 * a00 - a02 * a20) * det;
      out.elements[5] = (-a12 * a00 + a02 * a10) * det;
      out.elements[6] = b21 * det;
      out.elements[7] = (-a21 * a00 + a01 * a20) * det;
      out.elements[8] = (a11 * a00 - a01 * a10) * det;

      return out;

    },

    /**
     * @name Two.Matrix#scale
     * @function
     * @param {Number} scale - The one dimensional scale to apply to the matrix.
     * @description Uniformly scale the transformation matrix.
     */

    /**
     * @name Two.Matrix#scale
     * @function
     * @param {Number} sx - The horizontal scale factor.
     * @param {Number} sy - The vertical scale factor
     * @description Scale the transformation matrix in two dimensions.
     */
    scale: function(sx, sy) {

      var l = arguments.length;
      if (l <= 1) {
        sy = sx;
      }

      return this.multiply(sx, 0, 0, 0, sy, 0, 0, 0, 1);

    },

    /**
     * @name Two.Matrix#rotate
     * @function
     * @param {Radians} radians - The amount to rotate in radians.
     * @description Rotate the matrix.
     */
    rotate: function(radians) {

      var c = cos(radians);
      var s = sin(radians);

      return this.multiply(c, -s, 0, s, c, 0, 0, 0, 1);

    },

    /**
     * @name Two.Matrix#translate
     * @function
     * @param {Number} x - The horizontal translation value to apply.
     * @param {Number} y - The vertical translation value to apply.
     * @description Translate the matrix.
     */
    translate: function(x, y) {

      return this.multiply(1, 0, x, 0, 1, y, 0, 0, 1);

    },

    /**
     * @name Two.Matrix#skewX
     * @function
     * @param {Radians} radians - The amount to skew in radians.
     * @description Skew the matrix by an angle in the x axis direction.
     */
    skewX: function(radians) {

      var a = tan(radians);

      return this.multiply(1, a, 0, 0, 1, 0, 0, 0, 1);

    },

    /**
     * @name Two.Matrix#skewY
     * @function
     * @param {Radians} radians - The amount to skew in radians.
     * @description Skew the matrix by an angle in the y axis direction.
     */
    skewY: function(radians) {

      var a = tan(radians);

      return this.multiply(1, 0, 0, a, 1, 0, 0, 0, 1);

    },

    /**
     * @name Two.Matrix#toString
     * @function
     * @param {Boolean} [fullMatrix=false] - Return the full 9 elements of the matrix or just 6 for 2D transformations.
     * @returns {String} - The transformation matrix as a 6 component string separated by spaces.
     * @description Create a transform string. Used for the Two.js rendering APIs.
     */
    toString: function(fullMatrix) {

      array.length = 0;
      this.toTransformArray(fullMatrix, array);

      return array.map(Two.Utils.toFixed).join(' ');

    },

    /**
     * @name Two.Matrix#toTransformArray
     * @function
     * @param {Boolean} [fullMatrix=false] - Return the full 9 elements of the matrix or just 6 in the format for 2D transformations.
     * @param {Number[]} [output] - An array empty or otherwise to apply the values to.
     * @description Create a transform array. Used for the Two.js rendering APIs.
     */
    toTransformArray: function(fullMatrix, output) {

     var elements = this.elements;
     var hasOutput = !!output;

     var a = elements[0];
     var b = elements[1];
     var c = elements[2];
     var d = elements[3];
     var e = elements[4];
     var f = elements[5];

      if (fullMatrix) {

        var g = elements[6];
        var h = elements[7];
        var i = elements[8];

        if (hasOutput) {
          output[0] = a;
          output[1] = d;
          output[2] = g;
          output[3] = b;
          output[4] = e;
          output[5] = h;
          output[6] = c;
          output[7] = f;
          output[8] = i;
          return;
        }

        return [
          a, d, g, b, e, h, c, f, i
        ];
      }

      if (hasOutput) {
        output[0] = a;
        output[1] = d;
        output[2] = b;
        output[3] = e;
        output[4] = c;
        output[5] = f;
        return;
      }

      return [
        a, d, b, e, c, f  // Specific format see LN:19
      ];

    },

    /**
     * @name Two.Matrix#toArray
     * @function
     * @param {Boolean} [fullMatrix=false] - Return the full 9 elements of the matrix or just 6 for 2D transformations.
     * @param {Number[]} [output] - An array empty or otherwise to apply the values to.
     * @description Create a transform array. Used for the Two.js rendering APIs.
     */
    toArray: function(fullMatrix, output) {

     var elements = this.elements;
     var hasOutput = !!output;

     var a = elements[0];
     var b = elements[1];
     var c = elements[2];
     var d = elements[3];
     var e = elements[4];
     var f = elements[5];

      if (fullMatrix) {

        var g = elements[6];
        var h = elements[7];
        var i = elements[8];

        if (hasOutput) {
          output[0] = a;
          output[1] = b;
          output[2] = c;
          output[3] = d;
          output[4] = e;
          output[5] = f;
          output[6] = g;
          output[7] = h;
          output[8] = i;
          return;
        }

        return [
          a, b, c, d, e, f, g, h, i
        ];
      }

      if (hasOutput) {
        output[0] = a;
        output[1] = b;
        output[2] = c;
        output[3] = d;
        output[4] = e;
        output[5] = f;
        return;
      }

      return [
        a, b, c, d, e, f
      ];

    },

    /**
     * @name Two.Matrix#toObject
     * @function
     * @description Create a JSON compatible object that represents information of the matrix.
     */
    toObject: function() {
      return {
        elements: this.toArray(true),
        manual: !!this.manual
      };
    },

    /**
     * @name Two.Matrix#clone
     * @function
     * @description Clone the current matrix.
     */
    clone: function() {

      return new Two.Matrix().copy(this);

    }

  });

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  // Localize variables
  var mod = Two.Utils.mod, toFixed = Two.Utils.toFixed;
  var _ = Two.Utils;

  var svg = {

    version: 1.1,

    ns: 'http://www.w3.org/2000/svg',
    xlink: 'http://www.w3.org/1999/xlink',

    alignments: {
      left: 'start',
      center: 'middle',
      right: 'end'
    },

    /**
     * Create an svg namespaced element.
     */
    createElement: function(name, attrs) {
      var tag = name;
      var elem = document.createElementNS(svg.ns, tag);
      if (tag === 'svg') {
        attrs = _.defaults(attrs || {}, {
          version: svg.version
        });
      }
      if (!_.isEmpty(attrs)) {
        svg.setAttributes(elem, attrs);
      }
      return elem;
    },

    /**
     * Add attributes from an svg element.
     */
    setAttributes: function(elem, attrs) {
      var keys = Object.keys(attrs);
      for (var i = 0; i < keys.length; i++) {
        if (/href/.test(keys[i])) {
          elem.setAttributeNS(svg.xlink, keys[i], attrs[keys[i]]);
        } else {
          elem.setAttribute(keys[i], attrs[keys[i]]);
        }
      }
      return this;
    },

    /**
     * Remove attributes from an svg element.
     */
    removeAttributes: function(elem, attrs) {
      for (var key in attrs) {
        elem.removeAttribute(key);
      }
      return this;
    },

    /**
     * Turn a set of vertices into a string for the d property of a path
     * element. It is imperative that the string collation is as fast as
     * possible, because this call will be happening multiple times a
     * second.
     */
    toString: function(points, closed) {

      var l = points.length,
        last = l - 1,
        d, // The elusive last Two.Commands.move point
        string = '';

      for (var i = 0; i < l; i++) {
        var b = points[i];
        var command;
        var prev = closed ? mod(i - 1, l) : Math.max(i - 1, 0);
        var next = closed ? mod(i + 1, l) : Math.min(i + 1, last);

        var a = points[prev];
        var c = points[next];

        var vx, vy, ux, uy, ar, bl, br, cl;
        var rx, ry, xAxisRotation, largeArcFlag, sweepFlag;

        // Access x and y directly,
        // bypassing the getter
        var x = toFixed(b.x);
        var y = toFixed(b.y);

        switch (b.command) {

          case Two.Commands.close:
            command = Two.Commands.close;
            break;

          case Two.Commands.arc:

            rx = b.rx;
            ry = b.ry;
            xAxisRotation = b.xAxisRotation;
            largeArcFlag = b.largeArcFlag;
            sweepFlag = b.sweepFlag;

            command = Two.Commands.arc + ' ' + rx + ' ' + ry + ' '
              + xAxisRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' '
              + x + ' ' + y;
            break;

          case Two.Commands.curve:

            ar = (a.controls && a.controls.right) || Two.Vector.zero;
            bl = (b.controls && b.controls.left) || Two.Vector.zero;

            if (a.relative) {
              vx = toFixed((ar.x + a.x));
              vy = toFixed((ar.y + a.y));
            } else {
              vx = toFixed(ar.x);
              vy = toFixed(ar.y);
            }

            if (b.relative) {
              ux = toFixed((bl.x + b.x));
              uy = toFixed((bl.y + b.y));
            } else {
              ux = toFixed(bl.x);
              uy = toFixed(bl.y);
            }

            command = ((i === 0) ? Two.Commands.move : Two.Commands.curve) +
              ' ' + vx + ' ' + vy + ' ' + ux + ' ' + uy + ' ' + x + ' ' + y;
            break;

          case Two.Commands.move:
            d = b;
            command = Two.Commands.move + ' ' + x + ' ' + y;
            break;

          default:
            command = b.command + ' ' + x + ' ' + y;

        }

        // Add a final point and close it off

        if (i >= last && closed) {

          if (b.command === Two.Commands.curve) {

            // Make sure we close to the most previous Two.Commands.move
            c = d;

            br = (b.controls && b.controls.right) || b;
            cl = (c.controls && c.controls.left) || c;

            if (b.relative) {
              vx = toFixed((br.x + b.x));
              vy = toFixed((br.y + b.y));
            } else {
              vx = toFixed(br.x);
              vy = toFixed(br.y);
            }

            if (c.relative) {
              ux = toFixed((cl.x + c.x));
              uy = toFixed((cl.y + c.y));
            } else {
              ux = toFixed(cl.x);
              uy = toFixed(cl.y);
            }

            x = toFixed(c.x);
            y = toFixed(c.y);

            command +=
              ' C ' + vx + ' ' + vy + ' ' + ux + ' ' + uy + ' ' + x + ' ' + y;

          }

          if (b.command !== Two.Commands.close) {
            command += ' Z';
          }

        }

        string += command + ' ';

      }

      return string;

    },

    getClip: function(shape) {

      var clip = shape._renderer.clip;

      if (!clip) {

        var root = shape;

        while (root.parent) {
          root = root.parent;
        }

        clip = shape._renderer.clip = svg.createElement('clipPath');
        root.defs.appendChild(clip);

      }

      return clip;

    },

    group: {

      // TODO: Can speed up.
      // TODO: How does this effect a f
      appendChild: function(object) {

        var elem = object._renderer.elem;

        if (!elem) {
          return;
        }

        var tag = elem.nodeName;

        if (!tag || /(radial|linear)gradient/i.test(tag) || object._clip) {
          return;
        }

        this.elem.appendChild(elem);

      },

      removeChild: function(object) {

        var elem = object._renderer.elem;

        if (!elem || elem.parentNode != this.elem) {
          return;
        }

        var tag = elem.nodeName;

        if (!tag) {
          return;
        }

        // Defer subtractions while clipping.
        if (object._clip) {
          return;
        }

        this.elem.removeChild(elem);

      },

      orderChild: function(object) {
        this.elem.appendChild(object._renderer.elem);
      },

      renderChild: function(child) {
        svg[child._renderer.type].render.call(child, this);
      },

      render: function(domElement) {

        this._update();

        // Shortcut for hidden objects.
        // Doesn't reset the flags, so changes are stored and
        // applied once the object is visible again
        if (this._opacity === 0 && !this._flagOpacity) {
          return this;
        }

        if (!this._renderer.elem) {
          this._renderer.elem = svg.createElement('g', {
            id: this.id
          });
          domElement.appendChild(this._renderer.elem);
        }

        // _Update styles for the <g>
        var flagMatrix = this._matrix.manual || this._flagMatrix;
        var context = {
          domElement: domElement,
          elem: this._renderer.elem
        };

        if (flagMatrix) {
          this._renderer.elem.setAttribute('transform', 'matrix(' + this._matrix.toString() + ')');
        }

        for (var i = 0; i < this.children.length; i++) {
          var child = this.children[i];
          svg[child._renderer.type].render.call(child, domElement);
        }

        if (this._flagOpacity) {
          this._renderer.elem.setAttribute('opacity', this._opacity);
        }

        if (this._flagClassName) {
          this._renderer.elem.setAttribute('class', this.classList.join(' '));
        }

        if (this._flagAdditions) {
          this.additions.forEach(svg.group.appendChild, context);
        }

        if (this._flagSubtractions) {
          this.subtractions.forEach(svg.group.removeChild, context);
        }

        if (this._flagOrder) {
          this.children.forEach(svg.group.orderChild, context);
        }

        /**
         * Commented two-way functionality of clips / masks with groups and
         * polygons. Uncomment when this bug is fixed:
         * https://code.google.com/p/chromium/issues/detail?id=370951
         */

        // if (this._flagClip) {

        //   clip = svg.getClip(this);
        //   elem = this._renderer.elem;

        //   if (this._clip) {
        //     elem.removeAttribute('id');
        //     clip.setAttribute('id', this.id);
        //     clip.appendChild(elem);
        //   } else {
        //     clip.removeAttribute('id');
        //     elem.setAttribute('id', this.id);
        //     this.parent._renderer.elem.appendChild(elem); // TODO: should be insertBefore
        //   }

        // }

        if (this._flagMask) {
          if (this._mask) {
            this._renderer.elem.setAttribute('clip-path', 'url(#' + this._mask.id + ')');
          } else {
            this._renderer.elem.removeAttribute('clip-path');
          }
        }

        return this.flagReset();

      }

    },

    path: {

      render: function(domElement) {

        this._update();

        // Shortcut for hidden objects.
        // Doesn't reset the flags, so changes are stored and
        // applied once the object is visible again
        if (this._opacity === 0 && !this._flagOpacity) {
          return this;
        }

        // Collect any attribute that needs to be changed here
        var changed = {};

        var flagMatrix = this._matrix.manual || this._flagMatrix;

        if (flagMatrix) {
          changed.transform = 'matrix(' + this._matrix.toString() + ')';
        }

        if (this._flagVertices) {
          var vertices = svg.toString(this._renderer.vertices, this._closed);
          changed.d = vertices;
        }

        if (this._fill && this._fill._renderer) {
          this._fill._update();
          svg[this._fill._renderer.type].render.call(this._fill, domElement, true);
        }

        if (this._flagFill) {
          changed.fill = this._fill && this._fill.id
            ? 'url(#' + this._fill.id + ')' : this._fill;
        }

        if (this._stroke && this._stroke._renderer) {
          this._stroke._update();
          svg[this._stroke._renderer.type].render.call(this._stroke, domElement, true);
        }

        if (this._flagStroke) {
          changed.stroke = this._stroke && this._stroke.id
            ? 'url(#' + this._stroke.id + ')' : this._stroke;
        }

        if (this._flagLinewidth) {
          changed['stroke-width'] = this._linewidth;
        }

        if (this._flagOpacity) {
          changed['stroke-opacity'] = this._opacity;
          changed['fill-opacity'] = this._opacity;
        }

        if (this._flagClassName) {
          changed['class'] = this.classList.join(' ');
        }

        if (this._flagVisible) {
          changed.visibility = this._visible ? 'visible' : 'hidden';
        }

        if (this._flagCap) {
          changed['stroke-linecap'] = this._cap;
        }

        if (this._flagJoin) {
          changed['stroke-linejoin'] = this._join;
        }

        if (this._flagMiter) {
          changed['stroke-miterlimit'] = this._miter;
        }

        if (this.dashes && this.dashes.length > 0) {
          changed['stroke-dasharray'] = this.dashes.join(' ');
          changed['stroke-dashoffset'] = this.dashes.offset || 0;
        }

        // If there is no attached DOM element yet,
        // create it with all necessary attributes.
        if (!this._renderer.elem) {

          changed.id = this.id;
          this._renderer.elem = svg.createElement('path', changed);
          domElement.appendChild(this._renderer.elem);

        // Otherwise apply all pending attributes
        } else {
          svg.setAttributes(this._renderer.elem, changed);
        }

        if (this._flagClip) {

          var clip = svg.getClip(this);
          var elem = this._renderer.elem;

          if (this._clip) {
            elem.removeAttribute('id');
            clip.setAttribute('id', this.id);
            clip.appendChild(elem);
          } else {
            clip.removeAttribute('id');
            elem.setAttribute('id', this.id);
            this.parent._renderer.elem.appendChild(elem); // TODO: should be insertBefore
          }

        }

        /**
         * Commented two-way functionality of clips / masks with groups and
         * polygons. Uncomment when this bug is fixed:
         * https://code.google.com/p/chromium/issues/detail?id=370951
         */

        // if (this._flagMask) {
        //   if (this._mask) {
        //     elem.setAttribute('clip-path', 'url(#' + this._mask.id + ')');
        //   } else {
        //     elem.removeAttribute('clip-path');
        //   }
        // }

        return this.flagReset();

      }

    },

    text: {

      render: function(domElement) {

        this._update();

        var changed = {};

        var flagMatrix = this._matrix.manual || this._flagMatrix;

        if (flagMatrix) {
          changed.transform = 'matrix(' + this._matrix.toString() + ')';
        }

        if (this._flagFamily) {
          changed['font-family'] = this._family;
        }
        if (this._flagSize) {
          changed['font-size'] = this._size;
        }
        if (this._flagLeading) {
          changed['line-height'] = this._leading;
        }
        if (this._flagAlignment) {
          changed['text-anchor'] = svg.alignments[this._alignment] || this._alignment;
        }
        if (this._flagBaseline) {
          changed['alignment-baseline'] = changed['dominant-baseline'] = this._baseline;
        }
        if (this._flagStyle) {
          changed['font-style'] = this._style;
        }
        if (this._flagWeight) {
          changed['font-weight'] = this._weight;
        }
        if (this._flagDecoration) {
          changed['text-decoration'] = this._decoration;
        }
        if (this._fill && this._fill._renderer) {
          this._fill._update();
          svg[this._fill._renderer.type].render.call(this._fill, domElement, true);
        }
        if (this._flagFill) {
          changed.fill = this._fill && this._fill.id
            ? 'url(#' + this._fill.id + ')' : this._fill;
        }
        if (this._stroke && this._stroke._renderer) {
          this._stroke._update();
          svg[this._stroke._renderer.type].render.call(this._stroke, domElement, true);
        }
        if (this._flagStroke) {
          changed.stroke = this._stroke && this._stroke.id
            ? 'url(#' + this._stroke.id + ')' : this._stroke;
        }
        if (this._flagLinewidth) {
          changed['stroke-width'] = this._linewidth;
        }
        if (this._flagOpacity) {
          changed.opacity = this._opacity;
        }
        if (this._flagClassName) {
          changed['class'] = this.classList.join(' ');
        }
        if (this._flagVisible) {
          changed.visibility = this._visible ? 'visible' : 'hidden';
        }
        if (this.dashes && this.dashes.length > 0) {
          changed['stroke-dasharray'] = this.dashes.join(' ');
          changed['stroke-dashoffset'] = this.dashes.offset || 0;
        }

        if (!this._renderer.elem) {

          changed.id = this.id;

          this._renderer.elem = svg.createElement('text', changed);
          domElement.defs.appendChild(this._renderer.elem);

        } else {

          svg.setAttributes(this._renderer.elem, changed);

        }

        if (this._flagClip) {

          var clip = svg.getClip(this);
          var elem = this._renderer.elem;

          if (this._clip) {
            elem.removeAttribute('id');
            clip.setAttribute('id', this.id);
            clip.appendChild(elem);
          } else {
            clip.removeAttribute('id');
            elem.setAttribute('id', this.id);
            this.parent._renderer.elem.appendChild(elem); // TODO: should be insertBefore
          }

        }

        if (this._flagValue) {
          this._renderer.elem.textContent = this._value;
        }

        return this.flagReset();

      }

    },

    'linear-gradient': {

      render: function(domElement, silent) {

        if (!silent) {
          this._update();
        }

        var changed = {};

        if (this._flagEndPoints) {
          changed.x1 = this.left._x;
          changed.y1 = this.left._y;
          changed.x2 = this.right._x;
          changed.y2 = this.right._y;
        }

        if (this._flagSpread) {
          changed.spreadMethod = this._spread;
        }

        // If there is no attached DOM element yet,
        // create it with all necessary attributes.
        if (!this._renderer.elem) {

          changed.id = this.id;
          changed.gradientUnits = 'userSpaceOnUse';
          this._renderer.elem = svg.createElement('linearGradient', changed);
          domElement.defs.appendChild(this._renderer.elem);

        // Otherwise apply all pending attributes
        } else {

          svg.setAttributes(this._renderer.elem, changed);

        }

        if (this._flagStops) {

          var lengthChanged = this._renderer.elem.childNodes.length
            !== this.stops.length;

          if (lengthChanged) {
            while (this._renderer.elem.lastChild) {
              this._renderer.elem.removeChild(this._renderer.elem.lastChild);
            }
          }

          for (var i = 0; i < this.stops.length; i++) {

            var stop = this.stops[i];
            var attrs = {};

            if (stop._flagOffset) {
              attrs.offset = 100 * stop._offset + '%';
            }
            if (stop._flagColor) {
              attrs['stop-color'] = stop._color;
            }
            if (stop._flagOpacity) {
              attrs['stop-opacity'] = stop._opacity;
            }

            if (!stop._renderer.elem) {
              stop._renderer.elem = svg.createElement('stop', attrs);
            } else {
              svg.setAttributes(stop._renderer.elem, attrs);
            }

            if (lengthChanged) {
              this._renderer.elem.appendChild(stop._renderer.elem);
            }
            stop.flagReset();

          }

        }

        return this.flagReset();

      }

    },

    'radial-gradient': {

      render: function(domElement, silent) {

        if (!silent) {
          this._update();
        }

        var changed = {};

        if (this._flagCenter) {
          changed.cx = this.center._x;
          changed.cy = this.center._y;
        }
        if (this._flagFocal) {
          changed.fx = this.focal._x;
          changed.fy = this.focal._y;
        }

        if (this._flagRadius) {
          changed.r = this._radius;
        }

        if (this._flagSpread) {
          changed.spreadMethod = this._spread;
        }

        // If there is no attached DOM element yet,
        // create it with all necessary attributes.
        if (!this._renderer.elem) {

          changed.id = this.id;
          changed.gradientUnits = 'userSpaceOnUse';
          this._renderer.elem = svg.createElement('radialGradient', changed);
          domElement.defs.appendChild(this._renderer.elem);

        // Otherwise apply all pending attributes
        } else {

          svg.setAttributes(this._renderer.elem, changed);

        }

        if (this._flagStops) {

          var lengthChanged = this._renderer.elem.childNodes.length
            !== this.stops.length;

          if (lengthChanged) {
            while (this._renderer.elem.lastChild) {
              this._renderer.elem.removeChild(this._renderer.elem.lastChild);
            }
          }

          for (var i = 0; i < this.stops.length; i++) {

            var stop = this.stops[i];
            var attrs = {};

            if (stop._flagOffset) {
              attrs.offset = 100 * stop._offset + '%';
            }
            if (stop._flagColor) {
              attrs['stop-color'] = stop._color;
            }
            if (stop._flagOpacity) {
              attrs['stop-opacity'] = stop._opacity;
            }

            if (!stop._renderer.elem) {
              stop._renderer.elem = svg.createElement('stop', attrs);
            } else {
              svg.setAttributes(stop._renderer.elem, attrs);
            }

            if (lengthChanged) {
              this._renderer.elem.appendChild(stop._renderer.elem);
            }
            stop.flagReset();

          }

        }

        return this.flagReset();

      }

    },

    texture: {

      render: function(domElement, silent) {

        if (!silent) {
          this._update();
        }

        var changed = {};
        var styles = { x: 0, y: 0 };
        var image = this.image;

        if (this._flagLoaded && this.loaded) {

          switch (image.nodeName.toLowerCase()) {

            case 'canvas':
              styles.href = styles['xlink:href'] = image.toDataURL('image/png');
              break;
            case 'img':
            case 'image':
              styles.href = styles['xlink:href'] = this.src;
              break;

          }

        }

        if (this._flagOffset || this._flagLoaded || this._flagScale) {

          changed.x = this._offset.x;
          changed.y = this._offset.y;

          if (image) {

            changed.x -= image.width / 2;
            changed.y -= image.height / 2;

            if (this._scale instanceof Two.Vector) {
              changed.x *= this._scale.x;
              changed.y *= this._scale.y;
            } else {
              changed.x *= this._scale;
              changed.y *= this._scale;
            }
          }

          if (changed.x > 0) {
            changed.x *= - 1;
          }
          if (changed.y > 0) {
            changed.y *= - 1;
          }

        }

        if (this._flagScale || this._flagLoaded || this._flagRepeat) {

          changed.width = 0;
          changed.height = 0;

          if (image) {

            styles.width = changed.width = image.width;
            styles.height = changed.height = image.height;

            // TODO: Hack / Band-aid
            switch (this._repeat) {
              case 'no-repeat':
                changed.width += 1;
                changed.height += 1;
                break;
            }

            if (this._scale instanceof Two.Vector) {
              changed.width *= this._scale.x;
              changed.height *= this._scale.y;
            } else {
              changed.width *= this._scale;
              changed.height *= this._scale;
            }
          }

        }

        if (this._flagScale || this._flagLoaded) {
          if (!this._renderer.image) {
            this._renderer.image = svg.createElement('image', styles);
          } else if (!_.isEmpty(styles)) {
            svg.setAttributes(this._renderer.image, styles);
          }
        }

        if (!this._renderer.elem) {

          changed.id = this.id;
          changed.patternUnits = 'userSpaceOnUse';
          this._renderer.elem = svg.createElement('pattern', changed);
          domElement.defs.appendChild(this._renderer.elem);

        } else if (!_.isEmpty(changed)) {

          svg.setAttributes(this._renderer.elem, changed);

        }

        if (this._renderer.elem && this._renderer.image && !this._renderer.appended) {
          this._renderer.elem.appendChild(this._renderer.image);
          this._renderer.appended = true;
        }

        return this.flagReset();

      }

    }

  };

  /**
   * @name Two.SVGRenderer
   * @class
   * @extends Two.Utils.Events
   * @param {Object} [parameters] - This object is inherited when constructing a new instance of {@link Two}.
   * @param {Element} [parameters.domElement] - The `<svg />` to draw to. If none given a new one will be constructed.
   * @description This class is used by {@link Two} when constructing with `type` of `Two.Types.svg` (the default type). It takes Two.js' scenegraph and renders it to a `<svg />`.
   */
  var Renderer = Two[Two.Types.svg] = function(params) {

    /**
     * @name Two.SVGRenderer#domElement
     * @property {Element} - The `<svg />` associated with the Two.js scene.
     */
    this.domElement = params.domElement || svg.createElement('svg');

    /**
     * @name Two.SVGRenderer#scene
     * @property {Two.Group} - The root group of the scenegraph.
     */
    this.scene = new Two.Group();
    this.scene.parent = this;

    /**
     * @name Two.SVGRenderer#defs
     * @property {SvgDefintionsElement} - The `<defs />` to apply gradients, patterns, and bitmap imagery.
     */
    this.defs = svg.createElement('defs');
    this.domElement.appendChild(this.defs);
    this.domElement.defs = this.defs;
    this.domElement.style.overflow = 'hidden';

  };

  _.extend(Renderer, {

    /**
     * @name Two.SVGRenderer.Utils
     * @property {Object} - A massive object filled with utility functions and properties to render Two.js objects to a `<svg />`.
     */
    Utils: svg

  });

  _.extend(Renderer.prototype, Two.Utils.Events, {

    constructor: Renderer,

    /**
     * @name Two.SVGRenderer#setSize
     * @function
     * @param {Number} width - The new width of the renderer.
     * @param {Number} height - The new height of the renderer.
     * @description Change the size of the renderer.
     * @nota-bene Triggers a `Two.Events.resize`.
     */
    setSize: function(width, height) {

      this.width = width;
      this.height = height;

      svg.setAttributes(this.domElement, {
        width: width,
        height: height
      });

      return this.trigger(Two.Events.resize, width, height);

    },

    /**
     * @name Two.SVGRenderer#render
     * @function
     * @description Render the current scene to the `<svg />`.
     */
    render: function() {

      svg.group.render.call(this.scene, this.domElement);

      return this;

    }

  });

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  /**
   * Constants
   */
  var mod = Two.Utils.mod;
  var getRatio = Two.Utils.getRatio;
  var _ = Two.Utils;
  var emptyArray = [];
  var TWO_PI = Math.PI * 2,
    max = Math.max,
    min = Math.min,
    abs = Math.abs,
    sin = Math.sin,
    cos = Math.cos,
    acos = Math.acos,
    sqrt = Math.sqrt;

  // Returns true if this is a non-transforming matrix
  var isDefaultMatrix = function (m) {
    return (m[0] == 1 && m[3] == 0 && m[1] == 0 && m[4] == 1 && m[2] == 0 && m[5] == 0);
  };

  var canvas = {

    isHidden: /(undefined|none|transparent)/i,

    alignments: {
      left: 'start',
      middle: 'center',
      right: 'end'
    },

    shim: function(elem, name) {
      elem.tagName = elem.nodeName = name || 'canvas';
      elem.nodeType = 1;
      elem.getAttribute = function(prop) {
        return this[prop];
      };
      elem.setAttribute = function(prop, val) {
        this[prop] = val;
        return this;
      };
      return elem;
    },

    group: {

      renderChild: function(child) {
        canvas[child._renderer.type].render.call(child, this.ctx, true, this.clip);
      },

      render: function(ctx) {

        // TODO: Add a check here to only invoke _update if need be.
        this._update();

        var matrix = this._matrix.elements;
        var parent = this.parent;
        this._renderer.opacity = this._opacity
          * (parent && parent._renderer ? parent._renderer.opacity : 1);

        var mask = this._mask;
        // var clip = this._clip;

        var defaultMatrix = isDefaultMatrix(matrix);
        var shouldIsolate = !defaultMatrix || !!mask;

        if (!this._renderer.context) {
          this._renderer.context = {};
        }

        this._renderer.context.ctx = ctx;
        // this._renderer.context.clip = clip;

        if (shouldIsolate) {
          ctx.save();
          if (!defaultMatrix) {
            ctx.transform(  matrix[0], matrix[3], matrix[1],
              matrix[4], matrix[2], matrix[5]);
          }
        }

        if (mask) {
          canvas[mask._renderer.type].render.call(mask, ctx, true);
        }

        if (this.opacity > 0 && this.scale !== 0) {
          for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            canvas[child._renderer.type].render.call(child, ctx);
          }
        }

        if (shouldIsolate) {
          ctx.restore();
        }

       /**
         * Commented two-way functionality of clips / masks with groups and
         * polygons. Uncomment when this bug is fixed:
         * https://code.google.com/p/chromium/issues/detail?id=370951
         */

        // if (clip) {
        //   ctx.clip();
        // }

        return this.flagReset();

      }

    },

    path: {

      render: function(ctx, forced, parentClipped) {

        var matrix, stroke, linewidth, fill, opacity, visible, cap, join, miter,
            closed, commands, length, last, next, prev, a, b, c, d, ux, uy, vx, vy,
            ar, bl, br, cl, x, y, mask, clip, defaultMatrix, isOffset, dashes;

        // TODO: Add a check here to only invoke _update if need be.
        this._update();

        matrix = this._matrix.elements;
        stroke = this._stroke;
        linewidth = this._linewidth;
        fill = this._fill;
        opacity = this._opacity * this.parent._renderer.opacity;
        visible = this._visible;
        cap = this._cap;
        join = this._join;
        miter = this._miter;
        closed = this._closed;
        commands = this._renderer.vertices; // Commands
        length = commands.length;
        last = length - 1;
        defaultMatrix = isDefaultMatrix(matrix);
        dashes = this.dashes;

        // mask = this._mask;
        clip = this._clip;

        if (!forced && (!visible || clip)) {
          return this;
        }

        // Transform
        if (!defaultMatrix) {
          ctx.save();
          ctx.transform(matrix[0], matrix[3], matrix[1], matrix[4], matrix[2], matrix[5]);
        }

       /**
         * Commented two-way functionality of clips / masks with groups and
         * polygons. Uncomment when this bug is fixed:
         * https://code.google.com/p/chromium/issues/detail?id=370951
         */

        // if (mask) {
        //   canvas[mask._renderer.type].render.call(mask, ctx, true);
        // }

        // Styles
        if (fill) {
          if (_.isString(fill)) {
            ctx.fillStyle = fill;
          } else {
            canvas[fill._renderer.type].render.call(fill, ctx);
            ctx.fillStyle = fill._renderer.effect;
          }
        }
        if (stroke) {
          if (_.isString(stroke)) {
            ctx.strokeStyle = stroke;
          } else {
            canvas[stroke._renderer.type].render.call(stroke, ctx);
            ctx.strokeStyle = stroke._renderer.effect;
          }
          if (linewidth) {
            ctx.lineWidth = linewidth;
          }
          if (miter) {
            ctx.miterLimit = miter;
          }
          if (join) {
            ctx.lineJoin = join;
          }
          if (!closed && cap) {
            ctx.lineCap = cap;
          }
        }
        if (_.isNumber(opacity)) {
          ctx.globalAlpha = opacity;
        }

        if (dashes && dashes.length > 0) {
          ctx.lineDashOffset = dashes.offset || 0;
          ctx.setLineDash(dashes);
        }

        ctx.beginPath();

        for (var i = 0; i < commands.length; i++) {

          b = commands[i];

          x = b.x;
          y = b.y;

          switch (b.command) {

            case Two.Commands.close:
              ctx.closePath();
              break;

            case Two.Commands.arc:

              var rx = b.rx;
              var ry = b.ry;
              var xAxisRotation = b.xAxisRotation;
              var largeArcFlag = b.largeArcFlag;
              var sweepFlag = b.sweepFlag;

              prev = closed ? mod(i - 1, length) : max(i - 1, 0);
              a = commands[prev];

              var ax = a.x;
              var ay = a.y;

              canvas.renderSvgArcCommand(ctx, ax, ay, rx, ry, largeArcFlag, sweepFlag, xAxisRotation, x, y);
              break;

            case Two.Commands.curve:

              prev = closed ? mod(i - 1, length) : Math.max(i - 1, 0);
              next = closed ? mod(i + 1, length) : Math.min(i + 1, last);

              a = commands[prev];
              c = commands[next];
              ar = (a.controls && a.controls.right) || Two.Vector.zero;
              bl = (b.controls && b.controls.left) || Two.Vector.zero;

              if (a._relative) {
                vx = (ar.x + a.x);
                vy = (ar.y + a.y);
              } else {
                vx = ar.x;
                vy = ar.y;
              }

              if (b._relative) {
                ux = (bl.x + b.x);
                uy = (bl.y + b.y);
              } else {
                ux = bl.x;
                uy = bl.y;
              }

              ctx.bezierCurveTo(vx, vy, ux, uy, x, y);

              if (i >= last && closed) {

                c = d;

                br = (b.controls && b.controls.right) || Two.Vector.zero;
                cl = (c.controls && c.controls.left) || Two.Vector.zero;

                if (b._relative) {
                  vx = (br.x + b.x);
                  vy = (br.y + b.y);
                } else {
                  vx = br.x;
                  vy = br.y;
                }

                if (c._relative) {
                  ux = (cl.x + c.x);
                  uy = (cl.y + c.y);
                } else {
                  ux = cl.x;
                  uy = cl.y;
                }

                x = c.x;
                y = c.y;

                ctx.bezierCurveTo(vx, vy, ux, uy, x, y);

              }

              break;

            case Two.Commands.line:
              ctx.lineTo(x, y);
              break;

            case Two.Commands.move:
              d = b;
              ctx.moveTo(x, y);
              break;

          }
        }

        // Loose ends

        if (closed) {
          ctx.closePath();
        }

        if (!clip && !parentClipped) {
          if (!canvas.isHidden.test(fill)) {
            isOffset = fill._renderer && fill._renderer.offset;
            if (isOffset) {
              ctx.save();
              ctx.translate(
                - fill._renderer.offset.x, - fill._renderer.offset.y);
              ctx.scale(fill._renderer.scale.x, fill._renderer.scale.y);
            }
            ctx.fill();
            if (isOffset) {
              ctx.restore();
            }
          }
          if (!canvas.isHidden.test(stroke)) {
            isOffset = stroke._renderer && stroke._renderer.offset;
            if (isOffset) {
              ctx.save();
              ctx.translate(
                - stroke._renderer.offset.x, - stroke._renderer.offset.y);
              ctx.scale(stroke._renderer.scale.x, stroke._renderer.scale.y);
              ctx.lineWidth = linewidth / stroke._renderer.scale.x;
            }
            ctx.stroke();
            if (isOffset) {
              ctx.restore();
            }
          }
        }

        if (!defaultMatrix) {
          ctx.restore();
        }

        if (clip && !parentClipped) {
          ctx.clip();
        }

        if (dashes && dashes.length > 0) {
          ctx.setLineDash(emptyArray);
        }

        return this.flagReset();

      }

    },

    text: {

      render: function(ctx, forced, parentClipped) {

        // TODO: Add a check here to only invoke _update if need be.
        this._update();

        var matrix = this._matrix.elements;
        var stroke = this._stroke;
        var linewidth = this._linewidth;
        var fill = this._fill;
        var opacity = this._opacity * this.parent._renderer.opacity;
        var visible = this._visible;
        var defaultMatrix = isDefaultMatrix(matrix);
        var isOffset = fill._renderer && fill._renderer.offset
          && stroke._renderer && stroke._renderer.offset;
        var dashes = this.dashes;

        var a, b, c, d, e, sx, sy;

        // mask = this._mask;
        var clip = this._clip;

        if (!forced && (!visible || clip)) {
          return this;
        }

        // Transform
        if (!defaultMatrix) {
          ctx.save();
          ctx.transform(matrix[0], matrix[3], matrix[1], matrix[4], matrix[2], matrix[5]);
        }

       /**
         * Commented two-way functionality of clips / masks with groups and
         * polygons. Uncomment when this bug is fixed:
         * https://code.google.com/p/chromium/issues/detail?id=370951
         */

        // if (mask) {
        //   canvas[mask._renderer.type].render.call(mask, ctx, true);
        // }

        if (!isOffset) {
          ctx.font = [this._style, this._weight, this._size + 'px/' +
            this._leading + 'px', this._family].join(' ');
        }

        ctx.textAlign = canvas.alignments[this._alignment] || this._alignment;
        ctx.textBaseline = this._baseline;

        // Styles
        if (fill) {
          if (_.isString(fill)) {
            ctx.fillStyle = fill;
          } else {
            canvas[fill._renderer.type].render.call(fill, ctx);
            ctx.fillStyle = fill._renderer.effect;
          }
        }
        if (stroke) {
          if (_.isString(stroke)) {
            ctx.strokeStyle = stroke;
          } else {
            canvas[stroke._renderer.type].render.call(stroke, ctx);
            ctx.strokeStyle = stroke._renderer.effect;
          }
          if (linewidth) {
            ctx.lineWidth = linewidth;
          }
        }
        if (_.isNumber(opacity)) {
          ctx.globalAlpha = opacity;
        }
        if (dashes && dashes.length > 0) {
          ctx.lineDashOffset = dashes.offset || 0;
          ctx.setLineDash(dashes);
        }

        if (!clip && !parentClipped) {

          if (!canvas.isHidden.test(fill)) {

            if (fill._renderer && fill._renderer.offset) {

              sx = fill._renderer.scale.x;
              sy = fill._renderer.scale.y;

              ctx.save();
              ctx.translate( - fill._renderer.offset.x,
                - fill._renderer.offset.y);
              ctx.scale(sx, sy);

              a = this._size / fill._renderer.scale.y;
              b = this._leading / fill._renderer.scale.y;
              ctx.font = [this._style, this._weight, a + 'px/',
                b + 'px', this._family].join(' ');

              c = fill._renderer.offset.x / fill._renderer.scale.x;
              d = fill._renderer.offset.y / fill._renderer.scale.y;

              ctx.fillText(this.value, c, d);
              ctx.restore();

            } else {
              ctx.fillText(this.value, 0, 0);
            }

          }

          if (!canvas.isHidden.test(stroke)) {

            if (stroke._renderer && stroke._renderer.offset) {

              sx = stroke._renderer.scale.x;
              sy = stroke._renderer.scale.y;

              ctx.save();
              ctx.translate(- stroke._renderer.offset.x,
                - stroke._renderer.offset.y);
              ctx.scale(sx, sy);

              a = this._size / stroke._renderer.scale.y;
              b = this._leading / stroke._renderer.scale.y;
              ctx.font = [this._style, this._weight, a + 'px/',
                b + 'px', this._family].join(' ');

              c = stroke._renderer.offset.x / stroke._renderer.scale.x;
              d = stroke._renderer.offset.y / stroke._renderer.scale.y;
              e = linewidth / stroke._renderer.scale.x;

              ctx.lineWidth = e;
              ctx.strokeText(this.value, c, d);
              ctx.restore();

            } else {
              ctx.strokeText(this.value, 0, 0);
            }
          }
        }

        if (!defaultMatrix) {
          ctx.restore();
        }

        // TODO: Test for text
        if (clip && !parentClipped) {
          ctx.clip();
        }

        if (dashes && dashes.length > 0) {
          ctx.setLineDash(emptyArray);
        }

        return this.flagReset();

      }

    },

    'linear-gradient': {

      render: function(ctx) {

        this._update();

        if (!this._renderer.effect || this._flagEndPoints || this._flagStops) {

          this._renderer.effect = ctx.createLinearGradient(
            this.left._x, this.left._y,
            this.right._x, this.right._y
          );

          for (var i = 0; i < this.stops.length; i++) {
            var stop = this.stops[i];
            this._renderer.effect.addColorStop(stop._offset, stop._color);
          }

        }

        return this.flagReset();

      }

    },

    'radial-gradient': {

      render: function(ctx) {

        this._update();

        if (!this._renderer.effect || this._flagCenter || this._flagFocal
            || this._flagRadius || this._flagStops) {

          this._renderer.effect = ctx.createRadialGradient(
            this.center._x, this.center._y, 0,
            this.focal._x, this.focal._y, this._radius
          );

          for (var i = 0; i < this.stops.length; i++) {
            var stop = this.stops[i];
            this._renderer.effect.addColorStop(stop._offset, stop._color);
          }

        }

        return this.flagReset();

      }

    },

    texture: {

      render: function(ctx) {

        this._update();

        var image = this.image;
        var repeat;

        if (!this._renderer.effect || ((this._flagLoaded || this._flagImage || this._flagVideo || this._flagRepeat) && this.loaded)) {
          this._renderer.effect = ctx.createPattern(this.image, this._repeat);
        }

        if (this._flagOffset || this._flagLoaded || this._flagScale) {

          if (!(this._renderer.offset instanceof Two.Vector)) {
            this._renderer.offset = new Two.Vector();
          }

          this._renderer.offset.x = - this._offset.x;
          this._renderer.offset.y = - this._offset.y;

          if (image) {

            this._renderer.offset.x += image.width / 2;
            this._renderer.offset.y += image.height / 2;

            if (this._scale instanceof Two.Vector) {
              this._renderer.offset.x *= this._scale.x;
              this._renderer.offset.y *= this._scale.y;
            } else {
              this._renderer.offset.x *= this._scale;
              this._renderer.offset.y *= this._scale;
            }
          }

        }

        if (this._flagScale || this._flagLoaded) {

          if (!(this._renderer.scale instanceof Two.Vector)) {
            this._renderer.scale = new Two.Vector();
          }

          if (this._scale instanceof Two.Vector) {
            this._renderer.scale.copy(this._scale);
          } else {
            this._renderer.scale.set(this._scale, this._scale);
          }

        }

        return this.flagReset();

      }

    },

    renderSvgArcCommand: function(ctx, ax, ay, rx, ry, largeArcFlag, sweepFlag, xAxisRotation, x, y) {

      xAxisRotation = xAxisRotation * Math.PI / 180;

      // Ensure radii are positive
      rx = abs(rx);
      ry = abs(ry);

      // Compute (x1â€², y1â€²)
      var dx2 = (ax - x) / 2.0;
      var dy2 = (ay - y) / 2.0;
      var x1p = cos(xAxisRotation) * dx2 + sin(xAxisRotation) * dy2;
      var y1p = - sin(xAxisRotation) * dx2 + cos(xAxisRotation) * dy2;

      // Compute (cxâ€², cyâ€²)
      var rxs = rx * rx;
      var rys = ry * ry;
      var x1ps = x1p * x1p;
      var y1ps = y1p * y1p;

      // Ensure radii are large enough
      var cr = x1ps / rxs + y1ps / rys;

      if (cr > 1) {

        // scale up rx,ry equally so cr == 1
        var s = sqrt(cr);
        rx = s * rx;
        ry = s * ry;
        rxs = rx * rx;
        rys = ry * ry;

      }

      var dq = (rxs * y1ps + rys * x1ps);
      var pq = (rxs * rys - dq) / dq;
      var q = sqrt(max(0, pq));
      if (largeArcFlag === sweepFlag) q = - q;
      var cxp = q * rx * y1p / ry;
      var cyp = - q * ry * x1p / rx;

      // Step 3: Compute (cx, cy) from (cxâ€², cyâ€²)
      var cx = cos(xAxisRotation) * cxp
        - sin(xAxisRotation) * cyp + (ax + x) / 2;
      var cy = sin(xAxisRotation) * cxp
        + cos(xAxisRotation) * cyp + (ay + y) / 2;

      // Step 4: Compute Î¸1 and Î”Î¸
      var startAngle = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);
      var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry,
        (- x1p - cxp) / rx, (- y1p - cyp) / ry) % TWO_PI;

      var endAngle = startAngle + delta;

      var clockwise = sweepFlag === 0;

      renderArcEstimate(ctx, cx, cy, rx, ry, startAngle, endAngle,
        clockwise, xAxisRotation);

    }

  };

  /**
   * @name Two.CanvasRenderer
   * @class
   * @extends Two.Utils.Events
   * @param {Object} [parameters] - This object is inherited when constructing a new instance of {@link Two}.
   * @param {Element} [parameters.domElement] - The `<canvas />` to draw to. If none given a new one will be constructed.
   * @param {Boolean} [parameters.overdraw] - Determines whether the canvas should clear the background or not. Defaults to `true`.
   * @param {Boolean} [parameters.smoothing=true] - Determines whether the canvas should antialias drawing. Set it to `false` when working with pixel art. `false` can lead to better performance, since it would use a cheaper interpolation algorithm.
   * @description This class is used by {@link Two} when constructing with `type` of `Two.Types.canvas`. It takes Two.js' scenegraph and renders it to a `<canvas />`.
   */
  var Renderer = Two[Two.Types.canvas] = function(params) {

    // It might not make a big difference on GPU backed canvases.
    var smoothing = (params.smoothing !== false);

    /**
     * @name Two.CanvasRenderer#domElement
     * @property {Element} - The `<canvas />` associated with the Two.js scene.
     */
    this.domElement = params.domElement || document.createElement('canvas');

    /**
     * @name Two.CanvasRenderer#ctx
     * @property {Canvas2DContext} - Associated two dimensional context to render on the `<canvas />`.
     */
    this.ctx = this.domElement.getContext('2d');

    /**
     * @name Two.CanvasRenderer#overdraw
     * @property {Boolean} - Determines whether the canvas clears the background each draw call.
     * @default true
     */
    this.overdraw = params.overdraw || false;

    if (!_.isUndefined(this.ctx.imageSmoothingEnabled)) {
      this.ctx.imageSmoothingEnabled = smoothing;
    }

    /**
     * @name Two.CanvasRenderer#scene
     * @property {Two.Group} - The root group of the scenegraph.
     */
    this.scene = new Two.Group();
    this.scene.parent = this;
  };


  _.extend(Renderer, {

    /**
     * @name Two.CanvasRenderer.Utils
     * @property {Object} - A massive object filled with utility functions and properties to render Two.js objects to a `<canvas />`.
     */
    Utils: canvas

  });

  _.extend(Renderer.prototype, Two.Utils.Events, {

    constructor: Renderer,

    /**
     * @name Two.CanvasRenderer#setSize
     * @function
     * @param {Number} width - The new width of the renderer.
     * @param {Number} height - The new height of the renderer.
     * @param {Number} [ratio] - The new pixel ratio (pixel density) of the renderer. Defaults to calculate the pixel density of the user's screen.
     * @description Change the size of the renderer.
     * @nota-bene Triggers a `Two.Events.resize`.
     */
    setSize: function(width, height, ratio) {

      this.width = width;
      this.height = height;

      this.ratio = _.isUndefined(ratio) ? getRatio(this.ctx) : ratio;

      this.domElement.width = width * this.ratio;
      this.domElement.height = height * this.ratio;

      if (this.domElement.style) {
        _.extend(this.domElement.style, {
          width: width + 'px',
          height: height + 'px'
        });
      }

      return this.trigger(Two.Events.resize, width, height, ratio);

    },

    /**
     * @name Two.CanvasRenderer#render
     * @function
     * @description Render the current scene to the `<canvas />`.
     */
    render: function() {

      var isOne = this.ratio === 1;

      if (!isOne) {
        this.ctx.save();
        this.ctx.scale(this.ratio, this.ratio);
      }

      if (!this.overdraw) {
        this.ctx.clearRect(0, 0, this.width, this.height);
      }

      canvas.group.render.call(this.scene, this.ctx);

      if (!isOne) {
        this.ctx.restore();
      }

      return this;

    }

  });

  function renderArcEstimate(ctx, ox, oy, rx, ry, startAngle, endAngle, clockwise, xAxisRotation) {

    var epsilon = Two.Utils.Curve.Tolerance.epsilon;
    var deltaAngle = endAngle - startAngle;
    var samePoints = Math.abs(deltaAngle) < epsilon;

    // ensures that deltaAngle is 0 .. 2 PI
    deltaAngle = mod(deltaAngle, TWO_PI);

    if (deltaAngle < epsilon) {

      if (samePoints) {

        deltaAngle = 0;

      } else {

        deltaAngle = TWO_PI;

      }

    }

    if (clockwise === true && ! samePoints) {

      if (deltaAngle === TWO_PI) {

        deltaAngle = - TWO_PI;

      } else {

        deltaAngle = deltaAngle - TWO_PI;

      }

    }

    for (var i = 0; i < Two.Resolution; i++) {

      var t = i / (Two.Resolution - 1);

      var angle = startAngle + t * deltaAngle;
      var x = ox + rx * Math.cos(angle);
      var y = oy + ry * Math.sin(angle);

      if (xAxisRotation !== 0) {

        var cos = Math.cos(xAxisRotation);
        var sin = Math.sin(xAxisRotation);

        var tx = x - ox;
        var ty = y - oy;

        // Rotate the point about the center of the ellipse.
        x = tx * cos - ty * sin + ox;
        y = tx * sin + ty * cos + oy;

      }

      ctx.lineTo(x, y);

    }

  }

  function svgAngle(ux, uy, vx, vy) {

    var dot = ux * vx + uy * vy;
    var len = sqrt(ux * ux + uy * uy) *  sqrt(vx * vx + vy * vy);
    // floating point precision, slightly over values appear
    var ang = acos(max(-1, min(1, dot / len)));
    if ((ux * vy - uy * vx) < 0) {
      ang = - ang;
    }

    return ang;

  }

  function resetTransform(ctx) {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
  }

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  /**
   * Constants
   */

  var root = Two.root,
    multiplyMatrix = Two.Matrix.Multiply,
    mod = Two.Utils.mod,
    identity = [1, 0, 0, 0, 1, 0, 0, 0, 1],
    transformation = new Two.Array(9),
    getRatio = Two.Utils.getRatio,
    getComputedMatrix = Two.Utils.getComputedMatrix,
    CanvasUtils = Two[Two.Types.canvas].Utils,
    _ = Two.Utils;

  var webgl = {

    isHidden: /(undefined|none|transparent)/i,

    canvas: (root.document ? root.document.createElement('canvas') : { getContext: _.identity }),

    alignments: {
      left: 'start',
      middle: 'center',
      right: 'end'
    },

    matrix: new Two.Matrix(),

    group: {

      removeChild: function(child, gl) {
        if (child.children) {
          for (var i = 0; i < child.children.length; i++) {
            webgl.group.removeChild(child.children[i], gl);
          }
          return;
        }
        // Deallocate texture to free up gl memory.
        gl.deleteTexture(child._renderer.texture);
        delete child._renderer.texture;
      },

      render: function(gl, program) {

        this._update();

        var parent = this.parent;
        var flagParentMatrix = (parent._matrix && parent._matrix.manual) || parent._flagMatrix;
        var flagMatrix = this._matrix.manual || this._flagMatrix;

        if (flagParentMatrix || flagMatrix) {

          if (!this._renderer.matrix) {
            this._renderer.matrix = new Two.Array(9);
          }

          // Reduce amount of object / array creation / deletion
          this._matrix.toTransformArray(true, transformation);

          multiplyMatrix(transformation, parent._renderer.matrix, this._renderer.matrix);

          if (!(this._renderer.scale instanceof Two.Vector)) {
            this._renderer.scale = new Two.Vector();
          }

          if (this._scale instanceof Two.Vector) {
            this._renderer.scale.x = this._scale.x;
            this._renderer.scale.y = this._scale.y;
          } else {
            this._renderer.scale.x = this._scale;
            this._renderer.scale.y = this._scale;
          }

          if (!(/renderer/i.test(parent._renderer.type))) {
            this._renderer.scale.x *= parent._renderer.scale.x;
            this._renderer.scale.y *= parent._renderer.scale.y;
          }

          if (flagParentMatrix) {
            this._flagMatrix = true;
          }

        }

        if (this._mask) {

          // Stencil away everything that isn't rendered by the mask

          gl.clear(gl.STENCIL_BUFFER_BIT);
          gl.enable(gl.STENCIL_TEST);

          gl.stencilFunc(gl.ALWAYS, 1, 0);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);

          webgl[this._mask._renderer.type].render.call(this._mask, gl, program, this);

          gl.stencilFunc(gl.EQUAL, 1, 0xff);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);

        }

        this._flagOpacity = parent._flagOpacity || this._flagOpacity;

        this._renderer.opacity = this._opacity
          * (parent && parent._renderer ? parent._renderer.opacity : 1);

        var i;
        if (this._flagSubtractions) {
          for (i = 0; i < this.subtractions.length; i++) {
            webgl.group.removeChild(this.subtractions[i], gl);
          }
        }

        for (i = 0; i < this.children.length; i++) {
          var child = this.children[i];
          webgl[child._renderer.type].render.call(child, gl, program);
        }

        if (this._mask) {
          gl.disable(gl.STENCIL_TEST);
        }

        return this.flagReset();

      }

    },

    path: {

      updateCanvas: function(elem) {

        var next, prev, a, c, ux, uy, vx, vy, ar, bl, br, cl, x, y;
        var isOffset;

        var commands = elem._renderer.vertices;
        var canvas = this.canvas;
        var ctx = this.ctx;

        // Styles
        var scale = elem._renderer.scale;
        var stroke = elem._stroke;
        var linewidth = elem._linewidth;
        var fill = elem._fill;
        var opacity = elem._renderer.opacity || elem._opacity;
        var cap = elem._cap;
        var join = elem._join;
        var miter = elem._miter;
        var closed = elem._closed;
        var dashes = elem.dashes;
        var length = commands.length;
        var last = length - 1;

        canvas.width = Math.max(Math.ceil(elem._renderer.rect.width * scale.x), 1);
        canvas.height = Math.max(Math.ceil(elem._renderer.rect.height * scale.y), 1);

        var centroid = elem._renderer.rect.centroid;
        var cx = centroid.x;
        var cy = centroid.y;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (fill) {
          if (_.isString(fill)) {
            ctx.fillStyle = fill;
          } else {
            webgl[fill._renderer.type].render.call(fill, ctx, elem);
            ctx.fillStyle = fill._renderer.effect;
          }
        }
        if (stroke) {
          if (_.isString(stroke)) {
            ctx.strokeStyle = stroke;
          } else {
            webgl[stroke._renderer.type].render.call(stroke, ctx, elem);
            ctx.strokeStyle = stroke._renderer.effect;
          }
          if (linewidth) {
            ctx.lineWidth = linewidth;
          }
          if (miter) {
            ctx.miterLimit = miter;
          }
          if (join) {
            ctx.lineJoin = join;
          }
          if (!closed && cap) {
            ctx.lineCap = cap;
          }
        }
        if (_.isNumber(opacity)) {
          ctx.globalAlpha = opacity;
        }

        if (dashes && dashes.length > 0) {
          ctx.lineDashOffset = dashes.offset || 0;
          ctx.setLineDash(dashes);
        }

        var d;
        ctx.save();
        ctx.scale(scale.x, scale.y);

        ctx.translate(cx, cy);

        ctx.beginPath();
        for (var i = 0; i < commands.length; i++) {

          var b = commands[i];

          x = b.x;
          y = b.y;

          switch (b.command) {

            case Two.Commands.close:
              ctx.closePath();
              break;

            case Two.Commands.arc:

              var rx = b.rx;
              var ry = b.ry;
              var xAxisRotation = b.xAxisRotation;
              var largeArcFlag = b.largeArcFlag;
              var sweepFlag = b.sweepFlag;

              prev = closed ? mod(i - 1, length) : Math.max(i - 1, 0);
              a = commands[prev];

              var ax = a.x;
              var ay = a.y;

              CanvasUtils.renderSvgArcCommand(ctx, ax, ay, rx, ry, largeArcFlag, sweepFlag, xAxisRotation, x, y);
              break;

            case Two.Commands.curve:

              prev = closed ? mod(i - 1, length) : Math.max(i - 1, 0);
              next = closed ? mod(i + 1, length) : Math.min(i + 1, last);

              a = commands[prev];
              c = commands[next];
              ar = (a.controls && a.controls.right) || Two.Vector.zero;
              bl = (b.controls && b.controls.left) || Two.Vector.zero;

              if (a._relative) {
                vx = ar.x + a.x;
                vy = ar.y + a.y;
              } else {
                vx = ar.x;
                vy = ar.y;
              }

              if (b._relative) {
                ux = bl.x + b.x;
                uy = bl.y + b.y;
              } else {
                ux = bl.x;
                uy = bl.y;
              }

              ctx.bezierCurveTo(vx, vy, ux, uy, x, y);

              if (i >= last && closed) {

                c = d;

                br = (b.controls && b.controls.right) || Two.Vector.zero;
                cl = (c.controls && c.controls.left) || Two.Vector.zero;

                if (b._relative) {
                  vx = br.x + b.x;
                  vy = br.y + b.y;
                } else {
                  vx = br.x;
                  vy = br.y;
                }

                if (c._relative) {
                  ux = cl.x + c.x;
                  uy = cl.y + c.y;
                } else {
                  ux = cl.x;
                  uy = cl.y;
                }

                x = c.x;
                y = c.y;

                ctx.bezierCurveTo(vx, vy, ux, uy, x, y);

              }

              break;

            case Two.Commands.line:
              ctx.lineTo(x, y);
              break;

            case Two.Commands.move:
              d = b;
              ctx.moveTo(x, y);
              break;

          }

        }

        // Loose ends

        if (closed) {
          ctx.closePath();
        }

        if (!webgl.isHidden.test(fill)) {
          isOffset = fill._renderer && fill._renderer.offset;
          if (isOffset) {
            ctx.save();
            ctx.translate(
              - fill._renderer.offset.x, - fill._renderer.offset.y);
            ctx.scale(fill._renderer.scale.x, fill._renderer.scale.y);
          }
          ctx.fill();
          if (isOffset) {
            ctx.restore();
          }
        }

        if (!webgl.isHidden.test(stroke)) {
          isOffset = stroke._renderer && stroke._renderer.offset;
          if (isOffset) {
            ctx.save();
            ctx.translate(
              - stroke._renderer.offset.x, - stroke._renderer.offset.y);
            ctx.scale(stroke._renderer.scale.x, stroke._renderer.scale.y);
            ctx.lineWidth = linewidth / stroke._renderer.scale.x;
          }
          ctx.stroke();
          if (isOffset) {
            ctx.restore();
          }
        }

        ctx.restore();

      },

      /**
       * Returns the rect of a set of verts. Typically takes vertices that are
       * "centered" around 0 and returns them to be anchored upper-left.
       */
      getBoundingClientRect: function(vertices, border, rect) {

        var left = Infinity, right = -Infinity,
            top = Infinity, bottom = -Infinity,
            width, height;

        vertices.forEach(function(v) {

          var x = v.x, y = v.y, controls = v.controls;
          var a, b, c, d, cl, cr;

          top = Math.min(y, top);
          left = Math.min(x, left);
          right = Math.max(x, right);
          bottom = Math.max(y, bottom);

          if (!v.controls) {
            return;
          }

          cl = controls.left;
          cr = controls.right;

          if (!cl || !cr) {
            return;
          }

          a = v._relative ? cl.x + x : cl.x;
          b = v._relative ? cl.y + y : cl.y;
          c = v._relative ? cr.x + x : cr.x;
          d = v._relative ? cr.y + y : cr.y;

          if (!a || !b || !c || !d) {
            return;
          }

          top = Math.min(b, d, top);
          left = Math.min(a, c, left);
          right = Math.max(a, c, right);
          bottom = Math.max(b, d, bottom);

        });

        // Expand borders

        if (_.isNumber(border)) {
          top -= border;
          left -= border;
          right += border;
          bottom += border;
        }

        width = right - left;
        height = bottom - top;

        rect.top = top;
        rect.left = left;
        rect.right = right;
        rect.bottom = bottom;
        rect.width = width;
        rect.height = height;

        if (!rect.centroid) {
          rect.centroid = {};
        }

        rect.centroid.x = - left;
        rect.centroid.y = - top;

      },

      render: function(gl, program, forcedParent) {

        if (!this._visible || !this._opacity) {
          return this;
        }

        this._update();

        // Calculate what changed

        var parent = this.parent;
        var flagParentMatrix = parent._matrix.manual || parent._flagMatrix;
        var flagMatrix = this._matrix.manual || this._flagMatrix;
        var flagTexture = this._flagVertices || this._flagFill
          || (this._fill instanceof Two.LinearGradient && (this._fill._flagSpread || this._fill._flagStops || this._fill._flagEndPoints))
          || (this._fill instanceof Two.RadialGradient && (this._fill._flagSpread || this._fill._flagStops || this._fill._flagRadius || this._fill._flagCenter || this._fill._flagFocal))
          || (this._fill instanceof Two.Texture && (this._fill._flagLoaded && this._fill.loaded || this._fill._flagImage || this._fill._flagVideo || this._fill._flagRepeat || this._fill._flagOffset || this._fill._flagScale))
          || (this._stroke instanceof Two.LinearGradient && (this._stroke._flagSpread || this._stroke._flagStops || this._stroke._flagEndPoints))
          || (this._stroke instanceof Two.RadialGradient && (this._stroke._flagSpread || this._stroke._flagStops || this._stroke._flagRadius || this._stroke._flagCenter || this._stroke._flagFocal))
          || (this._stroke instanceof Two.Texture && (this._stroke._flagLoaded && this._stroke.loaded || this._stroke._flagImage || this._stroke._flagVideo || this._stroke._flagRepeat || this._stroke._flagOffset || this._fill._flagScale))
          || this._flagStroke || this._flagLinewidth || this._flagOpacity
          || parent._flagOpacity || this._flagVisible || this._flagCap
          || this._flagJoin || this._flagMiter || this._flagScale
          || (this.dashes && this.dashes.length > 0)
          || !this._renderer.texture;

        if (flagParentMatrix || flagMatrix) {

          if (!this._renderer.matrix) {
            this._renderer.matrix = new Two.Array(9);
          }

          // Reduce amount of object / array creation / deletion

          this._matrix.toTransformArray(true, transformation);

          multiplyMatrix(transformation, parent._renderer.matrix, this._renderer.matrix);

          if (!(this._renderer.scale instanceof Two.Vector)) {
            this._renderer.scale = new Two.Vector();
          }
          if (this._scale instanceof Two.Vector) {
            this._renderer.scale.x = this._scale.x * parent._renderer.scale.x;
            this._renderer.scale.y = this._scale.y * parent._renderer.scale.y;
          } else {
            this._renderer.scale.x = this._scale * parent._renderer.scale.x;
            this._renderer.scale.y = this._scale * parent._renderer.scale.y;
          }

        }

        if (flagTexture) {

          if (!this._renderer.rect) {
            this._renderer.rect = {};
          }

          this._renderer.opacity = this._opacity * parent._renderer.opacity;

          webgl.path.getBoundingClientRect(this._renderer.vertices, this._linewidth, this._renderer.rect);

          webgl.updateTexture.call(webgl, gl, this);

        } else {

          // We still need to update child Two elements on the fill and
          // stroke properties.
          if (this._fill && this._fill._update) {
            this._fill._update();
          }
          if (this._stroke && this._stroke._update) {
            this._stroke._update();
          }

        }

        // if (this._mask) {
        //   webgl[this._mask._renderer.type].render.call(mask, gl, program, this);
        // }

        if (this._clip && !forcedParent) {
          return;
        }

        // Draw Texture
        gl.bindTexture(gl.TEXTURE_2D, this._renderer.texture);

        // Draw Rect
        var rect = this._renderer.rect;
        gl.uniformMatrix3fv(program.matrix, false, this._renderer.matrix);
        gl.uniform4f(program.rect, rect.left, rect.top, rect.right, rect.bottom);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        return this.flagReset();

      }

    },

    text: {

      updateCanvas: function(elem) {

        var canvas = this.canvas;
        var ctx = this.ctx;

        // Styles
        var scale = elem._renderer.scale;
        var stroke = elem._stroke;
        var linewidth = elem._linewidth * scale;
        var fill = elem._fill;
        var opacity = elem._renderer.opacity || elem._opacity;
        var dashes = elem.dashes;

        canvas.width = Math.max(Math.ceil(elem._renderer.rect.width * scale.x), 1);
        canvas.height = Math.max(Math.ceil(elem._renderer.rect.height * scale.y), 1);

        var centroid = elem._renderer.rect.centroid;
        var cx = centroid.x;
        var cy = centroid.y;

        var a, b, c, d, e, sx, sy;
        var isOffset = fill._renderer && fill._renderer.offset
          && stroke._renderer && stroke._renderer.offset;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (!isOffset) {
          ctx.font = [elem._style, elem._weight, elem._size + 'px/' +
            elem._leading + 'px', elem._family].join(' ');
        }

        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Styles
        if (fill) {
          if (_.isString(fill)) {
            ctx.fillStyle = fill;
          } else {
            webgl[fill._renderer.type].render.call(fill, ctx, elem);
            ctx.fillStyle = fill._renderer.effect;
          }
        }
        if (stroke) {
          if (_.isString(stroke)) {
            ctx.strokeStyle = stroke;
          } else {
            webgl[stroke._renderer.type].render.call(stroke, ctx, elem);
            ctx.strokeStyle = stroke._renderer.effect;
          }
          if (linewidth) {
            ctx.lineWidth = linewidth;
          }
        }
        if (_.isNumber(opacity)) {
          ctx.globalAlpha = opacity;
        }
        if (dashes && dashes.length > 0) {
          ctx.lineDashOffset = dashes.offset || 0;
          ctx.setLineDash(dashes);
        }

        ctx.save();
        ctx.scale(scale.x, scale.y);
        ctx.translate(cx, cy);

        if (!webgl.isHidden.test(fill)) {

          if (fill._renderer && fill._renderer.offset) {

            sx = fill._renderer.scale.x;
            sy = fill._renderer.scale.y;

            ctx.save();
            ctx.translate( - fill._renderer.offset.x,
              - fill._renderer.offset.y);
            ctx.scale(sx, sy);

            a = elem._size / fill._renderer.scale.y;
            b = elem._leading / fill._renderer.scale.y;
            ctx.font = [elem._style, elem._weight, a + 'px/',
              b + 'px', elem._family].join(' ');

            c = fill._renderer.offset.x / fill._renderer.scale.x;
            d = fill._renderer.offset.y / fill._renderer.scale.y;

            ctx.fillText(elem.value, c, d);
            ctx.restore();

          } else {
            ctx.fillText(elem.value, 0, 0);
          }

        }

        if (!webgl.isHidden.test(stroke)) {

          if (stroke._renderer && stroke._renderer.offset) {

            sx = stroke._renderer.scale.x;
            sy = stroke._renderer.scale.y;

            ctx.save();
            ctx.translate(- stroke._renderer.offset.x,
              - stroke._renderer.offset.y);
            ctx.scale(sx, sy);

            a = elem._size / stroke._renderer.scale.y;
            b = elem._leading / stroke._renderer.scale.y;
            ctx.font = [elem._style, elem._weight, a + 'px/',
              b + 'px', elem._family].join(' ');

            c = stroke._renderer.offset.x / stroke._renderer.scale.x;
            d = stroke._renderer.offset.y / stroke._renderer.scale.y;
            e = linewidth / stroke._renderer.scale.x;

            ctx.lineWidth = e;
            ctx.strokeText(elem.value, c, d);
            ctx.restore();

          } else {
            ctx.strokeText(elem.value, 0, 0);
          }

        }

        ctx.restore();

      },

      getBoundingClientRect: function(elem, rect) {

        var ctx = webgl.ctx;

        ctx.font = [elem._style, elem._weight, elem._size + 'px/' +
          elem._leading + 'px', elem._family].join(' ');

        ctx.textAlign = 'center';
        ctx.textBaseline = elem._baseline;

        // TODO: Estimate this better
        var width = ctx.measureText(elem._value).width * 1.25;
        var height = Math.max(elem._size, elem._leading) * 1.25;

        if (this._linewidth && !webgl.isHidden.test(this._stroke)) {
          width += this._linewidth * 2;
          height += this._linewidth * 2;
        }

        var w = width / 2;
        var h = height / 2;

        switch (webgl.alignments[elem._alignment] || elem._alignment) {

          case webgl.alignments.left:
            rect.left = 0;
            rect.right = width;
            break;
          case webgl.alignments.right:
            rect.left = - width;
            rect.right = 0;
            break;
          default:
            rect.left = - w;
            rect.right = w;
        }

        // TODO: Gradients aren't inherited...
        switch (elem._baseline) {
          case 'bottom':
            rect.top = - height;
            rect.bottom = 0;
            break;
          case 'top':
            rect.top = 0;
            rect.bottom = height;
            break;
          default:
            rect.top = - h;
            rect.bottom = h;
        }

        rect.width = width;
        rect.height = height;

        if (!rect.centroid) {
          rect.centroid = {};
        }

        // TODO:
        rect.centroid.x = w;
        rect.centroid.y = h;

      },

      render: function(gl, program, forcedParent) {

        if (!this._visible || !this._opacity) {
          return this;
        }

        this._update();

        // Calculate what changed

        var parent = this.parent;
        var flagParentMatrix = parent._matrix.manual || parent._flagMatrix;
        var flagMatrix = this._matrix.manual || this._flagMatrix;
        var flagTexture = this._flagVertices || this._flagFill
          || (this._fill instanceof Two.LinearGradient && (this._fill._flagSpread || this._fill._flagStops || this._fill._flagEndPoints))
          || (this._fill instanceof Two.RadialGradient && (this._fill._flagSpread || this._fill._flagStops || this._fill._flagRadius || this._fill._flagCenter || this._fill._flagFocal))
          || (this._fill instanceof Two.Texture && (this._fill._flagLoaded && this._fill.loaded || this._fill._flagImage || this._fill._flagVideo || this._fill._flagRepeat || this._fill._flagOffset || this._fill._flagScale))
          || (this._stroke instanceof Two.LinearGradient && (this._stroke._flagSpread || this._stroke._flagStops || this._stroke._flagEndPoints))
          || (this._stroke instanceof Two.RadialGradient && (this._stroke._flagSpread || this._stroke._flagStops || this._stroke._flagRadius || this._stroke._flagCenter || this._stroke._flagFocal))
          || (this._stroke instanceof Two.Texture && (this._stroke._flagLoaded && this._stroke.loaded || this._stroke._flagImage || this._stroke._flagVideo || this._stroke._flagRepeat || this._stroke._flagOffset || this._fill._flagScale))
          || this._flagStroke || this._flagLinewidth || this._flagOpacity
          || parent._flagOpacity || this._flagVisible || this._flagScale
          || this._flagValue || this._flagFamily || this._flagSize
          || this._flagLeading || this._flagAlignment || this._flagBaseline
          || this._flagStyle || this._flagWeight || this._flagDecoration
          || (this.dashes && this.dashes.length > 0)
          || !this._renderer.texture;

        if (flagParentMatrix || flagMatrix) {

          if (!this._renderer.matrix) {
            this._renderer.matrix = new Two.Array(9);
          }

          // Reduce amount of object / array creation / deletion

          this._matrix.toTransformArray(true, transformation);

          multiplyMatrix(transformation, parent._renderer.matrix, this._renderer.matrix);

          if (!(this._renderer.scale instanceof Two.Vector)) {
            this._renderer.scale = new Two.Vector();
          }
          if (this._scale instanceof Two.Vector) {
            this._renderer.scale.x = this._scale.x * parent._renderer.scale.x;
            this._renderer.scale.y = this._scale.y * parent._renderer.scale.y;
          } else {
            this._renderer.scale.x = this._scale * parent._renderer.scale.x;
            this._renderer.scale.y = this._scale * parent._renderer.scale.y;
          }

        }

        if (flagTexture) {

          if (!this._renderer.rect) {
            this._renderer.rect = {};
          }

          this._renderer.opacity = this._opacity * parent._renderer.opacity;

          webgl.text.getBoundingClientRect(this, this._renderer.rect);

          webgl.updateTexture.call(webgl, gl, this);

        } else {

          // We still need to update child Two elements on the fill and
          // stroke properties.
          if (this._fill && this._fill._update) {
            this._fill._update();
          }
          if (this._stroke && this._stroke._update) {
            this._stroke._update();
          }

        }

        // if (this._mask) {
        //   webgl[this._mask._renderer.type].render.call(mask, gl, program, this);
        // }

        if (this._clip && !forcedParent) {
          return;
        }

        // Draw Texture
        gl.bindTexture(gl.TEXTURE_2D, this._renderer.texture);

        // Draw Rect
        var rect = this._renderer.rect;
        gl.uniformMatrix3fv(program.matrix, false, this._renderer.matrix);
        gl.uniform4f(program.rect, rect.left, rect.top, rect.right, rect.bottom);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        return this.flagReset();

      }

    },

    'linear-gradient': {

      render: function(ctx, elem) {

        if (!ctx.canvas.getContext('2d')) {
          return;
        }

        this._update();

        if (!this._renderer.effect || this._flagEndPoints || this._flagStops) {

          this._renderer.effect = ctx.createLinearGradient(
            this.left._x, this.left._y,
            this.right._x, this.right._y
          );

          for (var i = 0; i < this.stops.length; i++) {
            var stop = this.stops[i];
            this._renderer.effect.addColorStop(stop._offset, stop._color);
          }

        }

        return this.flagReset();

      }

    },

    'radial-gradient': {

      render: function(ctx, elem) {

        if (!ctx.canvas.getContext('2d')) {
          return;
        }

        this._update();

        if (!this._renderer.effect || this._flagCenter || this._flagFocal
            || this._flagRadius || this._flagStops) {

          this._renderer.effect = ctx.createRadialGradient(
            this.center._x, this.center._y, 0,
            this.focal._x, this.focal._y, this._radius
          );

          for (var i = 0; i < this.stops.length; i++) {
            var stop = this.stops[i];
            this._renderer.effect.addColorStop(stop._offset, stop._color);
          }

        }

        return this.flagReset();

      }

    },

    texture: {

      render: function(ctx, elem) {

        if (!ctx.canvas.getContext('2d')) {
          return;
        }

        this._update();

        var image = this.image;
        var repeat;

        if (((this._flagLoaded || this._flagImage || this._flagVideo || this._flagRepeat) && this.loaded)) {
          this._renderer.effect = ctx.createPattern(image, this._repeat);
        } else if (!this._renderer.effect) {
          return this.flagReset();
        }

        if (this._flagOffset || this._flagLoaded || this._flagScale) {

          if (!(this._renderer.offset instanceof Two.Vector)) {
            this._renderer.offset = new Two.Vector();
          }

          this._renderer.offset.x = - this._offset.x;
          this._renderer.offset.y = - this._offset.y;

          if (image) {

            this._renderer.offset.x += image.width / 2;
            this._renderer.offset.y += image.height / 2;

            if (this._scale instanceof Two.Vector) {
              this._renderer.offset.x *= this._scale.x;
              this._renderer.offset.y *= this._scale.y;
            } else {
              this._renderer.offset.x *= this._scale;
              this._renderer.offset.y *= this._scale;
            }
          }

        }

        if (this._flagScale || this._flagLoaded) {

          if (!(this._renderer.scale instanceof Two.Vector)) {
            this._renderer.scale = new Two.Vector();
          }

          if (this._scale instanceof Two.Vector) {
            this._renderer.scale.copy(this._scale);
          } else {
            this._renderer.scale.set(this._scale, this._scale);
          }

        }

        return this.flagReset();

      }

    },

    updateTexture: function(gl, elem) {

      this[elem._renderer.type].updateCanvas.call(webgl, elem);

      if (!elem._renderer.texture) {
        elem._renderer.texture = gl.createTexture();
      }

      gl.bindTexture(gl.TEXTURE_2D, elem._renderer.texture);

      // Set the parameters so we can render any size image.
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

      if (this.canvas.width <= 0 || this.canvas.height <= 0) {
        return;
      }

      // Upload the image into the texture.
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvas);

    },

    program: {

      create: function(gl, shaders) {
        var program, linked, error;
        program = gl.createProgram();
        _.each(shaders, function(s) {
          gl.attachShader(program, s);
        });

        gl.linkProgram(program);
        linked = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!linked) {
          error = gl.getProgramInfoLog(program);
          gl.deleteProgram(program);
          throw new Two.Utils.Error('unable to link program: ' + error);
        }

        return program;

      }

    },

    shaders: {

      create: function(gl, source, type) {
        var shader, compiled, error;
        shader = gl.createShader(gl[type]);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (!compiled) {
          error = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);
          throw new Two.Utils.Error('unable to compile shader ' + shader + ': ' + error);
        }

        return shader;

      },

      types: {
        vertex: 'VERTEX_SHADER',
        fragment: 'FRAGMENT_SHADER'
      },

      vertex: [
        'precision mediump float;',
        'attribute vec2 a_position;',
        '',
        'uniform mat3 u_matrix;',
        'uniform vec2 u_resolution;',
        'uniform vec4 u_rect;',
        '',
        'varying vec2 v_textureCoords;',
        '',
        'void main() {',
        '   vec2 rectCoords = (a_position * (u_rect.zw - u_rect.xy)) + u_rect.xy;',
        '   vec2 projected = (u_matrix * vec3(rectCoords, 1.0)).xy;',
        '   vec2 normal = projected / u_resolution;',
        '   vec2 clipspace = (normal * 2.0) - 1.0;',
        '',
        '   gl_Position = vec4(clipspace * vec2(1.0, -1.0), 0.0, 1.0);',
        '   v_textureCoords = a_position;',
        '}'
      ].join('\n'),

      fragment: [
        'precision mediump float;',
        '',
        'uniform sampler2D u_image;',
        'varying vec2 v_textureCoords;',
        '',
        'void main() {',
        '  vec4 texel = texture2D(u_image, v_textureCoords);',
        '  if (texel.a == 0.0) {',
        '    discard;',
        '  }',
        '  gl_FragColor = texel;',
        '}'
      ].join('\n')

    },

    TextureRegistry: new Two.Registry()

  };

  webgl.ctx = webgl.canvas.getContext('2d');

  /**
   * @name Two.WebGLRenderer
   * @class
   * @extends Two.Utils.Events
   * @param {Object} [parameters] - This object is inherited when constructing a new instance of {@link Two}.
   * @param {Element} [parameters.domElement] - The `<canvas />` to draw to. If none given a new one will be constructed.
   * @param {CanvasElement} [parameters.offscreenElement] - The offscreen two dimensional `<canvas />` to render each element on WebGL texture updates.
   * @param {Boolean} [parameters.antialias] - Determines whether the canvas should clear render with antialias on.
   * @description This class is used by {@link Two} when constructing with `type` of `Two.Types.webgl`. It takes Two.js' scenegraph and renders it to a `<canvas />` through the WebGL api.
   * @see {@link https://www.khronos.org/registry/webgl/specs/latest/1.0/}
   */
  var Renderer = Two[Two.Types.webgl] = function(params) {

    var gl, vs, fs;

    /**
     * @name Two.WebGLRenderer#domElement
     * @property {Element} - The `<canvas />` associated with the Two.js scene.
     */
    this.domElement = params.domElement || document.createElement('canvas');

    if (!_.isUndefined(params.offscreenElement)) {
      webgl.canvas = params.offscreenElement;
      webgl.ctx = webgl.canvas.getContext('2d');
    }

    /**
     * @name Two.WebGLRenderer#scene
     * @property {Two.Group} - The root group of the scenegraph.
     */
    this.scene = new Two.Group();
    this.scene.parent = this;

    this._renderer = {
      type: 'renderer',
      matrix: new Two.Array(identity),
      scale: 1,
      opacity: 1
    };
    this._flagMatrix = true;

    // http://games.greggman.com/game/webgl-and-alpha/
    // http://www.khronos.org/registry/webgl/specs/latest/#5.2
    params = _.defaults(params || {}, {
      antialias: false,
      alpha: true,
      premultipliedAlpha: true,
      stencil: true,
      preserveDrawingBuffer: true,
      overdraw: false
    });

    /**
     * @name Two.WebGLRenderer#overdraw
     * @property {Boolean} - Determines whether the canvas clears the background each draw call.
     * @default true
     */
    this.overdraw = params.overdraw;

    /**
     * @name Two.WebGLRenderer#ctx
     * @property {WebGLContext} - Associated two dimensional context to render on the `<canvas />`.
     */
    gl = this.ctx = this.domElement.getContext('webgl', params) ||
      this.domElement.getContext('experimental-webgl', params);

    if (!this.ctx) {
      throw new Two.Utils.Error(
        'unable to create a webgl context. Try using another renderer.');
    }

    // Compile Base Shaders to draw in pixel space.
    vs = webgl.shaders.create(
      gl, webgl.shaders.vertex, webgl.shaders.types.vertex);
    fs = webgl.shaders.create(
      gl, webgl.shaders.fragment, webgl.shaders.types.fragment);

    /**
     * @name Two.WebGLRenderer#program
     * @property {WebGLProgram} - Associated WebGL program to render all elements from the scenegraph.
     */
    this.program = webgl.program.create(gl, [vs, fs]);
    gl.useProgram(this.program);

    // Create and bind the drawing buffer

    // look up where the vertex data needs to go.
    this.program.position = gl.getAttribLocation(this.program, 'a_position');
    this.program.matrix = gl.getUniformLocation(this.program, 'u_matrix');
    this.program.rect = gl.getUniformLocation(this.program, 'u_rect');

    // Bind the vertex buffer
    var positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(this.program.position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(this.program.position);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Two.Array([
        0, 0,
        1, 0,
        0, 1,
        0, 1,
        1, 0,
        1, 1
      ]),
      gl.STATIC_DRAW);

    // Setup some initial statements of the gl context
    gl.enable(gl.BLEND);

    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);

    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
  };

  _.extend(Renderer, {

    /**
     * @name Two.WebGLRenderer.Utils
     * @property {Object} - A massive object filled with utility functions and properties to render Two.js objects to a `<canvas />` through the WebGL API.
     */
    Utils: webgl

  });

  _.extend(Renderer.prototype, Two.Utils.Events, {

    constructor: Renderer,

    /**
     * @name Two.WebGLRenderer#setSize
     * @function
     * @param {Number} width - The new width of the renderer.
     * @param {Number} height - The new height of the renderer.
     * @param {Number} [ratio] - The new pixel ratio (pixel density) of the renderer. Defaults to calculate the pixel density of the user's screen.
     * @description Change the size of the renderer.
     * @nota-bene Triggers a `Two.Events.resize`.
     */
    setSize: function(width, height, ratio) {

      this.width = width;
      this.height = height;

      this.ratio = _.isUndefined(ratio) ? getRatio(this.ctx) : ratio;

      this.domElement.width = width * this.ratio;
      this.domElement.height = height * this.ratio;

      if (_.isObject(this.domElement.style)) {
        _.extend(this.domElement.style, {
          width: width + 'px',
          height: height + 'px'
        });
      }

      // Set for this.stage parent scaling to account for HDPI
      this._renderer.matrix[0] = this._renderer.matrix[4] = this._renderer.scale = this.ratio;

      this._flagMatrix = true;

      this.ctx.viewport(0, 0, width * this.ratio, height * this.ratio);

      var resolutionLocation = this.ctx.getUniformLocation(
        this.program, 'u_resolution');
      this.ctx.uniform2f(resolutionLocation, width * this.ratio, height * this.ratio);

      return this.trigger(Two.Events.resize, width, height, ratio);

    },

    /**
     * @name Two.WebGLRenderer#render
     * @function
     * @description Render the current scene to the `<canvas />`.
     */
    render: function() {

      var gl = this.ctx;

      if (!this.overdraw) {
        gl.clear(gl.COLOR_BUFFER_BIT);
      }

      webgl.group.render.call(this.scene, gl, this.program);
      this._flagMatrix = false;

      return this;

    }

  });

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var _ = Two.Utils;

  /**
   * @name Two.Shape
   * @class
   * @extends Two.Utils.Events
   * @description The foundational transformation object for the Two.js scenegraph.
   */
  var Shape = Two.Shape = function() {

    /**
     * @name Two.Shape#_renderer
     * @property {Object}
     * @private
     * @description A private object to store relevant renderer specific variables.
     * @nota-bene With the {@link Two.SvgRenderer} you can access the underlying SVG element created via `shape._renderer.elem`.
     */
    this._renderer = {};
    this._renderer.flagMatrix = _.bind(Shape.FlagMatrix, this);
    this.isShape = true;

    /**
     * @name Two.Shape#id
     * @property {String} - Session specific unique identifier.
     * @nota-bene In the {@link Two.SvgRenderer} change this to change the underlying SVG element's id too.
     */
    this.id = Two.Identifier + Two.uniqueId();

    /**
     * @name Two.Shape#classList
     * @property {String[]}
     * @description A list of class strings stored if imported / interpreted  from an SVG element.
     */
    this.classList = [];

    /**
     * @name Two.Shape#matrix
     * @property {Two.Matrix}
     * @description The transformation matrix of the shape.
     * @nota-bene {@link Two.Shape#translation}, {@link Two.Shape#rotation}, and {@link Two.Shape#scale} apply their values to the matrix when changed. The matrix is what is sent to the renderer to be drawn.
     */
    this.matrix = new Two.Matrix();

    /**
     * @name Two.Shape#translation
     * @property {Two.Vector} - The x and y value for where the shape is placed relative to its parent.
     */
    this.translation = new Two.Vector();

    /**
     * @name Two.Shape#rotation
     * @property {Radians} - The value in radians for how much the shape is rotated relative to its parent.
     */
    this.rotation = 0;

    /**
     * @name Two.Shape#scale
     * @property {Number} - The value for how much the shape is scaled relative to its parent.
     * @nota-bene This value can be replaced with a {@link Two.Vector} to do non-uniform scaling. e.g: `shape.scale = new Two.Vector(2, 1);`
     */
    this.scale = 1;

  };

  _.extend(Shape, {

    /**
     * @name Two.Shape.FlagMatrix
     * @function
     * @description Utility function used in conjunction with event handlers to update the flagMatrix of a shape.
     */
    FlagMatrix: function() {
      this._flagMatrix = true;
    },

    /**
     * @name Two.Shape.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Shape} to any object. Handy if you'd like to extend the {@link Two.Shape} class on a custom class.
     */
    MakeObservable: function(object) {

      var translation = {
        enumerable: false,
        get: function() {
          return this._translation;
        },
        set: function(v) {
          if (this._translation) {
            this._translation.unbind(Two.Events.change, this._renderer.flagMatrix);
          }
          this._translation = v;
          this._translation.bind(Two.Events.change, this._renderer.flagMatrix);
          Shape.FlagMatrix.call(this);
        }
      };

      Object.defineProperty(object, 'translation', translation);
      Object.defineProperty(object, 'position', translation);

      Object.defineProperty(object, 'rotation', {
        enumerable: true,
        get: function() {
          return this._rotation;
        },
        set: function(v) {
          this._rotation = v;
          this._flagMatrix = true;
        }
      });

      Object.defineProperty(object, 'scale', {
        enumerable: true,
        get: function() {
          return this._scale;
        },
        set: function(v) {

          if (this._scale instanceof Two.Vector) {
            this._scale.unbind(Two.Events.change, this._renderer.flagMatrix);
          }

          this._scale = v;

          if (this._scale instanceof Two.Vector) {
            this._scale.bind(Two.Events.change, this._renderer.flagMatrix);
          }

          this._flagMatrix = true;
          this._flagScale = true;

        }
      });

      Object.defineProperty(object, 'matrix', {
        enumerable: true,
        get: function() {
          return this._matrix;
        },
        set: function(v) {
          this._matrix = v;
          this._flagMatrix = true;
        }
      });

      Object.defineProperty(object, 'className', {

        enumerable: true,

        get: function() {
          return this._className;
        },

        set: function(v) {

          this._flagClassName  = this._className !== v;

          if (this._flagClassName) {

            var prev = this._className.split(/\s+?/);
            var dest = v.split(/\s+?/);

            for (var i = 0; i < prev.length; i++) {
              var className = prev[i];
              var index = _.indexOf(this.classList, className);
              if (index >= 0) {
                this.classList.splice(index, 1);
              }
            }

            this.classList = this.classList.concat(dest);

          }

          this._className = v;

        }

      });

    }

  });

  _.extend(Shape.prototype, Two.Utils.Events, {

    // Flags

    /**
     * @name Two.Shape#_flagMatrix
     * @private
     * @property {Boolean} - Determines whether the matrix needs updating.
     */
    _flagMatrix: true,

    /**
     * @name Two.Shape#_flagScale
     * @private
     * @property {Boolean} - Determines whether the scale needs updating.
     */
    _flagScale: false,

    // _flagMask: false,
    // _flagClip: false,

    /**
     * @name Two.Shape#_flagClassName
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#className} need updating.
     */
    _flagClassName: false,

    // Underlying Properties

    /**
     * @name Two.Shape#_translation
     * @private
     * @property {Two.Vector} - The translation values as a {@link Two.Vector}.
     */
    _translation: null,

    /**
     * @name Two.Shape#_rotation
     * @private
     * @property {Radians} - The rotation value in radians.
     */
    _rotation: 0,

    /**
     * @name Two.Shape#_translation
     * @private
     * @property {Two.Vector} - The translation values as a {@link Two.Vector}.
     */
    _scale: 1,

    // _mask: null,
    // _clip: false,

    /**
     * @name Two.Group#className
     * @property {String} - A class to be applied to the element to be compatible with CSS styling.
     * @nota-bene Only available for the SVG renderer.
     */
    _className: '',

    constructor: Shape,

    /**
     * @name Two.Shape#addTo
     * @function
     * @param {Two.Group} group - The parent the shape adds itself to.
     * @description Convenience method to add itself to the scenegraph.
     */
    addTo: function(group) {
      group.add(this);
      return this;
    },

    /**
     * @name Two.Shape#clone
     * @function
     * @param {Two.Group} [parent] - Optional argument to automatically add the shape to a scenegraph.
     * @returns {Two.Shape}
     * @description Create a new {@link Two.Shape} with the same values as the current shape.
     */
    clone: function(parent) {

      var clone = new Shape();

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      if (parent) {
        parent.add(clone);
      }

      return clone._update();

    },

    /**
     * @name Two.Shape#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function(bubbles) {

      if (!this._matrix.manual && this._flagMatrix) {

        this._matrix
          .identity()
          .translate(this.translation.x, this.translation.y);

          if (this._scale instanceof Two.Vector) {
            this._matrix.scale(this._scale.x, this._scale.y);
          } else {
            this._matrix.scale(this._scale);
          }

          this._matrix.rotate(this.rotation);

      }

      if (bubbles) {
        if (this.parent && this.parent._update) {
          this.parent._update();
        }
      }

      return this;

    },

    /**
     * @name Two.Shape#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagMatrix = this._flagScale = this._flagClassName = false;

      return this;

    }

  });

  Shape.MakeObservable(Shape.prototype);

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  // Constants

  var min = Math.min, max = Math.max, round = Math.round,
    ceil = Math.ceil, floor = Math.floor,
    getComputedMatrix = Two.Utils.getComputedMatrix;

  var commands = {};
  var _ = Two.Utils;

  _.each(Two.Commands, function(v, k) {
    commands[k] = new RegExp(v);
  });

  /**
   * @name Two.Path
   * @class
   * @extends Two.Shape
   * @param {Two.Anchor[]} [vertices] - A list of {@link Two.Anchor}s that represent the order and coordinates to construct the rendered shape.
   * @param {Boolean} [closed=false] - Describes whether the shape is closed or open.
   * @param {Boolean} [curved=false] - Describes whether the shape automatically calculates bezier handles for each vertex.
   * @param {Boolean} [manual=false] - Describes whether the developer controls how vertices are plotted or if Two.js automatically plots coordinates based on closed and curved booleans.
   * @description This is the primary primitive class for creating all drawable shapes in Two.js. Unless specified methods return their instance of `Two.Path` for the purpose of chaining.
   */
  var Path = Two.Path = function(vertices, closed, curved, manual) {

    Two.Shape.call(this);

    this._renderer.type = 'path';
    this._renderer.flagVertices = _.bind(Path.FlagVertices, this);
    this._renderer.bindVertices = _.bind(Path.BindVertices, this);
    this._renderer.unbindVertices = _.bind(Path.UnbindVertices, this);

    this._renderer.flagFill = _.bind(Path.FlagFill, this);
    this._renderer.flagStroke = _.bind(Path.FlagStroke, this);
    this._renderer.vertices = [];
    this._renderer.collection = [];

    /**
     * @name Two.Path#closed
     * @property {Boolean} - Determines whether a final line is drawn between the final point in the `vertices` array and the first point.
     */
    this._closed = !!closed;

    /**
     * @name Two.Path#curved
     * @property {Boolean} - When the path is `automatic = true` this boolean determines whether the lines between the points are curved or not.
     */
    this._curved = !!curved;

    /**
     * @name Two.Path#beginning
     * @property {Number} - Number between zero and one to state the beginning of where the path is rendered.
     * @description {@link Two.Path#beginning} is a percentage value that represents at what percentage into the path should the renderer start drawing.
     * @nota-bene This is great for animating in and out stroked paths in conjunction with {@link Two.Path#ending}.
     */
    this.beginning = 0;

    /**
     * @name Two.Path#ending
     * @property {Number} - Number between zero and one to state the ending of where the path is rendered.
     * @description {@link Two.Path#ending} is a percentage value that represents at what percentage into the path should the renderer start drawing.
     * @nota-bene This is great for animating in and out stroked paths in conjunction with {@link Two.Path#beginning}.
     */
    this.ending = 1;

    // Style properties

    /**
     * @name Two.Path#fill
     * @property {(CssColor|Two.Gradient|Two.Texture)} - The value of what the path should be filled in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS Colors.
     */
    this.fill = '#fff';

    /**
     * @name Two.Path#stroke
     * @property {(CssColor|Two.Gradient|Two.Texture)} - The value of what the path should be outlined in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS Colors.
     */
    this.stroke = '#000';

    /**
     * @name Two.Path#linewidth
     * @property {Number} - The thickness in pixels of the stroke.
     */
    this.linewidth = 1.0;

    /**
     * @name Two.Path#opacity
     * @property {Number} - The opaqueness of the path.
     * @nota-bene Can be used in conjunction with CSS Colors that have an alpha value.
     */
    this.opacity = 1.0;

    /**
     * @name Two.Path#className
     * @property {String} - A class to be applied to the element to be compatible with CSS styling.
     * @nota-bene Only available for the SVG renderer.
     */
    this.className = '';

    /**
     * @name Two.Path#visible
     * @property {Boolean} - Display the path or not.
     * @nota-bene For {@link Two.CanvasRenderer} and {@link Two.WebGLRenderer} when set to false all updating is disabled improving performance dramatically with many objects in the scene.
     */
    this.visible = true;

    /**
     * @name Two.Path#cap
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeLinecapProperty}
     */
    this.cap = 'butt';      // Default of Adobe Illustrator

    /**
     * @name Two.Path#join
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeLinejoinProperty}
     */
    this.join = 'miter';    // Default of Adobe Illustrator

    /**
     * @name Two.Path#miter
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeMiterlimitProperty}
     */
    this.miter = 4;         // Default of Adobe Illustrator

    /**
     * @name Two.Path#vertices
     * @property {Two.Anchor[]} - An ordered list of anchor points for rendering the path.
     * @description A list of {@link Two.Anchor} objects that consist of what form the path takes.
     * @nota-bene The array when manipulating is actually a {@link Two.Utils.Collection}.
     */
    this.vertices = vertices;

    /**
     * @name Two.Path#automatic
     * @property {Boolean} - Determines whether or not Two.js should calculate curves, lines, and commands automatically for you or to let the developer manipulate them for themselves.
     */
    this.automatic = !manual;

    /**
     * @name Two.Path#dashes
     * @property {Number[]} - Array of numbers. Odd indices represent dash length. Even indices represent dash space.
     * @description A list of numbers that represent the repeated dash length and dash space applied to the stroke of the text.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray} for more information on the SVG stroke-dasharray attribute.
     */
    this.dashes = [];

    /**
     * @name Two.Path#dashes#offset
     * @property {Number} - A number in pixels to offset {@link Two.Path#dashes} display.
     */
    this.dashes.offset = 0;

  };

  _.extend(Path, {

    /**
     * @name Two.Path.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Path}.
     */
    Properties: [
      'fill',
      'stroke',
      'linewidth',
      'opacity',
      'visible',
      'cap',
      'join',
      'miter',

      'closed',
      'curved',
      'automatic',
      'beginning',
      'ending'
    ],

    Utils: {
      getCurveLength: getCurveLength
    },

    /**
     * @name Two.Path.FlagVertices
     * @function
     * @description Cached method to let renderers know vertices have been updated on a {@link Two.Path}.
     */
    FlagVertices: function() {
      this._flagVertices = true;
      this._flagLength = true;
      if (this.parent) {
        this.parent._flagLength = true;
      }
    },

    /**
     * @name Two.Path.BindVertices
     * @function
     * @description Cached method to let {@link Two.Path} know vertices have been added to the instance.
     */
    BindVertices: function(items) {

      // This function is called a lot
      // when importing a large SVG
      var i = items.length;
      while (i--) {
        items[i].bind(Two.Events.change, this._renderer.flagVertices);
      }

      this._renderer.flagVertices();

    },

    /**
     * @name Two.Path.UnbindVertices
     * @function
     * @description Cached method to let {@link Two.Path} know vertices have been removed from the instance.
     */
    UnbindVertices: function(items) {

      var i = items.length;
      while (i--) {
        items[i].unbind(Two.Events.change, this._renderer.flagVertices);
      }

      this._renderer.flagVertices();

    },

    /**
     * @name Two.Path.FlagFill
     * @function
     * @description Cached method to let {@link Two.Path} know the fill has changed.
     */
    FlagFill: function() {
      this._flagFill = true;
    },

    /**
     * @name Two.Path.FlagFill
     * @function
     * @description Cached method to let {@link Two.Path} know the stroke has changed.
     */
    FlagStroke: function() {
      this._flagStroke = true;
    },

    /**
     * @name Two.Path.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Path} to any object. Handy if you'd like to extend the {@link Two.Path} class on a custom class.
     */
    MakeObservable: function(object) {

      Two.Shape.MakeObservable(object);

      // Only the 7 defined properties are flagged like this. The subsequent
      // properties behave differently and need to be hand written.
      _.each(Path.Properties.slice(2, 8), Two.Utils.defineProperty, object);

      Object.defineProperty(object, 'fill', {
        enumerable: true,
        get: function() {
          return this._fill;
        },
        set: function(f) {

          if (this._fill instanceof Two.Gradient
            || this._fill instanceof Two.LinearGradient
            || this._fill instanceof Two.RadialGradient
            || this._fill instanceof Two.Texture) {
            this._fill.unbind(Two.Events.change, this._renderer.flagFill);
          }

          this._fill = f;
          this._flagFill = true;

          if (this._fill instanceof Two.Gradient
            || this._fill instanceof Two.LinearGradient
            || this._fill instanceof Two.RadialGradient
            || this._fill instanceof Two.Texture) {
            this._fill.bind(Two.Events.change, this._renderer.flagFill);
          }

        }
      });

      Object.defineProperty(object, 'stroke', {
        enumerable: true,
        get: function() {
          return this._stroke;
        },
        set: function(f) {

          if (this._stroke instanceof Two.Gradient
            || this._stroke instanceof Two.LinearGradient
            || this._stroke instanceof Two.RadialGradient
            || this._stroke instanceof Two.Texture) {
            this._stroke.unbind(Two.Events.change, this._renderer.flagStroke);
          }

          this._stroke = f;
          this._flagStroke = true;

          if (this._stroke instanceof Two.Gradient
            || this._stroke instanceof Two.LinearGradient
            || this._stroke instanceof Two.RadialGradient
            || this._stroke instanceof Two.Texture) {
            this._stroke.bind(Two.Events.change, this._renderer.flagStroke);
          }

        }
      });

      /**
       * @name Two.Path#length
       * @property {Number} - The sum of distances between all {@link Two.Path#vertices}.
       */
      Object.defineProperty(object, 'length', {
        get: function() {
          if (this._flagLength) {
            this._updateLength();
          }
          return this._length;
        }
      });

      Object.defineProperty(object, 'closed', {
        enumerable: true,
        get: function() {
          return this._closed;
        },
        set: function(v) {
          this._closed = !!v;
          this._flagVertices = true;
        }
      });

      Object.defineProperty(object, 'curved', {
        enumerable: true,
        get: function() {
          return this._curved;
        },
        set: function(v) {
          this._curved = !!v;
          this._flagVertices = true;
        }
      });

      Object.defineProperty(object, 'automatic', {
        enumerable: true,
        get: function() {
          return this._automatic;
        },
        set: function(v) {
          if (v === this._automatic) {
            return;
          }
          this._automatic = !!v;
          var method = this._automatic ? 'ignore' : 'listen';
          _.each(this.vertices, function(v) {
            v[method]();
          });
        }
      });

      Object.defineProperty(object, 'beginning', {
        enumerable: true,
        get: function() {
          return this._beginning;
        },
        set: function(v) {
          this._beginning = v;
          this._flagVertices = true;
        }
      });

      Object.defineProperty(object, 'ending', {
        enumerable: true,
        get: function() {
          return this._ending;
        },
        set: function(v) {
          this._ending = v;
          this._flagVertices = true;
        }
      });

      Object.defineProperty(object, 'vertices', {

        enumerable: true,

        get: function() {
          return this._collection;
        },

        set: function(vertices) {

          var updateVertices = this._renderer.flagVertices;
          var bindVertices = this._renderer.bindVertices;
          var unbindVertices = this._renderer.unbindVertices;

          // Remove previous listeners
          if (this._collection) {
            this._collection
              .unbind(Two.Events.insert, bindVertices)
              .unbind(Two.Events.remove, unbindVertices);
          }

          // Create new Collection with copy of vertices
          if (vertices instanceof Two.Utils.Collection) {
            this._collection = vertices;
          } else {
            this._collection = new Two.Utils.Collection(vertices || []);
          }


          // Listen for Collection changes and bind / unbind
          this._collection
            .bind(Two.Events.insert, bindVertices)
            .bind(Two.Events.remove, unbindVertices);

          // Bind Initial Vertices
          bindVertices(this._collection);

        }

      });

      /**
       * @name Two.Path#clip
       * @property {Two.Shape} - Object to define clipping area.
       * @nota-bene This property is currently not working becuase of SVG spec issues found here {@link https://code.google.com/p/chromium/issues/detail?id=370951}.
       */
      Object.defineProperty(object, 'clip', {
        enumerable: true,
        get: function() {
          return this._clip;
        },
        set: function(v) {
          this._clip = v;
          this._flagClip = true;
        }
      });

      Object.defineProperty(object, 'dashes', {
        enumerable: true,
        get: function() {
          return this._dashes;
        },
        set: function(v) {
          if (!_.isNumber(v.offset)) {
            v.offset = this._dashes.offset || 0;
          }
          this._dashes = v;
        }
      });

    }

  });

  _.extend(Path.prototype, Two.Shape.prototype, {

    // Flags
    // http://en.wikipedia.org/wiki/Flag

    /**
     * @name Two.Path#_flagVertices
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#vertices} need updating.
     */
    _flagVertices: true,

    /**
     * @name Two.Path#_flagLength
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#length} needs updating.
     */
    _flagLength: true,

    /**
     * @name Two.Path#_flagFill
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#fill} needs updating.
     */
    _flagFill: true,

    /**
     * @name Two.Path#_flagStroke
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#stroke} needs updating.
     */
    _flagStroke: true,

    /**
     * @name Two.Path#_flagLinewidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#linewidth} needs updating.
     */
    _flagLinewidth: true,

    /**
     * @name Two.Path#_flagOpacity
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#opacity} needs updating.
     */
    _flagOpacity: true,

    /**
     * @name Two.Path#_flagVisible
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#visible} needs updating.
     */
    _flagVisible: true,

    /**
     * @name Two.Path#_flagCap
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#cap} needs updating.
     */
    _flagCap: true,

    /**
     * @name Two.Path#_flagJoin
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#join} needs updating.
     */
    _flagJoin: true,

    /**
     * @name Two.Path#_flagMiter
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#miter} needs updating.
     */
    _flagMiter: true,

    /**
     * @name Two.Path#_flagClip
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#clip} needs updating.
     */
    _flagClip: false,

    // Underlying Properties

    /**
     * @name Two.Path#_length
     * @private
     * @see {@link Two.Path#length}
     */
    _length: 0,

    /**
     * @name Two.Path#_fill
     * @private
     * @see {@link Two.Path#fill}
     */
    _fill: '#fff',

    /**
     * @name Two.Path#_stroke
     * @private
     * @see {@link Two.Path#stroke}
     */
    _stroke: '#000',

    /**
     * @name Two.Path#_linewidth
     * @private
     * @see {@link Two.Path#linewidth}
     */
    _linewidth: 1.0,

    /**
     * @name Two.Path#_opacity
     * @private
     * @see {@link Two.Path#opacity}
     */
    _opacity: 1.0,

    /**
     * @name Two.Path#_visible
     * @private
     * @see {@link Two.Path#visible}
     */
    _visible: true,

    /**
     * @name Two.Path#_cap
     * @private
     * @see {@link Two.Path#cap}
     */
    _cap: 'round',

    /**
     * @name Two.Path#_join
     * @private
     * @see {@link Two.Path#join}
     */
    _join: 'round',

    /**
     * @name Two.Path#_miter
     * @private
     * @see {@link Two.Path#miter}
     */
    _miter: 4,

    /**
     * @name Two.Path#_closed
     * @private
     * @see {@link Two.Path#closed}
     */
    _closed: true,

    /**
     * @name Two.Path#_curved
     * @private
     * @see {@link Two.Path#curved}
     */
    _curved: false,

    /**
     * @name Two.Path#_automatic
     * @private
     * @see {@link Two.Path#automatic}
     */
    _automatic: true,

    /**
     * @name Two.Path#_beginning
     * @private
     * @see {@link Two.Path#beginning}
     */
    _beginning: 0,

    /**
     * @name Two.Path#_ending
     * @private
     * @see {@link Two.Path#ending}
     */
    _ending: 1.0,

    /**
     * @name Two.Path#_clip
     * @private
     * @see {@link Two.Path#clip}
     */
    _clip: false,

    /**
     * @name Two.Path#_dashes
     * @private
     * @see {@link Two.Path#dashes}
     */
    _dashes: [],

    constructor: Path,

    /**
     * @name Two.Path#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Path}
     * @description Create a new instance of {@link Two.Path} with the same properties of the current path.
     */
    clone: function(parent) {

      var clone = new Path();

      for (var j = 0; j < this.vertices.length; j++) {
        clone.vertices.push(this.vertices[j].clone());
      }

      for (var i = 0; i < Path.Properties.length; i++) {
        var k = Path.Properties[i];
        clone[k] = this[k];
      }

      clone.className = this.className;

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      if (parent) {
        parent.add(clone);
      }

      return clone._update();

    },

    /**
     * @name Two.Path#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var result = {
        vertices: _.map(this.vertices, function(v) {
          return v.toObject();
        })
      };

      _.each(Two.Shape.Properties, function(k) {
        result[k] = this[k];
      }, this);

      result.className = this.className;

      result.translation = this.translation.toObject();
      result.rotation = this.rotation;
      result.scale = this.scale instanceof Two.Vector ? this.scale.toObject() : this.scale;

      if (this.matrix.manual) {
        result.matrix = this.matrix.toObject();
      }

      return result;

    },

    /**
     * @name Two.Path#noFill
     * @function
     * @description Short hand method to set fill to `transparent`.
     */
    noFill: function() {
      this.fill = 'transparent';
      return this;
    },

    /**
     * @name Two.Path#noStroke
     * @function
     * @description Short hand method to set stroke to `transparent`.
     */
    noStroke: function() {
      this.stroke = undefined;
      return this;
    },

    /**
     * @name Two.Path#corner
     * @function
     * @description Orient the vertices of the shape to the upper left-hand corner of the path.
     */
    corner: function() {

      var rect = this.getBoundingClientRect(true);

      rect.centroid = {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };

      _.each(this.vertices, function(v) {
        v.subSelf(rect.centroid);
        v.x += rect.width / 2;
        v.y += rect.height / 2;
      });

      return this;

    },

    /**
     * @name Two.Path#center
     * @function
     * @description Orient the vertices of the shape to the center of the path.
     */
    center: function() {

      var rect = this.getBoundingClientRect(true);

      rect.centroid = {
        x: rect.left + rect.width / 2 - this.translation.x,
        y: rect.top + rect.height / 2 - this.translation.y
      };

      _.each(this.vertices, function(v) {
        v.subSelf(rect.centroid);
      });

      return this;

    },

    /**
     * @name Two.Path#remove
     * @function
     * @description Remove self from the scene / parent.
     */
    remove: function() {

      if (!this.parent) {
        return this;
      }

      this.parent.remove(this);

      return this;

    },

    /**
     * @name Two.Path#getBoundingClientRect
     * @function
     * @param {Boolean} [shallow=false] - Describes whether to calculate off local matrix or world matrix.
     * @returns {Object} - Returns object with top, left, right, bottom, width, height attributes.
     * @description Return an object with top, left, right, bottom, width, and height parameters of the path.
     */
    getBoundingClientRect: function(shallow) {
      var matrix, border, l, x, y, i, v0, c0, c1, v1;

      var left = Infinity, right = -Infinity,
          top = Infinity, bottom = -Infinity;

      // TODO: Update this to not __always__ update. Just when it needs to.
      this._update(true);

      matrix = shallow ? this._matrix : getComputedMatrix(this);

      border = this.linewidth / 2;
      l = this._renderer.vertices.length;

      if (l <= 0) {
        return {
          width: 0,
          height: 0
        };
      }

      for (i = 0; i < l; i++) {

        v1 = this._renderer.vertices[i];
        // If i = 0, then this "wraps around" to the last vertex. Otherwise, it's the previous vertex.
        // This is important for handling cyclic paths.
        v0 = this._renderer.vertices[(i + l - 1) % l];

        if (v0.controls && v1.controls) {

          if (v0.relative) {
            c0 = matrix.multiply(
              v0.controls.right.x + v0.x, v0.controls.right.y + v0.y, 1);
          } else {
            c0 = matrix.multiply(
              v0.controls.right.x, v0.controls.right.y, 1);
          }
          v0 = matrix.multiply(v0.x, v0.y, 1);

          if (v1.relative) {
            c1 = matrix.multiply(
              v1.controls.left.x + v1.x, v1.controls.left.y + v1.y, 1);
          } else {
            c1 = matrix.multiply(
              v1.controls.left.x, v1.controls.left.y, 1);
          }
          v1 = matrix.multiply(v1.x, v1.y, 1);

          var bb = Two.Utils.getCurveBoundingBox(
            v0.x, v0.y, c0.x, c0.y, c1.x, c1.y, v1.x, v1.y);

          top = min(bb.min.y - border, top);
          left = min(bb.min.x - border, left);
          right = max(bb.max.x + border, right);
          bottom = max(bb.max.y + border, bottom);

        } else {

          if (i <= 1) {

            v0 = matrix.multiply(v0.x, v0.y, 1);

            top = min(v0.y - border, top);
            left = min(v0.x - border, left);
            right = max(v0.x + border, right);
            bottom = max(v0.y + border, bottom);

          }

          v1 = matrix.multiply(v1.x, v1.y, 1);

          top = min(v1.y - border, top);
          left = min(v1.x - border, left);
          right = max(v1.x + border, right);
          bottom = max(v1.y + border, bottom);

        }

      }

      return {
        top: top,
        left: left,
        right: right,
        bottom: bottom,
        width: right - left,
        height: bottom - top
      };

    },

    /**
     * @name Two.Path#getPointAt
     * @function
     * @param {Boolean} t - Percentage value describing where on the Two.Path to estimate and assign coordinate values.
     * @param {Two.Vector} [obj=undefined] - Object to apply calculated x, y to. If none available returns new Object.
     * @returns {Object}
     * @description Given a float `t` from 0 to 1, return a point or assign a passed `obj`'s coordinates to that percentage on this Two.Path's curve.
     */
    getPointAt: function(t, obj) {

      var ia, ib, result;
      var x, x1, x2, x3, x4, y, y1, y2, y3, y4, left, right;
      var target = this.length * Math.min(Math.max(t, 0), 1);
      var length = this.vertices.length;
      var last = length - 1;

      var a = null;
      var b = null;

      for (var i = 0, l = this._lengths.length, sum = 0; i < l; i++) {

        if (sum + this._lengths[i] >= target) {

          if (this._closed) {
            ia = Two.Utils.mod(i, length);
            ib = Two.Utils.mod(i - 1, length);
            if (i === 0) {
              ia = ib;
              ib = i;
            }
          } else {
            ia = i;
            ib = Math.min(Math.max(i - 1, 0), last);
          }

          a = this.vertices[ia];
          b = this.vertices[ib];
          target -= sum;
          if (this._lengths[i] !== 0) {
            t = target / this._lengths[i];
          } else {
            t = 0;
          }

          break;

        }

        sum += this._lengths[i];

      }

      if (_.isNull(a) || _.isNull(b)) {
        return null;
      }

      if (!a) {
        return b;
      } else if (!b) {
        return a;
      }

      right = b.controls && b.controls.right;
      left = a.controls && a.controls.left;

      x1 = b.x;
      y1 = b.y;
      x2 = (right || b).x;
      y2 = (right || b).y;
      x3 = (left || a).x;
      y3 = (left || a).y;
      x4 = a.x;
      y4 = a.y;

      if (right && b.relative) {
        x2 += b.x;
        y2 += b.y;
      }

      if (left && a.relative) {
        x3 += a.x;
        y3 += a.y;
      }

      x = Two.Utils.getComponentOnCubicBezier(t, x1, x2, x3, x4);
      y = Two.Utils.getComponentOnCubicBezier(t, y1, y2, y3, y4);

      // Higher order points for control calculation.
      var t1x = Two.Utils.lerp(x1, x2, t);
      var t1y = Two.Utils.lerp(y1, y2, t);
      var t2x = Two.Utils.lerp(x2, x3, t);
      var t2y = Two.Utils.lerp(y2, y3, t);
      var t3x = Two.Utils.lerp(x3, x4, t);
      var t3y = Two.Utils.lerp(y3, y4, t);

      // Calculate the returned points control points.
      var brx = Two.Utils.lerp(t1x, t2x, t);
      var bry = Two.Utils.lerp(t1y, t2y, t);
      var alx = Two.Utils.lerp(t2x, t3x, t);
      var aly = Two.Utils.lerp(t2y, t3y, t);

      if (_.isObject(obj)) {

        obj.x = x;
        obj.y = y;

        if (!_.isObject(obj.controls)) {
          Two.Anchor.AppendCurveProperties(obj);
        }

        obj.controls.left.x = brx;
        obj.controls.left.y = bry;
        obj.controls.right.x = alx;
        obj.controls.right.y = aly;

        if (!_.isBoolean(obj.relative) || obj.relative) {
          obj.controls.left.x -= x;
          obj.controls.left.y -= y;
          obj.controls.right.x -= x;
          obj.controls.right.y -= y;
        }

        obj.t = t;

        return obj;

      }

      result = new Two.Anchor(
        x, y, brx - x, bry - y, alx - x, aly - y,
        this._curved ? Two.Commands.curve : Two.Commands.line
      );

      result.t = t;

      return result;

    },

    /**
     * @name Two.Path#plot
     * @function
     * @description Based on closed / curved and sorting of vertices plot where all points should be and where the respective handles should be too.
     * @nota-bene While this method is public it is internally called by {@link Two.Path#_update} when `automatic = true`.
     */
    plot: function() {

      if (this.curved) {
        Two.Utils.getCurveFromPoints(this._collection, this.closed);
        return this;
      }

      for (var i = 0; i < this._collection.length; i++) {
        this._collection[i].command = i === 0 ? Two.Commands.move : Two.Commands.line;
      }

      return this;

    },

    /**
     * @name Two.Path#subdivide
     * @function
     * @param {Integer} limit - How many times to recurse subdivisions.
     * @description Insert a {@link Two.Anchor} at the midpoint between every item in {@link Two.Path#vertices}.
     */
    subdivide: function(limit) {
      //TODO: DRYness (function below)
      this._update();

      var last = this.vertices.length - 1;
      var b = this.vertices[last];
      var closed = this._closed || this.vertices[last]._command === Two.Commands.close;
      var points = [];
      _.each(this.vertices, function(a, i) {

        if (i <= 0 && !closed) {
          b = a;
          return;
        }

        if (a.command === Two.Commands.move) {
          points.push(new Two.Anchor(b.x, b.y));
          if (i > 0) {
            points[points.length - 1].command = Two.Commands.line;
          }
          b = a;
          return;
        }

        var verts = getSubdivisions(a, b, limit);
        points = points.concat(verts);

        // Assign commands to all the verts
        _.each(verts, function(v, i) {
          if (i <= 0 && b.command === Two.Commands.move) {
            v.command = Two.Commands.move;
          } else {
            v.command = Two.Commands.line;
          }
        });

        if (i >= last) {

          // TODO: Add check if the two vectors in question are the same values.
          if (this._closed && this._automatic) {

            b = a;

            verts = getSubdivisions(a, b, limit);
            points = points.concat(verts);

            // Assign commands to all the verts
            _.each(verts, function(v, i) {
              if (i <= 0 && b.command === Two.Commands.move) {
                v.command = Two.Commands.move;
              } else {
                v.command = Two.Commands.line;
              }
            });

          } else if (closed) {
            points.push(new Two.Anchor(a.x, a.y));
          }

          points[points.length - 1].command = closed
            ? Two.Commands.close : Two.Commands.line;

        }

        b = a;

      }, this);

      this._automatic = false;
      this._curved = false;
      this.vertices = points;

      return this;

    },

    /**
     * @name Two.Path#_updateLength
     * @function
     * @private
     * @param {Integer} [limit=] -
     * @param {Boolean} [silent=false] - If set to `true` then the path isn't updated before calculation. Useful for internal use.
     * @description Recalculate the {@link Two.Path#length} value.
     */
    _updateLength: function(limit, silent) {
      //TODO: DRYness (function above)
      if (!silent) {
        this._update();
      }

      var length = this.vertices.length;
      var last = length - 1;
      var b = this.vertices[last];
      var closed = false;//this._closed || this.vertices[last]._command === Two.Commands.close;
      var sum = 0;

      if (_.isUndefined(this._lengths)) {
        this._lengths = [];
      }

      _.each(this.vertices, function(a, i) {

        if ((i <= 0 && !closed) || a.command === Two.Commands.move) {
          b = a;
          this._lengths[i] = 0;
          return;
        }

        this._lengths[i] = getCurveLength(a, b, limit);
        sum += this._lengths[i];

        if (i >= last && closed) {

          b = this.vertices[(i + 1) % length];

          this._lengths[i + 1] = getCurveLength(a, b, limit);
          sum += this._lengths[i + 1];

        }

        b = a;

      }, this);

      this._length = sum;
      this._flagLength = false;

      return this;

    },

    /**
     * @name Two.Path#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagVertices) {

        if (this._automatic) {
          this.plot();
        }

        if (this._flagLength) {
          this._updateLength(undefined, true);
        }

        var l = this._collection.length;
        var last = l - 1;
        var closed = this._closed;

        var beginning = Math.min(this._beginning, this._ending);
        var ending = Math.max(this._beginning, this._ending);

        var bid = getIdByLength(this, beginning * this._length);
        var eid = getIdByLength(this, ending * this._length);

        var low = ceil(bid);
        var high = floor(eid);

        var left, right, prev, next, v;

        this._renderer.vertices.length = 0;

        for (var i = 0; i < l; i++) {

          if (this._renderer.collection.length <= i) {
            // Expected to be `relative` anchor points.
            this._renderer.collection.push(new Two.Anchor());
          }

          if (i > high && !right) {

            v = this._renderer.collection[i];
            v.copy(this._collection[i]);
            this.getPointAt(ending, v);
            v.command = this._renderer.collection[i].command;
            this._renderer.vertices.push(v);

            right = v;
            prev = this._collection[i - 1];

            // Project control over the percentage `t`
            // of the in-between point
            if (prev && prev.controls) {

              v.controls.right.clear();

              this._renderer.collection[i - 1].controls.right
                .clear()
                .lerp(prev.controls.right, v.t);

            }

          } else if (i >= low && i <= high) {

            v = this._renderer.collection[i]
              .copy(this._collection[i]);
            this._renderer.vertices.push(v);

            if (i === high && contains(this, ending)) {
              right = v;
              if (!closed && right.controls) {
                right.controls.right.clear();
              }
            } else if (i === low && contains(this, beginning)) {
              left = v;
              left.command = Two.Commands.move;
              if (!closed && left.controls) {
                left.controls.left.clear();
              }
            }

          }

        }

        // Prepend the trimmed point if necessary.
        if (low > 0 && !left) {

          i = low - 1;

          v = this._renderer.collection[i];
          v.copy(this._collection[i]);
          this.getPointAt(beginning, v);
          v.command = Two.Commands.move;
          this._renderer.vertices.unshift(v);

          left = v;
          next = this._collection[i + 1];

          // Project control over the percentage `t`
          // of the in-between point
          if (next && next.controls) {

            v.controls.left.clear();

            this._renderer.collection[i + 1].controls.left
              .copy(next.controls.left)
              .lerp(Two.Vector.zero, v.t);

          }

        }

      }

      Two.Shape.prototype._update.apply(this, arguments);

      return this;

    },

    /**
     * @name Two.Path#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagVertices =  this._flagFill =  this._flagStroke =
         this._flagLinewidth = this._flagOpacity = this._flagVisible =
         this._flagCap = this._flagJoin = this._flagMiter =
         this._flagClip = false;

      Two.Shape.prototype.flagReset.call(this);

      return this;

    }

  });

  Path.MakeObservable(Path.prototype);

   // Utility functions

  function contains(path, t) {

    if (t === 0 || t === 1) {
      return true;
    }

    var length = path._length;
    var target = length * t;
    var elapsed = 0;

    for (var i = 0; i < path._lengths.length; i++) {
      var dist = path._lengths[i];
      if (elapsed >= target) {
        return target - elapsed >= 0;
      }
      elapsed += dist;
    }

    return false;

  }

  /**
   * @protected
   * @param {Two.Path} path - The path to analyze against.
   * @param {Number} target - The target length at which to find an anchor.
   * @returns {Integer}
   * @description Return the id of an anchor based on a target length.
   */
  function getIdByLength(path, target) {

    var total = path._length;

    if (target <= 0) {
      return 0;
    } else if (target >= total) {
      return path._lengths.length - 1;
    }

    for (var i = 0, sum = 0; i < path._lengths.length; i++) {

      if (sum + path._lengths[i] >= target) {
        target -= sum;
        return Math.max(i - 1, 0) + target / path._lengths[i];
      }

      sum += path._lengths[i];

    }

    return - 1;

  }

  function getCurveLength(a, b, limit) {
    // TODO: DRYness
    var x1, x2, x3, x4, y1, y2, y3, y4;

    var right = b.controls && b.controls.right;
    var left = a.controls && a.controls.left;

    x1 = b.x;
    y1 = b.y;
    x2 = (right || b).x;
    y2 = (right || b).y;
    x3 = (left || a).x;
    y3 = (left || a).y;
    x4 = a.x;
    y4 = a.y;

    if (right && b._relative) {
      x2 += b.x;
      y2 += b.y;
    }

    if (left && a._relative) {
      x3 += a.x;
      y3 += a.y;
    }

    return Two.Utils.getCurveLength(x1, y1, x2, y2, x3, y3, x4, y4, limit);

  }

  function getSubdivisions(a, b, limit) {
    // TODO: DRYness
    var x1, x2, x3, x4, y1, y2, y3, y4;

    var right = b.controls && b.controls.right;
    var left = a.controls && a.controls.left;

    x1 = b.x;
    y1 = b.y;
    x2 = (right || b).x;
    y2 = (right || b).y;
    x3 = (left || a).x;
    y3 = (left || a).y;
    x4 = a.x;
    y4 = a.y;

    if (right && b._relative) {
      x2 += b.x;
      y2 += b.y;
    }

    if (left && a._relative) {
      x3 += a.x;
      y3 += a.y;
    }

    return Two.Utils.subdivide(x1, y1, x2, y2, x3, y3, x4, y4, limit);

  }

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var Path = Two.Path;
  var _ = Two.Utils;

  /**
   * @name Two.Line
   * @class
   * @extends Two.Path
   * @param {Number} [x1=0] - The x position of the first vertex on the line.
   * @param {Number} [y1=0] - The y position of the first vertex on the line.
   * @param {Number} [x2=0] - The x position of the second vertex on the line.
   * @param {Number} [y2=0] - The y position of the second vertex on the line.
   */
  var Line = Two.Line = function(x1, y1, x2, y2) {

    var width = x2 - x1;
    var height = y2 - y1;

    var w2 = width / 2;
    var h2 = height / 2;

    Path.call(this, [
        new Two.Anchor(x1, y1),
        new Two.Anchor(x2, y2)
    ]);

    this.vertices[0].command = Two.Commands.move;
    this.vertices[1].command = Two.Commands.line;

    this.automatic = false;

  };

  _.extend(Line.prototype, Path.prototype);
  Line.prototype.constructor = Line;

  Path.MakeObservable(Line.prototype);

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var Path = Two.Path;
  var _ = Two.Utils;

  /**
   * @name Two.Rectangle
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the rectangle.
   * @param {Number} [y=0] - The y position of the rectangle.
   * @param {Number} width - The width value of the rectangle.
   * @param {Number} height - The width value of the rectangle.
   */
  var Rectangle = Two.Rectangle = function(x, y, width, height) {

    Path.call(this, [
      new Two.Anchor(),
      new Two.Anchor(),
      new Two.Anchor(),
      new Two.Anchor()
      // new Two.Anchor() // TODO: Figure out how to handle this for `beginning` / `ending` animations
    ], true, false, true);

    /**
     * @name Two.Rectangle#width
     * @property {Number} - The size of the width of the rectangle.
     */
    this.width = width;
    /**
     * @name Two.Rectangle#height
     * @property {Number} - The size of the height of the rectangle.
     */
    this.height = height;

    /**
     * @name Two.Rectangle#origin
     * @property {Number} - A two-component vector describing the origin offset to draw the rectangle. Default is `0, 0`.
     */
    this.origin = new Two.Vector();
    this.translation.set(x, y);

    this._update();

  };

  _.extend(Rectangle, {

    /**
     * @name Two.Rectangle.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Rectangle}.
     */
    Properties: ['width', 'height'],

    /**
     * @name Two.Rectangle.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Rectangle} to any object. Handy if you'd like to extend the {@link Two.Rectangle} class on a custom class.
     */
    MakeObservable: function(object) {

      Path.MakeObservable(object);
      _.each(Rectangle.Properties, Two.Utils.defineProperty, object);

      Object.defineProperty(object, 'origin', {
        enumerable: true,
        get: function() {
          return this._origin;
        },
        set: function(v) {
          if (this._origin) {
            this._origin.unbind(Two.Events.change, this._renderer.flagVertices);
          }
          this._origin = v;
          this._origin.bind(Two.Events.change, this._renderer.flagVertices);
          this._renderer.flagVertices();
        }
      });

    }

  });

  _.extend(Rectangle.prototype, Path.prototype, {

    /**
     * @name Two.Rectangle#_flagWidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Rectangle#width} needs updating.
     */
    _flagWidth: 0,
    /**
     * @name Two.Rectangle#_flagHeight
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Rectangle#height} needs updating.
     */
    _flagHeight: 0,

    /**
     * @name Two.Rectangle#_width
     * @private
     * @see {@link Two.Rectangle#width}
     */
    _width: 0,
    /**
     * @name Two.Rectangle#_height
     * @private
     * @see {@link Two.Rectangle#height}
     */
    _height: 0,

    _origin: null,

    constructor: Rectangle,

    /**
     * @name Two.Rectangle#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagWidth || this._flagHeight) {

        var xr = this._width / 2;
        var yr = this._height / 2;

        this.vertices[0].set(-xr, -yr).add(this._origin).command = Two.Commands.move;
        this.vertices[1].set(xr, -yr).add(this._origin).command = Two.Commands.line;
        this.vertices[2].set(xr, yr).add(this._origin).command = Two.Commands.line;
        this.vertices[3].set(-xr, yr).add(this._origin).command = Two.Commands.line;
        // FYI: Two.Sprite and Two.ImageSequence have 4 verts
        if (this.vertices[4]) {
          this.vertices[4].set(-xr, -yr).add(this._origin).command = Two.Commands.line;
        }

      }

      Path.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.Rectangle#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagWidth = this._flagHeight = false;
      Path.prototype.flagReset.call(this);

      return this;

    },

    /**
     * @name Two.Rectangle#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Rectangle}
     * @description Create a new instance of {@link Two.Rectangle} with the same properties of the current path.
     */
    clone: function(parent) {

      var clone = new Rectangle(0, 0, this.width, this.height);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Two.Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Rectangle#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);
      object.width = this.width;
      object.height = this.height;
      object.origin = this.origin.toObject();
      return object;

    }

  });

  Rectangle.MakeObservable(Rectangle.prototype);

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var Path = Two.Path, TWO_PI = Math.PI * 2, HALF_PI = Math.PI / 2;
  var cos = Math.cos, sin = Math.sin;
  var _ = Two.Utils;

  /**
   * @name Two.Ellipse
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the ellipse.
   * @param {Number} [y=0] - The y position of the ellipse.
   * @param {Number} rx - The radius value of the ellipse in the x direction.
   * @param {Number} ry - The radius value of the ellipse in the y direction.
   * @param {Number} [resolution=4] - The number of vertices used to construct the ellipse.
   */
  var Ellipse = Two.Ellipse = function(ox, oy, rx, ry, resolution) {

    if (!_.isNumber(ry)) {
      ry = rx;
    }

    // At least 2 vertices are required for proper circlage
    var amount = resolution ? Math.max(resolution, 2) : 4;

    var points = _.map(_.range(amount), function(i) {
      return new Two.Anchor();
    }, this);

    Path.call(this, points, true, true, true);

    /**
     * @name Two.Ellipse#width
     * @property {Number} - The width of the ellipse.
     */
    this.width = rx * 2;
    /**
     * @name Two.Ellipse#height
     * @property {Number} - The height of the ellipse.
     */
    this.height = ry * 2;

    this._update();
    this.translation.set(ox, oy);

  };

  _.extend(Ellipse, {

    /**
     * @name Two.Ellipse.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Ellipse}.
     */
    Properties: ['width', 'height'],

    /**
     * @name Two.Ellipse.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Ellipse} to any object. Handy if you'd like to extend the {@link Two.Ellipse} class on a custom class.
     */
    MakeObservable: function(obj) {

      Path.MakeObservable(obj);
      _.each(Ellipse.Properties, Two.Utils.defineProperty, obj);

    }

  });

  _.extend(Ellipse.prototype, Path.prototype, {

    /**
     * @name Two.Ellipse#_flagWidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Ellipse#width} needs updating.
     */
    _flagWidth: false,
    /**
     * @name Two.Ellipse#_flagHeight
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Ellipse#height} needs updating.
     */
    _flagHeight: false,

    /**
     * @name Two.Polygon#_width
     * @private
     * @see {@link Two.Ellipse#width}
     */
    _width: 0,
    /**
     * @name Two.Polygon#_height
     * @private
     * @see {@link Two.Ellipse#height}
     */
    _height: 0,

    constructor: Ellipse,

    /**
     * @name Two.Ellipse#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagWidth || this._flagHeight) {
        // Coefficient for approximating circular arcs with Bezier curves
        var c = (4 / 3) * Math.tan(Math.PI / (this.vertices.length * 2));
        var radiusX = this._width / 2;
        var radiusY = this._height / 2;

        for (var i = 0, numVertices = this.vertices.length; i < numVertices; i++) {
          var pct = i / numVertices;
          var theta = pct * TWO_PI;

          var x = radiusX * cos(theta);
          var y = radiusY * sin(theta);

          var lx = radiusX * c * cos(theta - HALF_PI);
          var ly = radiusY * c * sin(theta - HALF_PI);

          var rx = radiusX * c * cos(theta + HALF_PI);
          var ry = radiusY * c * sin(theta + HALF_PI);

          var v = this.vertices[i];

          v.command = Two.Commands.curve;
          v.set(x, y);
          v.controls.left.set(lx, ly);
          v.controls.right.set(rx, ry);
        }
      }

      Path.prototype._update.call(this);
      return this;

    },

    /**
     * @name Two.Ellipse#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagWidth = this._flagHeight = false;

      Path.prototype.flagReset.call(this);
      return this;

    },

    /**
     * @name Two.Ellipse#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Polygon}
     * @description Create a new instance of {@link Two.Polygon} with the same properties of the current path.
     */
    clone: function(parent) {

      var rx = this.width / 2;
      var ry = this.height / 2;
      var resolution = this.vertices.length;
      var clone = new Ellipse(0, 0, rx, ry, resolution);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Two.Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Ellipse#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(Ellipse.Properties, function(property) {
        object[property] = this[property];
      }, this);

      return object;

    }

  });

  Ellipse.MakeObservable(Ellipse.prototype);

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var Path = Two.Path, TWO_PI = Math.PI * 2, HALF_PI = Math.PI / 2;
  var cos = Math.cos, sin = Math.sin;
  var _ = Two.Utils;

  /**
   * @name Two.Circle
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the circle.
   * @param {Number} [y=0] - The y position of the circle.
   * @param {Number} radius - The radius value of the circle.
   * @param {Number} [resolution=4] - The number of vertices used to construct the circle.
   */
  var Circle = Two.Circle = function(ox, oy, r, resolution) {

    // At least 2 vertices are required for proper circlage
    var amount = resolution ? Math.max(resolution, 2) : 4;

    var points = _.map(_.range(amount), function(i) {
      return new Two.Anchor();
    }, this);

    Path.call(this, points, true, true, true);

    /**
     * @name Two.Circle#radius
     * @property {Number} - The size of the radius of the circle.
     */
    this.radius = r;

    this._update();

    if (_.isNumber(ox)) {
      this.translation.x = ox;
    }
    if (_.isNumber(oy)) {
      this.translation.y = oy;
    }

  };

  _.extend(Circle, {

    /**
     * @name Two.Circle.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Circle}.
     */
    Properties: ['radius'],

    /**
     * @name Two.Circle.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Circle} to any object. Handy if you'd like to extend the {@link Two.Circle} class on a custom class.
     */
    MakeObservable: function(obj) {

      Path.MakeObservable(obj);
      _.each(Circle.Properties, Two.Utils.defineProperty, obj);

    }

  });

  _.extend(Circle.prototype, Path.prototype, {

    /**
     * @name Two.Circle#_flagRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Circle#radius} needs updating.
     */
    _flagRadius: false,

    /**
     * @name Two.Circle#_radius
     * @private
     * @see {@link Two.Circle#radius}
     */
    _radius: 0,

    constructor: Circle,

    /**
     * @name Two.Circle#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagRadius) {
        // Coefficient for approximating circular arcs with Bezier curves
        var c = (4 / 3) * Math.tan(Math.PI / (this.vertices.length * 2));

        var radius = this._radius;
        var rc = radius * c;

        for (var i = 0, numVertices = this.vertices.length; i < numVertices; i++) {
          var pct = i / numVertices;
          var theta = pct * TWO_PI;

          var x = radius * cos(theta);
          var y = radius * sin(theta);

          var lx = rc * cos(theta - HALF_PI);
          var ly = rc * sin(theta - HALF_PI);

          var rx = rc * cos(theta + HALF_PI);
          var ry = rc * sin(theta + HALF_PI);

          var v = this.vertices[i];

          v.command = Two.Commands.curve;
          v.set(x, y);
          v.controls.left.set(lx, ly);
          v.controls.right.set(rx, ry);
        }
      }

      Path.prototype._update.call(this);
      return this;

    },

    /**
     * @name Two.Circle#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagRadius = false;

      Path.prototype.flagReset.call(this);
      return this;

    },

    /**
     * @name Two.Circle#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Circle}
     * @description Create a new instance of {@link Two.Circle} with the same properties of the current path.
     */
    clone: function(parent) {

      var clone = new Circle(0, 0, this.radius, this.vertices.length);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Two.Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Circle#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(Circle.Properties, function(property) {
        object[property] = this[property];
      }, this);

      return object;

    }

  });

  Circle.MakeObservable(Circle.prototype);

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var Path = Two.Path, TWO_PI = Math.PI * 2, cos = Math.cos, sin = Math.sin;
  var _ = Two.Utils;

  /**
   * @name Two.Polygon
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the polygon.
   * @param {Number} [y=0] - The y position of the polygon.
   * @param {Number} radius - The radius value of the polygon.
   * @param {Number} [sides=12] - The number of vertices used to construct the polygon.
   */
  var Polygon = Two.Polygon = function(ox, oy, r, sides) {

    sides = Math.max(sides || 0, 3);

    Path.call(this);

    this.closed = true;
    this.automatic = false;

    /**
     * @name Two.Polygon#width
     * @property {Number} - The size of the width of the polygon.
     */
    this.width = r * 2;
    /**
     * @name Two.Polygon#height
     * @property {Number} - The size of the height of the polygon.
     */
    this.height = r * 2;
    /**
     * @name Two.Polygon#sides
     * @property {Number} - The amount of sides the polyogn has.
     */
    this.sides = sides;

    this._update();
    this.translation.set(ox, oy);

  };

  _.extend(Polygon, {

    /**
     * @name Two.Polygon.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Polygon}.
     */
    Properties: ['width', 'height', 'sides'],

    /**
     * @name Two.Polygon.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Polygon} to any object. Handy if you'd like to extend the {@link Two.Polygon} class on a custom class.
     */
    MakeObservable: function(obj) {

      Path.MakeObservable(obj);
      _.each(Polygon.Properties, Two.Utils.defineProperty, obj);

    }

  });

  _.extend(Polygon.prototype, Path.prototype, {

    /**
     * @name Two.Polygon#_flagWidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Polygon#width} needs updating.
     */
    _flagWidth: false,
    /**
     * @name Two.Polygon#_flagHeight
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Polygon#height} needs updating.
     */
    _flagHeight: false,
    /**
     * @name Two.Polygon#_flagSides
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Polygon#sides} needs updating.
     */
    _flagSides: false,

    /**
     * @name Two.Polygon#_width
     * @private
     * @see {@link Two.Polygon#width}
     */
    _width: 0,
    /**
     * @name Two.Polygon#_height
     * @private
     * @see {@link Two.Polygon#height}
     */
    _height: 0,
    /**
     * @name Two.Polygon#_sides
     * @private
     * @see {@link Two.Polygon#sides}
     */
    _sides: 0,

    constructor: Polygon,

    /**
     * @name Two.Polygon#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagWidth || this._flagHeight || this._flagSides) {

        var sides = this._sides;
        var amount = sides + 1;
        var length = this.vertices.length;

        if (length > sides) {
          this.vertices.splice(sides - 1, length - sides);
          length = sides;
        }

        for (var i = 0; i < amount; i++) {

          var pct = (i + 0.5) / sides;
          var theta = TWO_PI * pct + Math.PI / 2;
          var x = this._width * cos(theta) / 2;
          var y = this._height * sin(theta) / 2;

          if (i >= length) {
            this.vertices.push(new Two.Anchor(x, y));
          } else {
            this.vertices[i].set(x, y);
          }

          this.vertices[i].command = i === 0
            ? Two.Commands.move : Two.Commands.line;

        }

      }

      Path.prototype._update.call(this);
      return this;

    },

    /**
     * @name Two.Polygon#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagWidth = this._flagHeight = this._flagSides = false;
      Path.prototype.flagReset.call(this);

      return this;

    },

    /**
     * @name Two.Polygon#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Polygon}
     * @description Create a new instance of {@link Two.Polygon} with the same properties of the current path.
     */
    clone: function(parent) {

      var clone = new Polygon(0, 0, this.radius, this.sides);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Two.Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Polygon#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(Polygon.Properties, function(property) {
        object[property] = this[property];
      }, this);

      return object;

    }

  });

  Polygon.MakeObservable(Polygon.prototype);

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var Path = Two.Path, PI = Math.PI, TWO_PI = Math.PI * 2, HALF_PI = Math.PI / 2,
    cos = Math.cos, sin = Math.sin, abs = Math.abs, _ = Two.Utils,
    mod = Two.Utils.mod;

  /**
   * @name Two.ArcSegment
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the arc segment.
   * @param {Number} [y=0] - The y position of the arc segment.
   * @param {Number} innerRadius - The inner radius value of the arc segment.
   * @param {Number} outerRadius - The outer radius value of the arc segment.
   * @param {Radians} startAngle - The start angle of the arc segment in radians.
   * @param {Radians} endAngle - The end angle of the arc segment in radians.
   * @param {Number} [resolution=24] - The number of vertices used to construct the arc segment.
   */
  var ArcSegment = Two.ArcSegment = function(ox, oy, ir, or, sa, ea, res) {

    var amount = res || (Two.Resolution * 3);
    var points = _.map(_.range(amount), function() {
      return new Two.Anchor();
    });

    Path.call(this, points, true, false, true);

    /**
     * @name Two.ArcSegment#innerRadius
     * @property {Number} - The size of the inner radius of the arc segment.
     */
    this.innerRadius = ir;
    /**
     * @name Two.ArcSegment#outerRadius
     * @property {Number} - The size of the outer radius of the arc segment.
     */
    this.outerRadius = or;

    /**
     * @name Two.ArcSegment#startRadius
     * @property {Radians} - The angle of one side for the arc segment.
     */
    this.startAngle = sa;
    /**
     * @name Two.ArcSegment#endAngle
     * @property {Radians} - The angle of the other side for the arc segment.
     */
    this.endAngle = ea;

    this._update();

    if (_.isNumber(ox)) {
      this.translation.x = ox;
    }
    if (_.isNumber(oy)) {
      this.translation.y = oy;
    }

  };

  _.extend(ArcSegment, {

    /**
     * @name Two.ArcSegment.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.ArcSegment}.
     */
    Properties: ['startAngle', 'endAngle', 'innerRadius', 'outerRadius'],

    /**
     * @name Two.ArcSegment.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.ArcSegment} to any object. Handy if you'd like to extend the {@link Two.ArcSegment} class on a custom class.
     */
    MakeObservable: function(obj) {

      Path.MakeObservable(obj);
      _.each(ArcSegment.Properties, Two.Utils.defineProperty, obj);

    }

  });

  _.extend(ArcSegment.prototype, Path.prototype, {

    /**
     * @name Two.ArcSegment#_flagStartAngle
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ArcSegment#startAngle} needs updating.
     */
    _flagStartAngle: false,
    /**
     * @name Two.ArcSegment#_flagEndAngle
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ArcSegment#endAngle} needs updating.
     */
    _flagEndAngle: false,
    /**
     * @name Two.ArcSegment#_flagInnerRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ArcSegment#innerRadius} needs updating.
     */
    _flagInnerRadius: false,
    /**
     * @name Two.ArcSegment#_flagOuterRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ArcSegment#outerRadius} needs updating.
     */
    _flagOuterRadius: false,

    /**
     * @name Two.ArcSegment#_startAngle
     * @private
     * @see {@link Two.ArcSegment#startAngle}
     */
    _startAngle: 0,
    /**
     * @name Two.ArcSegment#_endAngle
     * @private
     * @see {@link Two.ArcSegment#endAngle}
     */
    _endAngle: TWO_PI,
    /**
     * @name Two.ArcSegment#_innerRadius
     * @private
     * @see {@link Two.ArcSegment#innerRadius}
     */
    _innerRadius: 0,
    /**
     * @name Two.ArcSegment#_outerRadius
     * @private
     * @see {@link Two.ArcSegment#outerRadius}
     */
    _outerRadius: 0,

    constructor: ArcSegment,

    /**
     * @name Two.ArcSegment#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagStartAngle || this._flagEndAngle || this._flagInnerRadius
        || this._flagOuterRadius) {

        var sa = this._startAngle;
        var ea = this._endAngle;

        var ir = this._innerRadius;
        var or = this._outerRadius;

        var connected = mod(sa, TWO_PI) === mod(ea, TWO_PI);
        var punctured = ir > 0;

        var vertices = this.vertices;
        var length = (punctured ? vertices.length / 2 : vertices.length);
        var command, id = 0;

        if (connected) {
          length--;
        } else if (!punctured) {
          length -= 2;
        }

        /**
         * Outer Circle
         */
        for (var i = 0, last = length - 1; i < length; i++) {

          var pct = i / last;
          var v = vertices[id];
          var theta = pct * (ea - sa) + sa;
          var step = (ea - sa) / length;

          var x = or * Math.cos(theta);
          var y = or * Math.sin(theta);

          switch (i) {
            case 0:
              command = Two.Commands.move;
              break;
            default:
              command = Two.Commands.curve;
          }

          v.command = command;
          v.x = x;
          v.y = y;
          v.controls.left.clear();
          v.controls.right.clear();

          if (v.command === Two.Commands.curve) {
            var amp = or * step / Math.PI;
            v.controls.left.x = amp * Math.cos(theta - HALF_PI);
            v.controls.left.y = amp * Math.sin(theta - HALF_PI);
            v.controls.right.x = amp * Math.cos(theta + HALF_PI);
            v.controls.right.y = amp * Math.sin(theta + HALF_PI);
            if (i === 1) {
              v.controls.left.multiplyScalar(2);
            }
            if (i === last) {
              v.controls.right.multiplyScalar(2);
            }
          }

          id++;

        }

        if (punctured) {

          if (connected) {
            vertices[id].command = Two.Commands.close;
            id++;
          } else {
            length--;
            last = length - 1;
          }

          /**
           * Inner Circle
           */
          for (i = 0; i < length; i++) {

            pct = i / last;
            v = vertices[id];
            theta = (1 - pct) * (ea - sa) + sa;
            step = (ea - sa) / length;

            x = ir * Math.cos(theta);
            y = ir * Math.sin(theta);
            command = Two.Commands.curve;
            if (i <= 0) {
              command = connected ? Two.Commands.move : Two.Commands.line;
            }

            v.command = command;
            v.x = x;
            v.y = y;
            v.controls.left.clear();
            v.controls.right.clear();

            if (v.command === Two.Commands.curve) {
              amp = ir * step / Math.PI;
              v.controls.left.x = amp * Math.cos(theta + HALF_PI);
              v.controls.left.y = amp * Math.sin(theta + HALF_PI);
              v.controls.right.x = amp * Math.cos(theta - HALF_PI);
              v.controls.right.y = amp * Math.sin(theta - HALF_PI);
              if (i === 1) {
                v.controls.left.multiplyScalar(2);
              }
              if (i === last) {
                v.controls.right.multiplyScalar(2);
              }
            }

            id++;

          }

          // Final Point
          vertices[id].copy(vertices[0]);
          vertices[id].command = Two.Commands.line;

        } else if (!connected) {

          vertices[id].command = Two.Commands.line;
          vertices[id].x = 0;
          vertices[id].y = 0;
          id++;

          // Final Point
          vertices[id].copy(vertices[0]);
          vertices[id].command = Two.Commands.line;

        }

      }

      Path.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.ArcSegment#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      Path.prototype.flagReset.call(this);

      this._flagStartAngle = this._flagEndAngle
        = this._flagInnerRadius = this._flagOuterRadius = false;

      return this;

    },

    /**
     * @name Two.ArcSegment#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.ArcSegment}
     * @description Create a new instance of {@link Two.ArcSegment} with the same properties of the current path.
     */
    clone: function(parent) {

      var ir = this.innerRadius;
      var or = this.outerradius;
      var sa = this.startAngle;
      var ea = this.endAngle;
      var resolution = this.vertices.length;

      var clone = new ArcSegment(0, 0, ir, or, sa, ea, resolution);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Two.Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.ArcSegment#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(ArcSegment.Properties, function(property) {
        object[property] = this[property];
      }, this);

      return object;

    }

  });

  ArcSegment.MakeObservable(ArcSegment.prototype);

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var Path = Two.Path, TWO_PI = Math.PI * 2, cos = Math.cos, sin = Math.sin;
  var _ = Two.Utils;

  /**
   * @name Two.Star
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the star.
   * @param {Number} [y=0] - The y position of the star.
   * @param {Number} innerRadius - The inner radius value of the star.
   * @param {Number} outerRadius - The outer radius value of the star.
   * @param {Number} [sides=5] - The number of sides used to construct the star.
   */
  var Star = Two.Star = function(ox, oy, ir, or, sides) {

    if (arguments.length <= 3) {
      or = ir;
      ir = or / 2;
    }

    if (!_.isNumber(sides) || sides <= 0) {
      sides = 5;
    }

    var length = sides * 2;

    Path.call(this);
    this.closed = true;
    this.automatic = false;

    /**
     * @name Two.Star#innerRadius
     * @property {Number} - The size of the inner radius of the star.
     */
    this.innerRadius = ir;
    /**
     * @name Two.Star#outerRadius
     * @property {Number} - The size of the outer radius of the star.
     */
    this.outerRadius = or;
    /**
     * @name Two.Star#sides
     * @property {Number} - The amount of sides the star has.
     */
    this.sides = sides;

    this._update();
    this.translation.set(ox, oy);

  };

  _.extend(Star, {

    /**
     * @name Two.Star.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Star}.
     */
    Properties: ['innerRadius', 'outerRadius', 'sides'],

    /**
     * @name Two.Star.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Star} to any object. Handy if you'd like to extend the {@link Two.Star} class on a custom class.
     */
    MakeObservable: function(obj) {

      Path.MakeObservable(obj);
      _.each(Star.Properties, Two.Utils.defineProperty, obj);

    }

  });

  _.extend(Star.prototype, Path.prototype, {

    /**
     * @name Two.Star#_flagInnerRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Star#innerRadius} needs updating.
     */
    _flagInnerRadius: false,
    /**
     * @name Two.Star#_flagOuterRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Star#outerRadius} needs updating.
     */
    _flagOuterRadius: false,
    /**
     * @name Two.Star#_flagSides
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Star#sides} needs updating.
     */
    _flagSides: false,

    /**
     * @name Two.Star#_innerRadius
     * @private
     * @see {@link Two.Star#innerRadius}
     */
    _innerRadius: 0,
    /**
     * @name Two.Star#_outerRadius
     * @private
     * @see {@link Two.Star#outerRadius}
     */
    _outerRadius: 0,
    /**
     * @name Two.Star#_sides
     * @private
     * @see {@link Two.Star#sides}
     */
    _sides: 0,

    constructor: Star,

    /**
     * @name Two.Star#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagInnerRadius || this._flagOuterRadius || this._flagSides) {

        var sides = this._sides * 2;
        var amount = sides + 1;
        var length = this.vertices.length;

        if (length > sides) {
          this.vertices.splice(sides - 1, length - sides);
          length = sides;
        }

        for (var i = 0; i < amount; i++) {

          var pct = (i + 0.5) / sides;
          var theta = TWO_PI * pct;
          var r = (!(i % 2) ? this._innerRadius : this._outerRadius) / 2;
          var x = r * cos(theta);
          var y = r * sin(theta);

          if (i >= length) {
            this.vertices.push(new Two.Anchor(x, y));
          } else {
            this.vertices[i].set(x, y);
          }

          this.vertices[i].command = i === 0
            ? Two.Commands.move : Two.Commands.line;

        }

      }

      Path.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.Star#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagInnerRadius = this._flagOuterRadius = this._flagSides = false;
      Path.prototype.flagReset.call(this);

      return this;

    },

    /**
     * @name Two.Star#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Star}
     * @description Create a new instance of {@link Two.Star} with the same properties of the current path.
     */
    clone: function(parent) {

      var ir = this.innerRadius;
      var or = this.outerRadius;
      var sides = this.sides;

      var clone = new Star(0, 0, ir, or, sides);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Two.Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Star#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(Star.Properties, function(property) {
        object[property] = this[property];
      }, this);

      return object;

    }

  });

  Star.MakeObservable(Star.prototype);

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var Path = Two.Path;
  var _ = Two.Utils;

  /**
   * @name Two.RoundedRectangle
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the rounded rectangle.
   * @param {Number} [y=0] - The y position of the rounded rectangle.
   * @param {Number} width - The width value of the rounded rectangle.
   * @param {Number} height - The width value of the rounded rectangle.
   * @param {Number} radius - The radius value of the rounded rectangle.
   * @param {Number} [resolution=12] - The number of vertices used to construct the rounded rectangle.
   */
  var RoundedRectangle = Two.RoundedRectangle = function(ox, oy, width, height, radius) {

    if (_.isUndefined(radius)) {
      radius = Math.floor(Math.min(width, height) / 12);
    }

    var amount = 10;

    var points = _.map(_.range(amount), function(i) {
      return new Two.Anchor(0, 0, 0, 0, 0, 0,
        i === 0 ? Two.Commands.move : Two.Commands.curve);
    });

    // points[points.length - 1].command = Two.Commands.close;

    Path.call(this, points);

    this.closed = true;
    this.automatic = false;

    this._renderer.flagRadius = _.bind(RoundedRectangle.FlagRadius, this);

    /**
     * @name Two.RoundedRectangle#width
     * @property {Number} - The width of the rounded rectangle.
     */
    this.width = width;
    /**
     * @name Two.RoundedRectangle#height
     * @property {Number} - The height of the rounded rectangle.
     */
    this.height = height;
    /**
     * @name Two.RoundedRectangle#radius
     * @property {Number} - The size of the radius of the rounded rectangle.
     */
    this.radius = radius;

    this._update();
    this.translation.set(ox, oy);

  };

  _.extend(RoundedRectangle, {

    /**
     * @name Two.RoundedRectangle.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.RoundedRectangle}.
     */
    Properties: ['width', 'height'],

    /**
     * @name Two.RoundedRectangle.FlagRadius
     * @property {Function} - A convenience function to trigger the flag for radius changing.
     */
    FlagRadius: function() {
      this._flagRadius = true;
    },

    /**
     * @name Two.RoundedRectangle.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.RoundedRectangle} to any object. Handy if you'd like to extend the {@link Two.RoundedRectangle} class on a custom class.
     */
    MakeObservable: function(object) {

      Path.MakeObservable(object);
      _.each(RoundedRectangle.Properties, Two.Utils.defineProperty, object);

      Object.defineProperty(object, 'radius', {
        enumerable: true,
        get: function() {
          return this._radius;
        },
        set: function(v) {

          if (this._radius instanceof Two.Vector) {
            this._radius.unbind(Two.Events.change, this._renderer.flagRadius);
          }

          this._radius = v;

          if (this._radius instanceof Two.Vector) {
            this._radius.bind(Two.Events.change, this._renderer.flagRadius);
          }

          this._flagRadius = true;

        }
      });

    }

  });

  _.extend(RoundedRectangle.prototype, Path.prototype, {

    /**
     * @name Two.RoundedRectangle#_flagWidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RoundedRectangle#width} needs updating.
     */
    _flagWidth: false,
    /**
     * @name Two.RoundedRectangle#_flagHeight
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RoundedRectangle#height} needs updating.
     */
    _flagHeight: false,
    /**
     * @name Two.RoundedRectangle#_flagRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RoundedRectangle#radius} needs updating.
     */
    _flagRadius: false,

    /**
     * @name Two.RoundedRectangle#_width
     * @private
     * @see {@link Two.RoundedRectangle#width}
     */
    _width: 0,
    /**
     * @name Two.RoundedRectangle#_height
     * @private
     * @see {@link Two.RoundedRectangle#height}
     */
    _height: 0,
    /**
     * @name Two.RoundedRectangle#_radius
     * @private
     * @see {@link Two.RoundedRectangle#radius}
     */
    _radius: 0,

    constructor: RoundedRectangle,

    /**
     * @name Two.RoundedRectangle#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagWidth || this._flagHeight || this._flagRadius) {

        var width = this._width;
        var height = this._height;

        var rx, ry;

        if (this._radius instanceof Two.Vector) {
          rx = this._radius.x;
          ry = this._radius.y;
        } else {
          rx = this._radius;
          ry = this._radius;
        }

        var v;
        var w = width / 2;
        var h = height / 2;

        v = this.vertices[0];
        v.x = - (w - rx);
        v.y = - h;

        // Upper Right Corner

        v = this.vertices[1];
        v.x = (w - rx);
        v.y = - h;
        v.controls.left.clear();
        v.controls.right.x = rx;
        v.controls.right.y = 0;

        v = this.vertices[2];
        v.x = w;
        v.y = - (h - ry);
        v.controls.right.clear();
        v.controls.left.clear();

        // Bottom Right Corner

        v = this.vertices[3];
        v.x = w;
        v.y = (h - ry);
        v.controls.left.clear();
        v.controls.right.x = 0;
        v.controls.right.y = ry;

        v = this.vertices[4];
        v.x = (w - rx);
        v.y = h;
        v.controls.right.clear();
        v.controls.left.clear();

        // Bottom Left Corner

        v = this.vertices[5];
        v.x = - (w - rx);
        v.y = h;
        v.controls.left.clear();
        v.controls.right.x = - rx;
        v.controls.right.y = 0;

        v = this.vertices[6];
        v.x = - w;
        v.y = (h - ry);
        v.controls.left.clear();
        v.controls.right.clear();

        // Upper Left Corner

        v = this.vertices[7];
        v.x = - w;
        v.y = - (h - ry);
        v.controls.left.clear();
        v.controls.right.x = 0;
        v.controls.right.y = - ry;

        v = this.vertices[8];
        v.x = - (w - rx);
        v.y = - h;
        v.controls.left.clear();
        v.controls.right.clear();

        v = this.vertices[9];
        v.copy(this.vertices[8]);

      }

      Path.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.RoundedRectangle#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagWidth = this._flagHeight = this._flagRadius = false;
      Path.prototype.flagReset.call(this);

      return this;

    },

    /**
     * @name Two.RoundedRectangle#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.RoundedRectangle}
     * @description Create a new instance of {@link Two.RoundedRectangle} with the same properties of the current path.
     */
    clone: function(parent) {

      var width = this.width;
      var height = this.height;
      var radius = this.radius;

      var clone = new RoundedRectangle(0, 0, width, height, radius);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Two.Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.RoundedRectangle#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(RoundedRectangle.Properties, function(property) {
        object[property] = this[property];
      }, this);

      object.radius = _.isNumber(this.radius)
        ? this.radius : this.radius.toObject();

      return object;

    }

  });

  RoundedRectangle.MakeObservable(RoundedRectangle.prototype);

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var root = Two.root;
  var getComputedMatrix = Two.Utils.getComputedMatrix;
  var _ = Two.Utils;

  // Used with getBoundingClientRect was calculated through the ctx.getTextWidth
  // var canvas = getCanvas();
  // var ctx = canvas.getContext('2d');

  /**
   * @name Two.Text
   * @class
   * @extends Two.Shape
   * @param {String} message - The String to be rendered to the scene.
   * @param {Number} [x=0] - The position in the x direction for the object.
   * @param {Number} [y=0] - The position in the y direction for the object.
   * @param {Object} [styles] - An object where styles are applied. Attribute must exist in Two.Text.Properties.
   * @description This is a primitive class for creating drawable text that can be added to the scenegraph.
   */
  var Text = Two.Text = function(message, x, y, styles) {

    Two.Shape.call(this);

    this._renderer.type = 'text';
    this._renderer.flagFill = _.bind(Two.Text.FlagFill, this);
    this._renderer.flagStroke = _.bind(Two.Text.FlagStroke, this);

    this.value = message;

    if (_.isNumber(x)) {
        this.translation.x = x;
    }
    if (_.isNumber(y)) {
        this.translation.y = y;
    }

    /**
     * @name Two.Text#dashes
     * @property {Number[]} - Array of numbers. Odd indices represent dash length. Even indices represent dash space.
     * @description A list of numbers that represent the repeated dash length and dash space applied to the stroke of the text.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray} for more information on the SVG stroke-dasharray attribute.
     */
    this.dashes = [];

    /**
     * @name Two.Text#dashes#offset
     * @property {Number} - A number in pixels to offset {@link Two.Text#dashes} display.
     */
    this.dashes.offset = 0;

    if (!_.isObject(styles)) {
      return this;
    }

    _.each(Two.Text.Properties, function(property) {

      if (property in styles) {
        this[property] = styles[property];
      }

    }, this);

  };

  _.extend(Two.Text, {

    /**
     * @name Two.Text.Ratio
     * @property {Number} - Approximate aspect ratio of a typeface's character width to height.
     */
    Ratio: 0.6,

    /**
     * @name Two.Text.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Text}.
     */
    Properties: [
      'value', 'family', 'size', 'leading', 'alignment', 'linewidth', 'style',
      'className', 'weight', 'decoration', 'baseline', 'opacity', 'visible',
      'fill', 'stroke',
    ],

    /**
     * @name Two.Text.FlagFill
     * @function
     * @description Cached method to let renderers know the fill property have been updated on a {@link Two.Text}.
     */
    FlagFill: function() {
      this._flagFill = true;
    },

    /**
     * @name Two.Text.FlagStroke
     * @function
     * @description Cached method to let renderers know the stroke property have been updated on a {@link Two.Text}.
     */
    FlagStroke: function() {
      this._flagStroke = true;
    },

    MakeObservable: function(object) {

      Two.Shape.MakeObservable(object);

      _.each(Two.Text.Properties.slice(0, 13), Two.Utils.defineProperty, object);

      Object.defineProperty(object, 'fill', {
        enumerable: true,
        get: function() {
          return this._fill;
        },
        set: function(f) {

          if (this._fill instanceof Two.Gradient
            || this._fill instanceof Two.LinearGradient
            || this._fill instanceof Two.RadialGradient
            || this._fill instanceof Two.Texture) {
            this._fill.unbind(Two.Events.change, this._renderer.flagFill);
          }

          this._fill = f;
          this._flagFill = true;

          if (this._fill instanceof Two.Gradient
            || this._fill instanceof Two.LinearGradient
            || this._fill instanceof Two.RadialGradient
            || this._fill instanceof Two.Texture) {
            this._fill.bind(Two.Events.change, this._renderer.flagFill);
          }

        }
      });

      Object.defineProperty(object, 'stroke', {
        enumerable: true,
        get: function() {
          return this._stroke;
        },
        set: function(f) {

          if (this._stroke instanceof Two.Gradient
            || this._stroke instanceof Two.LinearGradient
            || this._stroke instanceof Two.RadialGradient
            || this._stroke instanceof Two.Texture) {
            this._stroke.unbind(Two.Events.change, this._renderer.flagStroke);
          }

          this._stroke = f;
          this._flagStroke = true;

          if (this._stroke instanceof Two.Gradient
            || this._stroke instanceof Two.LinearGradient
            || this._stroke instanceof Two.RadialGradient
            || this._stroke instanceof Two.Texture) {
            this._stroke.bind(Two.Events.change, this._renderer.flagStroke);
          }

        }
      });

      Object.defineProperty(object, 'clip', {
        enumerable: true,
        get: function() {
          return this._clip;
        },
        set: function(v) {
          this._clip = v;
          this._flagClip = true;
        }
      });

      Object.defineProperty(object, 'dashes', {
        enumerable: true,
        get: function() {
          return this._dashes;
        },
        set: function(v) {
          if (!_.isNumber(v.offset)) {
            v.offset = this._dashes.offset || 0;
          }
          this._dashes = v;
        }
      });

    }

  });

  _.extend(Two.Text.prototype, Two.Shape.prototype, {

    // Flags
    // http://en.wikipedia.org/wiki/Flag

    /**
     * @name Two.Text#_flagValue
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#value} need updating.
     */
    _flagValue: true,

    /**
     * @name Two.Text#_flagFamily
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#family} need updating.
     */
    _flagFamily: true,

    /**
     * @name Two.Text#_flagSize
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#size} need updating.
     */
    _flagSize: true,

    /**
     * @name Two.Text#_flagLeading
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#leading} need updating.
     */
    _flagLeading: true,

    /**
     * @name Two.Text#_flagAlignment
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#alignment} need updating.
     */
    _flagAlignment: true,

    /**
     * @name Two.Text#_flagBaseline
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#baseline} need updating.
     */
    _flagBaseline: true,

    /**
     * @name Two.Text#_flagStyle
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#style} need updating.
     */
    _flagStyle: true,

    /**
     * @name Two.Text#_flagWeight
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#weight} need updating.
     */
    _flagWeight: true,

    /**
     * @name Two.Text#_flagDecoration
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#decoration} need updating.
     */
    _flagDecoration: true,

    /**
     * @name Two.Text#_flagFill
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#fill} need updating.
     */
    _flagFill: true,

    /**
     * @name Two.Text#_flagStroke
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#stroke} need updating.
     */
    _flagStroke: true,

    /**
     * @name Two.Text#_flagLinewidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#linewidth} need updating.
     */
    _flagLinewidth: true,

    /**
     * @name Two.Text#_flagOpacity
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#opacity} need updating.
     */
    _flagOpacity: true,

    /**
     * @name Two.Text#_flagClassName
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#className} need updating.
     */
    _flagClassName: true,

    /**
     * @name Two.Text#_flagVisible
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#visible} need updating.
     */
    _flagVisible: true,

    /**
     * @name Two.Text#_flagClip
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#clip} need updating.
     */
    _flagClip: false,

    // Underlying Properties

    /**
     * @name Two.Text#value
     * @property {String} - The characters to be rendered to the the screen. Referred to in the documentation sometimes as the `message`.
     */
    _value: '',

    /**
     * @name Two.Text#family
     * @property {String} - The font family Two.js should attempt to regsiter for rendering. The default value is `'sans-serif'`. Comma separated font names can be supplied as a "stack", similar to the CSS implementation of `font-family`.
     */
    _family: 'sans-serif',

    /**
     * @name Two.Text#size
     * @property {Number} - The font size in Two.js point space. Defaults to `13`.
     */
    _size: 13,

    /**
     * @name Two.Text#leading
     * @property {Number} - The height between lines measured from base to base in Two.js point space. Defaults to `17`.
     */
    _leading: 17,

    /**
     * @name Two.Text#alignment
     * @property {String} - Alignment of text in relation to {@link Two.Text#translation}'s coordinates. Possible values include `'left'`, `'center'`, `'right'`. Defaults to `'center'`.
     */
    _alignment: 'center',

    /**
     * @name Two.Text#baseline
     * @property {String} - The vertical aligment of the text in relation to {@link Two.Text#translation}'s coordinates. Possible values include `'top'`, `'middle'`, `'bottom'`, and `'baseline'`. Defaults to `'baseline'`.
     */
    _baseline: 'middle',

    /**
     * @name Two.Text#style
     * @property {String} - The font's style. Possible values include '`normal`', `'italic'`. Defaults to `'normal'`.
     */
    _style: 'normal',

    /**
     * @name Two.Text#weight
     * @property {Number} - A number at intervals of 100 to describe the font's weight. This compatibility varies with the typeface's variant weights. Larger values are bolder. Smaller values are thinner. Defaults to `'500'`.
     */
    _weight: 500,

    /**
     * @name Two.Text#decoration
     * @property {String} - String to delineate whether text should be decorated with for instance an `'underline'`. Defaults to `'none'`.
     */
    _decoration: 'none',

    /**
     * @name Two.Text#fill
     * @property {(CssColor|Two.Gradient|Two.Texture)} - The value of what the text object should be filled in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS Colors.
     */
    _fill: '#000',

    /**
     * @name Two.Text#stroke
     * @property {(CssColor|Two.Gradient|Two.Texture)} - The value of what the text object should be filled in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS Colors.
     */
    _stroke: 'transparent',

    /**
     * @name Two.Text#linewidth
     * @property {Number} - The thickness in pixels of the stroke.
     */
    _linewidth: 1,

    /**
     * @name Two.Text#opacity
     * @property {Number} - The opaqueness of the text object.
     * @nota-bene Can be used in conjunction with CSS Colors that have an alpha value.
     */
    _opacity: 1,

    /**
     * @name Two.Text#className
     * @property {String} - A class to be applied to the element to be compatible with CSS styling. Only available for the {@link Two.SvgRenderer}.
     */
    _className: '',

    /**
     * @name Two.Text#visible
     * @property {Boolean} - Display the text object or not.
     * @nota-bene For {@link Two.CanvasRenderer} and {@link Two.WebGLRenderer} when set to false all updating is disabled improving performance dramatically with many objects in the scene.
     */
    _visible: true,

    /**
     * @name Two.Text#clip
     * @property {Two.Shape} - Object to define clipping area.
     * @nota-bene This property is currently not working becuase of SVG spec issues found here {@link https://code.google.com/p/chromium/issues/detail?id=370951}.
     */
    _clip: false,

    /**
     * @name Two.Text#_dashes
     * @private
     * @see {@link Two.Text#dashes}
     */
    _dashes: [],

    constructor: Two.Text,

    /**
     * @name Two.Text#remove
     * @function
     * @description Remove self from the scene / parent.
     */
    remove: function() {

      if (!this.parent) {
        return this;
      }

      this.parent.remove(this);

      return this;

    },

    /**
     * @name Two.Text#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Text}
     * @description Create a new instance of {@link Two.Text} with the same properties of the current text object.
     */
    clone: function(parent) {

      var clone = new Two.Text(this.value);
      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;

      _.each(Two.Text.Properties, function(property) {
        clone[property] = this[property];
      }, this);

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      if (parent) {
        parent.add(clone);
      }

      return clone._update();

    },

    /**
     * @name Two.Text#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the text object.
     */
    toObject: function() {

      var result = {
        translation: this.translation.toObject(),
        rotation: this.rotation,
        scale: this.scale
      };

      if (this.matrix.manual) {
        result.matrix = this.matrix.toObject();
      }

      _.each(Two.Text.Properties, function(property) {
        result[property] = this[property];
      }, this);

      return result;

    },

    /**
     * @name Two.Text#noFill
     * @function
     * @description Short hand method to set fill to `transparent`.
     */
    noFill: function() {
      this.fill = 'transparent';
      return this;
    },

    /**
     * @name Two.Text#noStroke
     * @function
     * @description Short hand method to set stroke to `transparent`.
     */
    noStroke: function() {
      this.stroke = undefined;
      this.linewidth = undefined;
      return this;
    },

    // A shim to not break `getBoundingClientRect` calls.
    // TODO: Implement a way to calculate proper bounding
    // boxes of `Two.Text`.

    /**
     * @name Two.Text#getBoundingClientRect
     * @function
     * @param {Boolean} [shallow=false] - Describes whether to calculate off local matrix or world matrix.
     * @returns {Object} - Returns object with top, left, right, bottom, width, height attributes.
     * @description Return an object with top, left, right, bottom, width, and height parameters of the text object.
     */
    getBoundingClientRect: function(shallow) {

      var matrix, border, l, x, y, i, v;
      var left, right, top, bottom;

      // TODO: Update this to not __always__ update. Just when it needs to.
      this._update(true);

      matrix = shallow ? this._matrix : getComputedMatrix(this);

      var height = this.leading;
      var width = this.value.length * this.size * Text.Ratio;

      switch (this.alignment) {
        case 'left':
          left = 0;
          right = width;
          break;
        case 'right':
          left = - width;
          right = 0;
          break;
        default:
          left = - width / 2;
          right = width / 2;
      }

      switch (this.baseline) {
        case 'top':
          top = 0;
          bottom = height;
          break;
        case 'bottom':
          top = - height;
          bottom = 0;
          break;
        default:
          top = - height / 2;
          bottom = height / 2;
      }

      v = matrix.multiply(left, top, 1);

      top = v.y;
      left = v.x;

      v = matrix.multiply(right, bottom, 1);

      right = v.x;
      bottom = v.y;

      return {
        top: top,
        left: left,
        right: right,
        bottom: bottom,
        width: right - left,
        height: bottom - top
      };

    },

    /**
     * @name Two.Text#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagValue = this._flagFamily = this._flagSize =
        this._flagLeading = this._flagAlignment = this._flagFill =
        this._flagStroke = this._flagLinewidth = this._flagOpacity =
        this._flagVisible = this._flagClip = this._flagDecoration =
        this._flagClassName = this._flagBaseline = false;

      Two.Shape.prototype.flagReset.call(this);

      return this;

    }

  });

  Two.Text.MakeObservable(Two.Text.prototype);

  function getCanvas() {
    if (root.document) {
      return root.document.createElement('canvas');
    } else {
      console.warn('Two.js: Unable to create canvas for Two.Text measurements.');
      return {
        getContext: _.identity
      };
    }
  }

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var _ = Two.Utils;

  /**
   * @name Two.Stop
   * @class
   * @param {Number} [offset] - The offset percentage of the stop represented as a zero-to-one value. Default value flip flops from zero-to-one as new stops are created.
   * @param {CssColor} [color] - The color of the stop. Default value flip flops from white to black as new stops are created.
   * @param {Number} [opacity] - The opacity value. Default value is 1, cannot be lower than 0.
   * @nota-bene Used specifically in conjunction with {@link Two.Gradient}s to control color graduation.
   */
  var Stop = Two.Stop = function(offset, color, opacity) {

    /**
     * @name Two.Stop#_renderer
     * @property {Object}
     * @private
     * @description A private object to store relevant renderer specific variables.
     * @nota-bene With the {@link Two.SvgRenderer} you can access the underlying SVG element created via `stop._renderer.elem`.
     */
    this._renderer = {};
    this._renderer.type = 'stop';

    /**
     * @name Two.Stop#offset
     * @property {Number} - The offset percentage of the stop represented as a zero-to-one value.
     */
    this.offset = _.isNumber(offset) ? offset
      : Stop.Index <= 0 ? 0 : 1;

    /**
     * @name Two.Stop#opacity
     * @property {Number} - The alpha percentage of the stop represented as a zero-to-one value.
     */
    this.opacity = _.isNumber(opacity) ? opacity : 1;

    /**
     * @name Two.Stop#color
     * @property {CssColor} - The color of the stop.
     */
    this.color = _.isString(color) ? color
      : Stop.Index <= 0 ? '#fff' : '#000';

    Stop.Index = (Stop.Index + 1) % 2;

  };

  _.extend(Stop, {

    /**
     * @name Two.Stop.Index
     * @property {Number} - The current index being referenced for calculating a stop's default offset value.
     */
    Index: 0,

    /**
     * @name Two.Stop.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Stop}.
     */
    Properties: [
      'offset',
      'opacity',
      'color'
    ],

    /**
     * @name Two.Stop.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Stop} to any object. Handy if you'd like to extend the {@link Two.Stop} class on a custom class.
     */
    MakeObservable: function(object) {

      _.each(Stop.Properties, function(property) {

        var object = this;
        var secret = '_' + property;
        var flag = '_flag' + property.charAt(0).toUpperCase() + property.slice(1);

        Object.defineProperty(object, property, {
          enumerable: true,
          get: function() {
            return this[secret];
          },
          set: function(v) {
            this[secret] = v;
            this[flag] = true;
            if (this.parent) {
              this.parent._flagStops = true;
            }
          }
        });

      }, object);

    }

  });

  _.extend(Stop.prototype, Two.Utils.Events, {

    constructor: Stop,

    /**
     * @name Two.Stop#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Stop}
     * @description Create a new instance of {@link Two.Stop} with the same properties of the current path.
     */
    clone: function() {

      var clone = new Stop();

      _.each(Stop.Properties, function(property) {
        clone[property] = this[property];
      }, this);

      return clone;

    },

    /**
     * @name Two.Stop#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var result = {};

      _.each(Stop.Properties, function(k) {
        result[k] = this[k];
      }, this);

      return result;

    },

    /**
     * @name Two.Stop#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagOffset = this._flagColor = this._flagOpacity = false;

      return this;

    }

  });

  Stop.MakeObservable(Stop.prototype);
  Stop.prototype.constructor = Stop;

  /**
   * @name Two.Gradient
   * @class
   * @param {Two.Stop[]} [stops] - A list of {@link Two.Stop}s that contain the gradient fill pattern for the gradient.
   * @description This is the base class for constructing different types of gradients with Two.js. The two common gradients are {@link Two.LinearGradient} and {@link Two.RadialGradient}.
   */
  var Gradient = Two.Gradient = function(stops) {

    /**
     * @name Two.Gradient#_renderer
     * @property {Object}
     * @private
     * @description A private object to store relevant renderer specific variables.
     * @nota-bene With the {@link Two.SvgRenderer} you can access the underlying SVG element created via `gradient._renderer.elem`.
     */
    this._renderer = {};
    this._renderer.type = 'gradient';

    /**
     * @name Two.Gradient#id
     * @property {String} - Session specific unique identifier.
     * @nota-bene In the {@link Two.SvgRenderer} change this to change the underlying SVG element's id too.
     */
    this.id = Two.Identifier + Two.uniqueId();
    this.classList = [];

    this._renderer.flagStops = _.bind(Gradient.FlagStops, this);
    this._renderer.bindStops = _.bind(Gradient.BindStops, this);
    this._renderer.unbindStops = _.bind(Gradient.UnbindStops, this);

    /**
     * @name Two.Gradient#spread
     * @property {String} - Indicates what happens if the gradient starts or ends inside the bounds of the target rectangle. Possible values are `'pad'`, `'reflect'`, and `'repeat'`.
     * @see {@link https://www.w3.org/TR/SVG11/pservers.html#LinearGradientElementSpreadMethodAttribute} for more information
     */
    this.spread = 'pad';

    /**
     * @name Two.Gradient#stops
     * @property {Two.Stop[]} - An ordered list of {@link Two.Stop}s for rendering the gradient.
     */
    this.stops = stops;

  };

  _.extend(Gradient, {

    /**
     * @name Two.Gradient#Stop
     * @see {@link Two.Stop}
     */
    Stop: Stop,

    /**
     * @name Two.Gradient.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Gradient}.
     */
    Properties: [
      'spread'
    ],

    /**
     * @name Two.Gradient.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Gradient} to any object. Handy if you'd like to extend the {@link Two.Gradient} class on a custom class.
     */
    MakeObservable: function(object) {

      _.each(Gradient.Properties, Two.Utils.defineProperty, object);

      Object.defineProperty(object, 'stops', {

        enumerable: true,

        get: function() {
          return this._stops;
        },

        set: function(stops) {

          var updateStops = this._renderer.flagStops;
          var bindStops = this._renderer.bindStops;
          var unbindStops = this._renderer.unbindStops;

          // Remove previous listeners
          if (this._stops) {
            this._stops
              .unbind(Two.Events.insert, bindStops)
              .unbind(Two.Events.remove, unbindStops);
          }

          // Create new Collection with copy of Stops
          this._stops = new Two.Utils.Collection((stops || []).slice(0));

          // Listen for Collection changes and bind / unbind
          this._stops
            .bind(Two.Events.insert, bindStops)
            .bind(Two.Events.remove, unbindStops);

          // Bind Initial Stops
          bindStops(this._stops);

        }

      });

    },

    /**
     * @name Two.Gradient.FlagStops
     * @function
     * @description Cached method to let renderers know stops have been updated on a {@link Two.Gradient}.
     */
    FlagStops: function() {
      this._flagStops = true;
    },

    /**
     * @name Two.Gradient.BindVertices
     * @function
     * @description Cached method to let {@link Two.Gradient} know vertices have been added to the instance.
     */
    BindStops: function(items) {

      // This function is called a lot
      // when importing a large SVG
      var i = items.length;
      while(i--) {
        items[i].bind(Two.Events.change, this._renderer.flagStops);
        items[i].parent = this;
      }

      this._renderer.flagStops();

    },

    /**
     * @name Two.Gradient.UnbindStops
     * @function
     * @description Cached method to let {@link Two.Gradient} know vertices have been removed from the instance.
     */
    UnbindStops: function(items) {

      var i = items.length;
      while(i--) {
        items[i].unbind(Two.Events.change, this._renderer.flagStops);
        delete items[i].parent;
      }

      this._renderer.flagStops();

    }

  });

  _.extend(Gradient.prototype, Two.Utils.Events, {

    /**
     * @name Two.Gradient#_flagStops
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Gradient#stops} need updating.
     */
    _flagStops: false,
    /**
     * @name Two.Gradient#_flagSpread
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Gradient#spread} need updating.
     */
    _flagSpread: false,

    /**
     * @name Two.Gradient#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Gradient}
     * @description Create a new instance of {@link Two.Gradient} with the same properties of the current path.
     */
    clone: function(parent) {

      var stops = _.map(this.stops, function(s) {
        return s.clone();
      });

      var clone = new Gradient(stops);

      _.each(Two.Gradient.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Gradient#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var result = {
        stops: _.map(this.stops, function(s) {
          return s.toObject();
        })
      };

      _.each(Gradient.Properties, function(k) {
        result[k] = this[k];
      }, this);

      return result;

    },

    /**
     * @name Two.Gradient#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagSpread || this._flagStops) {
        this.trigger(Two.Events.change);
      }

      return this;

    },

    /**
     * @name Two.Gradient#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagSpread = this._flagStops = false;

      return this;

    }

  });

  Gradient.MakeObservable(Gradient.prototype);

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var _ = Two.Utils;

  /**
   * @name Two.LinearGradient
   * @class
   * @extends Two.Gradient
   * @param {Number} [x1=0] - The x position of the first end point of the linear gradient.
   * @param {Number} [y1=0] - The y position of the first end point of the linear gradient.
   * @param {Number} [x2=0] - The x position of the second end point of the linear gradient.
   * @param {Number} [y2=0] - The y position of the second end point of the linear gradient.
   * @param {Two.Stop[]} [stops] - A list of {@link Two.Stop}s that contain the gradient fill pattern for the gradient.
   * @nota-bene The linear gradient lives within the space of the parent object's matrix space.
   */
  var LinearGradient = Two.LinearGradient = function(x1, y1, x2, y2, stops) {

    Two.Gradient.call(this, stops);

    this._renderer.type = 'linear-gradient';

    var flagEndPoints = _.bind(LinearGradient.FlagEndPoints, this);

    /**
     * @name Two.LinearGradient#left
     * @property {Two.Vector} - The x and y value for where the first end point is placed on the canvas.
     */
    this.left = new Two.Vector().bind(Two.Events.change, flagEndPoints);
    /**
     * @name Two.LinearGradient#right
     * @property {Two.Vector} - The x and y value for where the second end point is placed on the canvas.
     */
    this.right = new Two.Vector().bind(Two.Events.change, flagEndPoints);

    if (_.isNumber(x1)) {
      this.left.x = x1;
    }
    if (_.isNumber(y1)) {
      this.left.y = y1;
    }
    if (_.isNumber(x2)) {
      this.right.x = x2;
    }
    if (_.isNumber(y2)) {
      this.right.y = y2;
    }

  };

  _.extend(LinearGradient, {

    /**
     * @name Two.LinearGradient#Stop
     * @see {@link Two.Stop}
     */
    Stop: Two.Gradient.Stop,

    /**
     * @name Two.LinearGradient.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.LinearGradient} to any object. Handy if you'd like to extend the {@link Two.LinearGradient} class on a custom class.
     */
    MakeObservable: function(object) {
      Two.Gradient.MakeObservable(object);
    },

    /**
     * @name Two.LinearGradient.FlagEndPoints
     * @function
     * @description Cached method to let renderers know end points have been updated on a {@link Two.LinearGradient}.
     */
    FlagEndPoints: function() {
      this._flagEndPoints = true;
    }

  });

  _.extend(LinearGradient.prototype, Two.Gradient.prototype, {

    /**
     * @name Two.LinearGradient#_flagEndPoints
     * @private
     * @property {Boolean} - Determines whether the {@link Two.LinearGradient#left} or {@link Two.LinearGradient#right} changed and needs to update.
     */
    _flagEndPoints: false,

    constructor: LinearGradient,

    /**
     * @name Two.LinearGradient#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Gradient}
     * @description Create a new instance of {@link Two.LinearGradient} with the same properties of the current path.
     */
    clone: function(parent) {

      var stops = _.map(this.stops, function(stop) {
        return stop.clone();
      });

      var clone = new LinearGradient(this.left._x, this.left._y,
        this.right._x, this.right._y, stops);

      _.each(Two.Gradient.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.LinearGradient#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var result = Two.Gradient.prototype.toObject.call(this);

      result.left = this.left.toObject();
      result.right = this.right.toObject();

      return result;

    },

    /**
     * @name Two.LinearGradient#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagEndPoints || this._flagSpread || this._flagStops) {
        this.trigger(Two.Events.change);
      }

      return this;

    },

    /**
     * @name Two.LinearGradient#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagEndPoints = false;

      Two.Gradient.prototype.flagReset.call(this);

      return this;

    }

  });

  LinearGradient.MakeObservable(LinearGradient.prototype);

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var _ = Two.Utils;

  /**
   * @name Two.RadialGradient
   * @class
   * @extends Two.Gradient
   * @param {Number} [x=0] - The x position of the origin of the radial gradient.
   * @param {Number} [y=0] - The y position of the origin of the radial gradient.
   * @param {Number} [radius=0] - The radius of the radial gradient.
   * @param {Two.Stop[]} [stops] - A list of {@link Two.Stop}s that contain the gradient fill pattern for the gradient.
   * @param {Number} [focalX=0] - The x position of the focal point on the radial gradient.
   * @param {Number} [focalY=0] - The y position of the focal point on the radial gradient.
   * @nota-bene The radial gradient lives within the space of the parent object's matrix space.
   */
  var RadialGradient = Two.RadialGradient = function(cx, cy, r, stops, fx, fy) {

    Two.Gradient.call(this, stops);

    this._renderer.type = 'radial-gradient';

    /**
     * @name Two.RadialGradient#center
     * @property {Two.Vector} - The x and y value for where the origin of the radial gradient is.
     */
    this.center = new Two.Vector()
      .bind(Two.Events.change, _.bind(function() {
        this._flagCenter = true;
      }, this));

    this.radius = _.isNumber(r) ? r : 20;

    /**
     * @name Two.RadialGradient#focal
     * @property {Two.Vector} - The x and y value for where the focal point of the radial gradient is.
     * @nota-bene This effects the spray or spread of the radial gradient.
     */
    this.focal = new Two.Vector()
      .bind(Two.Events.change, _.bind(function() {
        this._flagFocal = true;
      }, this));

    if (_.isNumber(cx)) {
      this.center.x = cx;
    }
    if (_.isNumber(cy)) {
      this.center.y = cy;
    }

    this.focal.copy(this.center);

    if (_.isNumber(fx)) {
      this.focal.x = fx;
    }
    if (_.isNumber(fy)) {
      this.focal.y = fy;
    }

  };

  _.extend(RadialGradient, {

    /**
     * @name Two.RadialGradient#Stop
     * @see {@link Two.Stop}
     */
    Stop: Two.Gradient.Stop,

    /**
     * @name Two.RadialGradient.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.RadialGradient}.
     */
    Properties: [
      'radius'
    ],

    /**
     * @name Two.RadialGradient.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.RadialGradient} to any object. Handy if you'd like to extend the {@link Two.RadialGradient} class on a custom class.
     */
    MakeObservable: function(object) {

      Two.Gradient.MakeObservable(object);

      _.each(RadialGradient.Properties, Two.Utils.defineProperty, object);

    }

  });

  _.extend(RadialGradient.prototype, Two.Gradient.prototype, {

    /**
     * @name Two.RadialGradient#_flagRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RadialGradient#radius} changed and needs to update.
     */
    _flagRadius: false,
    /**
     * @name Two.RadialGradient#_flagCenter
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RadialGradient#center} changed and needs to update.
     */
    _flagCenter: false,
    /**
     * @name Two.RadialGradient#_flagFocal
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RadialGradient#focal} changed and needs to update.
     */
    _flagFocal: false,

    constructor: RadialGradient,

    /**
     * @name Two.RadialGradient#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Gradient}
     * @description Create a new instance of {@link Two.RadialGradient} with the same properties of the current path.
     */
    clone: function(parent) {

      var stops = _.map(this.stops, function(stop) {
        return stop.clone();
      });

      var clone = new RadialGradient(this.center._x, this.center._y,
          this._radius, stops, this.focal._x, this.focal._y);

      _.each(Two.Gradient.Properties.concat(RadialGradient.Properties), function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.RadialGradient#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var result = Two.Gradient.prototype.toObject.call(this);

      _.each(RadialGradient.Properties, function(k) {
        result[k] = this[k];
      }, this);

      result.center = this.center.toObject();
      result.focal = this.focal.toObject();

      return result;

    },

    /**
     * @name Two.RadialGradient#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagRadius || this._flatCenter || this._flagFocal
        || this._flagSpread || this._flagStops) {
        this.trigger(Two.Events.change);
      }

      return this;

    },

    /**
     * @name Two.RadialGradient#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagRadius = this._flagCenter = this._flagFocal = false;

      Two.Gradient.prototype.flagReset.call(this);

      return this;

    }

  });

  RadialGradient.MakeObservable(RadialGradient.prototype);

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var root = Two.root;
  var _ = Two.Utils;
  var anchor;
  var regex = {
    video: /\.(mp4|webm|ogg)$/i,
    image: /\.(jpe?g|png|gif|tiff|webp)$/i,
    effect: /texture|gradient/i
  };

  if (root.document) {
    anchor = document.createElement('a');
  }

  /**
   * @name Two.Texture
   * @class
   * @extends Two.Shape
   * @param {String|ImageElement} [src] - The URL path to an image file or an `<img />` element.
   * @param {Function} [callback] - An optional callback function once the image has been loaded.
   * @description Fundamental to work with bitmap data, a.k.a. pregenerated imagery, in Two.js. Supported formats include jpg, png, gif, and tiff. See {@link Two.Texture.RegularExpressions} for a full list of supported formats.
   */
  var Texture = Two.Texture = function(src, callback) {

    this._renderer = {};
    this._renderer.type = 'texture';
    this._renderer.flagOffset = _.bind(Texture.FlagOffset, this);
    this._renderer.flagScale = _.bind(Texture.FlagScale, this);

    this.id = Two.Identifier + Two.uniqueId();
    this.classList = [];

    /**
     * @name Two.Texture#loaded
     * @property {Boolean} - Shorthand value to determine if image has been loaded into the texture.
     */
    this.loaded = false;

    /**
     * @name Two.Texture#repeat
     * @property {String} - CSS style declaration to tile {@link Two.Path}. Valid values include: `'no-repeat'`, `'repeat'`, `'repeat-x'`, `'repeat-y'`.
     * @see {@link https://www.w3.org/TR/2dcontext/#dom-context-2d-createpattern}
     */
    this.repeat = 'no-repeat';

    /**
     * @name Two.Texture#offset
     * @property {Two.Vector} - A two-component vector describing any pixel offset of the texture when applied to a {@link Two.Path}.
     */
    this.offset = new Two.Vector();

    if (_.isFunction(callback)) {
      var loaded = _.bind(function() {
        this.unbind(Two.Events.load, loaded);
        if (_.isFunction(callback)) {
          callback();
        }
      }, this);
      this.bind(Two.Events.load, loaded);
    }

    /**
     * @name Two.Texture#src
     * @property {String} - The URL path to the image data.
     * @nota-bene This property is ultimately serialized in a {@link Two.Registry} to cache retrieval.
     */
    if (_.isString(src)) {
      this.src = src;
    } else if (_.isElement(src)) {
      /**
       * @name Two.Texture#image
       * @property {Element} - The corresponding DOM Element of the texture. Can be a `<img />`, `<canvas />`, or `<video />` element. See {@link Two.Texture.RegularExpressions} for a full list of supported elements.
       * @nota-bene In headless environments this is a `Canvas.Image` object. See {@link https://github.com/Automattic/node-canvas} for more information on headless image objects.
       */
      this.image = src;
    }

    this._update();

  };

  _.extend(Texture, {

    /**
     * @name Two.Texture.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Texture}.
     */
    Properties: [
      'src',
      'loaded',
      'repeat'
    ],

    /**
     * @name Two.Texture.RegularExpressions
     * @property {Object} - A map of compatible DOM Elements categorized by media format.
     */
    RegularExpressions: regex,

    /**
     * @name Two.Texture.ImageRegistry
     * @property {Two.Registry} - A canonical listing of image data used in a single session of Two.js.
     * @nota-bene This object is used to cache image data between different textures.
     */
    ImageRegistry: new Two.Registry(),

    /**
     * @name Two.Texture.getAbsoluteURL
     * @property {Function} - Serializes a URL as an absolute path for canonical attribution in {@link Two.ImageRegistry}.
     * @param {String} path
     * @returns {String} - The serialized absolute path.
     */
    getAbsoluteURL: function(path) {
      if (!anchor) {
        // TODO: Fix for headless environments
        return path;
      }
      anchor.href = path;
      return anchor.href;
    },

    /**
     * @name Two.Texture.loadHeadlessBuffer
     * @property {Function} - Loads an image as a buffer in headless environments.
     * @param {Two.Texture} texture - The {@link Two.Texture} to be loaded.
     * @param {Function} loaded - The callback function to be triggered once the image is loaded.
     * @nota-bene - This function uses node's `fs.readFileSync` to spoof the `<img />` loading process in the browser.
     */
    loadHeadlessBuffer: new Function('texture', 'loaded', [
      'var fs = require("fs");',
      'var buffer = fs.readFileSync(texture.src);',

      'texture.image.src = buffer;',
      'loaded();'
    ].join('\n')),

    /**
     * @name Two.Texture.getImage
     * @property {Function} - Convenience function to set {@link Two.Texture#image} properties with canonincal versions set in {@link Two.Texture.ImageRegistry}.
     * @param {String} src - The URL path of the image.
     * @returns {ImageElement} - Returns either a cached version of the image or a new one that is registered in {@link Two.Texture.ImageRegistry}.
     */
    getImage: function(src) {

      var absoluteSrc = Texture.getAbsoluteURL(src);

      if (Texture.ImageRegistry.contains(absoluteSrc)) {
        return Texture.ImageRegistry.get(absoluteSrc);
      }

      var image;

      if (Two.Utils.Image) {

        // TODO: Fix for headless environments
        image = new Two.Utils.Image();
        Two.CanvasRenderer.Utils.shim(image, 'img');

      } else if (root.document) {

        if (regex.video.test(absoluteSrc)) {
          image = document.createElement('video');
        } else {
          image = document.createElement('img');
        }

      } else {

        console.warn('Two.js: no prototypical image defined for Two.Texture');

      }

      image.crossOrigin = 'anonymous';

      return image;

    },

    /**
     * @name Two.Register
     * @interface
     * @description A collection of functions to register different types of textures. Used internally by a {@link Two.Texture}.
     */
    Register: {
      canvas: function(texture, callback) {
        texture._src = '#' + texture.id;
        Texture.ImageRegistry.add(texture.src, texture.image);
        if (_.isFunction(callback)) {
          callback();
        }
      },
      img: function(texture, callback) {

        var loaded = function(e) {
          if (_.isFunction(texture.image.removeEventListener)) {
            texture.image.removeEventListener('load', loaded, false);
            texture.image.removeEventListener('error', error, false);
          }
          if (_.isFunction(callback)) {
            callback();
          }
        };
        var error = function(e) {
          if (_.isFunction(texture.image.removeEventListener)) {
            texture.image.removeEventListener('load', loaded, false);
            texture.image.removeEventListener('error', error, false);
          }
          throw new Two.Utils.Error('unable to load ' + texture.src);
        };

        if (_.isNumber(texture.image.width) && texture.image.width > 0
          && _.isNumber(texture.image.height) && texture.image.height > 0) {
            loaded();
        } else if (_.isFunction(texture.image.addEventListener)) {
          texture.image.addEventListener('load', loaded, false);
          texture.image.addEventListener('error', error, false);
        }

        texture._src = Texture.getAbsoluteURL(texture._src);

        if (texture.image && texture.image.getAttribute('two-src')) {
          return;
        }

        texture.image.setAttribute('two-src', texture.src);
        Texture.ImageRegistry.add(texture.src, texture.image);

        if (Two.Utils.isHeadless) {

          Texture.loadHeadlessBuffer(texture, loaded);

        } else {

          texture.image.src = texture.src;

        }

      },
      video: function(texture, callback) {

        var loaded = function(e) {
          texture.image.removeEventListener('canplaythrough', loaded, false);
          texture.image.removeEventListener('error', error, false);
          texture.image.width = texture.image.videoWidth;
          texture.image.height = texture.image.videoHeight;
          texture.image.play();
          if (_.isFunction(callback)) {
            callback();
          }
        };
        var error = function(e) {
          texture.image.removeEventListener('canplaythrough', loaded, false);
          texture.image.removeEventListener('error', error, false);
          throw new Two.Utils.Error('unable to load ' + texture.src);
        };

        texture._src = Texture.getAbsoluteURL(texture._src);
        texture.image.addEventListener('canplaythrough', loaded, false);
        texture.image.addEventListener('error', error, false);

        if (texture.image && texture.image.getAttribute('two-src')) {
          return;
        }

        if (Two.Utils.isHeadless) {
          throw new Two.Utils.Error('video textures are not implemented in headless environments.');
        }

        texture.image.setAttribute('two-src', texture.src);
        Texture.ImageRegistry.add(texture.src, texture.image);
        texture.image.src = texture.src;
        texture.image.loop = true;
        texture.image.load();

      }
    },

    /**
     * @name Two.Texture.load
     * @function
     * @param {Two.Texture} texture - The texture to load.
     * @param {Function} callback - The function to be called once the texture is loaded.
     */
    load: function(texture, callback) {

      var src = texture.src;
      var image = texture.image;
      var tag = image && image.nodeName.toLowerCase();

      if (texture._flagImage) {
        if (/canvas/i.test(tag)) {
          Texture.Register.canvas(texture, callback);
        } else {
          texture._src = image.getAttribute('two-src') || image.src;
          Texture.Register[tag](texture, callback);
        }
      }

      if (texture._flagSrc) {
        if (!image) {
          texture.image = Texture.getImage(texture.src);
        }
        tag = texture.image.nodeName.toLowerCase();
        Texture.Register[tag](texture, callback);
      }

    },

    /**
     * @name Two.Texture.FlagOffset
     * @function
     * @description Cached method to let renderers know `offset` has been updated on a {@link Two.Texture}.
     */
    FlagOffset: function() {
      this._flagOffset = true;
    },

    /**
     * @name Two.Texture.FlagScale
     * @function
     * @description Cached method to let renderers know `scale` has been updated on a {@link Two.Texture}.
     */
    FlagScale: function() {
      this._flagScale = true;
    },

    /**
     * @name Two.Texture.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Texture} to any object. Handy if you'd like to extend or inherit the {@link Two.Texture} class on a custom class.
     */
    MakeObservable: function(object) {

      _.each(Texture.Properties, Two.Utils.defineProperty, object);

      Object.defineProperty(object, 'image', {
        enumerable: true,
        get: function() {
          return this._image;
        },
        set: function(image) {

          var tag = image && image.nodeName.toLowerCase();
          var index;

          switch (tag) {
            case 'canvas':
              index = '#' + image.id;
              break;
            default:
              index = image.src;
          }

          if (Texture.ImageRegistry.contains(index)) {
            this._image = Texture.ImageRegistry.get(image.src);
          } else {
            this._image = image;
          }

          this._flagImage = true;

        }

      });

      Object.defineProperty(object, 'offset', {
        enumerable: true,
        get: function() {
          return this._offset;
        },
        set: function(v) {
          if (this._offset) {
            this._offset.unbind(Two.Events.change, this._renderer.flagOffset);
          }
          this._offset = v;
          this._offset.bind(Two.Events.change, this._renderer.flagOffset);
          this._flagOffset = true;
        }
      });

      Object.defineProperty(object, 'scale', {
        enumerable: true,
        get: function() {
          return this._scale;
        },
        set: function(v) {

          if (this._scale instanceof Two.Vector) {
            this._scale.unbind(Two.Events.change, this._renderer.flagScale);
          }

          this._scale = v;

          if (this._scale instanceof Two.Vector) {
            this._scale.bind(Two.Events.change, this._renderer.flagScale);
          }

          this._flagScale = true;

        }
      });

    }

  });

  _.extend(Texture.prototype, Two.Utils.Events, Two.Shape.prototype, {

    /**
     * @name Two.Texture#_flagSrc
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#src} needs updating.
     */
    _flagSrc: false,

    /**
     * @name Two.Texture#_flagImage
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#image} needs updating.
     */
    _flagImage: false,

    /**
     * @name Two.Texture#_flagVideo
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#video} needs updating.
     */
    _flagVideo: false,

    /**
     * @name Two.Texture#_flagLoaded
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#loaded} needs updating.
     */
    _flagLoaded: false,

    /**
     * @name Two.Texture#_flagRepeat
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#repeat} needs updating.
     */
    _flagRepeat: false,

    /**
     * @name Two.Texture#_flagOffset
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#offset} needs updating.
     */
    _flagOffset: false,

    /**
     * @name Two.Texture#_flagScale
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#scale} needs updating.
     */
    _flagScale: false,

    /**
     * @name Two.Texture#_src
     * @private
     * @see {@link Two.Texture#src}
     */
    _src: '',

    /**
     * @name Two.Texture#_image
     * @private
     * @see {@link Two.Texture#image}
     */
    _image: null,

    /**
     * @name Two.Texture#_loaded
     * @private
     * @see {@link Two.Texture#loaded}
     */
    _loaded: false,

    /**
     * @name Two.Texture#_repeat
     * @private
     * @see {@link Two.Texture#repeat}
     */
    _repeat: 'no-repeat',

    /**
     * @name Two.Texture#_scale
     * @private
     * @see {@link Two.Texture#scale}
     */
    _scale: 1,

    /**
     * @name Two.Texture#_offset
     * @private
     * @see {@link Two.Texture#offset}
     */
    _offset: null,

    constructor: Texture,

    /**
     * @name Two.Texture#clone
     * @function
     * @returns {Two.Texture}
     * @description Create a new instance of {@link Two.Texture} with the same properties of the current texture.
     */
    clone: function() {
      var clone = new Texture(this.src);
      clone.repeat = this.repeat;
      clone.offset.copy(this.origin);
      clone.scale = this.scale;
      return clone;
    },

    /**
     * @name Two.Texture#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the texture.
     */
    toObject: function() {
      return {
        src: this.src,
        // image: this.image,
        repeat: this.repeat,
        origin: this.origin.toObject(),
        scale: _.isNumber(this.scale) ? this.scale : this.scale.toObject()
      };
    },

    /**
     * @name Two.Texture#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagSrc || this._flagImage) {

        this.trigger(Two.Events.change);

        if (this._flagSrc || this._flagImage) {
          this.loaded = false;
          Texture.load(this, _.bind(function() {
            this.loaded = true;
            this
              .trigger(Two.Events.change)
              .trigger(Two.Events.load);
          }, this));
        }

      }

      if (this._image && this._image.readyState >= 4) {
        this._flagVideo = true;
      }

      return this;

    },

    /**
     * @name Two.Texture#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagSrc = this._flagImage = this._flagLoaded
        = this._flagVideo = this._flagScale = this._flagOffset = false;

      return this;

    }

  });

  Texture.MakeObservable(Texture.prototype);

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var _ = Two.Utils;
  var Path = Two.Path;
  var Rectangle = Two.Rectangle;

  /**
   * @name Two.Sprite
   * @class
   * @extends Two.Rectangle
   * @param {String|Two.Texture} [path] - The URL path or {@link Two.Texture} to be used as the bitmap data displayed on the sprite.
   * @param {Number} [ox=0] - The initial `x` position of the Two.Sprite.
   * @param {Number} [oy=0] - The initial `y` position of the Two.Sprite.
   * @param {Integer} [cols=1] - The number of columns the sprite contains.
   * @param {Integer} [rows=1] - The number of rows the sprite contains.
   * @param {Integer} [frameRate=0] - The frame rate at which the partitions of the image should playback at.
   * @description A convenient package to display still or animated images through a tiled image source. For more information on the principals of animated imagery through tiling see [Texture Atlas]{@link https://en.wikipedia.org/wiki/Texture_atlas} on Wikipedia..
   */
  var Sprite = Two.Sprite = function(path, ox, oy, cols, rows, frameRate) {

    // Not using default constructor of Rectangle due to odd `beginning` / `ending` behavior.
    // See: https://github.com/jonobr1/two.js/issues/383
    Path.call(this, [
      new Two.Anchor(),
      new Two.Anchor(),
      new Two.Anchor(),
      new Two.Anchor()
    ], true);

    this.noStroke();
    this.noFill();

    /**
     * @name Two.Sprite#texture
     * @property {Two.Texture} - The texture to be used as bitmap data to display image in the scene.
     */
    if (path instanceof Two.Texture) {
      this.texture = path;
    } else if (_.isString(path)) {
      this.texture = new Two.Texture(path);
    }

    this.origin = new Two.Vector();

    this._update();
    this.translation.set(ox || 0, oy || 0);

    /**
     * @name Two.Sprite#columns
     * @property {Integer} - The number of columns to split the texture into. Defaults to `1`.
     */
    if (_.isNumber(cols)) {
      this.columns = cols;
    }

    /**
     * @name Two.Sprite#rows
     * @property {Integer} - The number of rows to split the texture into. Defaults to `1`.
     */
    if (_.isNumber(rows)) {
      this.rows = rows;
    }

    /**
     * @name Two.Sprite#frameRate
     * @property {Integer} - The number of frames to animate against per second. Defaults to `0` for non-animated sprites.
     */
    if (_.isNumber(frameRate)) {
      this.frameRate = frameRate;
    }

    /**
     * @name Two.Sprite#index
     * @property {Integer} - The index of the current tile of the sprite to display. Defaults to `0`.
     */
    this.index = 0;

  };

  _.extend(Sprite, {

    /**
     * @name Two.Sprite.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Sprite}.
     */
    Properties: [
      'texture', 'columns', 'rows', 'frameRate', 'index'
    ],

    /**
     * @name Two.Sprite.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Sprite} to any object. Handy if you'd like to extend or inherit the {@link Two.Sprite} class on a custom class.
     */
    MakeObservable: function(obj) {

      Rectangle.MakeObservable(obj);
      _.each(Sprite.Properties, Two.Utils.defineProperty, obj);

    }

  });

  _.extend(Sprite.prototype, Rectangle.prototype, {

    /**
     * @name Two.Sprite#_flagTexture
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Sprite#texture} needs updating.
     */
    _flagTexture: false,

    /**
     * @name Two.Sprite#_flagColumns
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Sprite#columns} need updating.
     */
    _flagColumns: false,

    /**
     * @name Two.Sprite#_flagRows
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Sprite#rows} need updating.
     */
    _flagRows: false,

    /**
     * @name Two.Sprite#_flagFrameRate
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Sprite#flagFrameRate} needs updating.
     */
    _flagFrameRate: false,

    /**
     * @name Two.Sprite#_flagIndex
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Sprite#index} needs updating.
     */
    flagIndex: false,

    // Private variables

    /**
     * @name Two.Sprite#_amount
     * @private
     * @property {Integer} - Number of frames for a given {@link Two.Sprite}.
     */
    _amount: 1,

    /**
     * @name Two.Sprite#_duration
     * @private
     * @property {Number} - Number of milliseconds a {@link Two.Sprite}.
     */
    _duration: 0,

    /**
     * @name Two.Sprite#_startTime
     * @private
     * @property {Milliseconds} - Epoch time in milliseconds of when the {@link Two.Sprite} started.
     */
    _startTime: 0,

    /**
     * @name Two.Sprite#_playing
     * @private
     * @property {Boolean} - Dictates whether the {@link Two.Sprite} is animating or not.
     */
    _playing: false,

    /**
     * @name Two.Sprite#_firstFrame
     * @private
     * @property {Integer} - The frame the {@link Two.Sprite} should start with.
     */
    _firstFrame: 0,

    /**
     * @name Two.Sprite#_lastFrame
     * @private
     * @property {Integer} - The frame the {@link Two.Sprite} should end with.
     */
    _lastFrame: 0,

    /**
     * @name Two.Sprite#_playing
     * @private
     * @property {Boolean} - Dictates whether the {@link Two.Sprite} should loop or not.
     */
    _loop: true,

    // Exposed through getter-setter

    /**
     * @name Two.Sprite#_texture
     * @private
     * @see {@link Two.Sprite#texture}
     */
    _texture: null,

    /**
     * @name Two.Sprite#_columns
     * @private
     * @see {@link Two.Sprite#columns}
     */
    _columns: 1,

    /**
     * @name Two.Sprite#_rows
     * @private
     * @see {@link Two.Sprite#rows}
     */
    _rows: 1,

    /**
     * @name Two.Sprite#_frameRate
     * @private
     * @see {@link Two.Sprite#frameRate}
     */
    _frameRate: 0,

    /**
     * @name Two.Sprite#_index
     * @private
     * @property {Integer} - The current frame the {@link Two.Sprite} is currently displaying.
     */
    _index: 0,

    /**
     * @name Two.Sprite#_origin
     * @private
     * @see {@link Two.Sprite#origin}
     */
    _origin: null,

    constructor: Sprite,

    /**
     * @name Two.Sprite#play
     * @function
     * @param {Integer} [firstFrame=0] - The index of the frame to start the animation with.
     * @param {Integer} [lastFrame] - The index of the frame to end the animation with. Defaults to the last item in the {@link Two.Sprite#textures}.
     * @param {Function} [onLastFrame] - Optional callback function to be triggered after playing the last frame. This fires multiple times when the sprite is looped.
     * @description Initiate animation playback of a {@link Two.Sprite}.
     */
    play: function(firstFrame, lastFrame, onLastFrame) {

      this._playing = true;
      this._firstFrame = 0;
      this._lastFrame = this.amount - 1;
      this._startTime = _.performance.now();

      if (_.isNumber(firstFrame)) {
        this._firstFrame = firstFrame;
      }
      if (_.isNumber(lastFrame)) {
        this._lastFrame = lastFrame;
      }
      if (_.isFunction(onLastFrame)) {
        this._onLastFrame = onLastFrame;
      } else {
        delete this._onLastFrame;
      }

      if (this._index !== this._firstFrame) {
        this._startTime -= 1000 * Math.abs(this._index - this._firstFrame)
          / this._frameRate;
      }

      return this;

    },

    /**
     * @name Two.Sprite#pause
     * @function
     * @description Halt animation playback of a {@link Two.Sprite}.
     */
    pause: function() {

      this._playing = false;
      return this;

    },

    /**
     * @name Two.Sprite#stop
     * @function
     * @description Halt animation playback of a {@link Two.Sprite} and set the current frame back to the first frame.
     */
    stop: function() {

      this._playing = false;
      this._index = 0;

      return this;

    },

    /**
     * @name Two.Sprite#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Sprite}
     * @description Create a new instance of {@link Two.Sprite} with the same properties of the current sprite.
     */
    clone: function(parent) {

      var clone = new Sprite(
        this.texture, this.translation.x, this.translation.y,
        this.columns, this.rows, this.frameRate
      );

      if (this.playing) {
        clone.play(this._firstFrame, this._lastFrame);
        clone._loop = this._loop;
      }

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Sprite#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {
      var object = Rectangle.prototype.toObject.call(this);
      object.texture = this.texture.toObject();
      object.columns = this.columns;
      object.rows = this.rows;
      object.frameRate = this.frameRate;
      object.index = this.index;
      object._firstFrame = this._firstFrame;
      object._lastFrame = this._lastFrame;
      object._loop = this._loop;
      return object;
    },

    /**
     * @name Two.Sprite#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      var effect = this._texture;
      var cols = this._columns;
      var rows = this._rows;

      var width, height, elapsed, amount, duration;
      var index, iw, ih, isRange, frames;

      if (this._flagColumns || this._flagRows) {
        this._amount = this._columns * this._rows;
      }

      if (this._flagFrameRate) {
        this._duration = 1000 * this._amount / this._frameRate;
      }

      if (this._flagTexture) {
        this.fill = this._texture;
      }

      if (this._texture.loaded) {

        iw = effect.image.width;
        ih = effect.image.height;

        width = iw / cols;
        height = ih / rows;
        amount = this._amount;

        if (this.width !== width) {
          this.width = width;
        }
        if (this.height !== height) {
          this.height = height;
        }

        if (this._playing && this._frameRate > 0) {

          if (_.isNaN(this._lastFrame)) {
            this._lastFrame = amount - 1;
          }

          // TODO: Offload perf logic to instance of `Two`.
          elapsed = _.performance.now() - this._startTime;
          frames = this._lastFrame + 1;
          duration = 1000 * (frames - this._firstFrame) / this._frameRate;

          if (this._loop) {
            elapsed = elapsed % duration;
          } else {
            elapsed = Math.min(elapsed, duration);
          }

          index = _.lerp(this._firstFrame, frames, elapsed / duration);
          index = Math.floor(index);

          if (index !== this._index) {
            this._index = index;
            if (index >= this._lastFrame - 1 && this._onLastFrame) {
              this._onLastFrame();  // Shortcut for chainable sprite animations
            }
          }

        }

        var col = this._index % cols;
        var row = Math.floor(this._index / cols);

        var ox = - width * col + (iw - width) / 2;
        var oy = - height * row + (ih - height) / 2;

        // TODO: Improve performance
        if (ox !== effect.offset.x) {
          effect.offset.x = ox;
        }
        if (oy !== effect.offset.y) {
          effect.offset.y = oy;
        }

      }

      Rectangle.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.Sprite#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagTexture = this._flagColumns = this._flagRows
        = this._flagFrameRate = false;

      Rectangle.prototype.flagReset.call(this);

      return this;
    }


  });

  Sprite.MakeObservable(Sprite.prototype);

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  var _ = Two.Utils;
  var Path = Two.Path;
  var Rectangle = Two.Rectangle;

  /**
   * @name Two.ImageSequence
   * @class
   * @extends Two.Rectangle
   * @param {String|String[]|Two.Texture|Two.Texture[]} paths - A list of URLs or {@link Two.Texture}s.
   * @param {Number} [ox=0] - The initial `x` position of the Two.ImageSequence.
   * @param {Number} [oy=0] - The initial `y` position of the Two.ImageSequence.
   * @param {Integer} [frameRate=30] - The frame rate at which the images should playback at.
   * @description A convenient package to display still or animated images organized as a series of still images.
   */
  var ImageSequence = Two.ImageSequence = function(paths, ox, oy, frameRate) {

    // Not using default constructor of Rectangle due to odd `beginning` / `ending` behavior.
    // See: https://github.com/jonobr1/two.js/issues/383
    Path.call(this, [
      new Two.Anchor(),
      new Two.Anchor(),
      new Two.Anchor(),
      new Two.Anchor()
    ], true);

    this._renderer.flagTextures = _.bind(ImageSequence.FlagTextures, this);
    this._renderer.bindTextures = _.bind(ImageSequence.BindTextures, this);
    this._renderer.unbindTextures = _.bind(ImageSequence.UnbindTextures, this);

    this.noStroke();
    this.noFill();

    /**
     * @name Two.ImageSequence#textures
     * @property {Two.Texture[]} - A list of textures to be used as frames for animating the {@link Two.ImageSequence}.
     */
    if (_.isObject(paths)) {
      this.textures = _.map(paths, ImageSequence.GenerateTexture, this);
    } else {
      // If just a single path convert into a single Two.Texture
      this.textures = [ImageSequence.GenerateTexture(paths)];
    }

    this.origin = new Two.Vector();

    this._update();
    this.translation.set(ox || 0, oy || 0);

    /**
     * @name Two.ImageSequence#frameRate
     * @property {Integer} - The number of frames to animate against per second.
     */
    if (_.isNumber(frameRate)) {
      this.frameRate = frameRate;
    } else {
      this.frameRate = ImageSequence.DefaultFrameRate;
    }

    /**
     * @name Two.ImageSequence#index
     * @property {Integer} - The index of the current tile of the sprite to display. Defaults to `0`.
     */
    this.index = 0;

  };

  _.extend(ImageSequence, {

    /**
     * @name Two.ImageSequence.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.ImageSequence}.
     */
    Properties: [
      'frameRate',
      'index'
    ],

    /**
     * @name Two.ImageSequence.DefaultFrameRate
     * @property The default frame rate that {@link Two.ImageSequence#frameRate} is set to when instantiated.
     */
    DefaultFrameRate: 30,

    /**
     * @name Two.ImageSequence.FlagTextures
     * @function
     * @description Cached method to let renderers know textures have been updated on a {@link Two.ImageSequence}.
     */
    FlagTextures: function() {
      this._flagTextures = true;
    },

    /**
     * @name Two.ImageSequence.BindTextures
     * @function
     * @description Cached method to let {@link Two.ImageSequence} know textures have been added to the instance.
     */
    BindTextures: function(items) {

      var i = items.length;
      while (i--) {
        items[i].bind(Two.Events.change, this._renderer.flagTextures);
      }

      this._renderer.flagTextures();

    },

    /**
     * @name Two.ImageSequence.UnbindVertices
     * @function
     * @description Cached method to let {@link Two.ImageSequence} know textures have been removed from the instance.
     */
    UnbindTextures: function(items) {

      var i = items.length;
      while (i--) {
        items[i].unbind(Two.Events.change, this._renderer.flagTextures);
      }

      this._renderer.flagTextures();

    },

    /**
     * @name Two.ImageSequence.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.ImageSequence} to any object. Handy if you'd like to extend or inherit the {@link Two.ImageSequence} class on a custom class.
     */
    MakeObservable: function(obj) {

      Rectangle.MakeObservable(obj);
      _.each(ImageSequence.Properties, Two.Utils.defineProperty, obj);

      Object.defineProperty(obj, 'textures', {

        enumerable: true,

        get: function() {
          return this._textures;
        },

        set: function(textures) {

          var updateTextures = this._renderer.flagTextures;
          var bindTextures = this._renderer.bindTextures;
          var unbindTextures = this._renderer.unbindTextures;

          // Remove previous listeners
          if (this._textures) {
            this._textures
              .unbind(Two.Events.insert, bindTextures)
              .unbind(Two.Events.remove, unbindTextures);
          }

          // Create new Collection with copy of vertices
          this._textures = new Two.Utils.Collection((textures || []).slice(0));

          // Listen for Collection changes and bind / unbind
          this._textures
            .bind(Two.Events.insert, bindTextures)
            .bind(Two.Events.remove, unbindTextures);

          // Bind Initial Textures
          bindTextures(this._textures);

        }

      });

    },

    /**
     * @name Two.ImageSequence.GenerateTexture
     * @property {Function} - Shorthand function to prepare source image material into readable format by {@link Two.ImageSequence}.
     * @param {String|Two.Texture} textureOrString - The texture or string to create a {@link Two.Texture} from.
     * @description Function used internally by {@link Two.ImageSequence} to parse arguments and return {@link Two.Texture}s.
     * @returns {Two.Texture}
     */
    GenerateTexture: function(obj) {
      if (obj instanceof Two.Texture) {
        return obj;
      } else if (_.isString(obj)) {
        return new Two.Texture(obj);
      }
    }

  });

  _.extend(ImageSequence.prototype, Rectangle.prototype, {

    /**
     * @name Two.ImageSequence#_flagTextures
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ImageSequence#textures} need updating.
     */
    _flagTextures: false,

    /**
     * @name Two.ImageSequence#_flagFrameRate
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ImageSequence#frameRate} needs updating.
     */
    _flagFrameRate: false,

    /**
     * @name Two.ImageSequence#_flagIndex
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ImageSequence#index} needs updating.
     */
    _flagIndex: false,

    // Private variables

    /**
     * @name Two.ImageSequence#_amount
     * @private
     * @property {Integer} - Number of frames for a given {@link Two.ImageSequence}.
     */
    _amount: 1,

    /**
     * @name Two.ImageSequence#_duration
     * @private
     * @property {Number} - Number of milliseconds a {@link Two.ImageSequence}.
     */
    _duration: 0,

    /**
     * @name Two.ImageSequence#_index
     * @private
     * @property {Integer} - The current frame the {@link Two.ImageSequence} is currently displaying.
     */
    _index: 0,

    /**
     * @name Two.ImageSequence#_startTime
     * @private
     * @property {Milliseconds} - Epoch time in milliseconds of when the {@link Two.ImageSequence} started.
     */
    _startTime: 0,

    /**
     * @name Two.ImageSequence#_playing
     * @private
     * @property {Boolean} - Dictates whether the {@link Two.ImageSequence} is animating or not.
     */
    _playing: false,

    /**
     * @name Two.ImageSequence#_firstFrame
     * @private
     * @property {Integer} - The frame the {@link Two.ImageSequence} should start with.
     */
    _firstFrame: 0,

    /**
     * @name Two.ImageSequence#_lastFrame
     * @private
     * @property {Integer} - The frame the {@link Two.ImageSequence} should end with.
     */
    _lastFrame: 0,

    /**
     * @name Two.ImageSequence#_playing
     * @private
     * @property {Boolean} - Dictates whether the {@link Two.ImageSequence} should loop or not.
     */
    _loop: true,

    // Exposed through getter-setter

    /**
     * @name Two.ImageSequence#_textures
     * @private
     * @see {@link Two.ImageSequence#textures}
     */
    _textures: null,

    /**
     * @name Two.ImageSequence#_frameRate
     * @private
     * @see {@link Two.ImageSequence#frameRate}
     */
    _frameRate: 0,

    /**
     * @name Two.ImageSequence#_origin
     * @private
     * @see {@link Two.ImageSequence#origin}
     */
    _origin: null,

    constructor: ImageSequence,

    /**
     * @name Two.ImageSequence#play
     * @function
     * @param {Integer} [firstFrame=0] - The index of the frame to start the animation with.
     * @param {Integer} [lastFrame] - The index of the frame to end the animation with. Defaults to the last item in the {@link Two.ImageSequence#textures}.
     * @param {Function} [onLastFrame] - Optional callback function to be triggered after playing the last frame. This fires multiple times when the image sequence is looped.
     * @description Initiate animation playback of a {@link Two.ImageSequence}.
     */
    play: function(firstFrame, lastFrame, onLastFrame) {

      this._playing = true;
      this._firstFrame = 0;
      this._lastFrame = this.amount - 1;
      this._startTime = _.performance.now();

      if (_.isNumber(firstFrame)) {
        this._firstFrame = firstFrame;
      }
      if (_.isNumber(lastFrame)) {
        this._lastFrame = lastFrame;
      }
      if (_.isFunction(onLastFrame)) {
        this._onLastFrame = onLastFrame;
      } else {
        delete this._onLastFrame;
      }

      if (this._index !== this._firstFrame) {
        this._startTime -= 1000 * Math.abs(this._index - this._firstFrame)
          / this._frameRate;
      }

      return this;

    },

    /**
     * @name Two.ImageSequence#pause
     * @function
     * @description Halt animation playback of a {@link Two.ImageSequence}.
     */
    pause: function() {

      this._playing = false;
      return this;

    },

    /**
     * @name Two.ImageSequence#stop
     * @function
     * @description Halt animation playback of a {@link Two.ImageSequence} and set the current frame back to the first frame.
     */
    stop: function() {

      this._playing = false;
      this._index = this._firstFrame;

      return this;

    },

    /**
     * @name Two.ImageSequence#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.ImageSequence}
     * @description Create a new instance of {@link Two.ImageSequence} with the same properties of the current image sequence.
     */
    clone: function(parent) {

      var clone = new ImageSequence(this.textures, this.translation.x,
        this.translation.y, this.frameRate);

      clone._loop = this._loop;

      if (this._playing) {
        clone.play();
      }

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.ImageSequence#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {
      var object = Rectangle.prototype.toObject.call(this);
      object.textures = _.map(this.textures, function(texture) {
        return texture.toObject();
      });
      object.frameRate = this.frameRate;
      object.index = this.index;
      object._firstFrame = this._firstFrame;
      object._lastFrame = this._lastFrame;
      object._loop = this._loop;
      return object;
    },

    /**
     * @name Two.ImageSequence#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      var effects = this._textures;
      var width, height, elapsed, amount, duration, texture;
      var index, frames;

      if (this._flagTextures) {
        this._amount = effects.length;
      }

      if (this._flagFrameRate) {
        this._duration = 1000 * this._amount / this._frameRate;
      }

      if (this._playing && this._frameRate > 0) {

        amount = this._amount;

        if (_.isNaN(this._lastFrame)) {
          this._lastFrame = amount - 1;
        }

        // TODO: Offload perf logic to instance of `Two`.
        elapsed = _.performance.now() - this._startTime;
        frames = this._lastFrame + 1;
        duration = 1000 * (frames - this._firstFrame) / this._frameRate;

        if (this._loop) {
          elapsed = elapsed % duration;
        } else {
          elapsed = Math.min(elapsed, duration);
        }

        index = _.lerp(this._firstFrame, frames, elapsed / duration);
        index = Math.floor(index);

        if (index !== this._index) {

          this._index = index;
          texture = effects[this._index];

          if (texture.loaded) {

            width = texture.image.width;
            height = texture.image.height;

            if (this.width !== width) {
              this.width = width;
            }
            if (this.height !== height) {
              this.height = height;
            }

            this.fill = texture;

            if (index >= this._lastFrame - 1 && this._onLastFrame) {
              this._onLastFrame();  // Shortcut for chainable sprite animations
            }

          }

        }

      } else if (this._flagIndex || !(this.fill instanceof Two.Texture)) {

        texture = effects[this._index];

        if (texture.loaded) {

          width = texture.image.width;
          height = texture.image.height;

          if (this.width !== width) {
            this.width = width;
          }
          if (this.height !== height) {
            this.height = height;
          }

        }

        this.fill = texture;

      }

      Rectangle.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.ImageSequence#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagTextures = this._flagFrameRate = false;
      Rectangle.prototype.flagReset.call(this);

      return this;

    }

  });

  ImageSequence.MakeObservable(ImageSequence.prototype);

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);

(function(Two) {

  // Constants

  var min = Math.min, max = Math.max;
  var _ = Two.Utils;

  /**
   * @class
   * @name Two.Group.Children
   * @extends Two.Utils.Collection
   * @description A children collection which is accesible both by index and by object `id`.
   */
  var Children = function() {

    Two.Utils.Collection.apply(this, arguments);

    Object.defineProperty(this, '_events', {
      value : {},
      enumerable: false
    });

    /**
     * @name Two.Group.Children#ids
     * @property {Object} - Map of all elements in the list keyed by `id`s.
     */
    this.ids = {};

    this.on(Two.Events.insert, this.attach);
    this.on(Two.Events.remove, this.detach);
    Children.prototype.attach.apply(this, arguments);

  };

  Children.prototype = new Two.Utils.Collection();

  _.extend(Children.prototype, {

    constructor: Children,

    /**
     * @function
     * @name Two.Group.Children#attach
     * @param {Two.Shape[]}
     * @description Adds elements to the `ids` map.
     */
    attach: function(children) {
      for (var i = 0; i < children.length; i++) {
        this.ids[children[i].id] = children[i];
      }
      return this;
    },

    /**
     * @function
     * @name Two.Group.Children#detach
     * @param {Two.Shape[]}
     * @description Removes elements to the `ids` map.
     */
    detach: function(children) {
      for (var i = 0; i < children.length; i++) {
        delete this.ids[children[i].id];
      }
      return this;
    }

  });

  /**
   * @class
   * @name Two.Group
   */
  var Group = Two.Group = function(children) {

    Two.Shape.call(this, true);

    this._renderer.type = 'group';

    /**
     * @name Two.Group#additions
     * @property {Two.Shape[]}
     * @description An automatically updated list of children that need to be appended to the renderer's scenegraph.
     */
    this.additions = [];

    /**
     * @name Two.Group#subtractions
     * @property {Two.Shape[]}
     * @description An automatically updated list of children that need to be removed from the renderer's scenegraph.
     */
    this.subtractions = [];

    /**
     * @name Two.Group#additions
     * @property {Two.Group.Children[]}
     * @description A list of all the children in the scenegraph.
     * @nota-bene Ther order of this list indicates the order each element is rendered to the screen.
     */
    this.children = _.isArray(children) ? children : arguments;

  };

  _.extend(Group, {

    Children: Children,

    /**
     * @name Two.Group.InsertChildren
     * @function
     * @description Cached method to let renderers know children have been added to a {@link Two.Group}.
     */
    InsertChildren: function(children) {
      for (var i = 0; i < children.length; i++) {
        replaceParent.call(this, children[i], this);
      }
    },

    /**
     * @name Two.Group.RemoveChildren
     * @function
     * @description Cached method to let renderers know children have been removed from a {@link Two.Group}.
     */
    RemoveChildren: function(children) {
      for (var i = 0; i < children.length; i++) {
        replaceParent.call(this, children[i]);
      }
    },

    /**
     * @name Two.Group.OrderChildren
     * @function
     * @description Cached method to let renderers know order has been updated on a {@link Two.Group}.
     */
    OrderChildren: function(children) {
      this._flagOrder = true;
    },

    /**
     * @name Two.Group.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Group}.
     */
    Properties: [
      'fill',
      'stroke',
      'linewidth',
      'visible',
      'cap',
      'join',
      'miter',

      'closed',
      'curved',
      'automatic'
    ],

    /**
     * @name Two.Group.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Group} to any object. Handy if you'd like to extend the {@link Two.Group} class on a custom class.
     */
    MakeObservable: function(object) {

      var properties = Two.Group.Properties;

      Object.defineProperty(object, 'opacity', {

        enumerable: true,

        get: function() {
          return this._opacity;
        },

        set: function(v) {
          this._flagOpacity = this._opacity !== v;
          this._opacity = v;
        }

      });

      Object.defineProperty(object, 'beginning', {

        enumerable: true,

        get: function() {
          return this._beginning;
        },

        set: function(v) {
          this._flagBeginning = this._beginning !== v;
          this._beginning = v;
        }

      });

      Object.defineProperty(object, 'ending', {

        enumerable: true,

        get: function() {
          return this._ending;
        },

        set: function(v) {
          this._flagEnding = this._ending !== v;
          this._ending = v;
        }

      });

      Object.defineProperty(object, 'length', {

        enumerable: true,

        get: function() {
          if (this._flagLength || this._length <= 0) {
            this._length = 0;
            if (!this.children) {
              return this._length;
            }
            for (var i = 0; i < this.children.length; i++) {
              var child = this.children[i];
              this._length += child.length;
            }
          }
          return this._length;
        }

      });

      Two.Shape.MakeObservable(object);
      Group.MakeGetterSetters(object, properties);

      Object.defineProperty(object, 'children', {

        enumerable: true,

        get: function() {
          return this._children;
        },

        set: function(children) {

          var insertChildren = _.bind(Group.InsertChildren, this);
          var removeChildren = _.bind(Group.RemoveChildren, this);
          var orderChildren = _.bind(Group.OrderChildren, this);

          if (this._children) {
            this._children.unbind();
          }

          this._children = new Children(children);
          this._children.bind(Two.Events.insert, insertChildren);
          this._children.bind(Two.Events.remove, removeChildren);
          this._children.bind(Two.Events.order, orderChildren);

        }

      });

      Object.defineProperty(object, 'mask', {

        enumerable: true,

        get: function() {
          return this._mask;
        },

        set: function(v) {
          this._mask = v;
          this._flagMask = true;
          if (!v.clip) {
            v.clip = true;
          }
        }

      });

    },

    /**
     * @name Two.Group.MakeGetterSetters
     * @function
     * @param {Two.Group} group - The group to apply getters and setters.
     * @param {Object} properties - A key / value object containing properties to inherit.
     */
    MakeGetterSetters: function(group, properties) {

      if (!_.isArray(properties)) {
        properties = [properties];
      }

      _.each(properties, function(k) {
        Group.MakeGetterSetter(group, k);
      });

    },

    /**
     * @name Two.Group.MakeGetterSetter
     * @function
     * @param {Two.Group} group - The group to apply getters and setters.
     * @param {String} key - The key which will become a property on the group.
     */
    MakeGetterSetter: function(group, key) {

      var secret = '_' + key;

      Object.defineProperty(group, key, {

        enumerable: true,

        get: function() {
          return this[secret];
        },

        set: function(v) {
          this[secret] = v;
          // Trickle down styles
          for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            child[key] = v;
          }
        }

      });

    }

  });

  _.extend(Group.prototype, Two.Shape.prototype, {

    // Flags
    // http://en.wikipedia.org/wiki/Flag

    /**
     * @name Two.Group#_flagAdditions
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#additions} need updating.
     */
    _flagAdditions: false,

    /**
     * @name Two.Group#_flagSubtractions
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#subtractions} need updating.
     */
    _flagSubtractions: false,

    /**
     * @name Two.Group#_flagOrder
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#order} need updating.
     */
    _flagOrder: false,

    /**
     * @name Two.Group#_flagOpacity
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#opacity} need updating.
     */
    _flagOpacity: true,

    /**
     * @name Two.Group#_flagBeginning
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#beginning} need updating.
     */
    _flagBeginning: false,

    /**
     * @name Two.Group#_flagEnding
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#ending} need updating.
     */
    _flagEnding: false,

    /**
     * @name Two.Group#_flagLength
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#length} need updating.
     */
    _flagLength: false,

    /**
     * @name Two.Group#_flagMask
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#mask} need updating.
     */
    _flagMask: false,

    // Underlying Properties

    /**
     * @name Two.Group#fill
     * @property {(CssColor|Two.Gradient|Two.Texture)} - The value of what all child shapes should be filled in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS Colors.
     */
    _fill: '#fff',

    /**
     * @name Two.Group#stroke
     * @property {(CssColor|Two.Gradient|Two.Texture)} - The value of what all child shapes should be outlined in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS Colors.
     */
    _stroke: '#000',

    /**
     * @name Two.Group#linewidth
     * @property {Number} - The thickness in pixels of the stroke for all child shapes.
     */
    _linewidth: 1.0,

    /**
     * @name Two.Group#opacity
     * @property {Number} - The opaqueness of all child shapes.
     * @nota-bene Becomes multiplied by the individual child's opacity property.
     */
    _opacity: 1.0,

    /**
     * @name Two.Group#visible
     * @property {Boolean} - Display the path or not.
     * @nota-bene For {@link Two.CanvasRenderer} and {@link Two.WebGLRenderer} when set to false all updating is disabled improving performance dramatically with many objects in the scene.
     */
    _visible: true,

    /**
     * @name Two.Group#cap
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeLinecapProperty}
     */
    _cap: 'round',

    /**
     * @name Two.Group#join
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeLinejoinProperty}
     */
    _join: 'round',

    /**
     * @name Two.Group#miter
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeMiterlimitProperty}
     */
    _miter: 4,

    /**
     * @name Two.Group#closed
     * @property {Boolean} - Determines whether a final line is drawn between the final point in the `vertices` array and the first point of all child shapes.
     */
    _closed: true,

    /**
     * @name Two.Group#curved
     * @property {Boolean} - When the child's path is `automatic = true` this boolean determines whether the lines between the points are curved or not.
     */
    _curved: false,

    /**
     * @name Two.Group#automatic
     * @property {Boolean} - Determines whether or not Two.js should calculate curves, lines, and commands automatically for you or to let the developer manipulate them for themselves.
     */
    _automatic: true,

    /**
     * @name Two.Group#beginning
     * @property {Number} - Number between zero and one to state the beginning of where the path is rendered.
     * @description {@link Two.Group#beginning} is a percentage value that represents at what percentage into all child shapes should the renderer start drawing.
     * @nota-bene This is great for animating in and out stroked paths in conjunction with {@link Two.Group#ending}.
     */
    _beginning: 0,

    /**
     * @name Two.Group#ending
     * @property {Number} - Number between zero and one to state the ending of where the path is rendered.
     * @description {@link Two.Group#ending} is a percentage value that represents at what percentage into all child shapes should the renderer start drawing.
     * @nota-bene This is great for animating in and out stroked paths in conjunction with {@link Two.Group#beginning}.
     */
    _ending: 1.0,

    /**
     * @name Two.Group#length
     * @property {Number} - The sum of distances between all child lengths.
     */
    _length: 0,

    /**
     * @name Two.Group#mask
     * @property {Two.Shape} - The Two.js object to clip from a group's rendering.
     */
    _mask: null,

    constructor: Group,

    /**
     * @name Two.Group#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Group}
     * @description Create a new instance of {@link Two.Group} with the same properties of the current group.
     */
    clone: function(parent) {

      // /**
      //  * TODO: Group has a gotcha in that it's at the moment required to be bound to
      //  * an instance of two in order to add elements correctly. This needs to
      //  * be rethought and fixed.
      //  */

      var clone = new Group();
      var children = _.map(this.children, function(child) {
        return child.clone();
      });

      clone.add(children);

      clone.opacity = this.opacity;

      if (this.mask) {
        clone.mask = this.mask;
      }

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.className = this.className;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      if (parent) {
        parent.add(clone);
      }

      return clone._update();

    },

    /**
     * @name Two.Group#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the group.
     */
    toObject: function() {

      var result = {
        children: [],
        translation: this.translation.toObject(),
        rotation: this.rotation,
        scale: this.scale instanceof Two.Vector ? this.scale.toObject() : this.scale,
        opacity: this.opacity,
        className: this.className,
        mask: (this.mask ? this.mask.toObject() : null)
      };

      if (this.matrix.manual) {
        result.matrix = this.matrix.toObject();
      }

      _.each(this.children, function(child, i) {
        result.children[i] = child.toObject();
      }, this);

      return result;

    },

    /**
     * @name Two.Group#corner
     * @function
     * @description Orient the children of the group to the upper left-hand corner of that group.
     */
    corner: function() {

      var rect = this.getBoundingClientRect(true);
      var corner = { x: rect.left, y: rect.top };

      this.children.forEach(function(child) {
        child.translation.sub(corner);
      });

      return this;

    },

    /**
     * @name Two.Group#center
     * @function
     * @description Orient the children of the group to the center of that group.
     */
    center: function() {

      var rect = this.getBoundingClientRect(true);

      rect.centroid = {
        x: rect.left + rect.width / 2 - this.translation.x,
        y: rect.top + rect.height / 2 - this.translation.y
      };

      this.children.forEach(function(child) {
        if (child.isShape) {
          child.translation.sub(rect.centroid);
        }
      });

      return this;

    },

    /**
     * @name Two.Group#getById
     * @function
     * @description Recursively search for id. Returns the first element found.
     * @returns {Two.Shape} - Or `null` if nothing is found.
     */
    getById: function (id) {
      var found = null;
      function search(node) {
        if (node.id === id) {
          return node;
        } else if (node.children) {
          for (var i = 0; i < node.children.length; i++) {
            found = search(node.children[i], id);
            if (found) {
              return found;
            }
          }
        }
        return null;
      }
      return search(this);
    },

    /**
     * @name Two.Group#getByClassName
     * @function
     * @description Recursively search for classes. Returns an array of matching elements.
     * @returns {Two.Shape[]} - Or empty array if nothing is found.
     */
    getByClassName: function(className) {
      var found = [];
      function search(node) {
        if (_.indexOf(node.classList, className) >= 0) {
          found.push(node);
        }
        if (node.children) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            search(child, className);
          }
        }
        return found;
      }
      return search(this);
    },

    /**
     * @name Two.Group#getByType
     * @function
     * @description Recursively search for children of a specific type, e.g. {@link Two.Path}. Pass a reference to this type as the param. Returns an array of matching elements.
     * @returns {Two.Shape[]} - Empty array if nothing is found.
     */
    getByType: function(type) {
      var found = [];
      function search(node) {
        if (node instanceof type) {
          found.push(node);
        }
        if (node.children) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            search(child);
          }
        }
        return found;
      }
      return search(this, type);
    },

    /**
     * @name Two.Group#add
     * @function
     * @param {Two.Shape[]} objects - An array of objects to be added. Can be also added as individual arguments.
     * @description Add objects to the group.
     */
    add: function(objects) {

      // Allow to pass multiple objects either as array or as multiple arguments
      // If it's an array also create copy of it in case we're getting passed
      // a childrens array directly.
      if (!(objects instanceof Array)) {
        objects = _.toArray(arguments);
      } else {
        objects = objects.slice();
      }

      // Add the objects
      for (var i = 0; i < objects.length; i++) {
        var child = objects[i];
        if (!(child && child.id)) {
          continue;
        }
        var index = _.indexOf(this.children, child);
        if (index >= 0) {
          this.children.splice(index, 1);
        }
        this.children.push(child);
      }

      return this;

    },

    /**
     * @name Two.Group#add
     * @function
     * @param {Two.Shape[]} objects - An array of objects to be removed. Can be also removed as individual arguments.
     * @description Remove objects from the group.
     */
    remove: function(objects) {

      var l = arguments.length,
        grandparent = this.parent;

      // Allow to call remove without arguments
      // This will detach the object from its own parent.
      if (l <= 0 && grandparent) {
        grandparent.remove(this);
        return this;
      }

      // Allow to pass multiple objects either as array or as multiple arguments
      // If it's an array also create copy of it in case we're getting passed
      // a childrens array directly.
      if (!(objects instanceof Array)) {
        objects = _.toArray(arguments);
      } else {
        objects = objects.slice();
      }

      // Remove the objects
      for (var i = 0; i < objects.length; i++) {
        if (!objects[i] || !(this.children.ids[objects[i].id])) continue;
        this.children.splice(_.indexOf(this.children, objects[i]), 1);
      }

      return this;

    },

    /**
     * @name Two.Group#getBoundingClientRect
     * @function
     * @param {Boolean} [shallow=false] - Describes whether to calculate off local matrix or world matrix.
     * @returns {Object} - Returns object with top, left, right, bottom, width, height attributes.
     * @description Return an object with top, left, right, bottom, width, and height parameters of the group.
     */
    getBoundingClientRect: function(shallow) {
      var rect;

      // TODO: Update this to not __always__ update. Just when it needs to.
      this._update(true);

      // Variables need to be defined here, because of nested nature of groups.
      var left = Infinity, right = -Infinity,
          top = Infinity, bottom = -Infinity;

      var regex = Two.Texture.RegularExpressions.effect;

      for (var i = 0; i < this.children.length; i++) {

        var child = this.children[i];

        if (!child.visible || regex.test(child._renderer.type)) {
          continue;
        }

        rect = child.getBoundingClientRect(shallow);

        if (!_.isNumber(rect.top)   || !_.isNumber(rect.left)   ||
            !_.isNumber(rect.right) || !_.isNumber(rect.bottom)) {
          continue;
        }

        top = min(rect.top, top);
        left = min(rect.left, left);
        right = max(rect.right, right);
        bottom = max(rect.bottom, bottom);

      }

      return {
        top: top,
        left: left,
        right: right,
        bottom: bottom,
        width: right - left,
        height: bottom - top
      };

    },

    /**
     * @name Two.Group#noFill
     * @function
     * @description Apply `noFill` method to all child shapes.
     */
    noFill: function() {
      this.children.forEach(function(child) {
        child.noFill();
      });
      return this;
    },

    /**
     * @name Two.Group#noStroke
     * @function
     * @description Apply `noStroke` method to all child shapes.
     */
    noStroke: function() {
      this.children.forEach(function(child) {
        child.noStroke();
      });
      return this;
    },

    /**
     * @name Two.Group#subdivide
     * @function
     * @description Apply `subdivide` method to all child shapes.
     */
    subdivide: function() {
      var args = arguments;
      this.children.forEach(function(child) {
        child.subdivide.apply(child, args);
      });
      return this;
    },

    /**
     * @name Two.Group#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagBeginning || this._flagEnding) {

        var beginning = Math.min(this._beginning, this._ending);
        var ending = Math.max(this._beginning, this._ending);
        var length = this.length;
        var sum = 0;

        var bd = beginning * length;
        var ed = ending * length;
        var distance = (ed - bd);

        for (var i = 0; i < this.children.length; i++) {

          var child = this.children[i];
          var l = child.length;

          if (bd > sum + l) {
            child.beginning = 1;
            child.ending = 1;
          } else if (ed < sum) {
            child.beginning = 0;
            child.ending = 0;
          } else if (bd > sum && bd < sum + l) {
            child.beginning = (bd - sum) / l;
            child.ending = 1;
          } else if (ed > sum && ed < sum + l) {
            child.beginning = 0;
            child.ending = (ed - sum) / l;
          } else {
            child.beginning = 0;
            child.ending = 1;
          }

          sum += l;

        }

      }

      return Two.Shape.prototype._update.apply(this, arguments);

    },

    /**
     * @name Two.Group#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      if (this._flagAdditions) {
        this.additions.length = 0;
        this._flagAdditions = false;
      }

      if (this._flagSubtractions) {
        this.subtractions.length = 0;
        this._flagSubtractions = false;
      }

      this._flagOrder = this._flagMask = this._flagOpacity =
        this._flagBeginning = this._flagEnding = false;

      Two.Shape.prototype.flagReset.call(this);

      return this;

    }

  });

  Group.MakeObservable(Group.prototype);

  // /**
  //  * Helper function used to sync parent-child relationship within the
  //  * `Two.Group.children` object.
  //  *
  //  * Set the parent of the passed object to another object
  //  * and updates parent-child relationships
  //  * Calling with one arguments will simply remove the parenting
  //  */
  function replaceParent(child, newParent) {

    var parent = child.parent;
    var index;

    if (parent === newParent) {
      add();
      return;
    }

    if (parent && parent.children.ids[child.id]) {

      index = _.indexOf(parent.children, child);
      parent.children.splice(index, 1);

      splice();

    }

    if (newParent) {
      add();
      return;
    }

    splice();

    if (parent._flagAdditions && parent.additions.length === 0) {
      parent._flagAdditions = false;
    }
    if (parent._flagSubtractions && parent.subtractions.length === 0) {
      parent._flagSubtractions = false;
    }

    delete child.parent;

    function add() {

      if (newParent.subtractions.length > 0) {
        index = _.indexOf(newParent.subtractions, child);

        if (index >= 0) {
          newParent.subtractions.splice(index, 1);
        }
      }

      if (newParent.additions.length > 0) {
        index = _.indexOf(newParent.additions, child);

        if (index >= 0) {
          newParent.additions.splice(index, 1);
        }
      }

      child.parent = newParent;
      newParent.additions.push(child);
      newParent._flagAdditions = true;

    }

    function splice() {

      index = _.indexOf(parent.additions, child);

      if (index >= 0) {
        parent.additions.splice(index, 1);
      }

      index = _.indexOf(parent.subtractions, child);

      if (index < 0) {
        parent.subtractions.push(child);
        parent._flagSubtractions = true;
      }

    }

  }

})((typeof global !== 'undefined' ? global : (undefined || self || window)).Two);


/* harmony default export */ __webpack_exports__["default"] = ((undefined || window).Two);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "../node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "../node_modules/webpack/buildin/amd-options.js":
/*!******************************************************!*\
  !*** ../node_modules/webpack/buildin/amd-options.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../node_modules/webpack/buildin/harmony-module.js":
/*!*********************************************************!*\
  !*** ../node_modules/webpack/buildin/harmony-module.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./js/algorithms/auto-layout.js":
/*!**************************************!*\
  !*** ./js/algorithms/auto-layout.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var non_layered_tidy_tree_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! non-layered-tidy-tree-layout */ "../node_modules/non-layered-tidy-tree-layout/src/index.js");
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layout */ "./js/algorithms/layout.js");
/* harmony import */ var _horizontal_layout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./horizontal-layout */ "./js/algorithms/horizontal-layout.js");




function autoLayout(root, isHorizontal) {
  var bb = new non_layered_tidy_tree_layout__WEBPACK_IMPORTED_MODULE_0__["BoundingBox"](0, 0);

  if (isHorizontal) {
    var layout = new _horizontal_layout__WEBPACK_IMPORTED_MODULE_2__["default"](bb);
    layout.layout(root);
  } else {
    var _layout = new _layout__WEBPACK_IMPORTED_MODULE_1__["default"](bb);

    _layout.layout(root);
  }

  return root;
}

/* harmony default export */ __webpack_exports__["default"] = (autoLayout);

/***/ }),

/***/ "./js/algorithms/horizontal-layout.js":
/*!********************************************!*\
  !*** ./js/algorithms/horizontal-layout.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var non_layered_tidy_tree_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! non-layered-tidy-tree-layout */ "../node_modules/non-layered-tidy-tree-layout/src/index.js");
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layout */ "./js/algorithms/layout.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var HorizontalLayout = /*#__PURE__*/function (_Layout) {
  _inherits(HorizontalLayout, _Layout);

  var _super = _createSuper(HorizontalLayout);

  function HorizontalLayout() {
    _classCallCheck(this, HorizontalLayout);

    return _super.apply(this, arguments);
  }

  _createClass(HorizontalLayout, [{
    key: "convert",

    /**
     * Returns Tree to layout, with bounding boxes added to each node.
     */
    value: function convert(treeData) {
      var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (treeData === null) return null;

      var _this$bb$addBoundingB = this.bb.addBoundingBox(treeData.height, treeData.width),
          width = _this$bb$addBoundingB.width,
          height = _this$bb$addBoundingB.height;

      var children = [];

      if (treeData.children && treeData.children.length) {
        for (var i = 0; i < treeData.children.length; i++) {
          children[i] = this.convert(treeData.children[i], x + height);
        }
      }

      return new non_layered_tidy_tree_layout__WEBPACK_IMPORTED_MODULE_0__["Tree"](width, height, x, children);
    }
    /**
     * Assign layout tree x, y coordinates back to treeData,
     * with bounding boxes removed.
     */

  }, {
    key: "assignCoordinates",
    value: function assignCoordinates(tree, treeData) {
      var _this$bb$removeBoundi = this.bb.removeBoundingBox(tree.x, tree.y),
          x = _this$bb$removeBoundi.x,
          y = _this$bb$removeBoundi.y;

      treeData.x = y;
      treeData.y = x;

      for (var i = 0; i < tree.c.length; i++) {
        this.assignCoordinates(tree.c[i], treeData.children[i]);
      }

      return treeData;
    }
  }]);

  return HorizontalLayout;
}(_layout__WEBPACK_IMPORTED_MODULE_1__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (HorizontalLayout);

/***/ }),

/***/ "./js/algorithms/layout.js":
/*!*********************************!*\
  !*** ./js/algorithms/layout.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var non_layered_tidy_tree_layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! non-layered-tidy-tree-layout */ "../node_modules/non-layered-tidy-tree-layout/src/index.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var Layout = /*#__PURE__*/function () {
  function Layout(boundingBox) {
    _classCallCheck(this, Layout);

    this.bb = boundingBox;
  }
  /**
   * Layout treeData.
   * Return modified treeData and the bounding box encompassing all the nodes.
   *
   * See getSize() for more explanation.
   */


  _createClass(Layout, [{
    key: "layout",
    value: function layout(treeData) {
      var tree = this.convert(treeData);

      Object(non_layered_tidy_tree_layout__WEBPACK_IMPORTED_MODULE_0__["layout"])(tree);

      var _this$assignLayout = this.assignLayout(tree, treeData),
          boundingBox = _this$assignLayout.boundingBox,
          result = _this$assignLayout.result;

      return {
        result: result,
        boundingBox: boundingBox
      };
    }
    /**
     * Returns Tree to layout, with bounding boxes added to each node.
     */

  }, {
    key: "convert",
    value: function convert(treeData) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      if (treeData === null) return null;

      var _this$bb$addBoundingB = this.bb.addBoundingBox(treeData.width, treeData.height),
          width = _this$bb$addBoundingB.width,
          height = _this$bb$addBoundingB.height;

      var children = [];

      if (treeData.children && treeData.children.length) {
        for (var i = 0; i < treeData.children.length; i++) {
          children[i] = this.convert(treeData.children[i], y + height);
        }
      }

      return new non_layered_tidy_tree_layout__WEBPACK_IMPORTED_MODULE_0__["Tree"](width, height, y, children);
    }
    /**
     * Assign layout tree x, y coordinates back to treeData,
     * with bounding boxes removed.
     */

  }, {
    key: "assignCoordinates",
    value: function assignCoordinates(tree, treeData) {
      var _this$bb$removeBoundi = this.bb.removeBoundingBox(tree.x, tree.y),
          x = _this$bb$removeBoundi.x,
          y = _this$bb$removeBoundi.y;

      treeData.x = x;
      treeData.y = y;

      for (var i = 0; i < tree.c.length; i++) {
        this.assignCoordinates(tree.c[i], treeData.children[i]);
      }

      return treeData;
    }
    /**
     * This function does assignCoordinates and getSize in one pass.
     */

  }, {
    key: "assignLayout",
    value: function assignLayout(tree, treeData) {
      var box = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      return {
        result: this.assignCoordinates(tree, treeData)
      };
    }
  }]);

  return Layout;
}();

/* harmony default export */ __webpack_exports__["default"] = (Layout);

/***/ }),

/***/ "./js/index.js":
/*!*********************!*\
  !*** ./js/index.js ***!
  \*********************/
/*! exports provided: Viewer, MindMap, MindmapLayouts, Parsers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _viewer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewer */ "./js/viewer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Viewer", function() { return _viewer__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _mindmap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mindmap */ "./js/mindmap.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MindMap", function() { return _mindmap__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _layouts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./layouts */ "./js/layouts/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MindmapLayouts", function() { return _layouts__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parser */ "./js/parser/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "Parsers", function() { return _parser__WEBPACK_IMPORTED_MODULE_3__; });






/***/ }),

/***/ "./js/layouts/downward-organizational.js":
/*!***********************************************!*\
  !*** ./js/layouts/downward-organizational.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layout */ "./js/layouts/layout.js");
/* harmony import */ var _algorithms_auto_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../algorithms/auto-layout */ "./js/algorithms/auto-layout.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var DownwardOrganizational = /*#__PURE__*/function (_Layout) {
  _inherits(DownwardOrganizational, _Layout);

  var _super = _createSuper(DownwardOrganizational);

  function DownwardOrganizational() {
    _classCallCheck(this, DownwardOrganizational);

    return _super.apply(this, arguments);
  }

  _createClass(DownwardOrganizational, [{
    key: "doLayout",
    value: function doLayout() {
      var root = this.root;
      return Object(_algorithms_auto_layout__WEBPACK_IMPORTED_MODULE_1__["default"])(root, false);
    }
  }]);

  return DownwardOrganizational;
}(_layout__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (DownwardOrganizational);

/***/ }),

/***/ "./js/layouts/index.js":
/*!*****************************!*\
  !*** ./js/layouts/index.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _right_logical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./right-logical */ "./js/layouts/right-logical.js");
/* harmony import */ var _downward_organizational__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./downward-organizational */ "./js/layouts/downward-organizational.js");
/* harmony import */ var _upward_organizational__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./upward-organizational */ "./js/layouts/upward-organizational.js");
/* harmony import */ var _left_logical__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./left-logical */ "./js/layouts/left-logical.js");
/* harmony import */ var _standard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./standard */ "./js/layouts/standard.js");





/* harmony default export */ __webpack_exports__["default"] = ({
  RightLogical: _right_logical__WEBPACK_IMPORTED_MODULE_0__["default"],
  DownwardOrganizational: _downward_organizational__WEBPACK_IMPORTED_MODULE_1__["default"],
  UpwardOrganizational: _upward_organizational__WEBPACK_IMPORTED_MODULE_2__["default"],
  LeftLogical: _left_logical__WEBPACK_IMPORTED_MODULE_3__["default"],
  Standard: _standard__WEBPACK_IMPORTED_MODULE_4__["default"]
});

/***/ }),

/***/ "./js/layouts/layout.js":
/*!******************************!*\
  !*** ./js/layouts/layout.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _structure_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../structure/node */ "./js/structure/node.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var Layout = /*#__PURE__*/function () {
  function Layout(rootNode) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var extraEdges = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    _classCallCheck(this, Layout);

    var me = this;
    me.root = rootNode;
    me.options = options;
    me.extraEdges = extraEdges;
  }

  _createClass(Layout, [{
    key: "isHorizontal",
    value: function isHorizontal() {
      return false;
    }
  }, {
    key: "doLayout",
    value: function doLayout() {
      throw new Error('please override this method');
    }
  }, {
    key: "getNodes",
    value: function getNodes() {
      var root = this.root;
      var nodes = [];
      var countByDepth = {};
      root.eachNode(function (node) {
        countByDepth[node.depth] = countByDepth[node.depth] || 0;
        countByDepth[node.depth]++;
        nodes.push({
          // origin data
          data: node.data,
          id: node.id,
          // position
          x: node.x,
          y: node.y,
          centX: node.x + node.width / 2,
          centY: node.y + node.height / 2,
          // size
          hgap: node.hgap,
          vgap: node.vgap,
          height: node.height,
          width: node.width,
          actualHeight: node.height - node.vgap * 2,
          actualWidth: node.width - node.hgap * 2,
          // depth
          depth: node.depth
        });
      });
      return nodes;
    }
  }, {
    key: "getEdges",
    value: function getEdges() {
      var me = this;
      var extraEdges = me.extraEdges;
      var root = this.root;
      var edges = [];
      root.eachNode(function (node) {
        node.children.forEach(function (child) {
          edges.push({
            source: node.id,
            target: child.id
          });
        });
      });
      edges.concat(extraEdges);
      return edges;
    }
  }]);

  return Layout;
}();

/* harmony default export */ __webpack_exports__["default"] = (Layout);

/***/ }),

/***/ "./js/layouts/left-logical.js":
/*!************************************!*\
  !*** ./js/layouts/left-logical.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layout */ "./js/layouts/layout.js");
/* harmony import */ var _algorithms_auto_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../algorithms/auto-layout */ "./js/algorithms/auto-layout.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var LeftLogical = /*#__PURE__*/function (_Layout) {
  _inherits(LeftLogical, _Layout);

  var _super = _createSuper(LeftLogical);

  function LeftLogical() {
    _classCallCheck(this, LeftLogical);

    return _super.apply(this, arguments);
  }

  _createClass(LeftLogical, [{
    key: "isHorizontal",
    value: function isHorizontal() {
      return true;
    }
  }, {
    key: "doLayout",
    value: function doLayout() {
      var root = this.root;
      Object(_algorithms_auto_layout__WEBPACK_IMPORTED_MODULE_1__["default"])(root, true);
      root.right2left();
      return root;
    }
  }]);

  return LeftLogical;
}(_layout__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (LeftLogical);

/***/ }),

/***/ "./js/layouts/right-logical.js":
/*!*************************************!*\
  !*** ./js/layouts/right-logical.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layout */ "./js/layouts/layout.js");
/* harmony import */ var _algorithms_auto_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../algorithms/auto-layout */ "./js/algorithms/auto-layout.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var RightLogical = /*#__PURE__*/function (_Layout) {
  _inherits(RightLogical, _Layout);

  var _super = _createSuper(RightLogical);

  function RightLogical() {
    _classCallCheck(this, RightLogical);

    return _super.apply(this, arguments);
  }

  _createClass(RightLogical, [{
    key: "isHorizontal",
    value: function isHorizontal() {
      return true;
    }
  }, {
    key: "doLayout",
    value: function doLayout() {
      var root = this.root;
      return Object(_algorithms_auto_layout__WEBPACK_IMPORTED_MODULE_1__["default"])(root, true);
    }
  }]);

  return RightLogical;
}(_layout__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (RightLogical);

/***/ }),

/***/ "./js/layouts/standard.js":
/*!********************************!*\
  !*** ./js/layouts/standard.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layout */ "./js/layouts/layout.js");
/* harmony import */ var _structure_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../structure/node */ "./js/structure/node.js");
/* harmony import */ var _algorithms_auto_layout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../algorithms/auto-layout */ "./js/algorithms/auto-layout.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var Standard = /*#__PURE__*/function (_Layout) {
  _inherits(Standard, _Layout);

  var _super = _createSuper(Standard);

  function Standard() {
    _classCallCheck(this, Standard);

    return _super.apply(this, arguments);
  }

  _createClass(Standard, [{
    key: "isHorizontal",
    value: function isHorizontal() {
      return true;
    }
  }, {
    key: "doLayout",
    value: function doLayout() {
      var me = this;
      var root = me.root;
      var options = me.options; // separate into left and right trees

      var leftTree = new _structure_node__WEBPACK_IMPORTED_MODULE_1__["default"](root.data, options, true);
      var rightTree = new _structure_node__WEBPACK_IMPORTED_MODULE_1__["default"](root.data, options, true);
      var treeSize = root.children.length;
      var rightTreeSize = Math.round(treeSize / 2);

      for (var i = 0; i < treeSize; i++) {
        var child = root.children[i];

        if (i < rightTreeSize) {
          rightTree.children.push(child);
        } else {
          leftTree.children.push(child);
        }
      }

      leftTree.children.reverse(); // do layout for left and right trees

      Object(_algorithms_auto_layout__WEBPACK_IMPORTED_MODULE_2__["default"])(rightTree, true);
      Object(_algorithms_auto_layout__WEBPACK_IMPORTED_MODULE_2__["default"])(leftTree, true);
      leftTree.right2left(); // combine left and right trees

      rightTree.translate(leftTree.x - rightTree.x, leftTree.y - rightTree.y); // translate root

      root.x = leftTree.x;
      root.y = rightTree.y;
      var bb = root.getBoundingBox();

      if (bb.top < 0) {
        root.translate(0, -bb.top);
      }

      return root;
    }
  }]);

  return Standard;
}(_layout__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (Standard);

/***/ }),

/***/ "./js/layouts/upward-organizational.js":
/*!*********************************************!*\
  !*** ./js/layouts/upward-organizational.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layout */ "./js/layouts/layout.js");
/* harmony import */ var _algorithms_auto_layout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../algorithms/auto-layout */ "./js/algorithms/auto-layout.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var UpwardOrganizational = /*#__PURE__*/function (_Layout) {
  _inherits(UpwardOrganizational, _Layout);

  var _super = _createSuper(UpwardOrganizational);

  function UpwardOrganizational() {
    _classCallCheck(this, UpwardOrganizational);

    return _super.apply(this, arguments);
  }

  _createClass(UpwardOrganizational, [{
    key: "doLayout",
    value: function doLayout() {
      var root = this.root;
      Object(_algorithms_auto_layout__WEBPACK_IMPORTED_MODULE_1__["default"])(root, false);
      root.down2up();
      return root;
    }
  }]);

  return UpwardOrganizational;
}(_layout__WEBPACK_IMPORTED_MODULE_0__["default"]);

/* harmony default export */ __webpack_exports__["default"] = (UpwardOrganizational);

/***/ }),

/***/ "./js/mindmap.js":
/*!***********************!*\
  !*** ./js/mindmap.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _structure_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./structure/node */ "./js/structure/node.js");
/* harmony import */ var _structure_theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./structure/theme */ "./js/structure/theme.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var MindMap = /*#__PURE__*/function () {
  function MindMap(data, layout, options) {
    _classCallCheck(this, MindMap);

    this.data = data;
    this.options = options;
    this.theme = options["theme"] || new _structure_theme__WEBPACK_IMPORTED_MODULE_1__["default"](data["theme"]);
    options["theme"] = this.theme;
    this.rootNode = new _structure_node__WEBPACK_IMPORTED_MODULE_0__["default"](data, options);
    this.layout = new layout(this.rootNode, options);
  }

  _createClass(MindMap, [{
    key: "build",
    value: function build() {
      return this.layout.doLayout();
    }
  }, {
    key: "getRootNode",
    value: function getRootNode() {
      return this.rootNode;
    }
  }, {
    key: "isHorizontalLayout",
    value: function isHorizontalLayout() {
      return this.layout.isHorizontal();
    }
  }, {
    key: "getBoundingBox",
    value: function getBoundingBox() {
      return this.rootNode.getBoundingBox();
    }
  }]);

  return MindMap;
}();

/* harmony default export */ __webpack_exports__["default"] = (MindMap);

/***/ }),

/***/ "./js/parser/index.js":
/*!****************************!*\
  !*** ./js/parser/index.js ***!
  \****************************/
/*! exports provided: TextParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _text_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./text-parser */ "./js/parser/text-parser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextParser", function() { return _text_parser__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "./js/parser/text-parser.js":
/*!**********************************!*\
  !*** ./js/parser/text-parser.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function parse(text) {
  var lines = text.match(/[^\r\n]+/g);
  var root = null;
  var levelStack = [];
  var currentLevel = 0;

  var _iterator = _createForOfIteratorHelper(lines),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var line = _step.value;

      if (root == null) {
        root = {
          content: getContent(line),
          children: []
        };
        levelStack.push({
          node: root,
          level: 0
        });
      } else {
        var content = getContent(line);
        var level = getLevel(line);
        var node = {
          content: content,
          children: []
        };

        if (level == 0) {
          break;
        }

        var lastIndex = levelStack.length - 1;

        while (levelStack[levelStack.length - 1].level > level) {
          levelStack.pop();
          currentLevel -= 1;
        }

        if (level != currentLevel) {
          levelStack[levelStack.length - 1].node.children.push(node);
          levelStack.push({
            node: node,
            level: level
          });
          currentLevel = level;
        } else {
          levelStack.pop();
          levelStack[levelStack.length - 1].node.children.push(node);
          levelStack.push({
            node: node,
            level: level
          });
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  console.log(root);
  return {
    root: root
  };
}

function getLevel(line) {
  line = line.replace(/\t/, "    ");
  var leadingWs = line.match(/^\s*/);
  leadingWs = leadingWs[0] || "";
  return Math.round(leadingWs.length / 4);
}

function getContent(line) {
  line = line.trim();
  line = line.replace(/^[+\-_*]\s*/, "");
  return line;
}

/* harmony default export */ __webpack_exports__["default"] = ({
  parse: parse
});

/***/ }),

/***/ "./js/renderer/draw-link.js":
/*!**********************************!*\
  !*** ./js/renderer/draw-link.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var two_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! two.js */ "../node_modules/two.js/build/two.module.js");

var lineColor = '#999';

function drawLine(a, b, two) {
  var isHorizontal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  if (!isHorizontal) {
    return drawVerticalLink(a, b, two);
  } else {
    return drawHorizontalLink(a, b, two);
  }
}

function drawVerticalLink(a, b, two) {
  var beginNode = a;
  var endNode = b;
  var startPoint, endPoint;

  if (a.y > b.y) {
    beginNode = b;
    endNode = a;
  }

  startPoint = beginNode.getLinkingPoints().bottom;
  endPoint = endNode.getLinkingPoints().top;

  if (beginNode.isRoot()) {
    startPoint = beginNode.getCenter();
  }

  if (endNode.isRoot()) {
    endPoint = endNode.getCenter();
  }

  drawSLine(endPoint, startPoint, false, two, a);
}

function drawHorizontalLink(a, b, two) {
  var beginNode = a;
  var endNode = b;
  var startPoint, endPoint;

  if (a.x > b.x) {
    beginNode = b;
    endNode = a;
  }

  startPoint = beginNode.getLinkingPoints().right;
  endPoint = endNode.getLinkingPoints().left;

  if (beginNode.isRoot()) {
    startPoint = beginNode.getCenter();
  }

  if (endNode.isRoot()) {
    endPoint = endNode.getCenter();
  }

  drawSLine(endPoint, startPoint, true, two, a);
}

function drawSLine(startPoint, endPoint, isHorizontal, two, style) {
  var anchors = [];
  var startAnchor, endAnchor;

  if (isHorizontal) {
    startAnchor = {
      x: Math.round((endPoint.x - startPoint.x) / 2),
      y: 0
    };
    endAnchor = {
      x: Math.round((startPoint.x - endPoint.x) / 2),
      y: 0
    };
  } else {
    startAnchor = {
      x: 0,
      y: Math.round((endPoint.y - startPoint.y) / 2)
    };
    endAnchor = {
      x: 0,
      y: Math.round((startPoint.y - endPoint.y) / 2)
    };
  }

  anchors.push(new two_js__WEBPACK_IMPORTED_MODULE_0__["default"].Anchor(startPoint.x, startPoint.y, 0, 0, startAnchor.x, startAnchor.y));
  anchors.push(new two_js__WEBPACK_IMPORTED_MODULE_0__["default"].Anchor(endPoint.x, endPoint.y, endAnchor.x, endAnchor.y, 0, 0));
  var path = new two_js__WEBPACK_IMPORTED_MODULE_0__["default"].Path(anchors, false, true);
  path.stroke = style.getStyle("line-color");
  path.linewidth = style.getStyle("line-width");
  path.noFill();
  two.add(path);
}

function drawPoint(_ref, two) {
  var x = _ref.x,
      y = _ref.y;
  two.makeCircle(x, y, 5).fill = 'rgb(0, 200, 255)';
}

/* harmony default export */ __webpack_exports__["default"] = (drawLine);

/***/ }),

/***/ "./js/renderer/draw-node.js":
/*!**********************************!*\
  !*** ./js/renderer/draw-node.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sample_random_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sample/random-color */ "./js/sample/random-color.js");


function drawNode(node, ctx) {
  drawShape(node, ctx);
  drawText(node, ctx);
}

function drawShape(node, ctx) {
  switch (node.getStyle("shape")) {
    case "line":
      drawLine(node, ctx);
      break;

    default:
      drawRoundedRect(node, ctx);
  }
}

function drawRoundedRect(node, ctx) {
  var _node$getBox = node.getBox(),
      width = _node$getBox.width,
      height = _node$getBox.height;

  var _node$getCenter = node.getCenter(),
      x = _node$getCenter.x,
      y = _node$getCenter.y;

  var rect = ctx.makeRoundedRectangle(x, y, width, height, 3);
  rect.stroke = node.getStyle("background-color");
  rect.fill = node.getStyle("background-color");
}

function drawLine(node, ctx) {
  var linkingPoints = node.getLinkingPoints();
  var line = ctx.makeLine(linkingPoints.left.x, linkingPoints.left.y, linkingPoints.right.x, linkingPoints.right.y);
  var parent = node.parent || node;
  line.stroke = parent.getStyle("line-color");
  line.linewidth = parent.getStyle("line-width");
}

function drawText(node, ctx) {
  var _node$getCenter2 = node.getCenter(),
      x = _node$getCenter2.x,
      y = _node$getCenter2.y;

  var text = new Two.Text(node.content, x, y);
  text.color = node.getStyle("color");
  text.size = node.getStyle("font-size");
  ctx.add(text);
}

/* harmony default export */ __webpack_exports__["default"] = (drawNode);

/***/ }),

/***/ "./js/renderer/index.js":
/*!******************************!*\
  !*** ./js/renderer/index.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _draw_link_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw-link.js */ "./js/renderer/draw-link.js");
/* harmony import */ var _draw_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./draw-node.js */ "./js/renderer/draw-node.js");
/* harmony import */ var two_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! two.js */ "../node_modules/two.js/build/two.module.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




/*
{ width: 500, height: 500 }
*/

var Renderer = /*#__PURE__*/function () {
  function Renderer(twoCtx, options) {
    _classCallCheck(this, Renderer);

    this.two = twoCtx;
    this.options = options;
  }

  _createClass(Renderer, [{
    key: "render",
    value: function render(mindMap) {
      var _this = this;

      this.two.clear();
      mindMap.getRootNode().eachNode(function (node) {
        node.children.forEach(function (child) {
          Object(_draw_link_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node, child, _this.two, mindMap.isHorizontalLayout());
        });
        Object(_draw_node_js__WEBPACK_IMPORTED_MODULE_1__["default"])(node, _this.two, 1);
      });
      this.two.update();
    }
  }]);

  return Renderer;
}();

/* harmony default export */ __webpack_exports__["default"] = (Renderer);

/***/ }),

/***/ "./js/sample/random-color.js":
/*!***********************************!*\
  !*** ./js/sample/random-color.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var colors = ["#FFC312", "#C4E538", "#12CBC4", "#FDA7DF", "#ED4C67", "#F79F1F", "#A3CB38", "#1289A7", "#D980FA", "#B53471", "#833471", "#9980FA", "#0652DD", "#009432", "#EE5A24", "#EA2027", "#006266", "#5758BB", "#6F1E51"];

function randomInt(max) {
  return Math.floor(Math.random() * max);
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var index = randomInt(colors.length);
  return colors[index];
});

/***/ }),

/***/ "./js/structure/node.js":
/*!******************************!*\
  !*** ./js/structure/node.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var two_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! two.js */ "../node_modules/two.js/build/two.module.js");
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./style */ "./js/structure/style.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



var PEM = 18;
var DEFAULT_OPTIONS = {
  horizontal_gap: PEM,
  vertical_gap: PEM
};

var Node = /*#__PURE__*/function () {
  function Node(data) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var isolated = arguments.length > 2 ? arguments[2] : undefined;
    var parent = arguments.length > 3 ? arguments[3] : undefined;

    _classCallCheck(this, Node);

    if (data instanceof Node) return data;
    options = Object.assign({}, DEFAULT_OPTIONS, options);
    this.options = options;
    this.id = data.id;
    this.data = data;
    this.content = data.name || data.content;
    this.vgap = this.hgap = 0;
    this.x = this.y = 0;
    /* Next milestone */

    this.style = data["style"] && new _style__WEBPACK_IMPORTED_MODULE_1__["default"](data["style"]);
    this.shape = null;
    this.type = null; // box | line

    /* end */

    this.depth = parent == null ? 0 : parent.depth + 1;
    this.parent = parent;
    this.children = [];
    this.className = "";
    this.decideClassName();
    this.width = this.getWidth();
    this.height = this.getHeight();
    this.addGap(options.horizontal_gap, options.vertical_gap);

    if (!isolated && !data.isCollapsed) {
      if (!this.data.isCollapsed) {
        var children = this.data.children || [];

        var _iterator = _createForOfIteratorHelper(children),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var item = _step.value;
            var child = new Node(item, options, false, this);
            this.children.push(child);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
  }

  _createClass(Node, [{
    key: "decideClassName",
    value: function decideClassName() {
      switch (this.depth) {
        case 0:
          this.className = "root";
          break;

        case 1:
          this.className = "main-branch";
          break;

        default:
          this.className = "sub-branch";
      }
    }
  }, {
    key: "getStyle",
    value: function getStyle(attribute) {
      var style = this.getStyleObject();
      var value = style.getAttribute(attribute);

      if ((value == "inherit" || value == null) && this.parent != null) {
        return this.parent.getStyle(attribute);
      } else {
        return value;
      }
    }
  }, {
    key: "getStyleObject",
    value: function getStyleObject() {
      if (this.style) {
        return this.style.mergeMissingAttribute(this.getClassStyle());
      } else {
        return this.getClassStyle();
      }
    }
  }, {
    key: "getClassStyle",
    value: function getClassStyle() {
      return this.options.theme.getClass(this.className);
    }
  }, {
    key: "clearStyle",
    value: function clearStyle() {
      this.style = null;
    }
  }, {
    key: "isRoot",
    value: function isRoot() {
      return this.depth === 0;
    }
  }, {
    key: "addGap",
    value: function addGap(hgap, vgap) {
      this.hgap += hgap;
      this.vgap += vgap;
      this.width += 2 * hgap;
      this.height += 2 * vgap;
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      if (this.isRoot()) {
        return this.getStyle("font-size") * 2.4;
      }

      return this.getStyle("font-size") * 1.6;
    }
  }, {
    key: "getWidth",
    value: function getWidth() {
      var text = new two_js__WEBPACK_IMPORTED_MODULE_0__["default"].Text(this.content, 0, 0);
      text.size = this.getStyle("font-size");

      if (this.isRoot()) {
        return text.getBoundingClientRect().width * 1.5 + this.getStyle("font-size") * 1.6;
      }

      return text.getBoundingClientRect().width + this.getStyle("font-size") * 1.6;
    }
  }, {
    key: "eachNode",
    value: function eachNode(callback) {
      var nodes = [this];
      var current = null;

      while (current = nodes.pop()) {
        callback(current);
        nodes = nodes.concat(current.children);
      }
    }
  }, {
    key: "getBox",
    value: function getBox() {
      return {
        width: Math.floor(this.width - this.hgap * 2),
        height: Math.floor(this.height - this.vgap * 2),
        x: Math.floor(this.x + this.hgap),
        y: Math.floor(this.y - this.vgap)
      };
    }
  }, {
    key: "getCenter",
    value: function getCenter() {
      return {
        x: this.x + this.width / 2,
        y: this.y + this.height / 2
      };
    }
  }, {
    key: "getLinkingPoints",
    value: function getLinkingPoints() {
      var _this$getCenter = this.getCenter(),
          x = _this$getCenter.x,
          y = _this$getCenter.y;

      var _this$getBox = this.getBox(),
          width = _this$getBox.width,
          height = _this$getBox.height;

      var data = {
        top: {
          x: x,
          y: Math.round(y - height / 2)
        },
        right: {
          x: Math.round(x + width / 2),
          y: y
        },
        bottom: {
          x: x,
          y: Math.round(y + height / 2)
        },
        left: {
          x: Math.round(x - width / 2),
          y: y
        }
      };

      if (this.getStyle("shape") == "line") {
        var tmp = {
          right: {
            x: Math.round(x + width / 2),
            y: Math.round(y + height / 2)
          },
          left: {
            x: Math.round(x - width / 2),
            y: Math.round(y + height / 2)
          }
        };
        data = Object.assign({}, data, tmp);
      }

      return data;
    }
  }, {
    key: "getBoundingBox",
    value: function getBoundingBox() {
      var bb = {
        left: Number.MAX_VALUE,
        top: Number.MAX_VALUE,
        width: 0,
        height: 0
      };
      this.eachNode(function (node) {
        bb.left = Math.min(bb.left, node.x);
        bb.top = Math.min(bb.top, node.y);
        bb.width = Math.max(bb.width, node.x + node.width);
        bb.height = Math.max(bb.height, node.y + node.height);
      });
      return bb;
    }
  }, {
    key: "translate",
    value: function translate() {
      var tx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this.eachNode(function (node) {
        node.x += tx;
        node.y += ty;
      });
    }
  }, {
    key: "right2left",
    value: function right2left() {
      var bb = this.getBoundingBox();
      this.eachNode(function (node) {
        node.x = node.x - (node.x - bb.left) * 2 - node.width;
      });
      this.translate(bb.width, 0);
    }
  }, {
    key: "down2up",
    value: function down2up() {
      var bb = this.getBoundingBox();
      this.eachNode(function (node) {
        node.y = node.y - (node.y - bb.top) * 2 - node.height;
      });
      this.translate(0, bb.height);
    }
  }]);

  return Node;
}();

/* harmony default export */ __webpack_exports__["default"] = (Node);

/***/ }),

/***/ "./js/structure/style.js":
/*!*******************************!*\
  !*** ./js/structure/style.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DEFAULT_STYLE = {// "shape": "rounded-rectangle",
  // "background-color": "#aaaaaa",
  // "color": "#666666",
  // "font-size": 13,
  // "font-weight": 400,
  // "font-style": "normal",
  // "line-color": "inherit",
  // "line-width": 2
};

var snakeToCamel = function snakeToCamel(str) {
  return str.replace(/([-_][a-z])/g, function (group) {
    return group.toUpperCase().replace('-', '').replace('_', '');
  });
};

var Style = /*#__PURE__*/function () {
  function Style(style) {
    _classCallCheck(this, Style);

    style = Object.assign({}, DEFAULT_STYLE, style || {});
    this.shape = style["shape"];
    this.backgroundColor = style["background-color"];
    this.fontSize = style["font-size"];
    this.fontFamily = style["font-size"];
    this.fontWeight = style["font-weight"];
    this.fontStyle = style["font-style"];
    this.color = style["color"];
    this.lineColor = style["line-color"];
    this.lineWidth = style["line-width"];
  }

  _createClass(Style, [{
    key: "mergeMissingAttribute",
    value: function mergeMissingAttribute(otherStyle) {
      for (var att in this) {
        if (att in otherStyle && this[att] == null) {
          this[att] = otherStyle[att];
        }
      }

      return this;
    }
  }, {
    key: "getAttribute",
    value: function getAttribute(name) {
      name = snakeToCamel(name);
      return this[name];
    }
  }]);

  return Style;
}();

/* harmony default export */ __webpack_exports__["default"] = (Style);

/***/ }),

/***/ "./js/structure/theme.js":
/*!*******************************!*\
  !*** ./js/structure/theme.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style */ "./js/structure/style.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


var DEFAULT_THEME = {
  "background-color": "#fff",
  "classes": {
    "root": {
      "shape": "rounded_rectangle",
      "background-color": "#F6212D",
      "font-size": 28,
      "font-family": "Arial",
      "color": "#fff",
      "line-color": "#333333",
      "line-width": 4
    },
    "main-branch": {
      "shape": "rounded_rectangle",
      "background-color": "#0288D1",
      "font-size": 20,
      "font-family": "Arial",
      "color": "#333",
      "line-color": "inherit",
      "line-width": 2
    },
    "sub-branch": {
      "shape": "rounded_rectangle",
      "background-color": "none",
      "font-size": 14,
      "font-family": "Arial",
      "color": "#333"
    }
  }
};

var Theme = /*#__PURE__*/function () {
  function Theme(themeObject) {
    _classCallCheck(this, Theme);

    var theme = Object.assign({}, DEFAULT_THEME, themeObject || {});
    this.style = new _style__WEBPACK_IMPORTED_MODULE_0__["default"](theme);
    this.classes = {};

    for (var className in theme["classes"]) {
      this.classes[className] = new _style__WEBPACK_IMPORTED_MODULE_0__["default"](theme.classes[className]);
    }
  }

  _createClass(Theme, [{
    key: "getClass",
    value: function getClass(className) {
      return this.classes[className];
    }
  }]);

  return Theme;
}();

/* harmony default export */ __webpack_exports__["default"] = (Theme);

/***/ }),

/***/ "./js/viewer.js":
/*!**********************!*\
  !*** ./js/viewer.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var two_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! two.js */ "../node_modules/two.js/build/two.module.js");
/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderer */ "./js/renderer/index.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }



/*
{ width: 500, height: 500 }
*/

var MindmapViewer = /*#__PURE__*/function () {
  function MindmapViewer(selector, options) {
    _classCallCheck(this, MindmapViewer);

    var el = document.querySelector(selector);

    if (el == null) {
      throw "Invalid selector";
    }

    this.container = el;
    this.width = el.offsetWidth;
    this.height = el.offsetHeight;
    this.two = new two_js__WEBPACK_IMPORTED_MODULE_0__["default"]({
      width: this.width,
      height: this.height
    }).appendTo(el);
    this.renderer = new _renderer__WEBPACK_IMPORTED_MODULE_1__["default"](this.two, options);
    this.scale = 1;
    this.center = {
      x: this.offsetWidth / 2,
      y: this.offsetHeight / 2
    };
    this.bindMouseEvent();
    this.bindMouseDrag();
    this.mindMap = null;
  }

  _createClass(MindmapViewer, [{
    key: "setScale",
    value: function setScale(scale) {
      if (scale <= 0) {
        raise("Scale must be greater than 0");
      } else {
        this.scale = scale;
        this.two.scene.scale = this.scale;
        this.two.update();
      }
    }
  }, {
    key: "render",
    value: function render(mindMap) {
      this.mindMap = mindMap;
      this.container.style.backgroundColor = mindMap.theme.style.getAttribute("background-color");
      this.renderer.render(mindMap);
    }
  }, {
    key: "zoomIn",
    value: function zoomIn(percent) {
      var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.zoomBy(percent, x, y);
    }
  }, {
    key: "zoomOut",
    value: function zoomOut(percent) {
      var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.zoomBy(-percent);
    }
  }, {
    key: "zoomBy",
    value: function zoomBy(percent) {
      var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var dx = x * (this.scale + percent) - x * this.scale;
      var dy = y * (this.scale + percent) - y * this.scale;
      this.two.scene.scale = this.scale = this.scale + percent;
      this.translateBy(-dx, -dy);
      this.two.update();
    }
  }, {
    key: "centerView",
    value: function centerView() {
      var clientRect = this.mindMap.getBoundingBox();
      var centerX = (clientRect.left + clientRect.width / 2) * this.scale;
      var centerY = (clientRect.top + clientRect.height / 2) * this.scale;
      var clientCenterX = this.width / 2;
      var clientCenterY = this.height / 2;
      var dx = clientCenterX - centerX;
      var dy = clientCenterY - centerY;
      this.two.scene.translation.set(0, 0);
      this.two.scene.translation.set(dx, dy);
    }
  }, {
    key: "fitView",
    value: function fitView() {
      var clientRect = this.mindMap.getBoundingBox();
      var scaleX = this.width / clientRect.width;
      var scaleY = this.height / clientRect.height;
      this.scale = Math.min(scaleX, scaleY);
      this.two.scene.scale = this.scale;
      this.centerView();
      this.two.update();
    }
  }, {
    key: "translateBy",
    value: function translateBy(dx, dy) {
      this.two.scene.translation.add(dx, dy);
      this.two.update();
    }
  }, {
    key: "bindMouseEvent",
    value: function bindMouseEvent() {
      var _this = this;

      var stage = this.two.renderer.domElement;
      stage.addEventListener("wheel", function (e) {
        e.stopPropagation();
        e.preventDefault();
        var dy = e.deltaY / 100;

        _this.zoomBy(dy, e.clientX, e.clientY);
      });
    }
  }, {
    key: "bindMouseDrag",
    value: function bindMouseDrag() {
      var _this2 = this;

      var stage = this.two.renderer.domElement;

      var onDrag = function onDrag(e) {
        var dx = e.movementX;
        var dy = e.movementY;

        _this2.translateBy(dx, dy);
      };

      var onDragEnd = function onDragEnd(e) {
        stage.removeEventListener("mousemove", onDrag);
        stage.removeEventListener("mouseup", onDragEnd);
      };

      stage.addEventListener("mousedown", function (e) {
        e.stopPropagation();
        e.preventDefault();
        stage.addEventListener("mousemove", onDrag);
        stage.addEventListener("mouseup", onDragEnd);
      });
    }
  }, {
    key: "getSvgData",
    value: function getSvgData() {
      var svgText = this.container.innerHTML;

      if (!svgText.match(/xmlns=\"/im)) {
        svgText = svgText.replace("<svg ", '<svg xmlns="http://www.w3.org/2000/svg" ');
      }

      return svgText;
    }
  }, {
    key: "downloadDataAsFile",
    value: function downloadDataAsFile(data, filename) {
      var element = document.createElement("a");
      element.setAttribute("href", data);
      element.setAttribute("download", filename);
      element.style.display = "none";
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }
  }, {
    key: "exportSvg",
    value: function exportSvg() {
      var filename = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "mindmap.svg";
      this.downloadDataAsFile("data:image/svg+xml;utf8," + encodeURIComponent(this.getSvgData()), filename);
    }
  }, {
    key: "exportPng",
    value: function exportPng() {
      var _this3 = this;

      var filename = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "mindmap.png";
      var bb = this.mindMap.getBoundingBox(); // backup current value

      var scale = this.two.scene.scale;
      var translation = this.two.scene.translation.clone(); // set svg full size

      this.two.scene.scale = 1;
      this.two.scene.translation.set(0, 0);
      this.two.width = bb.width;
      this.two.height = bb.height; // get svg data

      this.two.update();
      var svgText = this.getSvgData(); // restore original size

      this.two.width = this.width;
      this.two.height = this.height;
      this.two.scene.scale = scale;
      this.two.scene.translation.copy(translation);
      this.two.update();
      var fill = this.mindMap.theme.style.getAttribute("background-color");
      this.svgToPng(svgText, 0, fill).then(function (data) {
        return _this3.downloadDataAsFile(data, filename);
      });
    }
    /**
     * This function is shamelessly copy from https://sites.google.com/a/mcpher.com/share/Home/excelquirks/gassnips/svgtopng
     * converts an svg string to base64 png using the domUrl
     * @param {string} svgText the svgtext
     * @param {number} [margin=0] the width of the border - the image size will be height+margin by width+margin
     * @param {string} [fill] optionally backgrund canvas fill
     * @return {Promise} a promise to the bas64 png image
     */

  }, {
    key: "svgToPng",
    value: function svgToPng(svgText) {
      var margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var fill = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var self = this; // convert an svg text to png using the browser

      return new Promise(function (resolve, reject) {
        try {
          // can use the domUrl function from the browser
          var domUrl = window.URL || window.webkitURL || window;

          if (!domUrl) {
            throw new Error("(browser doesnt support this)");
          } // get original size


          var match = svgText.match(/height=\"(\d+)/m);
          var height = match && match[1] ? parseInt(match[1], 10) : 200;
          var match = svgText.match(/width=\"(\d+)/m);
          var width = match && match[1] ? parseInt(match[1], 10) : 200; // it needs a namespace

          if (!svgText.match(/xmlns=\"/im)) {
            svgText = svgText.replace("<svg ", '<svg xmlns="http://www.w3.org/2000/svg" ');
          } // create a canvas element to pass through


          var canvas = document.createElement("canvas");
          canvas.width = width + margin * 2;
          canvas.height = height + margin * 2;
          var ctx = canvas.getContext("2d"); // make a blob from the svg

          var svg = new Blob([svgText], {
            type: "image/svg+xml;charset=utf-8"
          }); // create a dom object for that image

          var url = domUrl.createObjectURL(svg); // create a new image to hold it the converted type

          var img = new Image(); // when the image is loaded we can get it as base64 url

          img.onload = function () {
            // draw it to the canvas
            ctx.drawImage(this, margin, margin); // if it needs some styling, we need a new canvas

            console.log(fill);

            if (fill) {
              var styled = document.createElement("canvas");
              styled.width = canvas.width;
              styled.height = canvas.height;
              var styledCtx = styled.getContext("2d");
              styledCtx.save();
              styledCtx.fillStyle = fill;
              styledCtx.fillRect(0, 0, canvas.width, canvas.height);
              styledCtx.strokeRect(0, 0, canvas.width, canvas.height);
              styledCtx.restore();
              styledCtx.drawImage(canvas, 0, 0);
              canvas = styled;
            } // we don't need the original any more


            domUrl.revokeObjectURL(url); // now we can resolve the promise, passing the base64 url

            resolve(canvas.toDataURL());
          }; // load the image


          img.src = url;
        } catch (err) {
          reject("failed to convert svg to png " + err);
        }
      });
    }
  }]);

  return MindmapViewer;
}();

/* harmony default export */ __webpack_exports__["default"] = (MindmapViewer);

/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9taW5kdHJlZS93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vbWluZHRyZWUvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vbWluZHRyZWUvLi4vbm9kZV9tb2R1bGVzL25vbi1sYXllcmVkLXRpZHktdHJlZS1sYXlvdXQvc3JjL2FsZ29yaXRobS5qcyIsIndlYnBhY2s6Ly9taW5kdHJlZS8uLi9ub2RlX21vZHVsZXMvbm9uLWxheWVyZWQtdGlkeS10cmVlLWxheW91dC9zcmMvaGVscGVycy5qcyIsIndlYnBhY2s6Ly9taW5kdHJlZS8uLi9ub2RlX21vZHVsZXMvbm9uLWxheWVyZWQtdGlkeS10cmVlLWxheW91dC9zcmMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWluZHRyZWUvLi4vbm9kZV9tb2R1bGVzL3R3by5qcy9idWlsZC90d28ubW9kdWxlLmpzIiwid2VicGFjazovL21pbmR0cmVlLy4uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vbWluZHRyZWUvLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vbWluZHRyZWUvLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9oYXJtb255LW1vZHVsZS5qcyIsIndlYnBhY2s6Ly9taW5kdHJlZS8uL2pzL2FsZ29yaXRobXMvYXV0by1sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vbWluZHRyZWUvLi9qcy9hbGdvcml0aG1zL2hvcml6b250YWwtbGF5b3V0LmpzIiwid2VicGFjazovL21pbmR0cmVlLy4vanMvYWxnb3JpdGhtcy9sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vbWluZHRyZWUvLi9qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9taW5kdHJlZS8uL2pzL2xheW91dHMvZG93bndhcmQtb3JnYW5pemF0aW9uYWwuanMiLCJ3ZWJwYWNrOi8vbWluZHRyZWUvLi9qcy9sYXlvdXRzL2luZGV4LmpzIiwid2VicGFjazovL21pbmR0cmVlLy4vanMvbGF5b3V0cy9sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vbWluZHRyZWUvLi9qcy9sYXlvdXRzL2xlZnQtbG9naWNhbC5qcyIsIndlYnBhY2s6Ly9taW5kdHJlZS8uL2pzL2xheW91dHMvcmlnaHQtbG9naWNhbC5qcyIsIndlYnBhY2s6Ly9taW5kdHJlZS8uL2pzL2xheW91dHMvc3RhbmRhcmQuanMiLCJ3ZWJwYWNrOi8vbWluZHRyZWUvLi9qcy9sYXlvdXRzL3Vwd2FyZC1vcmdhbml6YXRpb25hbC5qcyIsIndlYnBhY2s6Ly9taW5kdHJlZS8uL2pzL21pbmRtYXAuanMiLCJ3ZWJwYWNrOi8vbWluZHRyZWUvLi9qcy9wYXJzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbWluZHRyZWUvLi9qcy9wYXJzZXIvdGV4dC1wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vbWluZHRyZWUvLi9qcy9yZW5kZXJlci9kcmF3LWxpbmsuanMiLCJ3ZWJwYWNrOi8vbWluZHRyZWUvLi9qcy9yZW5kZXJlci9kcmF3LW5vZGUuanMiLCJ3ZWJwYWNrOi8vbWluZHRyZWUvLi9qcy9yZW5kZXJlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9taW5kdHJlZS8uL2pzL3NhbXBsZS9yYW5kb20tY29sb3IuanMiLCJ3ZWJwYWNrOi8vbWluZHRyZWUvLi9qcy9zdHJ1Y3R1cmUvbm9kZS5qcyIsIndlYnBhY2s6Ly9taW5kdHJlZS8uL2pzL3N0cnVjdHVyZS9zdHlsZS5qcyIsIndlYnBhY2s6Ly9taW5kdHJlZS8uL2pzL3N0cnVjdHVyZS90aGVtZS5qcyIsIndlYnBhY2s6Ly9taW5kdHJlZS8uL2pzL3ZpZXdlci5qcyJdLCJuYW1lcyI6WyJhdXRvTGF5b3V0Iiwicm9vdCIsImlzSG9yaXpvbnRhbCIsImJiIiwiQm91bmRpbmdCb3giLCJsYXlvdXQiLCJIb3Jpem9udGFsTGF5b3V0IiwiTGF5b3V0IiwidHJlZURhdGEiLCJ4IiwiYWRkQm91bmRpbmdCb3giLCJoZWlnaHQiLCJ3aWR0aCIsImNoaWxkcmVuIiwibGVuZ3RoIiwiaSIsImNvbnZlcnQiLCJUcmVlIiwidHJlZSIsInJlbW92ZUJvdW5kaW5nQm94IiwieSIsImMiLCJhc3NpZ25Db29yZGluYXRlcyIsImJvdW5kaW5nQm94IiwiYXNzaWduTGF5b3V0IiwicmVzdWx0IiwiYm94IiwiRG93bndhcmRPcmdhbml6YXRpb25hbCIsIlJpZ2h0TG9naWNhbCIsIlVwd2FyZE9yZ2FuaXphdGlvbmFsIiwiTGVmdExvZ2ljYWwiLCJTdGFuZGFyZCIsInJvb3ROb2RlIiwib3B0aW9ucyIsImV4dHJhRWRnZXMiLCJtZSIsIkVycm9yIiwibm9kZXMiLCJjb3VudEJ5RGVwdGgiLCJlYWNoTm9kZSIsIm5vZGUiLCJkZXB0aCIsInB1c2giLCJkYXRhIiwiaWQiLCJjZW50WCIsImNlbnRZIiwiaGdhcCIsInZnYXAiLCJhY3R1YWxIZWlnaHQiLCJhY3R1YWxXaWR0aCIsImVkZ2VzIiwiZm9yRWFjaCIsImNoaWxkIiwic291cmNlIiwidGFyZ2V0IiwiY29uY2F0IiwicmlnaHQybGVmdCIsImxlZnRUcmVlIiwiTm9kZSIsInJpZ2h0VHJlZSIsInRyZWVTaXplIiwicmlnaHRUcmVlU2l6ZSIsIk1hdGgiLCJyb3VuZCIsInJldmVyc2UiLCJ0cmFuc2xhdGUiLCJnZXRCb3VuZGluZ0JveCIsInRvcCIsImRvd24ydXAiLCJNaW5kTWFwIiwidGhlbWUiLCJUaGVtZSIsImRvTGF5b3V0IiwicGFyc2UiLCJ0ZXh0IiwibGluZXMiLCJtYXRjaCIsImxldmVsU3RhY2siLCJjdXJyZW50TGV2ZWwiLCJsaW5lIiwiY29udGVudCIsImdldENvbnRlbnQiLCJsZXZlbCIsImdldExldmVsIiwibGFzdEluZGV4IiwicG9wIiwiY29uc29sZSIsImxvZyIsInJlcGxhY2UiLCJsZWFkaW5nV3MiLCJ0cmltIiwibGluZUNvbG9yIiwiZHJhd0xpbmUiLCJhIiwiYiIsInR3byIsImRyYXdWZXJ0aWNhbExpbmsiLCJkcmF3SG9yaXpvbnRhbExpbmsiLCJiZWdpbk5vZGUiLCJlbmROb2RlIiwic3RhcnRQb2ludCIsImVuZFBvaW50IiwiZ2V0TGlua2luZ1BvaW50cyIsImJvdHRvbSIsImlzUm9vdCIsImdldENlbnRlciIsImRyYXdTTGluZSIsInJpZ2h0IiwibGVmdCIsInN0eWxlIiwiYW5jaG9ycyIsInN0YXJ0QW5jaG9yIiwiZW5kQW5jaG9yIiwiVHdvIiwiQW5jaG9yIiwicGF0aCIsIlBhdGgiLCJzdHJva2UiLCJnZXRTdHlsZSIsImxpbmV3aWR0aCIsIm5vRmlsbCIsImFkZCIsImRyYXdQb2ludCIsIm1ha2VDaXJjbGUiLCJmaWxsIiwiZHJhd05vZGUiLCJjdHgiLCJkcmF3U2hhcGUiLCJkcmF3VGV4dCIsImRyYXdSb3VuZGVkUmVjdCIsImdldEJveCIsInJlY3QiLCJtYWtlUm91bmRlZFJlY3RhbmdsZSIsImxpbmtpbmdQb2ludHMiLCJtYWtlTGluZSIsInBhcmVudCIsIlRleHQiLCJjb2xvciIsInNpemUiLCJSZW5kZXJlciIsInR3b0N0eCIsIm1pbmRNYXAiLCJjbGVhciIsImdldFJvb3ROb2RlIiwiZHJhd0xpbmsiLCJpc0hvcml6b250YWxMYXlvdXQiLCJ1cGRhdGUiLCJjb2xvcnMiLCJyYW5kb21JbnQiLCJtYXgiLCJmbG9vciIsInJhbmRvbSIsImluZGV4IiwiUEVNIiwiREVGQVVMVF9PUFRJT05TIiwiaG9yaXpvbnRhbF9nYXAiLCJ2ZXJ0aWNhbF9nYXAiLCJpc29sYXRlZCIsIk9iamVjdCIsImFzc2lnbiIsIm5hbWUiLCJTdHlsZSIsInNoYXBlIiwidHlwZSIsImNsYXNzTmFtZSIsImRlY2lkZUNsYXNzTmFtZSIsImdldFdpZHRoIiwiZ2V0SGVpZ2h0IiwiYWRkR2FwIiwiaXNDb2xsYXBzZWQiLCJpdGVtIiwiYXR0cmlidXRlIiwiZ2V0U3R5bGVPYmplY3QiLCJ2YWx1ZSIsImdldEF0dHJpYnV0ZSIsIm1lcmdlTWlzc2luZ0F0dHJpYnV0ZSIsImdldENsYXNzU3R5bGUiLCJnZXRDbGFzcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNhbGxiYWNrIiwiY3VycmVudCIsInRtcCIsIk51bWJlciIsIk1BWF9WQUxVRSIsIm1pbiIsInR4IiwidHkiLCJERUZBVUxUX1NUWUxFIiwic25ha2VUb0NhbWVsIiwic3RyIiwiZ3JvdXAiLCJ0b1VwcGVyQ2FzZSIsImJhY2tncm91bmRDb2xvciIsImZvbnRTaXplIiwiZm9udEZhbWlseSIsImZvbnRXZWlnaHQiLCJmb250U3R5bGUiLCJsaW5lV2lkdGgiLCJvdGhlclN0eWxlIiwiYXR0IiwiREVGQVVMVF9USEVNRSIsInRoZW1lT2JqZWN0IiwiY2xhc3NlcyIsIk1pbmRtYXBWaWV3ZXIiLCJzZWxlY3RvciIsImVsIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiY29udGFpbmVyIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJhcHBlbmRUbyIsInJlbmRlcmVyIiwic2NhbGUiLCJjZW50ZXIiLCJiaW5kTW91c2VFdmVudCIsImJpbmRNb3VzZURyYWciLCJyYWlzZSIsInNjZW5lIiwicmVuZGVyIiwicGVyY2VudCIsInpvb21CeSIsImR4IiwiZHkiLCJ0cmFuc2xhdGVCeSIsImNsaWVudFJlY3QiLCJjZW50ZXJYIiwiY2VudGVyWSIsImNsaWVudENlbnRlclgiLCJjbGllbnRDZW50ZXJZIiwidHJhbnNsYXRpb24iLCJzZXQiLCJzY2FsZVgiLCJzY2FsZVkiLCJjZW50ZXJWaWV3Iiwic3RhZ2UiLCJkb21FbGVtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJzdG9wUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsImRlbHRhWSIsImNsaWVudFgiLCJjbGllbnRZIiwib25EcmFnIiwibW92ZW1lbnRYIiwibW92ZW1lbnRZIiwib25EcmFnRW5kIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInN2Z1RleHQiLCJpbm5lckhUTUwiLCJmaWxlbmFtZSIsImVsZW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiZGlzcGxheSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNsaWNrIiwicmVtb3ZlQ2hpbGQiLCJkb3dubG9hZERhdGFBc0ZpbGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJnZXRTdmdEYXRhIiwiY2xvbmUiLCJjb3B5Iiwic3ZnVG9QbmciLCJ0aGVuIiwibWFyZ2luIiwic2VsZiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZG9tVXJsIiwid2luZG93IiwiVVJMIiwid2Via2l0VVJMIiwicGFyc2VJbnQiLCJjYW52YXMiLCJnZXRDb250ZXh0Iiwic3ZnIiwiQmxvYiIsInVybCIsImNyZWF0ZU9iamVjdFVSTCIsImltZyIsIkltYWdlIiwib25sb2FkIiwiZHJhd0ltYWdlIiwic3R5bGVkIiwic3R5bGVkQ3R4Iiwic2F2ZSIsImZpbGxTdHlsZSIsImZpbGxSZWN0Iiwic3Ryb2tlUmVjdCIsInJlc3RvcmUiLCJyZXZva2VPYmplY3RVUkwiLCJ0b0RhdGFVUkwiLCJzcmMiLCJlcnIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPO1FDVkE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUI7Ozs7Ozs7Ozs7Ozs7QUMvTXZCO0FBQUE7QUFBQTtBQUFBO0FBQTBDOztBQUUxQztBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkseURBQU07QUFDVixXQUFXLHNCQUFzQjs7QUFFakMsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4QkFBOEI7QUFDbkQ7QUFDQTtBQUNBOztBQUVBLGVBQWUsK0NBQUk7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwREFBMEQ7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBOztBQUU4Qjs7Ozs7Ozs7Ozs7OztBQy9IOUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUEwQztBQUNLOzs7Ozs7Ozs7Ozs7OztBQ0QvQztBQUFBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsU0FBSTs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsa0VBQWtFOztBQUVsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQ0FBaUMsRUFBRTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU8saUZBQWlGLGlCQUFpQjtBQUN0SCxhQUFhLFFBQVEsd0lBQXdJLGVBQWU7QUFDNUs7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOzs7QUFHQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsTUFBTTtBQUN2QixtQkFBbUIsT0FBTztBQUMxQixpSUFBaUksZ0RBQWdEO0FBQ2pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLFNBQVM7QUFDMUIsbUJBQW1CLGVBQWU7QUFDbEMsa0dBQWtHLGVBQWU7QUFDakg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEMsbUJBQW1CLE9BQU87QUFDMUIsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsSUFBSTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCLGlCQUFpQixXQUFXO0FBQzVCLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QixxQkFBcUI7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsaUJBQWlCLE9BQU87QUFDeEIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFlBQVk7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCLGlCQUFpQixPQUFPO0FBQ3hCLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQixtQkFBbUIsVUFBVTtBQUM3QjtBQUNBLGtDQUFrQyxtQkFBbUI7QUFDckQ7QUFDQTs7QUFFQSx3QkFBd0IsaUJBQWlCLGdCQUFnQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0IsbUJBQW1CLFVBQVUsc0JBQXNCLGdCQUFnQjtBQUNuRSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0Esb0JBQW9CLE9BQU8sOEhBQThILG9CQUFvQjtBQUM3SztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCOztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw2QkFBNkIsb0JBQW9CO0FBQ2pEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdEQUF3RCxPQUFPOztBQUUvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlOztBQUVmOztBQUVBOztBQUVBLGFBQWE7O0FBRWI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXOztBQUVYOztBQUVBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsMEJBQTBCOztBQUVuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsMEJBQTBCOztBQUVuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixpQkFBaUIsT0FBTztBQUN4QixtQkFBbUIsT0FBTztBQUMxQixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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LG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxPQUFPOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGVBQWU7QUFDakY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7O0FBRWhCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsR0FBRzs7QUFFSCxDQUFDLDZDQUE2QyxTQUFJOztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsdUJBQXVCOztBQUVoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FB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O0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QixxQkFBcUI7O0FBRTVDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsS0FB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Q0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiw4QkFBOEI7QUFDbkQ7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIscUJBQXFCOztBQUU1Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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Q0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSw0QkFBNEIsMEJBQTBCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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RDs7Ozs7O0FBRVk5Riw0RUFBZixFIiwiZmlsZSI6ImpzL21pbmR0cmVlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wibWluZHRyZWVcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wibWluZHRyZWVcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9kaXN0L1wiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2pzL2luZGV4LmpzXCIpO1xuIiwiY2xhc3MgVHJlZSB7XG4gIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIHksIGNoaWxkcmVuKSB7XG4gICAgdGhpcy53ID0gd2lkdGhcbiAgICB0aGlzLmggPSBoZWlnaHRcbiAgICB0aGlzLnkgPSB5XG4gICAgdGhpcy5jID0gY2hpbGRyZW5cbiAgICB0aGlzLmNzID0gY2hpbGRyZW4ubGVuZ3RoXG5cbiAgICB0aGlzLnggPSAwXG4gICAgdGhpcy5wcmVsaW0gPSAwXG4gICAgdGhpcy5tb2QgPSAwXG4gICAgdGhpcy5zaGlmdCA9IDBcbiAgICB0aGlzLmNoYW5nZSA9IDBcbiAgICB0aGlzLnRsID0gbnVsbCAvLyBMZWZ0IHRocmVhZFxuICAgIHRoaXMudHIgPSBudWxsIC8vIFJpZ2h0IHRocmVhZFxuICAgIHRoaXMuZWwgPSBudWxsIC8vIGV4dHJlbWUgbGVmdCBub2Rlc1xuICAgIHRoaXMuZXIgPSBudWxsIC8vIGV4dHJlbWUgcmlnaHQgbm9kZXNcbiAgICAvL3N1bSBvZiBtb2RpZmllcnMgYXQgdGhlIGV4dHJlbWUgbm9kZXNcbiAgICB0aGlzLm1zZWwgPSAwXG4gICAgdGhpcy5tc2VyID0gMFxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEV4dHJlbWVzKHRyZWUpIHtcbiAgaWYgKHRyZWUuY3MgPT09IDApIHtcbiAgICB0cmVlLmVsID0gdHJlZVxuICAgIHRyZWUuZXIgPSB0cmVlXG4gICAgdHJlZS5tc2VsID0gdHJlZS5tc2VyID0gMFxuICB9IGVsc2Uge1xuICAgIHRyZWUuZWwgPSB0cmVlLmNbMF0uZWxcbiAgICB0cmVlLm1zZWwgPSB0cmVlLmNbMF0ubXNlbFxuICAgIHRyZWUuZXIgPSB0cmVlLmNbdHJlZS5jcyAtIDFdLmVyXG4gICAgdHJlZS5tc2VyID0gdHJlZS5jW3RyZWUuY3MgLSAxXS5tc2VyXG4gIH1cbn1cblxuZnVuY3Rpb24gYm90dG9tKHRyZWUpIHtcbiAgcmV0dXJuIHRyZWUueSArIHRyZWUuaFxufVxuXG4vKiBBIGxpbmtlZCBsaXN0IG9mIHRoZSBpbmRleGVzIG9mIGxlZnQgc2libGluZ3MgYW5kIHRoZWlyIGxvd2VzdCB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICovXG5jbGFzcyBJWUwge1xuICBjb25zdHJ1Y3Rvcihsb3dZLCBpbmRleCwgbmV4dCkge1xuICAgIHRoaXMubG93WSA9IGxvd1lcbiAgICB0aGlzLmluZGV4ID0gaW5kZXhcbiAgICB0aGlzLm5leHQgPSBuZXh0XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlSVlMKG1pblksIGksIGloKSB7XG4gIC8vIFJlbW92ZSBzaWJsaW5ncyB0aGF0IGFyZSBoaWRkZW4gYnkgdGhlIG5ldyBzdWJ0cmVlLlxuICB3aGlsZSAoaWggIT09IG51bGwgJiYgbWluWSA+PSBpaC5sb3dZKSB7XG4gICAgLy8gUHJlcGVuZCB0aGUgbmV3IHN1YnRyZWVcbiAgICBpaCA9IGloLm5leHRcbiAgfVxuICByZXR1cm4gbmV3IElZTChtaW5ZLCBpLCBpaClcbn1cblxuZnVuY3Rpb24gZGlzdHJpYnV0ZUV4dHJhKHRyZWUsIGksIHNpLCBkaXN0YW5jZSkge1xuICAvLyBBcmUgdGhlcmUgaW50ZXJtZWRpYXRlIGNoaWxkcmVuP1xuICBpZiAoc2kgIT09IGkgLSAxKSB7XG4gICAgY29uc3QgbnIgPSBpIC0gc2lcbiAgICB0cmVlLmNbc2kgKyAxXS5zaGlmdCArPSBkaXN0YW5jZSAvIG5yXG4gICAgdHJlZS5jW2ldLnNoaWZ0IC09IGRpc3RhbmNlIC8gbnJcbiAgICB0cmVlLmNbaV0uY2hhbmdlIC09IGRpc3RhbmNlIC0gZGlzdGFuY2UgLyBuclxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdmVTdWJ0cmVlKHRyZWUsIGksIHNpLCBkaXN0YW5jZSkge1xuICAvLyBNb3ZlIHN1YnRyZWUgYnkgY2hhbmdpbmcgbW9kLlxuICB0cmVlLmNbaV0ubW9kICs9IGRpc3RhbmNlXG4gIHRyZWUuY1tpXS5tc2VsICs9IGRpc3RhbmNlXG4gIHRyZWUuY1tpXS5tc2VyICs9IGRpc3RhbmNlXG4gIGRpc3RyaWJ1dGVFeHRyYSh0cmVlLCBpLCBzaSwgZGlzdGFuY2UpXG59XG5cbmZ1bmN0aW9uIG5leHRMZWZ0Q29udG91cih0cmVlKSB7XG4gIHJldHVybiB0cmVlLmNzID09PSAwID8gdHJlZS50bCA6IHRyZWUuY1swXVxufVxuXG5mdW5jdGlvbiBuZXh0UmlnaHRDb250b3VyKHRyZWUpIHtcbiAgcmV0dXJuIHRyZWUuY3MgPT09IDAgPyB0cmVlLnRyIDogdHJlZS5jW3RyZWUuY3MgLSAxXVxufVxuXG5mdW5jdGlvbiBzZXRMZWZ0VGhyZWFkKHRyZWUsIGksIGNsLCBtb2RzdW1jbCkge1xuICBjb25zdCBsaSA9IHRyZWUuY1swXS5lbFxuICBsaS50bCA9IGNsXG4gIC8vIENoYW5nZSBtb2Qgc28gdGhhdCB0aGUgc3VtIG9mIG1vZGlmaWVyIGFmdGVyIGZvbGxvd2luZyB0aHJlYWQgaXMgY29ycmVjdC5cbiAgY29uc3QgZGlmZiA9IChtb2RzdW1jbCAtIGNsLm1vZCkgLSB0cmVlLmNbMF0ubXNlbFxuICBsaS5tb2QgKz0gZGlmZlxuICAvLyBDaGFuZ2UgcHJlbGltaW5hcnkgeCBjb29yZGluYXRlIHNvIHRoYXQgdGhlIG5vZGUgZG9lcyBub3QgbW92ZS5cbiAgbGkucHJlbGltIC09IGRpZmZcbiAgLy8gVXBkYXRlIGV4dHJlbWUgbm9kZSBhbmQgaXRzIHN1bSBvZiBtb2RpZmllcnMuXG4gIHRyZWUuY1swXS5lbCA9IHRyZWUuY1tpXS5lbFxuICB0cmVlLmNbMF0ubXNlbCA9IHRyZWUuY1tpXS5tc2VsXG59XG5cbi8vIFN5bW1ldHJpY2FsIHRvIHNldExlZnRUaHJlYWRcbmZ1bmN0aW9uIHNldFJpZ2h0VGhyZWFkKHRyZWUsIGksIHNyLCBtb2RzdW1zcikge1xuICBjb25zdCByaSA9IHRyZWUuY1tpXS5lclxuICByaS50ciA9IHNyXG4gIGNvbnN0IGRpZmYgPSAobW9kc3Vtc3IgLSBzci5tb2QpIC0gdHJlZS5jW2ldLm1zZXJcbiAgcmkubW9kICs9IGRpZmZcbiAgcmkucHJlbGltIC09IGRpZmZcbiAgdHJlZS5jW2ldLmVyID0gdHJlZS5jW2kgLSAxXS5lclxuICB0cmVlLmNbaV0ubXNlciA9IHRyZWUuY1tpIC0gMV0ubXNlclxufVxuXG5mdW5jdGlvbiBzZXBlcmF0ZSh0cmVlLCBpLCBpaCkge1xuICAvLyBSaWdodCBjb250b3VyIG5vZGUgb2YgbGVmdCBzaWJsaW5ncyBhbmQgaXRzIHN1bSBvZiBtb2RpZmllcnMuXG4gIGxldCBzciA9IHRyZWUuY1tpIC0gMV1cbiAgbGV0IG1zc3IgPSBzci5tb2RcbiAgLy8gTGVmdCBjb250b3VyIG5vZGUgb2YgcmlnaHQgc2libGluZ3MgYW5kIGl0cyBzdW0gb2YgbW9kaWZpZXJzLlxuICBsZXQgY2wgPSB0cmVlLmNbaV1cbiAgbGV0IG1zY2wgPSBjbC5tb2RcbiAgd2hpbGUgKHNyICE9PSBudWxsICYmIGNsICE9PSBudWxsKSB7XG4gICAgaWYgKGJvdHRvbShzcikgPiBpaC5sb3dZKSB7XG4gICAgICBpaCA9IGloLm5leHRcbiAgICB9XG4gICAgLy8gSG93IGZhciB0byB0aGUgbGVmdCBvZiB0aGUgcmlnaHQgc2lkZSBvZiBzciBpcyB0aGUgbGVmdCBzaWRlIG9mIGNsLlxuICAgIGNvbnN0IGRpc3RhbmNlID0gbXNzciArIHNyLnByZWxpbSArIHNyLncgLSAobXNjbCArIGNsLnByZWxpbSlcbiAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICBtc2NsICs9IGRpc3RhbmNlXG4gICAgICBtb3ZlU3VidHJlZSh0cmVlLCBpLCBpaC5pbmRleCwgZGlzdGFuY2UpXG4gICAgfVxuXG4gICAgY29uc3Qgc3kgPSBib3R0b20oc3IpXG4gICAgY29uc3QgY3kgPSBib3R0b20oY2wpXG4gICAgaWYgKHN5IDw9IGN5KSB7XG4gICAgICBzciA9IG5leHRSaWdodENvbnRvdXIoc3IpXG4gICAgICBpZiAoc3IgIT09IG51bGwpIHtcbiAgICAgICAgbXNzciArPSBzci5tb2RcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN5ID49IGN5KSB7XG4gICAgICBjbCA9IG5leHRMZWZ0Q29udG91cihjbClcbiAgICAgIGlmIChjbCAhPT0gbnVsbCkge1xuICAgICAgICBtc2NsICs9IGNsLm1vZFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNldCB0aHJlYWRzIGFuZCB1cGRhdGUgZXh0cmVtZSBub2Rlcy5cbiAgLy8gSW4gdGhlIGZpcnN0IGNhc2UsIHRoZSBjdXJyZW50IHN1YnRyZWUgbXVzdCBiZSB0YWxsZXIgdGhhbiB0aGUgbGVmdCBzaWJsaW5ncy5cbiAgaWYgKHNyID09PSBudWxsICYmIGNsICE9PSBudWxsKSB7XG4gICAgc2V0TGVmdFRocmVhZCh0cmVlLCBpLCBjbCwgbXNjbClcbiAgfSBlbHNlIGlmIChzciAhPT0gbnVsbCAmJiBjbCA9PT0gbnVsbCkge1xuICAgIHNldFJpZ2h0VGhyZWFkKHRyZWUsIGksIHNyLCBtc3NyKVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvc2l0aW9uUm9vdCh0cmVlKSB7XG4gIC8vIFBvc2l0aW9uIHJvb3QgYmV0d2VlbiBjaGlsZHJlbiwgdGFraW5nIGludG8gYWNjb3VudCB0aGVpciBtb2QuXG4gIHRyZWUucHJlbGltID1cbiAgICAodHJlZS5jWzBdLnByZWxpbSArXG4gICAgICB0cmVlLmNbMF0ubW9kICtcbiAgICAgIHRyZWUuY1t0cmVlLmNzIC0gMV0ubW9kICtcbiAgICAgIHRyZWUuY1t0cmVlLmNzIC0gMV0ucHJlbGltICtcbiAgICAgIHRyZWUuY1t0cmVlLmNzIC0gMV0udykgL1xuICAgICAgMiAtXG4gICAgdHJlZS53IC8gMlxufVxuXG5mdW5jdGlvbiBmaXJzdFdhbGsodHJlZSkge1xuICBpZiAodHJlZS5jcyA9PT0gMCkge1xuICAgIHNldEV4dHJlbWVzKHRyZWUpXG4gICAgcmV0dXJuXG4gIH1cblxuICBmaXJzdFdhbGsodHJlZS5jWzBdKVxuICBsZXQgaWggPSB1cGRhdGVJWUwoYm90dG9tKHRyZWUuY1swXS5lbCksIDAsIG51bGwpXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgdHJlZS5jczsgaSsrKSB7XG4gICAgZmlyc3RXYWxrKHRyZWUuY1tpXSlcbiAgICBjb25zdCBtaW5ZID0gYm90dG9tKHRyZWUuY1tpXS5lcilcbiAgICBzZXBlcmF0ZSh0cmVlLCBpLCBpaClcbiAgICBpaCA9IHVwZGF0ZUlZTChtaW5ZLCBpLCBpaClcbiAgfVxuICBwb3NpdGlvblJvb3QodHJlZSlcbiAgc2V0RXh0cmVtZXModHJlZSlcbn1cblxuZnVuY3Rpb24gYWRkQ2hpbGRTcGFjaW5nKHRyZWUpIHtcbiAgbGV0IGQgPSAwXG4gIGxldCBtb2RzdW1kZWx0YSA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlLmNzOyBpKyspIHtcbiAgICBkICs9IHRyZWUuY1tpXS5zaGlmdFxuICAgIG1vZHN1bWRlbHRhICs9IGQgKyB0cmVlLmNbaV0uY2hhbmdlXG4gICAgdHJlZS5jW2ldLm1vZCArPSBtb2RzdW1kZWx0YVxuICB9XG59XG5cbmZ1bmN0aW9uIHNlY29uZFdhbGsodHJlZSwgbW9kc3VtKSB7XG4gIG1vZHN1bSArPSB0cmVlLm1vZFxuICAvLyBTZXQgYWJzb2x1dGUgKG5vLXJlbGF0aXZlKSBob3Jpem9udGFsIGNvb3JkaW5hdGVzLlxuICB0cmVlLnggPSB0cmVlLnByZWxpbSArIG1vZHN1bVxuICBhZGRDaGlsZFNwYWNpbmcodHJlZSlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlLmNzOyBpKyspIHtcbiAgICBzZWNvbmRXYWxrKHRyZWUuY1tpXSwgbW9kc3VtKVxuICB9XG59XG5cbmZ1bmN0aW9uIGxheW91dCh0cmVlKSB7XG4gIGZpcnN0V2Fsayh0cmVlKVxuICBzZWNvbmRXYWxrKHRyZWUsIDApXG59XG5cbmV4cG9ydCB7IFRyZWUsIGxheW91dCB9XG4iLCJpbXBvcnQgeyBsYXlvdXQsIFRyZWUgfSBmcm9tICcuL2FsZ29yaXRobSdcblxuY2xhc3MgQm91bmRpbmdCb3gge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGdhcCAtIHRoZSBnYXAgYmV0d2VlbiBzaWJsaW5nIG5vZGVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b21QYWRkaW5nIC0gdGhlIGhlaWdodCByZXNlcnZlZCBmb3IgY29ubmVjdGlvbiBkcmF3aW5nXG4gICAqL1xuICBjb25zdHJ1Y3RvcihnYXAsIGJvdHRvbVBhZGRpbmcpIHtcbiAgICB0aGlzLmdhcCA9IGdhcFxuICAgIHRoaXMuYm90dG9tUGFkZGluZyA9IGJvdHRvbVBhZGRpbmdcbiAgfVxuXG4gIGFkZEJvdW5kaW5nQm94KHdpZHRoLCBoZWlnaHQpIHtcbiAgICByZXR1cm4geyB3aWR0aDogd2lkdGggKyB0aGlzLmdhcCwgaGVpZ2h0OiBoZWlnaHQgKyB0aGlzLmJvdHRvbVBhZGRpbmcgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY29vcmRpbmF0ZSB3aXRob3V0IHRoZSBib3VuZGluZyBib3ggZm9yIGEgbm9kZVxuICAgKi9cbiAgcmVtb3ZlQm91bmRpbmdCb3goeCwgeSkge1xuICAgIHJldHVybiB7IHg6IHggKyB0aGlzLmdhcCAvIDIsIHkgfVxuICB9XG59XG5cbmNsYXNzIExheW91dCB7XG4gIGNvbnN0cnVjdG9yKGJvdW5kaW5nQm94KSB7XG4gICAgdGhpcy5iYiA9IGJvdW5kaW5nQm94XG4gIH1cblxuICAvKipcbiAgICogTGF5b3V0IHRyZWVEYXRhLlxuICAgKiBSZXR1cm4gbW9kaWZpZWQgdHJlZURhdGEgYW5kIHRoZSBib3VuZGluZyBib3ggZW5jb21wYXNzaW5nIGFsbCB0aGUgbm9kZXMuXG4gICAqIFxuICAgKiBTZWUgZ2V0U2l6ZSgpIGZvciBtb3JlIGV4cGxhbmF0aW9uLlxuICAgKi9cbiAgbGF5b3V0KHRyZWVEYXRhKSB7XG4gICAgY29uc3QgdHJlZSA9IHRoaXMuY29udmVydCh0cmVlRGF0YSlcbiAgICBsYXlvdXQodHJlZSlcbiAgICBjb25zdCB7IGJvdW5kaW5nQm94LCByZXN1bHQgfSA9IHRoaXMuYXNzaWduTGF5b3V0KHRyZWUsIHRyZWVEYXRhKVxuXG4gICAgcmV0dXJuIHsgcmVzdWx0LCBib3VuZGluZ0JveCB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBUcmVlIHRvIGxheW91dCwgd2l0aCBib3VuZGluZyBib3hlcyBhZGRlZCB0byBlYWNoIG5vZGUuXG4gICAqL1xuICBjb252ZXJ0KHRyZWVEYXRhLCB5ID0gMCkge1xuICAgIGlmICh0cmVlRGF0YSA9PT0gbnVsbCkgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5iYi5hZGRCb3VuZGluZ0JveChcbiAgICAgIHRyZWVEYXRhLndpZHRoLFxuICAgICAgdHJlZURhdGEuaGVpZ2h0XG4gICAgKVxuICAgIGxldCBjaGlsZHJlbiA9IFtdXG4gICAgaWYgKHRyZWVEYXRhLmNoaWxkcmVuICYmIHRyZWVEYXRhLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlRGF0YS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZHJlbltpXSA9IHRoaXMuY29udmVydCh0cmVlRGF0YS5jaGlsZHJlbltpXSwgeSArIGhlaWdodClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRyZWUod2lkdGgsIGhlaWdodCwgeSwgY2hpbGRyZW4pXG4gIH1cblxuICAvKipcbiAgICogQXNzaWduIGxheW91dCB0cmVlIHgsIHkgY29vcmRpbmF0ZXMgYmFjayB0byB0cmVlRGF0YSxcbiAgICogd2l0aCBib3VuZGluZyBib3hlcyByZW1vdmVkLlxuICAgKi9cbiAgYXNzaWduQ29vcmRpbmF0ZXModHJlZSwgdHJlZURhdGEpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMuYmIucmVtb3ZlQm91bmRpbmdCb3godHJlZS54LCB0cmVlLnkpXG4gICAgdHJlZURhdGEueCA9IHhcbiAgICB0cmVlRGF0YS55ID0geVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5jLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmFzc2lnbkNvb3JkaW5hdGVzKHRyZWUuY1tpXSwgdHJlZURhdGEuY2hpbGRyZW5baV0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYm91bmRpbmcgYm94IHRoYXQgZW5jb21wYXNzZXMgYWxsIHRoZSBub2Rlcy5cbiAgICogVGhlIHJlc3VsdCBoYXMgYSBzdHJ1Y3R1cmUgb2ZcbiAgICogeyBsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIHRvcDogbnVtYmVyLCBib3R0b206IG51Ym1lcn0uXG4gICAqIFRoaXMgaXMgbm90IHRoZSBzYW1lIGJvdW5kaW5nIGJveCBjb25jZXB0IGFzIHRoZSBgQm91bmRpbmdCb3hgIGNsYXNzXG4gICAqIHVzZWQgdG8gY29uc3RydWN0IGBMYXlvdXRgIGNsYXNzLlxuICAgKi9cbiAgZ2V0U2l6ZSh0cmVlRGF0YSwgYm94ID0gbnVsbCkge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdHJlZURhdGFcbiAgICBpZiAoYm94ID09PSBudWxsKSB7XG4gICAgICBib3ggPSB7IGxlZnQ6IHgsIHJpZ2h0OiB4ICsgd2lkdGgsIHRvcDogeSwgYm90dG9tOiB5ICsgaGVpZ2h0IH1cbiAgICB9XG4gICAgYm94LmxlZnQgPSBNYXRoLm1pbihib3gubGVmdCwgeClcbiAgICBib3gucmlnaHQgPSBNYXRoLm1heChib3gucmlnaHQsIHggKyB3aWR0aClcbiAgICBib3gudG9wID0gTWF0aC5taW4oYm94LnRvcCwgeSlcbiAgICBib3guYm90dG9tID0gTWF0aC5tYXgoYm94LmJvdHRvbSwgeSArIGhlaWdodClcblxuICAgIGlmICh0cmVlRGF0YS5jaGlsZHJlbikge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0cmVlRGF0YS5jaGlsZHJlbikge1xuICAgICAgICB0aGlzLmdldFNpemUoY2hpbGQsIGJveClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYm94XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBkb2VzIGFzc2lnbkNvb3JkaW5hdGVzIGFuZCBnZXRTaXplIGluIG9uZSBwYXNzLlxuICAgKi9cbiAgYXNzaWduTGF5b3V0KHRyZWUsIHRyZWVEYXRhLCBib3ggPSBudWxsKSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLmJiLnJlbW92ZUJvdW5kaW5nQm94KHRyZWUueCwgdHJlZS55KVxuICAgIHRyZWVEYXRhLnggPSB4XG4gICAgdHJlZURhdGEueSA9IHlcblxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdHJlZURhdGFcbiAgICBpZiAoYm94ID09PSBudWxsKSB7XG4gICAgICBib3ggPSB7IGxlZnQ6IHgsIHJpZ2h0OiB4ICsgd2lkdGgsIHRvcDogeSwgYm90dG9tOiB5ICsgaGVpZ2h0IH1cbiAgICB9XG4gICAgYm94LmxlZnQgPSBNYXRoLm1pbihib3gubGVmdCwgeClcbiAgICBib3gucmlnaHQgPSBNYXRoLm1heChib3gucmlnaHQsIHggKyB3aWR0aClcbiAgICBib3gudG9wID0gTWF0aC5taW4oYm94LnRvcCwgeSlcbiAgICBib3guYm90dG9tID0gTWF0aC5tYXgoYm94LmJvdHRvbSwgeSArIGhlaWdodClcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5jLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmFzc2lnbkxheW91dCh0cmVlLmNbaV0sIHRyZWVEYXRhLmNoaWxkcmVuW2ldLCBib3gpXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcmVzdWx0OiB0cmVlRGF0YSwgYm91bmRpbmdCb3g6IGJveCB9XG4gIH1cbn1cblxuZXhwb3J0IHsgTGF5b3V0LCBCb3VuZGluZ0JveCB9XG4iLCJpbXBvcnQgeyBsYXlvdXQsIFRyZWUgfSBmcm9tICcuL2FsZ29yaXRobSdcbmltcG9ydCB7IEJvdW5kaW5nQm94LCBMYXlvdXQgfSBmcm9tICcuL2hlbHBlcnMnXG5cbmV4cG9ydCB7IGxheW91dCwgVHJlZSwgQm91bmRpbmdCb3gsIExheW91dCB9IiwiLyoqXHJcblxuTUlUIExpY2Vuc2VcclxuXHJcbkNvcHlyaWdodCAoYykgMjAxMiAtIDIwMjAgam9ub2JyMSAvIGh0dHA6Ly9qb25vYnIxLmNvbVxyXG5cclxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxyXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxyXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcclxuU09GVFdBUkUuXHJcblxuKi9cclxuXG4odGhpcyB8fCBzZWxmIHx8IHdpbmRvdykuVHdvID0gKGZ1bmN0aW9uKHByZXZpb3VzVHdvKSB7XHJcblxyXG4gIHZhciByb290O1xyXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgcm9vdCA9IHdpbmRvdztcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICByb290ID0gZ2xvYmFsO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICByb290ID0gc2VsZjtcclxuICB9IGVsc2Uge1xyXG4gICAgcm9vdCA9IHRoaXM7XHJcbiAgfVxyXG5cclxuICB2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xyXG4gIC8qKlxyXG4gICAqIEBuYW1lIF9cclxuICAgKiBAaW50ZXJmYWNlXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAZGVzY3JpcHRpb24gQSBjb2xsZWN0aW9uIG9mIHVzZWZ1bCBmdW5jdGlvbnMgYm9ycm93ZWQgYW5kIHJlcHVycG9zZWQgZnJvbSBVbmRlcnNjb3JlLmpzLlxyXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL31cclxuICAgKi9cclxuICB2YXIgXyA9IHtcclxuICAgIC8vIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyDigKIgMS44LjNcclxuICAgIF9pbmRleEFtb3VudDogMCxcclxuICAgIG5hdHVyYWw6IHtcclxuICAgICAgc2xpY2U6IEFycmF5LnByb3RvdHlwZS5zbGljZSxcclxuICAgICAgaW5kZXhPZjogQXJyYXkucHJvdG90eXBlLmluZGV4T2YsXHJcbiAgICAgIGtleXM6IE9iamVjdC5rZXlzLFxyXG4gICAgICBiaW5kOiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCxcclxuICAgICAgY3JlYXRlOiBPYmplY3QuY3JlYXRlXHJcbiAgICB9LFxyXG4gICAgaWRlbnRpdHk6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH0sXHJcbiAgICBpc0FyZ3VtZW50czogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xyXG4gICAgfSxcclxuICAgIGlzRnVuY3Rpb246IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xyXG4gICAgfSxcclxuICAgIGlzU3RyaW5nOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XHJcbiAgICB9LFxyXG4gICAgaXNOdW1iZXI6IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBOdW1iZXJdJztcclxuICAgIH0sXHJcbiAgICBpc0RhdGU6IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSc7XHJcbiAgICB9LFxyXG4gICAgaXNSZWdFeHA6IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJztcclxuICAgIH0sXHJcbiAgICBpc0Vycm9yOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRXJyb3JdJztcclxuICAgIH0sXHJcbiAgICBpc0Zpbml0ZTogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgIHJldHVybiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xyXG4gICAgfSxcclxuICAgIGlzTmFOOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT09ICtvYmo7XHJcbiAgICB9LFxyXG4gICAgaXNCb29sZWFuOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xyXG4gICAgfSxcclxuICAgIGlzTnVsbDogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgIHJldHVybiBvYmogPT09IG51bGw7XHJcbiAgICB9LFxyXG4gICAgaXNVbmRlZmluZWQ6IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XHJcbiAgICB9LFxyXG4gICAgaXNFbXB0eTogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XHJcbiAgICAgIGlmIChpc0FycmF5TGlrZSAmJiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopIHx8IF8uaXNBcmd1bWVudHMob2JqKSkpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xyXG4gICAgICByZXR1cm4gXy5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xyXG4gICAgfSxcclxuICAgIGlzRWxlbWVudDogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcclxuICAgIH0sXHJcbiAgICBpc0FycmF5OiBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xyXG4gICAgfSxcclxuICAgIGlzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xyXG4gICAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcclxuICAgIH0sXHJcbiAgICB0b0FycmF5OiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgaWYgKCFvYmopIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICAgIH1cclxuICAgICAgaWYgKF8uaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xyXG4gICAgICAgIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBfLnZhbHVlcyhvYmopO1xyXG4gICAgfSxcclxuICAgIHJhbmdlOiBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xyXG4gICAgICBpZiAoc3RvcCA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XHJcbiAgICAgICAgc3RhcnQgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIHN0ZXAgPSBzdGVwIHx8IDE7XHJcblxyXG4gICAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xyXG4gICAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xyXG5cclxuICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKywgc3RhcnQgKz0gc3RlcCkge1xyXG4gICAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJhbmdlO1xyXG4gICAgfSxcclxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uKGxpc3QsIGl0ZW0pIHtcclxuICAgICAgaWYgKF8ubmF0dXJhbC5pbmRleE9mKSB7XHJcbiAgICAgICAgcmV0dXJuIF8ubmF0dXJhbC5pbmRleE9mLmNhbGwobGlzdCwgaXRlbSk7XHJcbiAgICAgIH1cclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGxpc3RbaV0gPT09IGl0ZW0pIHtcclxuICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gLTE7XHJcbiAgICB9LFxyXG4gICAgaGFzOiBmdW5jdGlvbihvYmosIGtleSkge1xyXG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XHJcbiAgICB9LFxyXG4gICAgYmluZDogZnVuY3Rpb24oZnVuYywgY3R4KSB7XHJcbiAgICAgIHZhciBuYXR1cmFsID0gXy5uYXR1cmFsLmJpbmQ7XHJcbiAgICAgIGlmIChuYXR1cmFsICYmIGZ1bmMuYmluZCA9PT0gbmF0dXJhbCkge1xyXG4gICAgICAgIHJldHVybiBuYXR1cmFsLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgICBmdW5jLmFwcGx5KGN0eCwgYXJncyk7XHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgZXh0ZW5kOiBmdW5jdGlvbihiYXNlKSB7XHJcbiAgICAgIHZhciBzb3VyY2VzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgb2JqID0gc291cmNlc1tpXTtcclxuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xyXG4gICAgICAgICAgYmFzZVtrXSA9IG9ialtrXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGJhc2U7XHJcbiAgICB9LFxyXG4gICAgZGVmYXVsdHM6IGZ1bmN0aW9uKGJhc2UpIHtcclxuICAgICAgdmFyIHNvdXJjZXMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBvYmogPSBzb3VyY2VzW2ldO1xyXG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XHJcbiAgICAgICAgICBpZiAoYmFzZVtrXSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGJhc2Vba10gPSBvYmpba107XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBiYXNlO1xyXG4gICAgfSxcclxuICAgIGtleXM6IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoXy5uYXR1cmFsLmtleXMpIHtcclxuICAgICAgICByZXR1cm4gXy5uYXR1cmFsLmtleXMob2JqKTtcclxuICAgICAgfVxyXG4gICAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBrIGluIG9iaikge1xyXG4gICAgICAgIGlmIChfLmhhcyhvYmosIGspKSB7XHJcbiAgICAgICAgICBrZXlzLnB1c2goayk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBrZXlzO1xyXG4gICAgfSxcclxuICAgIHZhbHVlczogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XHJcbiAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGsgPSBrZXlzW2ldO1xyXG4gICAgICAgIHZhbHVlcy5wdXNoKG9ialtrXSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgIH0sXHJcbiAgICBlYWNoOiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XHJcbiAgICAgIHZhciBjdHggPSBjb250ZXh0IHx8IHRoaXM7XHJcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaik7XHJcbiAgICAgIHZhciBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBrID0ga2V5cyA/IGtleXNbaV0gOiBpO1xyXG4gICAgICAgIGl0ZXJhdGVlLmNhbGwoY3R4LCBvYmpba10sIGssIG9iaik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG9iajtcclxuICAgIH0sXHJcbiAgICBtYXA6IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcclxuICAgICAgdmFyIGN0eCA9IGNvbnRleHQgfHwgdGhpcztcclxuICAgICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKTtcclxuICAgICAgdmFyIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xyXG4gICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgayA9IGtleXMgPyBrZXlzW2ldIDogaTtcclxuICAgICAgICByZXN1bHRbaV0gPSBpdGVyYXRlZS5jYWxsKGN0eCwgb2JqW2tdLCBrLCBvYmopO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG4gICAgb25jZTogZnVuY3Rpb24oZnVuYykge1xyXG4gICAgICB2YXIgaW5pdCA9IGZhbHNlO1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGluaXQpIHtcclxuICAgICAgICAgIHJldHVybiBmdW5jO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbml0ID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICAgIGFmdGVyOiBmdW5jdGlvbih0aW1lcywgZnVuYykge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgd2hpbGUgKC0tdGltZXMgPCAxKSB7XHJcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH0sXHJcbiAgICB1bmlxdWVJZDogZnVuY3Rpb24ocHJlZml4KSB7XHJcbiAgICAgIHZhciBpZCA9ICsrXy5faW5kZXhBbW91bnQgKyAnJztcclxuICAgICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gQ29uc3RhbnRzXHJcblxyXG4gIHZhciBzaW4gPSBNYXRoLnNpbixcclxuICAgIGNvcyA9IE1hdGguY29zLFxyXG4gICAgYWNvcyA9IE1hdGguYWNvcyxcclxuICAgIGF0YW4yID0gTWF0aC5hdGFuMixcclxuICAgIHNxcnQgPSBNYXRoLnNxcnQsXHJcbiAgICByb3VuZCA9IE1hdGgucm91bmQsXHJcbiAgICBhYnMgPSBNYXRoLmFicyxcclxuICAgIFBJID0gTWF0aC5QSSxcclxuICAgIFRXT19QSSA9IFBJICogMixcclxuICAgIEhBTEZfUEkgPSBQSSAvIDIsXHJcbiAgICBwb3cgPSBNYXRoLnBvdyxcclxuICAgIG1pbiA9IE1hdGgubWluLFxyXG4gICAgbWF4ID0gTWF0aC5tYXg7XHJcblxyXG4gIC8vIExvY2FsaXplZCB2YXJpYWJsZXNcclxuXHJcbiAgdmFyIGNvdW50ID0gMDtcclxuICB2YXIgc2xpY2UgPSBfLm5hdHVyYWwuc2xpY2U7XHJcbiAgdmFyIHBlcmYgPSAoKHJvb3QucGVyZm9ybWFuY2UgJiYgcm9vdC5wZXJmb3JtYW5jZS5ub3cpID8gcm9vdC5wZXJmb3JtYW5jZSA6IERhdGUpO1xyXG4gIHZhciBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xyXG4gIHZhciBnZXRMZW5ndGggPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialsnbGVuZ3RoJ107XHJcbiAgfTtcclxuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XHJcbiAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGNvbGxlY3Rpb24pO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcclxuICB9O1xyXG5cclxuICAvLyBDcm9zcyBicm93c2VyIGRvbSBldmVudHMuXHJcblxyXG4gIHZhciBkb20gPSB7XHJcblxyXG4gICAgdGVtcDogKHJvb3QuZG9jdW1lbnQgPyByb290LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDoge30pLFxyXG5cclxuICAgIGhhc0V2ZW50TGlzdGVuZXJzOiBfLmlzRnVuY3Rpb24ocm9vdC5hZGRFdmVudExpc3RlbmVyKSxcclxuXHJcbiAgICBiaW5kOiBmdW5jdGlvbihlbGVtLCBldmVudCwgZnVuYywgYm9vbCkge1xyXG4gICAgICBpZiAodGhpcy5oYXNFdmVudExpc3RlbmVycykge1xyXG4gICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgISFib29sKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbGVtLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGRvbTtcclxuICAgIH0sXHJcblxyXG4gICAgdW5iaW5kOiBmdW5jdGlvbihlbGVtLCBldmVudCwgZnVuYywgYm9vbCkge1xyXG4gICAgICBpZiAoZG9tLmhhc0V2ZW50TGlzdGVuZXJzKSB7XHJcbiAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVycyhldmVudCwgZnVuYywgISFib29sKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBlbGVtLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGRvbTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0UmVxdWVzdEFuaW1hdGlvbkZyYW1lOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHZhciBsYXN0VGltZSA9IDA7XHJcbiAgICAgIHZhciB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcclxuICAgICAgdmFyIHJlcXVlc3QgPSByb290LnJlcXVlc3RBbmltYXRpb25GcmFtZSwgY2FuY2VsO1xyXG5cclxuICAgICAgaWYoIXJlcXVlc3QpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHJlcXVlc3QgPSByb290W3ZlbmRvcnNbaV0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10gfHwgcmVxdWVzdDtcclxuICAgICAgICAgIGNhbmNlbCA9IHJvb3RbdmVuZG9yc1tpXSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddXHJcbiAgICAgICAgICAgIHx8IHJvb3RbdmVuZG9yc1tpXSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXSB8fCBjYW5jZWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXF1ZXN0ID0gcmVxdWVzdCB8fCBmdW5jdGlvbihjYWxsYmFjaywgZWxlbWVudCkge1xyXG4gICAgICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcclxuICAgICAgICAgIHZhciBpZCA9IHJvb3Quc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTsgfSwgdGltZVRvQ2FsbCk7XHJcbiAgICAgICAgICBsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcclxuICAgICAgICAgIHJldHVybiBpZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGNhbmNlbCA9IGNhbmNlbCB8fCBmdW5jdGlvbihpZCkge1xyXG4gICAgICAgIC8vICAgY2xlYXJUaW1lb3V0KGlkKTtcclxuICAgICAgICAvLyB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXF1ZXN0LmluaXQgPSBfLm9uY2UobG9vcCk7XHJcblxyXG4gICAgICByZXR1cm4gcmVxdWVzdDtcclxuXHJcbiAgICB9XHJcblxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuYW1lIFR3b1xyXG4gICAqIEBjbGFzc1xyXG4gICAqIEBnbG9iYWxcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mdWxsc2NyZWVuPWZhbHNlXSAtIFNldCB0byBgdHJ1ZWAgdG8gYXV0b21hdGljYWxseSBtYWtlIHRoZSBzdGFnZSBhZGFwdCB0byB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgcGFyZW50IGRvY3VtZW50LiBUaGlzIHBhcmFtZXRlciBvdmVycmlkZXMgYHdpZHRoYCBhbmQgYGhlaWdodGAgcGFyYW1ldGVycyBpZiBzZXQgdG8gYHRydWVgLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD02NDBdIC0gVGhlIHdpZHRoIG9mIHRoZSBzdGFnZSBvbiBjb25zdHJ1Y3Rpb24uIFRoaXMgY2FuIGJlIHNldCBhdCBhIGxhdGVyIHRpbWUuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD00ODBdIC0gVGhlIGhlaWdodCBvZiB0aGUgc3RhZ2Ugb24gY29uc3RydWN0aW9uLiBUaGlzIGNhbiBiZSBzZXQgYXQgYSBsYXRlciB0aW1lLlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50eXBlPVR3by5UeXBlcy5zdmddIC0gVGhlIHR5cGUgb2YgcmVuZGVyZXIgdG8gc2V0dXAgZHJhd2luZyB3aXRoLiBTZWUge0BsaW5rICBUd28uVHlwZXN9IGZvciBhdmFpbGFibGUgb3B0aW9ucy5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9zdGFydD1mYWxzZV0gLSBTZXQgdG8gYHRydWVgIHRvIGFkZCB0aGUgaW5zdGFuY2UgdG8gZHJhdyBvbiBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYC4gVGhpcyBpcyBhIGNvbnZlbmllbnQgc3Vic3RpdHV0ZSBmb3Ige0BsaW5rIFR3byNwbGF5fS5cclxuICAgKiBAZGVzY3JpcHRpb24gVGhlIGVudHJ5cG9pbnQgZm9yIFR3by5qcy4gSW5zdGFudGlhdGUgYSBgbmV3IFR3b2AgaW4gb3JkZXIgdG8gc2V0dXAgYSBzY2VuZSB0byByZW5kZXIgdG8uIGBUd29gIGlzIGFsc28gdGhlIHB1YmxpY2x5IGFjY2Vzc2libGUgbmFtZXNwYWNlIHRoYXQgYWxsIG90aGVyIHN1Yi1jbGFzc2VzLCBmdW5jdGlvbnMsIGFuZCB1dGlsaXRpZXMgYXR0YWNoIHRvLlxyXG4gICAqL1xyXG4gIHZhciBUd28gPSByb290LlR3byA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgd2hhdCBSZW5kZXJlciB0byB1c2UgYW5kIHNldHVwIGEgc2NlbmUuXHJcblxyXG4gICAgdmFyIHBhcmFtcyA9IF8uZGVmYXVsdHMob3B0aW9ucyB8fCB7fSwge1xyXG4gICAgICBmdWxsc2NyZWVuOiBmYWxzZSxcclxuICAgICAgd2lkdGg6IDY0MCxcclxuICAgICAgaGVpZ2h0OiA0ODAsXHJcbiAgICAgIHR5cGU6IFR3by5UeXBlcy5zdmcsXHJcbiAgICAgIGF1dG9zdGFydDogZmFsc2VcclxuICAgIH0pO1xyXG5cclxuICAgIF8uZWFjaChwYXJhbXMsIGZ1bmN0aW9uKHYsIGspIHtcclxuICAgICAgaWYgKC9mdWxsc2NyZWVuL2kudGVzdChrKSB8fCAvYXV0b3N0YXJ0L2kudGVzdChrKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzW2tdID0gdjtcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIC8vIFNwZWNpZmllZCBkb21FbGVtZW50IG92ZXJyaWRlcyB0eXBlIGRlY2xhcmF0aW9uIG9ubHkgaWYgdGhlIGVsZW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBkZWNsYXJlZCByZW5kZXJlciB0eXBlLlxyXG4gICAgaWYgKF8uaXNFbGVtZW50KHBhcmFtcy5kb21FbGVtZW50KSkge1xyXG4gICAgICB2YXIgdGFnTmFtZSA9IHBhcmFtcy5kb21FbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgLy8gVE9ETzogUmVjb25zaWRlciB0aGlzIGlmIHN0YXRlbWVudCdzIGxvZ2ljLlxyXG4gICAgICBpZiAoIS9eKENhbnZhc1JlbmRlcmVyLWNhbnZhc3xXZWJHTFJlbmRlcmVyLWNhbnZhc3xTVkdSZW5kZXJlci1zdmcpJC8udGVzdCh0aGlzLnR5cGUrJy0nK3RhZ05hbWUpKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gVHdvLlR5cGVzW3RhZ05hbWVdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUd29bdGhpcy50eXBlXSh0aGlzKTtcclxuICAgIFR3by5VdGlscy5zZXRQbGF5aW5nLmNhbGwodGhpcywgcGFyYW1zLmF1dG9zdGFydCk7XHJcbiAgICB0aGlzLmZyYW1lQ291bnQgPSAwO1xyXG5cclxuICAgIGlmIChwYXJhbXMuZnVsbHNjcmVlbikge1xyXG5cclxuICAgICAgdmFyIGZpdHRlZCA9IF8uYmluZChmaXRUb1dpbmRvdywgdGhpcyk7XHJcbiAgICAgIF8uZXh0ZW5kKGRvY3VtZW50LmJvZHkuc3R5bGUsIHtcclxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXHJcbiAgICAgICAgbWFyZ2luOiAwLFxyXG4gICAgICAgIHBhZGRpbmc6IDAsXHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnXHJcbiAgICAgIH0pO1xyXG4gICAgICBfLmV4dGVuZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQuc3R5bGUsIHtcclxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxyXG4gICAgICAgIHRvcDogMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJ1xyXG4gICAgICB9KTtcclxuICAgICAgZG9tLmJpbmQocm9vdCwgJ3Jlc2l6ZScsIGZpdHRlZCk7XHJcbiAgICAgIGZpdHRlZCgpO1xyXG5cclxuXHJcbiAgICB9IGVsc2UgaWYgKCFfLmlzRWxlbWVudChwYXJhbXMuZG9tRWxlbWVudCkpIHtcclxuXHJcbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZShwYXJhbXMud2lkdGgsIHBhcmFtcy5oZWlnaHQsIHRoaXMucmF0aW8pO1xyXG4gICAgICB0aGlzLndpZHRoID0gcGFyYW1zLndpZHRoO1xyXG4gICAgICB0aGlzLmhlaWdodCA9IHBhcmFtcy5oZWlnaHQ7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucmVuZGVyZXIuYmluZChUd28uRXZlbnRzLnJlc2l6ZSwgXy5iaW5kKHVwZGF0ZURpbWVuc2lvbnMsIHRoaXMpKTtcclxuICAgIHRoaXMuc2NlbmUgPSB0aGlzLnJlbmRlcmVyLnNjZW5lO1xyXG5cclxuICAgIFR3by5JbnN0YW5jZXMucHVzaCh0aGlzKTtcclxuICAgIGlmIChwYXJhbXMuYXV0b3N0YXJ0KSB7XHJcbiAgICAgIHJhZi5pbml0KCk7XHJcbiAgICB9XHJcblxyXG4gIH07XHJcblxyXG4gIF8uZXh0ZW5kKFR3bywge1xyXG5cclxuICAgIC8vIEFjY2VzcyB0byByb290IGluIG90aGVyIGZpbGVzLlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLnJvb3RcclxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgcm9vdCBvZiB0aGUgc2Vzc2lvbiBjb250ZXh0LiBJbiB0aGUgYnJvd3NlciB0aGlzIGlzIHRoZSBgd2luZG93YCB2YXJpYWJsZS4gVGhpcyB2YXJpZXMgaW4gaGVhZGxlc3MgZW52aXJvbm1lbnRzLlxyXG4gICAgICovXHJcbiAgICByb290OiByb290LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLm5leHRGcmFtZUlEXHJcbiAgICAgKiBAcHJvcGVydHkge0ludGVnZXJ9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIGlkIG9mIHRoZSBuZXh0IHJlcXVlc3RBbmltYXRpb25GcmFtZSBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgbmV4dEZyYW1lSUQ6IG51bGwsXHJcblxyXG4gICAgLy8gUHJpbWl0aXZlXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uQXJyYXlcclxuICAgICAqIEBkZXNjcmlwdGlvbiBBIHNpbXBsZSBwb2x5ZmlsbCBmb3IgRmxvYXQzMkFycmF5LlxyXG4gICAgICovXHJcbiAgICBBcnJheTogcm9vdC5GbG9hdDMyQXJyYXkgfHwgQXJyYXksXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVHlwZXNcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAtIFRoZSBkaWZmZXJlbnQgcmVuZGVyaW5nIHR5cGVzIGF2YWlsYWJlIGluIHRoZSBsaWJyYXJ5LlxyXG4gICAgICovXHJcbiAgICBUeXBlczoge1xyXG4gICAgICB3ZWJnbDogJ1dlYkdMUmVuZGVyZXInLFxyXG4gICAgICBzdmc6ICdTVkdSZW5kZXJlcicsXHJcbiAgICAgIGNhbnZhczogJ0NhbnZhc1JlbmRlcmVyJ1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZXJzaW9uXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBUaGUgY3VycmVudCB3b3JraW5nIHZlcnNpb24gb2YgdGhlIGxpYnJhcnkuXHJcbiAgICAgKi9cclxuICAgIFZlcnNpb246ICd2MC43LjAnLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlB1Ymxpc2hEYXRlXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBUaGUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgcHVibGlzaCBkYXRlIGluIHRoZSBidWlsZCBwcm9jZXNzIHRvIHZlcmlmeSB2ZXJzaW9uIHJlbGVhc2UgY2FuZGlkYXRlcy5cclxuICAgICAqL1xyXG4gICAgUHVibGlzaERhdGU6ICcyMDIwLTAxLTIyVDIxOjE3OjI4LjQyMVonLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLklkZW50aWZpZXJcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIFN0cmluZyBwcmVmaXggZm9yIGFsbCBUd28uanMgb2JqZWN0J3MgaWRzLiBUaGlzIHRyaWNrbGVzIGRvd24gdG8gU1ZHIGlkcy5cclxuICAgICAqL1xyXG4gICAgSWRlbnRpZmllcjogJ3R3by0nLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkV2ZW50c1xyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IC0gTWFwIG9mIHBvc3NpYmxlIGV2ZW50cyBpbiBUd28uanMuXHJcbiAgICAgKi9cclxuICAgIEV2ZW50czoge1xyXG4gICAgICBwbGF5OiAncGxheScsXHJcbiAgICAgIHBhdXNlOiAncGF1c2UnLFxyXG4gICAgICB1cGRhdGU6ICd1cGRhdGUnLFxyXG4gICAgICByZW5kZXI6ICdyZW5kZXInLFxyXG4gICAgICByZXNpemU6ICdyZXNpemUnLFxyXG4gICAgICBjaGFuZ2U6ICdjaGFuZ2UnLFxyXG4gICAgICByZW1vdmU6ICdyZW1vdmUnLFxyXG4gICAgICBpbnNlcnQ6ICdpbnNlcnQnLFxyXG4gICAgICBvcmRlcjogJ29yZGVyJyxcclxuICAgICAgbG9hZDogJ2xvYWQnXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkNvbW1hbmRzXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gLSBNYXAgb2YgcG9zc2libGUgcGF0aCBjb21tYW5kcy4gVGFrZW4gZnJvbSB0aGUgU1ZHIHNwZWNpZmljYXRpb24uXHJcbiAgICAgKi9cclxuICAgIENvbW1hbmRzOiB7XHJcbiAgICAgIG1vdmU6ICdNJyxcclxuICAgICAgbGluZTogJ0wnLFxyXG4gICAgICBjdXJ2ZTogJ0MnLFxyXG4gICAgICBhcmM6ICdBJyxcclxuICAgICAgY2xvc2U6ICdaJ1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5SZXNvbHV0aW9uXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBEZWZhdWx0IGFtb3VudCBvZiB2ZXJ0aWNlcyB0byBiZSB1c2VkIGZvciBpbnRlcnByZXRpbmcgQXJjcyBhbmQgQXJjU2VnbWVudHMuXHJcbiAgICAgKi9cclxuICAgIFJlc29sdXRpb246IDEyLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkluc3RhbmNlc1xyXG4gICAgICogQHByb3BlcnR5IHtUd29bXX0gLSBSZWdpc3RlcmVkIGxpc3Qgb2YgYWxsIFR3by5qcyBpbnN0YW5jZXMgaW4gdGhlIGN1cnJlbnQgc2Vzc2lvbi5cclxuICAgICAqL1xyXG4gICAgSW5zdGFuY2VzOiBbXSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBUd28ubm9Db25mbGljdFxyXG4gICAgICogQGRlc2NyaXB0aW9uIEEgZnVuY3Rpb24gdG8gcmV2ZXJ0IHRoZSBnbG9iYWwgbmFtZXNwYWNlZCBgVHdvYCB2YXJpYWJsZSB0byBpdHMgcHJldmlvdXMgaW5jYXJuYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7VHdvfSBSZXR1cm5zIGFjY2VzcyB0byB0aGUgdG9wLWxldmVsIFR3by5qcyBsaWJyYXJ5IGZvciBsb2NhbCB1c2UuXHJcbiAgICAgKi9cclxuICAgIG5vQ29uZmxpY3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByb290LlR3byA9IHByZXZpb3VzVHdvO1xyXG4gICAgICByZXR1cm4gVHdvO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBUd28udW5pcXVlSWRcclxuICAgICAqIEBkZXNjcmlwdGlvbiBTaW1wbGUgbWV0aG9kIHRvIGFjY2VzcyBhbiBpbmNyZW1lbnRpbmcgdmFsdWUuIFVzZWQgZm9yIGBpZGAgYWxsb2NhdGlvbiBvbiBhbGwgVHdvLmpzIG9iamVjdHMuXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBFdmVyIGluY3JlYXNpbmcgaW50ZWdlci5cclxuICAgICAqL1xyXG4gICAgdW5pcXVlSWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgaWQgPSBjb3VudDtcclxuICAgICAgY291bnQrKztcclxuICAgICAgcmV0dXJuIGlkO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5VdGlsc1xyXG4gICAgICogQGludGVyZmFjZVxyXG4gICAgICogQGltcGxlbWVudHMge199XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQSBob2RnZXBvZGdlIG9mIGhhbmR5IGZ1bmN0aW9ucywgbWF0aCwgYW5kIHByb3BlcnRpZXMgYXJlIHN0b3JlZCBoZXJlLlxyXG4gICAgICovXHJcbiAgICBVdGlsczogXy5leHRlbmQoXywge1xyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuYW1lIFR3by5VdGlscy5wZXJmb3JtYW5jZVxyXG4gICAgICAgKiBAcHJvcGVydHkge0RhdGV9IC0gQSBzcGVjaWFsIGBEYXRlYCBsaWtlIG9iamVjdCB0byBnZXQgdGhlIGN1cnJlbnQgbWlsbGlzIG9mIHRoZSBzZXNzaW9uLiBVc2VkIGludGVybmFsbHkgdG8gY2FsY3VsYXRlIHRpbWUgYmV0d2VlbiBmcmFtZXMuXHJcbiAgICAgICAqIGUuZzogYFR3by5VdGlscy5wZXJmb3JtYW5jZS5ub3coKSAvLyBtaWxsaXNlY29uZHMgc2luY2UgZXBvY2hgXHJcbiAgICAgICAqL1xyXG4gICAgICBwZXJmb3JtYW5jZTogcGVyZixcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmFtZSBUd28uVXRpbHMuZGVmaW5lUHJvcGVydHlcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIEB0aGlzIFR3byNcclxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gVGhlIHByb3BlcnR5IHRvIGFkZCBhbiBlbnVtZXJhYmxlIGdldHRlciAvIHNldHRlciB0by5cclxuICAgICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHNldHVwIHRoZSBmbGFnIGJhc2VkIGdldHRlciAvIHNldHRlciB0aGF0IG1vc3QgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBhcyBpbiBUd28uanMuXHJcbiAgICAgICAqL1xyXG4gICAgICBkZWZpbmVQcm9wZXJ0eTogZnVuY3Rpb24ocHJvcGVydHkpIHtcclxuXHJcbiAgICAgICAgdmFyIG9iamVjdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHNlY3JldCA9ICdfJyArIHByb3BlcnR5O1xyXG4gICAgICAgIHZhciBmbGFnID0gJ19mbGFnJyArIHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XHJcblxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCB7XHJcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbc2VjcmV0XTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgICAgdGhpc1tzZWNyZXRdID0gdjtcclxuICAgICAgICAgICAgdGhpc1tmbGFnXSA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICB9LFxyXG5cclxuICAgICAgSW1hZ2U6IG51bGwsXHJcblxyXG4gICAgICBpc0hlYWRsZXNzOiBmYWxzZSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmFtZSBUd28uVXRpbHMuc2hpbVxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogQHBhcmFtIHtjYW52YXN9IGNhbnZhcyAtIFRoZSBpbnN0YW5jZWQgYENhbnZhc2Agb2JqZWN0IHByb3ZpZGVkIGJ5IGBub2RlLWNhbnZhc2AuXHJcbiAgICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtJbWFnZV0gLSBUaGUgcHJvdG90eXBpY2FsIGBJbWFnZWAgb2JqZWN0IHByb3ZpZGVkIGJ5IGBub2RlLWNhbnZhc2AuIFRoaXMgaXMgb25seSBuZWNlc3NhcnkgdG8gcGFzcyBpZiB5b3UncmUgZ29pbmcgdG8gbG9hZCBiaXRtYXAgaW1hZ2VyeS5cclxuICAgICAgICogQHJldHVybnMge2NhbnZhc30gUmV0dXJucyB0aGUgaW5zdGFuY2VkIGNhbnZhcyBvYmplY3QgeW91IHBhc3NlZCBmcm9tIHdpdGggYWRkaXRpb25hbCBhdHRyaWJ1dGVzIG5lZWRlZCBmb3IgVHdvLmpzLlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgbWV0aG9kIGZvciBkZWZpbmluZyBhbGwgdGhlIGRlcGVuZGVuY2llcyBmcm9tIHRoZSBucG0gcGFja2FnZSBgbm9kZS1jYW52YXNgLiBTZWUgW25vZGUtY2FudmFzXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9ub2RlLWNhbnZhc30gZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gb24gc2V0dGluZyB1cCBIVE1MNSBgPGNhbnZhcyAvPmAgZHJhd2luZyBpbiBhIG5vZGUuanMgZW52aXJvbm1lbnQuXHJcbiAgICAgICAqL1xyXG4gICAgICBzaGltOiBmdW5jdGlvbihjYW52YXMsIEltYWdlKSB7XHJcbiAgICAgICAgVHdvLkNhbnZhc1JlbmRlcmVyLlV0aWxzLnNoaW0oY2FudmFzKTtcclxuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoSW1hZ2UpKSB7XHJcbiAgICAgICAgICBUd28uVXRpbHMuSW1hZ2UgPSBJbWFnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgVHdvLlV0aWxzLmlzSGVhZGxlc3MgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBjYW52YXM7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5hbWUgVHdvLlV0aWxzLnJlbGVhc2VcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICAgICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG9iamVjdCBwYXNzZWQgZm9yIGV2ZW50IGRlYWxsb2NhdGlvbi5cclxuICAgICAgICogQGRlc2NyaXB0aW9uIFJlbGVhc2UgYW4gYXJiaXRyYXJ5IGNsYXNzJyBldmVudHMgZnJvbSB0aGUgVHdvLmpzIGNvcnB1cyBhbmQgcmVjdXJzZSB0aHJvdWdoIGl0cyBjaGlsZHJlbiBhbmQgb3IgdmVydGljZXMuXHJcbiAgICAgICAqL1xyXG4gICAgICByZWxlYXNlOiBmdW5jdGlvbihvYmopIHtcclxuXHJcbiAgICAgICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqLnVuYmluZCkpIHtcclxuICAgICAgICAgIG9iai51bmJpbmQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvYmoudmVydGljZXMpIHtcclxuICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqLnZlcnRpY2VzLnVuYmluZCkpIHtcclxuICAgICAgICAgICAgb2JqLnZlcnRpY2VzLnVuYmluZCgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXy5lYWNoKG9iai52ZXJ0aWNlcywgZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKHYudW5iaW5kKSkge1xyXG4gICAgICAgICAgICAgIHYudW5iaW5kKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9iai5jaGlsZHJlbikge1xyXG4gICAgICAgICAgXy5lYWNoKG9iai5jaGlsZHJlbiwgZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgICAgIFR3by5VdGlscy5yZWxlYXNlKG9iaik7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcblxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuYW1lIFR3by5VdGlscy54aHJcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXHJcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICAgICAqIEByZXR1cm5zIHtYTUxIdHRwUmVxdWVzdH0gVGhlIGNvbnN0cnVjdGVkIGFuZCBjYWxsZWQgWEhSIHJlcXVlc3QuXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBDYW5vbmljYWwgbWV0aG9kIHRvIGluaXRpYXRlIGBHRVRgIHJlcXVlc3RzIGluIHRoZSBicm93c2VyLiBNYWlubHkgdXNlZCBieSB7QGxpbmsgVHdvI2xvYWR9IG1ldGhvZC5cclxuICAgICAgICovXHJcbiAgICAgIHhocjogZnVuY3Rpb24ocGF0aCwgY2FsbGJhY2spIHtcclxuXHJcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBwYXRoKTtcclxuXHJcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0ICYmIHhoci5zdGF0dXMgPT09IDIwMCkge1xyXG4gICAgICAgICAgICBjYWxsYmFjayh4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB4aHIuc2VuZCgpO1xyXG4gICAgICAgIHJldHVybiB4aHI7XHJcblxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuYW1lIFR3by5VdGlscy5DdXJ2ZVxyXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gLSBBZGRpdGlvbmFsIHV0aWxpdHkgY29uc3RhbnQgdmFyaWFibGVzIHJlbGF0ZWQgdG8gY3VydmUgbWF0aCBhbmQgY2FsY3VsYXRpb25zLlxyXG4gICAgICAgKi9cclxuICAgICAgQ3VydmU6IHtcclxuXHJcbiAgICAgICAgQ29sbGluZWFyaXR5RXBzaWxvbjogcG93KDEwLCAtMzApLFxyXG5cclxuICAgICAgICBSZWN1cnNpb25MaW1pdDogMTYsXHJcblxyXG4gICAgICAgIEN1c3BMaW1pdDogMCxcclxuXHJcbiAgICAgICAgVG9sZXJhbmNlOiB7XHJcbiAgICAgICAgICBkaXN0YW5jZTogMC4yNSxcclxuICAgICAgICAgIGFuZ2xlOiAwLFxyXG4gICAgICAgICAgZXBzaWxvbjogTnVtYmVyLkVQU0lMT05cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBMb29rdXAgdGFibGVzIGZvciBhYnNjaXNzYXMgYW5kIHdlaWdodHMgd2l0aCB2YWx1ZXMgZm9yIG4gPSAyIC4uIDE2LlxyXG4gICAgICAgIC8vIEFzIHZhbHVlcyBhcmUgc3ltbWV0cmljLCBvbmx5IHN0b3JlIGhhbGYgb2YgdGhlbSBhbmQgYWRhcHQgYWxnb3JpdGhtXHJcbiAgICAgICAgLy8gdG8gZmFjdG9yIGluIHN5bW1ldHJ5LlxyXG4gICAgICAgIGFic2Npc3NhczogW1xyXG4gICAgICAgICAgWyAgMC41NzczNTAyNjkxODk2MjU3NjQ1MDkxNDg4XSxcclxuICAgICAgICAgIFswLDAuNzc0NTk2NjY5MjQxNDgzMzc3MDM1ODUzMV0sXHJcbiAgICAgICAgICBbICAwLjMzOTk4MTA0MzU4NDg1NjI2NDgwMjY2NTgsMC44NjExMzYzMTE1OTQwNTI1NzUyMjM5NDY1XSxcclxuICAgICAgICAgIFswLDAuNTM4NDY5MzEwMTA1NjgzMDkxMDM2MzE0NCwwLjkwNjE3OTg0NTkzODY2Mzk5Mjc5NzYyNjldLFxyXG4gICAgICAgICAgWyAgMC4yMzg2MTkxODYwODMxOTY5MDg2MzA1MDE3LDAuNjYxMjA5Mzg2NDY2MjY0NTEzNjYxMzk5NiwwLjkzMjQ2OTUxNDIwMzE1MjAyNzgxMjMwMTZdLFxyXG4gICAgICAgICAgWzAsMC40MDU4NDUxNTEzNzczOTcxNjY5MDY2MDY0LDAuNzQxNTMxMTg1NTk5Mzk0NDM5ODYzODY0OCwwLjk0OTEwNzkxMjM0Mjc1ODUyNDUyNjE4OTddLFxyXG4gICAgICAgICAgWyAgMC4xODM0MzQ2NDI0OTU2NDk4MDQ5Mzk0NzYxLDAuNTI1NTMyNDA5OTE2MzI4OTg1ODE3NzM5MCwwLjc5NjY2NjQ3NzQxMzYyNjczOTU5MTU1MzksMC45NjAyODk4NTY0OTc1MzYyMzE2ODM1NjA5XSxcclxuICAgICAgICAgIFswLDAuMzI0MjUzNDIzNDAzODA4OTI5MDM4NTM4MCwwLjYxMzM3MTQzMjcwMDU5MDM5NzMwODcwMjAsMC44MzYwMzExMDczMjY2MzU3OTQyOTk0Mjk4LDAuOTY4MTYwMjM5NTA3NjI2MDg5ODM1NTc2Ml0sXHJcbiAgICAgICAgICBbICAwLjE0ODg3NDMzODk4MTYzMTIxMDg4NDgyNjAsMC40MzMzOTUzOTQxMjkyNDcxOTA3OTkyNjU5LDAuNjc5NDA5NTY4Mjk5MDI0NDA2MjM0MzI3NCwwLjg2NTA2MzM2NjY4ODk4NDUxMDczMjA5NjcsMC45NzM5MDY1Mjg1MTcxNzE3MjAwNzc5NjQwXSxcclxuICAgICAgICAgIFswLDAuMjY5NTQzMTU1OTUyMzQ0OTcyMzMxNTMyMCwwLjUxOTA5NjEyOTIwNjgxMTgxNTkyNTcyNTcsMC43MzAxNTIwMDU1NzQwNDkzMjQwOTM0MTYzLDAuODg3MDYyNTk5NzY4MDk1Mjk5MDc1MTU3OCwwLjk3ODIyODY1ODE0NjA1Njk5MjgwMzkzODBdLFxyXG4gICAgICAgICAgWyAgMC4xMjUyMzM0MDg1MTE0Njg5MTU0NzI0NDE0LDAuMzY3ODMxNDk4OTk4MTgwMTkzNzUyNjkxNSwwLjU4NzMxNzk1NDI4NjYxNzQ0NzI5NjcwMjQsMC43Njk5MDI2NzQxOTQzMDQ2ODcwMzY4OTM4LDAuOTA0MTE3MjU2MzcwNDc0ODU2Njc4NDY1OSwwLjk4MTU2MDYzNDI0NjcxOTI1MDY5MDU0OTFdLFxyXG4gICAgICAgICAgWzAsMC4yMzA0NTgzMTU5NTUxMzQ3OTQwNjU1MjgxLDAuNDQ4NDkyNzUxMDM2NDQ2ODUyODc3OTEyOSwwLjY0MjM0OTMzOTQ0MDM0MDIyMDY0Mzk4NDYsMC44MDE1NzgwOTA3MzMzMDk5MTI3OTQyMDY1LDAuOTE3NTk4Mzk5MjIyOTc3OTY1MjA2NTQ3OCwwLjk4NDE4MzA1NDcxODU4ODE0OTQ3MjgyOTRdLFxyXG4gICAgICAgICAgWyAgMC4xMDgwNTQ5NDg3MDczNDM2NjIwNjYyNDQ3LDAuMzE5MTEyMzY4OTI3ODg5NzYwNDM1NjcxOCwwLjUxNTI0ODYzNjM1ODE1NDA5MTk2NTI5MDcsMC42ODcyOTI5MDQ4MTE2ODU0NzAxNDgwMTk4LDAuODI3MjAxMzE1MDY5NzY0OTkzMTg5Nzk0NywwLjkyODQzNDg4MzY2MzU3MzUxNzMzNjM5MTEsMC45ODYyODM4MDg2OTY4MTIzMzg4NDE1OTczXSxcclxuICAgICAgICAgIFswLDAuMjAxMTk0MDkzOTk3NDM0NTIyMzAwNjI4MywwLjM5NDE1MTM0NzA3NzU2MzM2OTg5NzIwNzQsMC41NzA5NzIxNzI2MDg1Mzg4NDc1MzcyMjY3LDAuNzI0NDE3NzMxMzYwMTcwMDQ3NDE2MTg2MSwwLjg0ODIwNjU4MzQxMDQyNzIxNjIwMDY0ODMsMC45MzcyNzMzOTI0MDA3MDU5MDQzMDc3NTg5LDAuOTg3OTkyNTE4MDIwNDg1NDI4NDg5NTY1N10sXHJcbiAgICAgICAgICBbICAwLjA5NTAxMjUwOTgzNzYzNzQ0MDE4NTMxOTMsMC4yODE2MDM1NTA3NzkyNTg5MTMyMzA0NjA1LDAuNDU4MDE2Nzc3NjU3MjI3Mzg2MzQyNDE5NCwwLjYxNzg3NjI0NDQwMjY0Mzc0ODQ0NjY3MTgsMC43NTU0MDQ0MDgzNTUwMDMwMzM4OTUxMDEyLDAuODY1NjMxMjAyMzg3ODMxNzQzODgwNDY3OSwwLjk0NDU3NTAyMzA3MzIzMjU3NjA3Nzk4ODQsMC45ODk0MDA5MzQ5OTE2NDk5MzI1OTYxNTQyXVxyXG4gICAgICAgIF0sXHJcblxyXG4gICAgICAgIHdlaWdodHM6IFtcclxuICAgICAgICAgIFsxXSxcclxuICAgICAgICAgIFswLjg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODksMC41NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU2XSxcclxuICAgICAgICAgIFswLjY1MjE0NTE1NDg2MjU0NjE0MjYyNjkzNjEsMC4zNDc4NTQ4NDUxMzc0NTM4NTczNzMwNjM5XSxcclxuICAgICAgICAgIFswLjU2ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODksMC40Nzg2Mjg2NzA0OTkzNjY0NjgwNDEyOTE1LDAuMjM2OTI2ODg1MDU2MTg5MDg3NTE0MjY0MF0sXHJcbiAgICAgICAgICBbMC40Njc5MTM5MzQ1NzI2OTEwNDczODk4NzAzLDAuMzYwNzYxNTczMDQ4MTM4NjA3NTY5ODMzNSwwLjE3MTMyNDQ5MjM3OTE3MDM0NTA0MDI5NjFdLFxyXG4gICAgICAgICAgWzAuNDE3OTU5MTgzNjczNDY5Mzg3NzU1MTAyMCwwLjM4MTgzMDA1MDUwNTExODk0NDk1MDM2OTgsMC4yNzk3MDUzOTE0ODkyNzY2Njc5MDE0Njc4LDAuMTI5NDg0OTY2MTY4ODY5NjkzMjcwNjExNF0sXHJcbiAgICAgICAgICBbMC4zNjI2ODM3ODMzNzgzNjE5ODI5NjUxNTA0LDAuMzEzNzA2NjQ1ODc3ODg3Mjg3MzM3OTYyMiwwLjIyMjM4MTAzNDQ1MzM3NDQ3MDU0NDM1NjAsMC4xMDEyMjg1MzYyOTAzNzYyNTkxNTI1MzE0XSxcclxuICAgICAgICAgIFswLjMzMDIzOTM1NTAwMTI1OTc2MzE2NDUyNTEsMC4zMTIzNDcwNzcwNDAwMDI4NDAwNjg2MzA0LDAuMjYwNjEwNjk2NDAyOTM1NDYyMzE4NzQyOSwwLjE4MDY0ODE2MDY5NDg1NzQwNDA1ODQ3MjAsMC4wODEyNzQzODgzNjE1NzQ0MTE5NzE4OTIyXSxcclxuICAgICAgICAgIFswLjI5NTUyNDIyNDcxNDc1Mjg3MDE3Mzg5MzAsMC4yNjkyNjY3MTkzMDk5OTYzNTUwOTEyMjY5LDAuMjE5MDg2MzYyNTE1OTgyMDQzOTk1NTM0OSwwLjE0OTQ1MTM0OTE1MDU4MDU5MzE0NTc3NjMsMC4wNjY2NzEzNDQzMDg2ODgxMzc1OTM1Njg4XSxcclxuICAgICAgICAgIFswLjI3MjkyNTA4Njc3NzkwMDYzMDcxNDQ4MzUsMC4yNjI4MDQ1NDQ1MTAyNDY2NjIxODA2ODg5LDAuMjMzMTkzNzY0NTkxOTkwNDc5OTE4NTIzNywwLjE4NjI5MDIxMDkyNzczNDI1MTQyNjA5NzYsMC4xMjU1ODAzNjk0NjQ5MDQ2MjQ2MzQ2OTQzLDAuMDU1NjY4NTY3MTE2MTczNjY2NDgyNzUzN10sXHJcbiAgICAgICAgICBbMC4yNDkxNDcwNDU4MTM0MDI3ODUwMDA1NjI0LDAuMjMzNDkyNTM2NTM4MzU0ODA4NzYwODQ5OSwwLjIwMzE2NzQyNjcyMzA2NTkyMTc0OTA2NDUsMC4xNjAwNzgzMjg1NDMzNDYyMjYzMzQ2NTI1LDAuMTA2OTM5MzI1OTk1MzE4NDMwOTYwMjU0NywwLjA0NzE3NTMzNjM4NjUxMTgyNzE5NDYxNjBdLFxyXG4gICAgICAgICAgWzAuMjMyNTUxNTUzMjMwODczOTEwMTk0NTg5NSwwLjIyNjI4MzE4MDI2Mjg5NzIzODQxMjA5MDIsMC4yMDc4MTYwNDc1MzY4ODg1MDIzMTI1MjMyLDAuMTc4MTQ1OTgwNzYxOTQ1NzM4MjgwMDQ2NywwLjEzODg3MzUxMDIxOTc4NzIzODQ2MzYwMTgsMC4wOTIxMjE0OTk4Mzc3Mjg0NDc5MTQ0MjE4LDAuMDQwNDg0MDA0NzY1MzE1ODc5NTIwMDIxNl0sXHJcbiAgICAgICAgICBbMC4yMTUyNjM4NTM0NjMxNTc3OTAxOTU4NzY0LDAuMjA1MTk4NDYzNzIxMjk1NjAzOTY1OTI0MSwwLjE4NTUzODM5NzQ3NzkzNzgxMzc0MTcxNjYsMC4xNTcyMDMxNjcxNTgxOTM1MzQ1Njk2MDE5LDAuMTIxNTE4NTcwNjg3OTAzMTg0Njg5NDE0OCwwLjA4MDE1ODA4NzE1OTc2MDIwOTgwNTYzMzMsMC4wMzUxMTk0NjAzMzE3NTE4NjMwMzE4MzI5XSxcclxuICAgICAgICAgIFswLjIwMjU3ODI0MTkyNTU2MTI3Mjg4MDYyMDIsMC4xOTg0MzE0ODUzMjcxMTE1NzY0NTYxMTgzLDAuMTg2MTYxMDAwMDE1NTYyMjExMDI2ODAwNiwwLjE2NjI2OTIwNTgxNjk5MzkzMzU1MzIwMDksMC4xMzk1NzA2Nzc5MjYxNTQzMTQ0NDc4MDQ4LDAuMTA3MTU5MjIwNDY3MTcxOTM1MDExODY5NSwwLjA3MDM2NjA0NzQ4ODEwODEyNDcwOTI2NzQsMC4wMzA3NTMyNDE5OTYxMTcyNjgzNTQ2Mjg0XSxcclxuICAgICAgICAgIFswLjE4OTQ1MDYxMDQ1NTA2ODQ5NjI4NTM5NjcsMC4xODI2MDM0MTUwNDQ5MjM1ODg4NjY3NjM3LDAuMTY5MTU2NTE5Mzk1MDAyNTM4MTg5MzEyMSwwLjE0OTU5NTk4ODgxNjU3NjczMjA4MTUwMTcsMC4xMjQ2Mjg5NzEyNTU1MzM4NzIwNTI0NzYzLDAuMDk1MTU4NTExNjgyNDkyNzg0ODA5OTI1MSwwLjA2MjI1MzUyMzkzODY0Nzg5Mjg2Mjg0MzgsMC4wMjcxNTI0NTk0MTE3NTQwOTQ4NTE3ODA2XVxyXG4gICAgICAgIF1cclxuXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICBkZXZpY2VQaXhlbFJhdGlvOiByb290LmRldmljZVBpeGVsUmF0aW8gfHwgMSxcclxuXHJcbiAgICAgIGdldEJhY2tpbmdTdG9yZVJhdGlvOiBmdW5jdGlvbihjdHgpIHtcclxuICAgICAgICByZXR1cm4gY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcclxuICAgICAgICAgIGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XHJcbiAgICAgICAgICBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XHJcbiAgICAgICAgICBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcclxuICAgICAgICAgIGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5hbWUgVHdvLlV0aWxzLmdldFJhdGlvXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKiBAcGFyYW0ge0NhbnZhcy5jb250ZXh0MkR9IGN0eFxyXG4gICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgcmF0aW8gb2YgYSB1bml0IGluIFR3by5qcyB0byB0aGUgcGl4ZWwgZGVuc2l0eSBvZiBhIHNlc3Npb24ncyBzY3JlZW4uXHJcbiAgICAgICAqIEBzZWUgW0hpZ2ggRFBJIFJlbmRlcmluZ117QGxpbmsgaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvY2FudmFzL2hpZHBpL31cclxuICAgICAgICovXHJcbiAgICAgIGdldFJhdGlvOiBmdW5jdGlvbihjdHgpIHtcclxuICAgICAgICByZXR1cm4gVHdvLlV0aWxzLmRldmljZVBpeGVsUmF0aW8gLyBnZXRCYWNraW5nU3RvcmVSYXRpbyhjdHgpO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuYW1lIFR3by5VdGlscy5zZXRQbGF5aW5nXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKiBAdGhpcyBUd28jXHJcbiAgICAgICAqIEByZXR1cm5zIHtUd299IFRoZSBpbnN0YW5jZSBjYWxsZWQgd2l0aCBmb3IgcG90ZW50aWFsIGNoYWluaW5nLlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb24gSW50ZXJuYWwgY29udmVuaWVuY2UgbWV0aG9kIHRvIHByb3Blcmx5IGRlZmVyIHBsYXkgY2FsbGluZyB1bnRpbCBhZnRlciBhbGwgb2JqZWN0cyBoYXZlIGJlZW4gdXBkYXRlZCB3aXRoIHRoZWlyIG5ld2VzdCBzdHlsZXMuXHJcbiAgICAgICAqL1xyXG4gICAgICBzZXRQbGF5aW5nOiBmdW5jdGlvbihiKSB7XHJcblxyXG4gICAgICAgIHRoaXMucGxheWluZyA9ICEhYjtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5hbWUgVHdvLlV0aWxzLmdldENvbXB1dGVkTWF0cml4XHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKiBAcGFyYW0ge1R3by5TaGFwZX0gb2JqZWN0IC0gVGhlIFR3by5qcyBvYmplY3QgdGhhdCBoYXMgYSBtYXRyaXggcHJvcGVydHkgdG8gY2FsY3VsYXRlIGZyb20uXHJcbiAgICAgICAqIEBwYXJhbSB7VHdvLk1hdHJpeH0gW21hdHJpeF0gLSBUaGUgbWF0cml4IHRvIGFwcGx5IGNhbGN1bGF0ZWQgdHJhbnNmb3JtYXRpb25zIHRvIGlmIGF2YWlsYWJsZS5cclxuICAgICAgICogQHJldHVybnMge1R3by5NYXRyaXh9IFRoZSBjb21wdXRlZCBtYXRyaXggb2YgYSBuZXN0ZWQgb2JqZWN0LiBJZiBubyBgbWF0cml4YCB3YXMgcGFzc2VkIGluIGFyZ3VtZW50cyB0aGVuIGEgYG5ldyBUd28uTWF0cml4YCBpcyByZXR1cm5lZC5cclxuICAgICAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0byBnZXQgdGhlIHdvcmxkIHNwYWNlIHRyYW5zZm9ybWF0aW9uIG9mIGEgZ2l2ZW4gb2JqZWN0IGluIGEgVHdvLmpzIHNjZW5lLlxyXG4gICAgICAgKi9cclxuICAgICAgZ2V0Q29tcHV0ZWRNYXRyaXg6IGZ1bmN0aW9uKG9iamVjdCwgbWF0cml4KSB7XHJcblxyXG4gICAgICAgIG1hdHJpeCA9IChtYXRyaXggJiYgbWF0cml4LmlkZW50aXR5KCkpIHx8IG5ldyBUd28uTWF0cml4KCk7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IG9iamVjdCwgbWF0cmljZXMgPSBbXTtcclxuXHJcbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuX21hdHJpeCkge1xyXG4gICAgICAgICAgbWF0cmljZXMucHVzaChwYXJlbnQuX21hdHJpeCk7XHJcbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbWF0cmljZXMucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdHJpY2VzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgdmFyIG0gPSBtYXRyaWNlc1tpXTtcclxuICAgICAgICAgIHZhciBlID0gbS5lbGVtZW50cztcclxuICAgICAgICAgIG1hdHJpeC5tdWx0aXBseShcclxuICAgICAgICAgICAgZVswXSwgZVsxXSwgZVsyXSwgZVszXSwgZVs0XSwgZVs1XSwgZVs2XSwgZVs3XSwgZVs4XSwgZVs5XSk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcclxuXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5hbWUgVHdvLlV0aWxzLmRlY29tcG9zZU1hdHJpeFxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogQHBhcmFtIHtUd28uTWF0cml4fSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIGRlY29tcG9zZS5cclxuICAgICAgICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgcmVsZXZhbnQgc2tldyB2YWx1ZXMuXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBEZWNvbXBvc2UgYSAyRCAzeDMgTWF0cml4IHRvIGZpbmQgdGhlIHNrZXcuXHJcbiAgICAgICAqL1xyXG4gICAgICBkZWNvbXBvc2VNYXRyaXg6IGZ1bmN0aW9uKG1hdHJpeCkge1xyXG5cclxuICAgICAgICAvLyBUT0RPOiBJbmNsdWRlIHNrZXdYLCBza2V3WVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0cmFuc2xhdGVYOiBtYXRyaXguZSxcclxuICAgICAgICAgICAgdHJhbnNsYXRlWTogbWF0cml4LmYsXHJcbiAgICAgICAgICAgIHNjYWxlWDogbWF0cml4LmEsXHJcbiAgICAgICAgICAgIHNjYWxlWTogbWF0cml4LmQsXHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiBNYXRoLmFzaW4oLSBtYXRyaXguYilcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmFtZSBUd28uVXRpbHMuZXh0cmFjdENTU1RleHRcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IC0gVGhlIENTUyB0ZXh0IGJvZHkgdG8gYmUgcGFyc2VkIGFuZCBleHRyYWN0ZWQuXHJcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVzXSAtIFRoZSBzdHlsZXMgb2JqZWN0IHRvIGFwcGx5IENTUyBrZXkgdmFsdWVzIHRvLlxyXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzdHlsZXNcclxuICAgICAgICogQGRlc2NyaXB0aW9uIFBhcnNlIENTUyB0ZXh0IGJvZHkgYW5kIGFwcGx5IHRoZW0gYXMga2V5IHZhbHVlIHBhaXJzIHRvIGEgSmF2YVNjcmlwdCBvYmplY3QuXHJcbiAgICAgICAqL1xyXG4gICAgICBleHRyYWN0Q1NTVGV4dDogZnVuY3Rpb24odGV4dCwgc3R5bGVzKSB7XHJcblxyXG4gICAgICAgIHZhciBjb21tYW5kcywgY29tbWFuZCwgbmFtZSwgdmFsdWU7XHJcblxyXG4gICAgICAgIGlmICghc3R5bGVzKSB7XHJcbiAgICAgICAgICBzdHlsZXMgPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbW1hbmRzID0gdGV4dC5zcGxpdCgnOycpO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjb21tYW5kID0gY29tbWFuZHNbaV0uc3BsaXQoJzonKTtcclxuICAgICAgICAgIG5hbWUgPSBjb21tYW5kWzBdO1xyXG4gICAgICAgICAgdmFsdWUgPSBjb21tYW5kWzFdO1xyXG4gICAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQobmFtZSkgfHwgXy5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzdHlsZXNbbmFtZV0gPSB2YWx1ZS5yZXBsYWNlKC9cXHMvLCAnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3R5bGVzO1xyXG5cclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmFtZSBUd28uVXRpbHMuZ2V0U3ZnU3R5bGVzXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKiBAcGFyYW0ge1N2Z05vZGV9IG5vZGUgLSBUaGUgU1ZHIG5vZGUgdG8gcGFyc2UuXHJcbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IHN0eWxlc1xyXG4gICAgICAgKiBAZGVzY3JpcHRpb24gR2V0IHRoZSBDU1MgY29tYW5kcyBmcm9tIHRoZSBgc3R5bGVgIGF0dHJpYnV0ZSBvZiBhbiBTVkcgbm9kZSBhbmQgYXBwbHkgdGhlbSBhcyBrZXkgdmFsdWUgcGFpcnMgdG8gYSBKYXZhU2NyaXB0IG9iamVjdC5cclxuICAgICAgICovXHJcbiAgICAgIGdldFN2Z1N0eWxlczogZnVuY3Rpb24obm9kZSkge1xyXG5cclxuICAgICAgICB2YXIgc3R5bGVzID0ge307XHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBUd28uVXRpbHMuZ2V0U3ZnQXR0cmlidXRlcyhub2RlKTtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoYXR0cmlidXRlcy5sZW5ndGgsIG5vZGUuc3R5bGUubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAgIHZhciBjb21tYW5kID0gbm9kZS5zdHlsZVtpXTtcclxuICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2ldO1xyXG5cclxuICAgICAgICAgIGlmIChjb21tYW5kKSB7XHJcbiAgICAgICAgICAgIHN0eWxlc1tjb21tYW5kXSA9IG5vZGUuc3R5bGVbY29tbWFuZF07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoYXR0cmlidXRlKSB7XHJcbiAgICAgICAgICAgIHN0eWxlc1thdHRyaWJ1dGVdID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3R5bGVzO1xyXG5cclxuICAgICAgfSxcclxuXHJcbiAgICAgIGdldFN2Z0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKG5vZGUpIHtcclxuXHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBub2RlLmdldEF0dHJpYnV0ZU5hbWVzKCk7XHJcblxyXG4gICAgICAgIC8vIFJlc2VydmVkIGF0dHJpYnV0ZXMgdG8gcmVtb3ZlXHJcbiAgICAgICAgdmFyIGtleXdvcmRzID0gWydpZCcsICdjbGFzcycsICd0cmFuc2Zvcm0nLCAneG1sbnMnLCAndmlld0JveCddO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXdvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIga2V5d29yZCA9IGtleXdvcmRzW2ldO1xyXG4gICAgICAgICAgdmFyIGluZGV4ID0gXy5pbmRleE9mKGF0dHJpYnV0ZXMsIGtleXdvcmQpO1xyXG4gICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcblxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuYW1lIFR3by5VdGlscy5hcHBseVN2Z1ZpZXdCb3hcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIEBwYXJhbSB7VHdvLlNoYXBlfSBub2RlIC0gVGhlIFR3by5qcyBvYmplY3QgdG8gYXBwbHkgdmlld2JveCBtYXRyaXggdG9cclxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIC0gVGhlIHZpZXdCb3ggdmFsdWUgZnJvbSB0aGUgU1ZHIGF0dHJpYnV0ZVxyXG4gICAgICAgKiBAcmV0dXJucyB7VHdvLlNoYXBlfSBub2RlXHJcbiAgICAgICBAIEBkZXNjcmlwdGlvblxyXG4gICAgICAgKi9cclxuICAgICAgYXBwbHlTdmdWaWV3Qm94OiBmdW5jdGlvbihub2RlLCB2YWx1ZSkge1xyXG5cclxuICAgICAgICB2YXIgZWxlbWVudHMgPSB2YWx1ZS5zcGxpdCgvXFxzLyk7XHJcblxyXG4gICAgICAgIHZhciB4ID0gcGFyc2VGbG9hdChlbGVtZW50c1swXSk7XHJcbiAgICAgICAgdmFyIHkgPSBwYXJzZUZsb2F0KGVsZW1lbnRzWzFdKTtcclxuICAgICAgICB2YXIgd2lkdGggPSBwYXJzZUZsb2F0KGVsZW1lbnRzWzJdKTtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VGbG9hdChlbGVtZW50c1szXSk7XHJcblxyXG4gICAgICAgIHZhciBzID0gTWF0aC5taW4odGhpcy53aWR0aCAvIHdpZHRoLCB0aGlzLmhlaWdodCAvIGhlaWdodCk7XHJcblxyXG4gICAgICAgIG5vZGUudHJhbnNsYXRpb24ueCAtPSB4ICogcztcclxuICAgICAgICBub2RlLnRyYW5zbGF0aW9uLnkgLT0geSAqIHM7XHJcbiAgICAgICAgbm9kZS5zY2FsZSA9IHM7XHJcblxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG5cclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmFtZSBUd28uVXRpbHMuYXBwbHlTdmdBdHRyaWJ1dGVzXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKiBAcGFyYW0ge1N2Z05vZGV9IG5vZGUgLSBBbiBTVkcgTm9kZSB0byBleHRyYXBvbGF0ZSBhdHRyaWJ1dGVzIGZyb20uXHJcbiAgICAgICAqIEBwYXJhbSB7VHdvLlNoYXBlfSBlbGVtIC0gVGhlIFR3by5qcyBvYmplY3QgdG8gYXBwbHkgZXh0cmFwb2xhdGVkIGF0dHJpYnV0ZXMgdG8uXHJcbiAgICAgICAqIEByZXR1cm5zIHtUd28uU2hhcGV9IFRoZSBUd28uanMgb2JqZWN0IHBhc3NlZCBub3cgd2l0aCBhcHBsaWVkIGF0dHJpYnV0ZXMuXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGl0ZXJhdGVzIHRocm91Z2ggYW4gU1ZHIE5vZGUncyBwcm9wZXJ0aWVzIGFuZCBzdG9yZXMgb25lcyBvZiBpbnRlcmVzdC4gSXQgdHJpZXMgdG8gcmVzb2x2ZSBzdHlsZXMgYXBwbGllZCB2aWEgQ1NTIGFzIHdlbGwuXHJcbiAgICAgICAqIEBUT0RPIFJldmVyc2UgY2FsY3VsYXRlIHtAbGluayBUd28uR3JhZGllbnR9cyBmb3IgZmlsbCAvIHN0cm9rZSBvZiBhbnkgZ2l2ZW4gcGF0aC5cclxuICAgICAgICovXHJcbiAgICAgIGFwcGx5U3ZnQXR0cmlidXRlczogZnVuY3Rpb24obm9kZSwgZWxlbSwgcGFyZW50U3R5bGVzKSB7XHJcblxyXG4gICAgICAgIHZhciAgc3R5bGVzID0ge30sIGF0dHJpYnV0ZXMgPSB7fSwgZXh0cmFjdGVkID0ge30sIGksIGtleSwgdmFsdWUsIGF0dHI7XHJcblxyXG4gICAgICAgIC8vIE5vdCBhdmFpbGFibGUgaW4gbm9uIGJyb3dzZXIgZW52aXJvbm1lbnRzXHJcbiAgICAgICAgaWYgKHJvb3QuZ2V0Q29tcHV0ZWRTdHlsZSkge1xyXG4gICAgICAgICAgLy8gQ29udmVydCBDU1NTdHlsZURlY2xhcmF0aW9uIHRvIGEgbm9ybWFsIG9iamVjdFxyXG4gICAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGVzID0gcm9vdC5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xyXG4gICAgICAgICAgaSA9IGNvbXB1dGVkU3R5bGVzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIGtleSA9IGNvbXB1dGVkU3R5bGVzW2ldO1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkU3R5bGVzW2tleV07XHJcbiAgICAgICAgICAgIC8vIEdlY2tvIHJldHVybnMgdW5kZWZpbmVkIGZvciB1bnNldCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgIC8vIFdlYmtpdCByZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlXHJcbiAgICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICBzdHlsZXNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IE5vZGVNYXAgdG8gYSBub3JtYWwgb2JqZWN0XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgYXR0ciA9IG5vZGUuYXR0cmlidXRlc1tpXTtcclxuICAgICAgICAgIGlmICgvc3R5bGUvaS50ZXN0KGF0dHIubm9kZU5hbWUpKSB7XHJcbiAgICAgICAgICAgIFR3by5VdGlscy5leHRyYWN0Q1NTVGV4dChhdHRyLnZhbHVlLCBleHRyYWN0ZWQpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXR0cmlidXRlc1thdHRyLm5vZGVOYW1lXSA9IGF0dHIudmFsdWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBHZXR0aW5nIHRoZSBjb3JyZWN0IG9wYWNpdHkgaXMgYSBiaXQgdHJpY2t5LCBzaW5jZSBTVkcgcGF0aCBlbGVtZW50cyBkb24ndFxyXG4gICAgICAgIC8vIHN1cHBvcnQgb3BhY2l0eSBhcyBhbiBhdHRyaWJ1dGUsIGJ1dCB5b3UgY2FuIGFwcGx5IGl0IHZpYSBDU1MuXHJcbiAgICAgICAgLy8gU28gd2UgdGFrZSB0aGUgb3BhY2l0eSBhbmQgc2V0IChzdHJva2UvZmlsbCktb3BhY2l0eSB0byB0aGUgc2FtZSB2YWx1ZS5cclxuICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoc3R5bGVzLm9wYWNpdHkpKSB7XHJcbiAgICAgICAgICBzdHlsZXNbJ3N0cm9rZS1vcGFjaXR5J10gPSBzdHlsZXMub3BhY2l0eTtcclxuICAgICAgICAgIHN0eWxlc1snZmlsbC1vcGFjaXR5J10gPSBzdHlsZXMub3BhY2l0eTtcclxuICAgICAgICAgIGRlbGV0ZSBzdHlsZXMub3BhY2l0eTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1lcmdlIGF0dHJpYnV0ZXMgYW5kIGFwcGxpZWQgc3R5bGVzIChhdHRyaWJ1dGVzIHRha2UgcHJlY2VkZW5jZSlcclxuICAgICAgICBpZiAocGFyZW50U3R5bGVzKSB7XHJcbiAgICAgICAgICBfLmRlZmF1bHRzKHN0eWxlcywgcGFyZW50U3R5bGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXy5leHRlbmQoc3R5bGVzLCBhdHRyaWJ1dGVzLCBleHRyYWN0ZWQpO1xyXG5cclxuICAgICAgICAvLyBTaW1pbGFybHkgdmlzaWJpbGl0eSBpcyBpbmZsdWVuY2VkIGJ5IHRoZSB2YWx1ZSBvZiBib3RoIGRpc3BsYXkgYW5kIHZpc2liaWxpdHkuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGEgdW5pZmllZCB2YWx1ZSBoZXJlIHdoaWNoIGRlZmF1bHRzIHRvIGB0cnVlYC5cclxuICAgICAgICBzdHlsZXMudmlzaWJsZSA9ICEoXy5pc1VuZGVmaW5lZChzdHlsZXMuZGlzcGxheSkgJiYgL25vbmUvaS50ZXN0KHN0eWxlcy5kaXNwbGF5KSlcclxuICAgICAgICAgIHx8IChfLmlzVW5kZWZpbmVkKHN0eWxlcy52aXNpYmlsaXR5KSAmJiAvaGlkZGVuL2kudGVzdChzdHlsZXMudmlzaWJpbGl0eSkpO1xyXG5cclxuICAgICAgICAvLyBOb3cgaXRlcmF0ZSB0aGUgd2hvbGUgdGhpbmdcclxuICAgICAgICBmb3IgKGtleSBpbiBzdHlsZXMpIHtcclxuICAgICAgICAgIHZhbHVlID0gc3R5bGVzW2tleV07XHJcblxyXG4gICAgICAgICAgc3dpdGNoIChrZXkpIHtcclxuICAgICAgICAgICAgY2FzZSAndHJhbnNmb3JtJzpcclxuICAgICAgICAgICAgICAvLyBUT0RPOiBDaGVjayB0aGlzIG91dCBodHRwczovL2dpdGh1Yi5jb20vcGFwZXJqcy9wYXBlci5qcy9ibG9iL2RldmVsb3Avc3JjL3N2Zy9TdmdJbXBvcnQuanMjTDMxNVxyXG4gICAgICAgICAgICAgIGlmICgvbm9uZS9pLnRlc3QodmFsdWUpKSBicmVhaztcclxuICAgICAgICAgICAgICB2YXIgbSA9IChub2RlLnRyYW5zZm9ybSAmJiBub2RlLnRyYW5zZm9ybS5iYXNlVmFsICYmIG5vZGUudHJhbnNmb3JtLmJhc2VWYWwubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgID8gbm9kZS50cmFuc2Zvcm0uYmFzZVZhbFswXS5tYXRyaXhcclxuICAgICAgICAgICAgICAgIDogKG5vZGUuZ2V0Q1RNID8gbm9kZS5nZXRDVE0oKSA6IG51bGwpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBNaWdodCBoYXBwZW4gd2hlbiB0cmFuc2Zvcm0gc3RyaW5nIGlzIGVtcHR5IG9yIG5vdCB2YWxpZC5cclxuICAgICAgICAgICAgICBpZiAoXy5pc051bGwobSkpIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAvLyAvLyBPcHRpb24gMTogZWRpdCB0aGUgdW5kZXJseWluZyBtYXRyaXggYW5kIGRvbid0IGZvcmNlIGFuIGF1dG8gY2FsYy5cclxuICAgICAgICAgICAgICAvLyB2YXIgbSA9IG5vZGUuZ2V0Q1RNKCk7XHJcbiAgICAgICAgICAgICAgLy8gZWxlbS5fbWF0cml4Lm1hbnVhbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgLy8gZWxlbS5fbWF0cml4LnNldChtLmEsIG0uYiwgbS5jLCBtLmQsIG0uZSwgbS5mKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gT3B0aW9uIDI6IERlY29tcG9zZSBhbmQgaW5mZXIgVHdvLmpzIHJlbGF0ZWQgcHJvcGVydGllcy5cclxuICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtcyA9IFR3by5VdGlscy5kZWNvbXBvc2VNYXRyaXgobSk7XHJcblxyXG4gICAgICAgICAgICAgIGVsZW0udHJhbnNsYXRpb24uc2V0KHRyYW5zZm9ybXMudHJhbnNsYXRlWCwgdHJhbnNmb3Jtcy50cmFuc2xhdGVZKTtcclxuICAgICAgICAgICAgICBlbGVtLnJvdGF0aW9uID0gTWF0aC5QSSAqICh0cmFuc2Zvcm1zLnJvdGF0aW9uIC8gMTgwKTtcclxuICAgICAgICAgICAgICBlbGVtLnNjYWxlID0gbmV3IFR3by5WZWN0b3IodHJhbnNmb3Jtcy5zY2FsZVgsIHRyYW5zZm9ybXMuc2NhbGVZKTtcclxuXHJcbiAgICAgICAgICAgICAgdmFyIHggPSBwYXJzZUZsb2F0KChzdHlsZXMueCArICcnKS5yZXBsYWNlKCdweCcpKTtcclxuICAgICAgICAgICAgICB2YXIgeSA9IHBhcnNlRmxvYXQoKHN0eWxlcy55ICsgJycpLnJlcGxhY2UoJ3B4JykpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBPdmVycmlkZSBiYXNlZCBvbiBhdHRyaWJ1dGVzLlxyXG4gICAgICAgICAgICAgIGlmICh4KSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtLnRyYW5zbGF0aW9uLnggPSB4O1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKHkpIHtcclxuICAgICAgICAgICAgICAgIGVsZW0udHJhbnNsYXRpb24ueSA9IHk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAndmlld0JveCc6XHJcbiAgICAgICAgICAgICAgVHdvLlV0aWxzLmFwcGx5U3ZnVmlld0JveC5jYWxsKHRoaXMsIGVsZW0sIHZhbHVlKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAndmlzaWJsZSc6XHJcbiAgICAgICAgICAgICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBUd28uR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIGVsZW0uX3Zpc2libGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbGVtLnZpc2libGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnc3Ryb2tlLWxpbmVjYXAnOlxyXG4gICAgICAgICAgICAgIGlmIChlbGVtIGluc3RhbmNlb2YgVHdvLkdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtLl9jYXAgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbGVtLmNhcCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdzdHJva2UtbGluZWpvaW4nOlxyXG4gICAgICAgICAgICAgIGlmIChlbGVtIGluc3RhbmNlb2YgVHdvLkdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtLl9qb2luID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxlbS5qb2luID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3N0cm9rZS1taXRlcmxpbWl0JzpcclxuICAgICAgICAgICAgICBpZiAoZWxlbSBpbnN0YW5jZW9mIFR3by5Hcm91cCkge1xyXG4gICAgICAgICAgICAgICAgZWxlbS5fbWl0ZXIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBlbGVtLm1pdGVyID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3N0cm9rZS13aWR0aCc6XHJcbiAgICAgICAgICAgICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBUd28uR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIGVsZW0uX2xpbmV3aWR0aCA9IHBhcnNlRmxvYXQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsZW0ubGluZXdpZHRoID0gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ29wYWNpdHknOlxyXG4gICAgICAgICAgICBjYXNlICdzdHJva2Utb3BhY2l0eSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2ZpbGwtb3BhY2l0eSc6XHJcbiAgICAgICAgICAgICAgLy8gT25seSBhcHBseSBzdHlsZXMgdG8gcmVuZGVyZWQgc2hhcGVzXHJcbiAgICAgICAgICAgICAgLy8gaW4gdGhlIHNjZW5lLlxyXG4gICAgICAgICAgICAgIGlmIChlbGVtIGluc3RhbmNlb2YgVHdvLkdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtLl9vcGFjaXR5ID0gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZWxlbS5vcGFjaXR5ID0gcGFyc2VGbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2ZpbGwnOlxyXG4gICAgICAgICAgICBjYXNlICdzdHJva2UnOlxyXG4gICAgICAgICAgICAgIGlmIChlbGVtIGluc3RhbmNlb2YgVHdvLkdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSAnXycgKyBrZXk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmICgvdXJsXFwoIy4qXFwpL2kudGVzdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzY2VuZSA9IFR3by5VdGlscy5nZXRTY2VuZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGVsZW1ba2V5XSA9IHNjZW5lLmdldEJ5SWQoXHJcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnJlcGxhY2UoL3VybFxcKCMoLiopXFwpL2ksICckMScpKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZWxlbVtrZXldID0gKC9ub25lL2kudGVzdCh2YWx1ZSkpID8gJ3RyYW5zcGFyZW50JyA6IHZhbHVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnaWQnOlxyXG4gICAgICAgICAgICAgIGVsZW0uaWQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAvLyBPdmVyd3JpdHRlbiBpZCBmb3Igbm9uLWNvbmZsaWN0cyBvbiBzYW1lIHBhZ2UgU1ZHIGRvY3VtZW50c1xyXG4gICAgICAgICAgICAgIC8vIFRPRE86IE1ha2UgdGhpcyBub24tZGVzY3J1Y3RpdmVcclxuICAgICAgICAgICAgICBub2RlLmlkID0gdmFsdWUgKyAnLScgKyBUd28uSWRlbnRpZmllciArICdhcHBsaWVkJztcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnY2xhc3MnOlxyXG4gICAgICAgICAgICBjYXNlICdjbGFzc05hbWUnOlxyXG4gICAgICAgICAgICAgIGVsZW0uY2xhc3NMaXN0ID0gdmFsdWUuc3BsaXQoJyAnKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdHlsZXM7XHJcblxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuYW1lIHR3by5VdGlscy5nZXRTY2VuZVxyXG4gICAgICAgKiBAcGFyYW0ge1R3by5TaGFwZX0gbm9kZSAtIFRoZSBjdXJyZW50bHkgYXZhaWxhYmxlIG9iamVjdCBpbiB0aGUgc2NlbmVncmFwaC5cclxuICAgICAgICogQHJldHVybnMge1R3by5Hcm91cH0gLSBUaGUgaGlnaGVzdCBvcmRlciB7QGxpbmsgVHdvLkdyb3VwfSBpbiB0aGUgc2NlbmVncmFwaC5cclxuICAgICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn1cclxuICAgICAgICovXHJcbiAgICAgIGdldFNjZW5lOiBmdW5jdGlvbihub2RlKSB7XHJcblxyXG4gICAgICAgIHdoaWxlIChub2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5vZGUuc2NlbmU7XHJcblxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuYW1lIFR3by5VdGlscy5yZWFkXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSByZWFkIC0gQSBtYXAgb2YgZnVuY3Rpb25zIHRvIHJlYWQgYW55IG51bWJlciBvZiBTVkcgbm9kZSB0eXBlcyBhbmQgY3JlYXRlIFR3by5qcyBlcXVpdmFsZW50cyBvZiB0aGVtLiBQcmltYXJpbHkgdXNlZCBieSB0aGUge0BsaW5rIFR3byNpbnRlcnByZXR9IG1ldGhvZC5cclxuICAgICAgICovXHJcbiAgICAgIHJlYWQ6IHtcclxuXHJcbiAgICAgICAgc3ZnOiBmdW5jdGlvbihub2RlKSB7XHJcblxyXG4gICAgICAgICAgdmFyIHN2ZyA9IFR3by5VdGlscy5yZWFkLmcuY2FsbCh0aGlzLCBub2RlKTtcclxuICAgICAgICAgIHZhciB2aWV3Qm94ID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKTtcclxuICAgICAgICAgIC8vIFR3by5VdGlscy5hcHBseVN2Z1ZpZXdCb3goc3ZnLCB2aWV3Qm94KTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gc3ZnO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBkZWZzOiBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgVHdvLlV0aWxzLkVycm9yKCdpbnRlcnByZXQgPGRlZnMgLz4gbm90IHN1cHBvcnRlZC4nKTtcclxuICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvci5uYW1lLCBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVzZTogZnVuY3Rpb24obm9kZSkge1xyXG4gICAgICAgICAgdmFyIGVycm9yID0gbmV3IFR3by5VdGlscy5FcnJvcignaW50ZXJwcmV0IDx1c2UgLz4gbm90IHN1cHBvcnRlZC4nKTtcclxuICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvci5uYW1lLCBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGc6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudFN0eWxlcykge1xyXG5cclxuICAgICAgICAgIHZhciBzdHlsZXMsIGF0dHJzO1xyXG4gICAgICAgICAgdmFyIGdyb3VwID0gbmV3IFR3by5Hcm91cCgpO1xyXG5cclxuICAgICAgICAgIFR3by5VdGlscy5hcHBseVN2Z0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBub2RlLCBncm91cCwgcGFyZW50U3R5bGVzKTtcclxuXHJcbiAgICAgICAgICB0aGlzLmFkZChncm91cCk7XHJcblxyXG4gICAgICAgICAgLy8gU3dpdGNoZWQgdXAgb3JkZXIgdG8gaW5oZXJpdCBtb3JlIHNwZWNpZmljIHN0eWxlc1xyXG4gICAgICAgICAgc3R5bGVzID0gVHdvLlV0aWxzLmdldFN2Z1N0eWxlcy5jYWxsKHRoaXMsIG5vZGUpO1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbiA9IG5vZGUuY2hpbGROb2Rlc1tpXTtcclxuICAgICAgICAgICAgdmFyIHRhZyA9IG4ubm9kZU5hbWU7XHJcbiAgICAgICAgICAgIGlmICghdGFnKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICB2YXIgdGFnTmFtZSA9IHRhZy5yZXBsYWNlKC9zdmc6L2lnLCAnJykudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0YWdOYW1lIGluIFR3by5VdGlscy5yZWFkKSB7XHJcbiAgICAgICAgICAgICAgdmFyIG8gPSBUd28uVXRpbHMucmVhZFt0YWdOYW1lXS5jYWxsKGdyb3VwLCBuLCBzdHlsZXMpO1xyXG4gICAgICAgICAgICAgIGlmICghIW8gJiYgIW8ucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBncm91cC5hZGQobyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGdyb3VwO1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwb2x5Z29uOiBmdW5jdGlvbihub2RlLCBwYXJlbnRTdHlsZXMpIHtcclxuXHJcbiAgICAgICAgICB2YXIgcG9pbnRzID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpO1xyXG5cclxuICAgICAgICAgIHZhciB2ZXJ0cyA9IFtdO1xyXG4gICAgICAgICAgcG9pbnRzLnJlcGxhY2UoLygtP1tcXGQuP10rKVssfFxcc10oLT9bXFxkLj9dKykvZywgZnVuY3Rpb24obWF0Y2gsIHAxLCBwMikge1xyXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKG5ldyBUd28uQW5jaG9yKHBhcnNlRmxvYXQocDEpLCBwYXJzZUZsb2F0KHAyKSkpO1xyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgdmFyIHBvbHkgPSBuZXcgVHdvLlBhdGgodmVydHMsIHRydWUpLm5vU3Ryb2tlKCk7XHJcbiAgICAgICAgICBwb2x5LmZpbGwgPSAnYmxhY2snO1xyXG5cclxuICAgICAgICAgIFR3by5VdGlscy5hcHBseVN2Z0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBub2RlLCBwb2x5LCBwYXJlbnRTdHlsZXMpO1xyXG5cclxuICAgICAgICAgIHJldHVybiBwb2x5O1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBwb2x5bGluZTogZnVuY3Rpb24obm9kZSwgcGFyZW50U3R5bGVzKSB7XHJcbiAgICAgICAgICB2YXIgcG9seSA9IFR3by5VdGlscy5yZWFkLnBvbHlnb24uY2FsbCh0aGlzLCBub2RlLCBwYXJlbnRTdHlsZXMpO1xyXG4gICAgICAgICAgcG9seS5jbG9zZWQgPSBmYWxzZTtcclxuICAgICAgICAgIHJldHVybiBwb2x5O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHBhdGg6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudFN0eWxlcykge1xyXG5cclxuICAgICAgICAgIHZhciBwYXRoID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2QnKTtcclxuICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgICAgIHZhciBjbG9zZWQgPSBmYWxzZSwgcmVsYXRpdmUgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICBpZiAocGF0aCkge1xyXG5cclxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgVHdvLlBhdGggZnJvbSB0aGUgcGF0aHMuXHJcblxyXG4gICAgICAgICAgICB2YXIgY29vcmQgPSBuZXcgVHdvLkFuY2hvcigpO1xyXG4gICAgICAgICAgICB2YXIgY29udHJvbCwgY29vcmRzO1xyXG4gICAgICAgICAgICB2YXIgY29tbWFuZHMgPSBwYXRoLm1hdGNoKC9bYS1kZi16XVteYS1kZi16XSovaWcpO1xyXG4gICAgICAgICAgICB2YXIgbGFzdCA9IGNvbW1hbmRzLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgICAgICAgICAvLyBTcGxpdCB1cCBwb2x5YmV6aWVyc1xyXG5cclxuICAgICAgICAgICAgXy5lYWNoKGNvbW1hbmRzLnNsaWNlKDApLCBmdW5jdGlvbihjb21tYW5kLCBpKSB7XHJcblxyXG4gICAgICAgICAgICAgIHZhciBudW1iZXIsIGZpZCwgbGlkLCBudW1iZXJzLCBmaXJzdCwgcztcclxuICAgICAgICAgICAgICB2YXIgaiwgaywgY3QsIGwsIHRpbWVzO1xyXG5cclxuICAgICAgICAgICAgICB2YXIgdHlwZSA9IGNvbW1hbmRbMF07XHJcbiAgICAgICAgICAgICAgdmFyIGxvd2VyID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgIHZhciBpdGVtcyA9IGNvbW1hbmQuc2xpY2UoMSkudHJpbSgpLnNwbGl0KC9bXFxzLF0rfCg/PVxccz9bKy1dKS8pO1xyXG4gICAgICAgICAgICAgIHZhciBwcmUsIHBvc3QsIHJlc3VsdCA9IFtdLCBiaW47XHJcbiAgICAgICAgICAgICAgdmFyIGhhc0RvdWJsZURlY2ltYWxzID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEhhbmRsZSBkb3VibGUgZGVjaW1hbCB2YWx1ZXMgZS5nOiA0OC42MDM3LjcxLjhcclxuICAgICAgICAgICAgICAvLyBMaWtlOiBodHRwczovL20uYWJjc29mY2hpbmVzZS5jb20vaW1hZ2VzL3N2Zy/kurxqaTIuc3ZnXHJcbiAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgbnVtYmVyID0gaXRlbXNbal07XHJcbiAgICAgICAgICAgICAgICBmaWQgPSBudW1iZXIuaW5kZXhPZignLicpO1xyXG4gICAgICAgICAgICAgICAgbGlkID0gbnVtYmVyLmxhc3RJbmRleE9mKCcuJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZpZCAhPT0gbGlkKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICBudW1iZXJzID0gbnVtYmVyLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICAgIGZpcnN0ID0gbnVtYmVyc1swXSArICcuJyArIG51bWJlcnNbMV07XHJcblxyXG4gICAgICAgICAgICAgICAgICBpdGVtcy5zcGxpY2UoaiwgMSwgZmlyc3QpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgZm9yIChzID0gMjsgcyA8IG51bWJlcnMubGVuZ3RoOyBzKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtcy5zcGxpY2UoaiArIHMgLSAxLCAwLCAnMC4nICsgbnVtYmVyc1tzXSk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIGhhc0RvdWJsZURlY2ltYWxzID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKGhhc0RvdWJsZURlY2ltYWxzKSB7XHJcbiAgICAgICAgICAgICAgICBjb21tYW5kID0gdHlwZSArIGl0ZW1zLmpvaW4oJywnKTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChpIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbW1hbmRzID0gW107XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBzd2l0Y2ggKGxvd2VyKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdoJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxyXG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdtJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAndCc6XHJcbiAgICAgICAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluID0gMjtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAncSc6XHJcbiAgICAgICAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluID0gNDtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxyXG4gICAgICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gNikge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpbiA9IDY7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdhJzpcclxuICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDcpIHtcclxuICAgICAgICAgICAgICAgICAgICBiaW4gPSA3O1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB3ZSBoYXZlIGEgcG9seWJlemllci5cclxuICAgICAgICAgICAgICBpZiAoYmluKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMCwgbCA9IGl0ZW1zLmxlbmd0aCwgdGltZXMgPSAwOyBqIDwgbDsgais9YmluKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICBjdCA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh0aW1lcyA+IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3QgPSAnbCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0ID0gJ0wnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdCArIGl0ZW1zLnNsaWNlKGosIGogKyBiaW4pLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgICAgICAgICAgIHRpbWVzKys7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbW1hbmRzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShjb21tYW5kcywgcmVzdWx0KTtcclxuXHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb21tYW5kcy5wdXNoKGNvbW1hbmQpO1xyXG5cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgdmVydGljZXMgZm9yIG91ciBUd28uUGF0aFxyXG5cclxuICAgICAgICAgICAgXy5lYWNoKGNvbW1hbmRzLCBmdW5jdGlvbihjb21tYW5kLCBpKSB7XHJcblxyXG4gICAgICAgICAgICAgIHZhciByZXN1bHQsIHgsIHk7XHJcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBjb21tYW5kWzBdO1xyXG4gICAgICAgICAgICAgIHZhciBsb3dlciA9IHR5cGUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgY29vcmRzID0gY29tbWFuZC5zbGljZSgxKS50cmltKCk7XHJcbiAgICAgICAgICAgICAgY29vcmRzID0gY29vcmRzLnJlcGxhY2UoLygtP1xcZCsoPzpcXC5cXGQqKT8pW2VFXShbKy1dP1xcZCspL2csIGZ1bmN0aW9uKG1hdGNoLCBuMSwgbjIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG4xKSAqIHBvdygxMCwgbjIpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIGNvb3JkcyA9IGNvb3Jkcy5zcGxpdCgvW1xccyxdK3woPz1cXHM/WystXSkvKTtcclxuICAgICAgICAgICAgICByZWxhdGl2ZSA9IHR5cGUgPT09IGxvd2VyO1xyXG5cclxuICAgICAgICAgICAgICB2YXIgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCByZWZsZWN0aW9uO1xyXG5cclxuICAgICAgICAgICAgICBzd2l0Y2ggKGxvd2VyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAneic6XHJcbiAgICAgICAgICAgICAgICAgIGlmIChpID49IGxhc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbG9zZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBjb29yZC54O1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBjb29yZC55O1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUd28uQW5jaG9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgeCwgeSxcclxuICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICBUd28uQ29tbWFuZHMuY2xvc2VcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgY29vcmQgYmUgdGhlIGxhc3QgYG1gIGNvbW1hbmRcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gcG9pbnRzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoL20vaS50ZXN0KHBvaW50LmNvbW1hbmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkID0gcG9pbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdtJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgIHggPSBwYXJzZUZsb2F0KGNvb3Jkc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgIHkgPSBwYXJzZUZsb2F0KGNvb3Jkc1sxXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVHdvLkFuY2hvcihcclxuICAgICAgICAgICAgICAgICAgICB4LCB5LFxyXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIC9tL2kudGVzdChsb3dlcikgPyBUd28uQ29tbWFuZHMubW92ZSA6IFR3by5Db21tYW5kcy5saW5lXHJcbiAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkU2VsZihjb29yZCk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdC5jb250cm9scy5sZWZ0LmNvcHkocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0LmNvbnRyb2xzLnJpZ2h0LmNvcHkocmVzdWx0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIGNvb3JkID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdoJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgdmFyIGEgPSAvaC9pLnRlc3QobG93ZXIpID8gJ3gnIDogJ3knO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgYiA9IC94L2kudGVzdChhKSA/ICd5JyA6ICd4JztcclxuXHJcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUd28uQW5jaG9yKFxyXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIFR3by5Db21tYW5kcy5saW5lXHJcbiAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgIHJlc3VsdFthXSA9IHBhcnNlRmxvYXQoY29vcmRzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgcmVzdWx0W2JdID0gY29vcmRbYl07XHJcblxyXG4gICAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbYV0gKz0gY29vcmRbYV07XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdC5jb250cm9scy5sZWZ0LmNvcHkocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0LmNvbnRyb2xzLnJpZ2h0LmNvcHkocmVzdWx0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIGNvb3JkID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdjJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgeDEgPSBjb29yZC54O1xyXG4gICAgICAgICAgICAgICAgICB5MSA9IGNvb3JkLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgICBpZiAoIWNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gbmV3IFR3by5WZWN0b3IoKTsvLy5jb3B5KGNvb3JkKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgaWYgKC9jL2kudGVzdChsb3dlcikpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBwYXJzZUZsb2F0KGNvb3Jkc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeTIgPSBwYXJzZUZsb2F0KGNvb3Jkc1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeDMgPSBwYXJzZUZsb2F0KGNvb3Jkc1syXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeTMgPSBwYXJzZUZsb2F0KGNvb3Jkc1szXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeDQgPSBwYXJzZUZsb2F0KGNvb3Jkc1s0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeTQgPSBwYXJzZUZsb2F0KGNvb3Jkc1s1XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgcmVmbGVjdGlvbiBjb250cm9sIHBvaW50IGZvciBwcm9wZXIgeDIsIHkyXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jbHVzaW9uLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZWZsZWN0aW9uID0gZ2V0UmVmbGVjdGlvbihjb29yZCwgY29udHJvbCwgcmVsYXRpdmUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB4MiA9IHJlZmxlY3Rpb24ueDtcclxuICAgICAgICAgICAgICAgICAgICB5MiA9IHJlZmxlY3Rpb24ueTtcclxuICAgICAgICAgICAgICAgICAgICB4MyA9IHBhcnNlRmxvYXQoY29vcmRzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICB5MyA9IHBhcnNlRmxvYXQoY29vcmRzWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICB4NCA9IHBhcnNlRmxvYXQoY29vcmRzWzJdKTtcclxuICAgICAgICAgICAgICAgICAgICB5NCA9IHBhcnNlRmxvYXQoY29vcmRzWzNdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHgyICs9IHgxO1xyXG4gICAgICAgICAgICAgICAgICAgIHkyICs9IHkxO1xyXG4gICAgICAgICAgICAgICAgICAgIHgzICs9IHgxO1xyXG4gICAgICAgICAgICAgICAgICAgIHkzICs9IHkxO1xyXG4gICAgICAgICAgICAgICAgICAgIHg0ICs9IHgxO1xyXG4gICAgICAgICAgICAgICAgICAgIHk0ICs9IHkxO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICBpZiAoIV8uaXNPYmplY3QoY29vcmQuY29udHJvbHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVHdvLkFuY2hvci5BcHBlbmRDdXJ2ZVByb3BlcnRpZXMoY29vcmQpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICBjb29yZC5jb250cm9scy5yaWdodC5zZXQoeDIgLSBjb29yZC54LCB5MiAtIGNvb3JkLnkpO1xyXG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVHdvLkFuY2hvcihcclxuICAgICAgICAgICAgICAgICAgICB4NCwgeTQsXHJcbiAgICAgICAgICAgICAgICAgICAgeDMgLSB4NCwgeTMgLSB5NCxcclxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICBUd28uQ29tbWFuZHMuY3VydmVcclxuICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIGNvb3JkID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICBjb250cm9sID0gcmVzdWx0LmNvbnRyb2xzLmxlZnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICd0JzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3EnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgeDEgPSBjb29yZC54O1xyXG4gICAgICAgICAgICAgICAgICB5MSA9IGNvb3JkLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgICBpZiAoIWNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gbmV3IFR3by5WZWN0b3IoKTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgaWYgKC9xL2kudGVzdChsb3dlcikpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeDIgPSBwYXJzZUZsb2F0KGNvb3Jkc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeTIgPSBwYXJzZUZsb2F0KGNvb3Jkc1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeDMgPSBwYXJzZUZsb2F0KGNvb3Jkc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeTMgPSBwYXJzZUZsb2F0KGNvb3Jkc1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeDQgPSBwYXJzZUZsb2F0KGNvb3Jkc1syXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeTQgPSBwYXJzZUZsb2F0KGNvb3Jkc1szXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZWZsZWN0aW9uID0gZ2V0UmVmbGVjdGlvbihjb29yZCwgY29udHJvbCwgcmVsYXRpdmUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB4MiA9IHJlZmxlY3Rpb24ueDtcclxuICAgICAgICAgICAgICAgICAgICB5MiA9IHJlZmxlY3Rpb24ueTtcclxuICAgICAgICAgICAgICAgICAgICB4MyA9IHJlZmxlY3Rpb24ueDtcclxuICAgICAgICAgICAgICAgICAgICB5MyA9IHJlZmxlY3Rpb24ueTtcclxuICAgICAgICAgICAgICAgICAgICB4NCA9IHBhcnNlRmxvYXQoY29vcmRzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICB5NCA9IHBhcnNlRmxvYXQoY29vcmRzWzFdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHgyICs9IHgxO1xyXG4gICAgICAgICAgICAgICAgICAgIHkyICs9IHkxO1xyXG4gICAgICAgICAgICAgICAgICAgIHgzICs9IHgxO1xyXG4gICAgICAgICAgICAgICAgICAgIHkzICs9IHkxO1xyXG4gICAgICAgICAgICAgICAgICAgIHg0ICs9IHgxO1xyXG4gICAgICAgICAgICAgICAgICAgIHk0ICs9IHkxO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICBpZiAoIV8uaXNPYmplY3QoY29vcmQuY29udHJvbHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVHdvLkFuY2hvci5BcHBlbmRDdXJ2ZVByb3BlcnRpZXMoY29vcmQpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICBjb29yZC5jb250cm9scy5yaWdodC5zZXQoXHJcbiAgICAgICAgICAgICAgICAgICAgKHgyIC0gY29vcmQueCkgKiAwLjMzLCAoeTIgLSBjb29yZC55KSAqIDAuMzMpO1xyXG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVHdvLkFuY2hvcihcclxuICAgICAgICAgICAgICAgICAgICB4NCwgeTQsXHJcbiAgICAgICAgICAgICAgICAgICAgeDMgLSB4NCwgeTMgLSB5NCxcclxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICBUd28uQ29tbWFuZHMuY3VydmVcclxuICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIGNvb3JkID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICBjb250cm9sID0gcmVzdWx0LmNvbnRyb2xzLmxlZnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdhJzpcclxuXHJcbiAgICAgICAgICAgICAgICAgIHgxID0gY29vcmQueDtcclxuICAgICAgICAgICAgICAgICAgeTEgPSBjb29yZC55O1xyXG5cclxuICAgICAgICAgICAgICAgICAgdmFyIHJ4ID0gcGFyc2VGbG9hdChjb29yZHNbMF0pO1xyXG4gICAgICAgICAgICAgICAgICB2YXIgcnkgPSBwYXJzZUZsb2F0KGNvb3Jkc1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgIHZhciB4QXhpc1JvdGF0aW9uID0gcGFyc2VGbG9hdChjb29yZHNbMl0pOy8vICogUEkgLyAxODA7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBsYXJnZUFyY0ZsYWcgPSBwYXJzZUZsb2F0KGNvb3Jkc1szXSk7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBzd2VlcEZsYWcgPSBwYXJzZUZsb2F0KGNvb3Jkc1s0XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICB4NCA9IHBhcnNlRmxvYXQoY29vcmRzWzVdKTtcclxuICAgICAgICAgICAgICAgICAgeTQgPSBwYXJzZUZsb2F0KGNvb3Jkc1s2XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICB4NCArPSB4MTtcclxuICAgICAgICAgICAgICAgICAgICB5NCArPSB5MTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvciA9IG5ldyBUd28uQW5jaG9yKHg0LCB5NCk7XHJcbiAgICAgICAgICAgICAgICAgIGFuY2hvci5jb21tYW5kID0gVHdvLkNvbW1hbmRzLmFyYztcclxuICAgICAgICAgICAgICAgICAgYW5jaG9yLnJ4ID0gcng7XHJcbiAgICAgICAgICAgICAgICAgIGFuY2hvci5yeSA9IHJ5O1xyXG4gICAgICAgICAgICAgICAgICBhbmNob3IueEF4aXNSb3RhdGlvbiA9IHhBeGlzUm90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgIGFuY2hvci5sYXJnZUFyY0ZsYWcgPSBsYXJnZUFyY0ZsYWc7XHJcbiAgICAgICAgICAgICAgICAgIGFuY2hvci5zd2VlcEZsYWcgPSBzd2VlcEZsYWc7XHJcblxyXG4gICAgICAgICAgICAgICAgICByZXN1bHQgPSBhbmNob3I7XHJcblxyXG4gICAgICAgICAgICAgICAgICBjb29yZCA9IGFuY2hvcjtcclxuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfLmlzQXJyYXkocmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICBwb2ludHMgPSBwb2ludHMuY29uY2F0KHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBwYXRoID0gbmV3IFR3by5QYXRoKHBvaW50cywgY2xvc2VkLCB1bmRlZmluZWQsIHRydWUpLm5vU3Ryb2tlKCk7XHJcbiAgICAgICAgICBwYXRoLmZpbGwgPSAnYmxhY2snO1xyXG5cclxuICAgICAgICAgIHZhciByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QodHJ1ZSk7XHJcblxyXG4gICAgICAgICAgLy8gQ2VudGVyIG9iamVjdHMgdG8gc3RheSBjb25zaXN0ZW50XHJcbiAgICAgICAgICAvLyB3aXRoIHRoZSByZXN0IG9mIHRoZSBUd28uanMgQVBJLlxyXG4gICAgICAgICAgcmVjdC5jZW50cm9pZCA9IHtcclxuICAgICAgICAgICAgeDogcmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAvIDIsXHJcbiAgICAgICAgICAgIHk6IHJlY3QudG9wICsgcmVjdC5oZWlnaHQgLyAyXHJcbiAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgIF8uZWFjaChwYXRoLnZlcnRpY2VzLCBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICAgIHYuc3ViU2VsZihyZWN0LmNlbnRyb2lkKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIFR3by5VdGlscy5hcHBseVN2Z0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBub2RlLCBwYXRoLCBwYXJlbnRTdHlsZXMpO1xyXG5cclxuICAgICAgICAgIHBhdGgudHJhbnNsYXRpb24uYWRkU2VsZihyZWN0LmNlbnRyb2lkKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gcGF0aDtcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2lyY2xlOiBmdW5jdGlvbihub2RlLCBwYXJlbnRTdHlsZXMpIHtcclxuXHJcbiAgICAgICAgICB2YXIgeCA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ2N4JykpO1xyXG4gICAgICAgICAgdmFyIHkgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCdjeScpKTtcclxuICAgICAgICAgIHZhciByID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgncicpKTtcclxuXHJcbiAgICAgICAgICB2YXIgY2lyY2xlID0gbmV3IFR3by5DaXJjbGUoeCwgeSwgcikubm9TdHJva2UoKTtcclxuICAgICAgICAgIGNpcmNsZS5maWxsID0gJ2JsYWNrJztcclxuXHJcbiAgICAgICAgICBUd28uVXRpbHMuYXBwbHlTdmdBdHRyaWJ1dGVzLmNhbGwodGhpcywgbm9kZSwgY2lyY2xlLCBwYXJlbnRTdHlsZXMpO1xyXG5cclxuICAgICAgICAgIHJldHVybiBjaXJjbGU7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGVsbGlwc2U6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudFN0eWxlcykge1xyXG5cclxuICAgICAgICAgIHZhciB4ID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgnY3gnKSk7XHJcbiAgICAgICAgICB2YXIgeSA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ2N5JykpO1xyXG4gICAgICAgICAgdmFyIHdpZHRoID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgncngnKSk7XHJcbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgncnknKSk7XHJcblxyXG4gICAgICAgICAgdmFyIGVsbGlwc2UgPSBuZXcgVHdvLkVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCkubm9TdHJva2UoKTtcclxuICAgICAgICAgIGVsbGlwc2UuZmlsbCA9ICdibGFjayc7XHJcblxyXG4gICAgICAgICAgVHdvLlV0aWxzLmFwcGx5U3ZnQXR0cmlidXRlcy5jYWxsKHRoaXMsIG5vZGUsIGVsbGlwc2UsIHBhcmVudFN0eWxlcyk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGVsbGlwc2U7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlY3Q6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudFN0eWxlcykge1xyXG5cclxuICAgICAgICAgIHZhciByeCA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3J4JykpO1xyXG4gICAgICAgICAgdmFyIHJ5ID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgncnknKSk7XHJcblxyXG4gICAgICAgICAgaWYgKCFfLmlzTmFOKHJ4KSB8fCAhXy5pc05hTihyeSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFR3by5VdGlscy5yZWFkWydyb3VuZGVkLXJlY3QnXShub2RlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgeCA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3gnKSkgfHwgMDtcclxuICAgICAgICAgIHZhciB5ID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgneScpKSB8fCAwO1xyXG4gICAgICAgICAgdmFyIHdpZHRoID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSk7XHJcbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpO1xyXG5cclxuICAgICAgICAgIHZhciB3MiA9IHdpZHRoIC8gMjtcclxuICAgICAgICAgIHZhciBoMiA9IGhlaWdodCAvIDI7XHJcblxyXG4gICAgICAgICAgdmFyIHJlY3QgPSBuZXcgVHdvLlJlY3RhbmdsZSh4ICsgdzIsIHkgKyBoMiwgd2lkdGgsIGhlaWdodClcclxuICAgICAgICAgICAgLm5vU3Ryb2tlKCk7XHJcbiAgICAgICAgICByZWN0LmZpbGwgPSAnYmxhY2snO1xyXG5cclxuICAgICAgICAgIFR3by5VdGlscy5hcHBseVN2Z0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBub2RlLCByZWN0LCBwYXJlbnRTdHlsZXMpO1xyXG5cclxuICAgICAgICAgIHJldHVybiByZWN0O1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAncm91bmRlZC1yZWN0JzogZnVuY3Rpb24obm9kZSwgcGFyZW50U3R5bGVzKSB7XHJcblxyXG4gICAgICAgICAgdmFyIHggPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCd4JykpIHx8IDA7XHJcbiAgICAgICAgICB2YXIgeSA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3knKSkgfHwgMDtcclxuICAgICAgICAgIHZhciByeCA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3J4JykpIHx8IDA7XHJcbiAgICAgICAgICB2YXIgcnkgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCdyeScpKSB8fCAwO1xyXG5cclxuICAgICAgICAgIHZhciB3aWR0aCA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpO1xyXG4gICAgICAgICAgdmFyIGhlaWdodCA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKTtcclxuXHJcbiAgICAgICAgICB2YXIgdzIgPSB3aWR0aCAvIDI7XHJcbiAgICAgICAgICB2YXIgaDIgPSBoZWlnaHQgLyAyO1xyXG4gICAgICAgICAgdmFyIHJhZGl1cyA9IG5ldyBUd28uVmVjdG9yKHJ4LCByeSk7XHJcblxyXG4gICAgICAgICAgdmFyIHJlY3QgPSBuZXcgVHdvLlJvdW5kZWRSZWN0YW5nbGUoeCArIHcyLCB5ICsgaDIsIHdpZHRoLCBoZWlnaHQsIHJhZGl1cylcclxuICAgICAgICAgICAgLm5vU3Ryb2tlKCk7XHJcbiAgICAgICAgICByZWN0LmZpbGwgPSAnYmxhY2snO1xyXG5cclxuICAgICAgICAgIFR3by5VdGlscy5hcHBseVN2Z0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBub2RlLCByZWN0LCBwYXJlbnRTdHlsZXMpO1xyXG5cclxuICAgICAgICAgIHJldHVybiByZWN0O1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBsaW5lOiBmdW5jdGlvbihub2RlLCBwYXJlbnRTdHlsZXMpIHtcclxuXHJcbiAgICAgICAgICB2YXIgeDEgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCd4MScpKTtcclxuICAgICAgICAgIHZhciB5MSA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3kxJykpO1xyXG4gICAgICAgICAgdmFyIHgyID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgneDInKSk7XHJcbiAgICAgICAgICB2YXIgeTIgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCd5MicpKTtcclxuXHJcbiAgICAgICAgICB2YXIgbGluZSA9IG5ldyBUd28uTGluZSh4MSwgeTEsIHgyLCB5Mikubm9GaWxsKCk7XHJcblxyXG4gICAgICAgICAgVHdvLlV0aWxzLmFwcGx5U3ZnQXR0cmlidXRlcy5jYWxsKHRoaXMsIG5vZGUsIGxpbmUsIHBhcmVudFN0eWxlcyk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGxpbmU7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGxpbmVhcmdyYWRpZW50OiBmdW5jdGlvbihub2RlLCBwYXJlbnRTdHlsZXMpIHtcclxuXHJcbiAgICAgICAgICB2YXIgeDEgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCd4MScpKTtcclxuICAgICAgICAgIHZhciB5MSA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3kxJykpO1xyXG4gICAgICAgICAgdmFyIHgyID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgneDInKSk7XHJcbiAgICAgICAgICB2YXIgeTIgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCd5MicpKTtcclxuXHJcbiAgICAgICAgICB2YXIgb3ggPSAoeDIgKyB4MSkgLyAyO1xyXG4gICAgICAgICAgdmFyIG95ID0gKHkyICsgeTEpIC8gMjtcclxuXHJcbiAgICAgICAgICB2YXIgc3RvcHMgPSBbXTtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ29mZnNldCcpO1xyXG4gICAgICAgICAgICBpZiAoLyUvaWcudGVzdChvZmZzZXQpKSB7XHJcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gcGFyc2VGbG9hdChvZmZzZXQucmVwbGFjZSgvJS9pZywgJycpKSAvIDEwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KG9mZnNldCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3N0b3AtY29sb3InKTtcclxuICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3N0b3Atb3BhY2l0eScpO1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbWF0Y2hlcztcclxuICAgICAgICAgICAgaWYgKF8uaXNOdWxsKGNvbG9yKSkge1xyXG4gICAgICAgICAgICAgIG1hdGNoZXMgPSBzdHlsZSA/IHN0eWxlLm1hdGNoKC9zdG9wLWNvbG9yOlxccz8oWyNhLWZBLUYwLTldKikvKSA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGNvbG9yID0gbWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDEgPyBtYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoXy5pc051bGwob3BhY2l0eSkpIHtcclxuICAgICAgICAgICAgICBtYXRjaGVzID0gc3R5bGUgPyBzdHlsZS5tYXRjaCgvc3RvcC1vcGFjaXR5Olxccz8oWzAtOS4tXSopLykgOiBmYWxzZTtcclxuICAgICAgICAgICAgICBvcGFjaXR5ID0gbWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDEgPyBwYXJzZUZsb2F0KG1hdGNoZXNbMV0pIDogMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBvcGFjaXR5ID0gcGFyc2VGbG9hdChvcGFjaXR5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3RvcHMucHVzaChuZXcgVHdvLkdyYWRpZW50LlN0b3Aob2Zmc2V0LCBjb2xvciwgb3BhY2l0eSkpO1xyXG5cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBuZXcgVHdvLkxpbmVhckdyYWRpZW50KHgxIC0gb3gsIHkxIC0gb3ksIHgyIC0gb3gsXHJcbiAgICAgICAgICAgIHkyIC0gb3ksIHN0b3BzKTtcclxuXHJcbiAgICAgICAgICBUd28uVXRpbHMuYXBwbHlTdmdBdHRyaWJ1dGVzLmNhbGwodGhpcywgbm9kZSwgZ3JhZGllbnQsIHBhcmVudFN0eWxlcyk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGdyYWRpZW50O1xyXG5cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICByYWRpYWxncmFkaWVudDogZnVuY3Rpb24obm9kZSwgcGFyZW50U3R5bGVzKSB7XHJcblxyXG4gICAgICAgICAgdmFyIGN4ID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgnY3gnKSkgfHwgMDtcclxuICAgICAgICAgIHZhciBjeSA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ2N5JykpIHx8IDA7XHJcbiAgICAgICAgICB2YXIgciA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3InKSk7XHJcblxyXG4gICAgICAgICAgdmFyIGZ4ID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgnZngnKSk7XHJcbiAgICAgICAgICB2YXIgZnkgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCdmeScpKTtcclxuXHJcbiAgICAgICAgICBpZiAoXy5pc05hTihmeCkpIHtcclxuICAgICAgICAgICAgZnggPSBjeDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoXy5pc05hTihmeSkpIHtcclxuICAgICAgICAgICAgZnkgPSBjeTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgb3ggPSBhYnMoY3ggKyBmeCkgLyAyO1xyXG4gICAgICAgICAgdmFyIG95ID0gYWJzKGN5ICsgZnkpIC8gMjtcclxuXHJcbiAgICAgICAgICB2YXIgc3RvcHMgPSBbXTtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcclxuXHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ29mZnNldCcpO1xyXG4gICAgICAgICAgICBpZiAoLyUvaWcudGVzdChvZmZzZXQpKSB7XHJcbiAgICAgICAgICAgICAgb2Zmc2V0ID0gcGFyc2VGbG9hdChvZmZzZXQucmVwbGFjZSgvJS9pZywgJycpKSAvIDEwMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KG9mZnNldCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3N0b3AtY29sb3InKTtcclxuICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3N0b3Atb3BhY2l0eScpO1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbWF0Y2hlcztcclxuICAgICAgICAgICAgaWYgKF8uaXNOdWxsKGNvbG9yKSkge1xyXG4gICAgICAgICAgICAgIG1hdGNoZXMgPSBzdHlsZSA/IHN0eWxlLm1hdGNoKC9zdG9wLWNvbG9yOlxccz8oWyNhLWZBLUYwLTldKikvKSA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGNvbG9yID0gbWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDEgPyBtYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoXy5pc051bGwob3BhY2l0eSkpIHtcclxuICAgICAgICAgICAgICBtYXRjaGVzID0gc3R5bGUgPyBzdHlsZS5tYXRjaCgvc3RvcC1vcGFjaXR5Olxccz8oWzAtOS4tXSopLykgOiBmYWxzZTtcclxuICAgICAgICAgICAgICBvcGFjaXR5ID0gbWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDEgPyBwYXJzZUZsb2F0KG1hdGNoZXNbMV0pIDogMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBvcGFjaXR5ID0gcGFyc2VGbG9hdChvcGFjaXR5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc3RvcHMucHVzaChuZXcgVHdvLkdyYWRpZW50LlN0b3Aob2Zmc2V0LCBjb2xvciwgb3BhY2l0eSkpO1xyXG5cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBuZXcgVHdvLlJhZGlhbEdyYWRpZW50KGN4IC0gb3gsIGN5IC0gb3ksIHIsXHJcbiAgICAgICAgICAgIHN0b3BzLCBmeCAtIG94LCBmeSAtIG95KTtcclxuXHJcbiAgICAgICAgICBUd28uVXRpbHMuYXBwbHlTdmdBdHRyaWJ1dGVzLmNhbGwodGhpcywgbm9kZSwgZ3JhZGllbnQsIHBhcmVudFN0eWxlcyk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGdyYWRpZW50O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuYW1lIFR3by5VdGlscy5zdWJkaXZpZGVcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MSAtIHggcG9zaXRpb24gb2YgZmlyc3QgYW5jaG9yIHBvaW50LlxyXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0geTEgLSB5IHBvc2l0aW9uIG9mIGZpcnN0IGFuY2hvciBwb2ludC5cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHgyIC0geCBwb3NpdGlvbiBvZiBmaXJzdCBhbmNob3IgcG9pbnQncyBcInJpZ2h0XCIgYmV6aWVyIGhhbmRsZS5cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkyIC0geSBwb3NpdGlvbiBvZiBmaXJzdCBhbmNob3IgcG9pbnQncyBcInJpZ2h0XCIgYmV6aWVyIGhhbmRsZS5cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHgzIC0geCBwb3NpdGlvbiBvZiBzZWNvbmQgYW5jaG9yIHBvaW50J3MgXCJsZWZ0XCIgYmV6aWVyIGhhbmRsZS5cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkzIC0geSBwb3NpdGlvbiBvZiBzZWNvbmQgYW5jaG9yIHBvaW50J3MgXCJsZWZ0XCIgYmV6aWVyIGhhbmRsZS5cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHg0IC0geCBwb3NpdGlvbiBvZiBzZWNvbmQgYW5jaG9yIHBvaW50LlxyXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0geTQgLSB5IHBvc2l0aW9uIG9mIHNlY29uZCBhbmNob3IgcG9pbnQuXHJcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbGltaXQ9VHdvLlV0aWxzLkN1cnZlLlJlY3Vyc2lvbkxpbWl0XSAtIFRoZSBhbW91bnQgb2YgdmVydGljZXMgdG8gY3JlYXRlIGJ5IHN1YmRpdmlkaW5nLlxyXG4gICAgICAgKiBAcmV0dXJucyB7VHdvLkFuY2hvcltdfSBBIGxpc3Qgb2YgYW5jaG9yIHBvaW50cyBvcmRlcmVkIGluIGJldHdlZW4gYHgxYCwgYHkxYCBhbmQgYHg0YCwgYHk0YFxyXG4gICAgICAgKiBAZGVzY3JpcHRpb24gR2l2ZW4gMiBwb2ludHMgKGEsIGIpIGFuZCBjb3JyZXNwb25kaW5nIGNvbnRyb2wgcG9pbnQgZm9yIGVhY2ggcmV0dXJuIGFuIGFycmF5IG9mIHBvaW50cyB0aGF0IHJlcHJlc2VudCBwb2ludHMgcGxvdHRlZCBhbG9uZyB0aGUgY3VydmUuIFRoZSBudW1iZXIgb2YgcmV0dXJuZWQgcG9pbnRzIGlzIGRldGVybWluZWQgYnkgYGxpbWl0YC5cclxuICAgICAgICovXHJcbiAgICAgIHN1YmRpdmlkZTogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCBsaW1pdCkge1xyXG5cclxuICAgICAgICBsaW1pdCA9IGxpbWl0IHx8IFR3by5VdGlscy5DdXJ2ZS5SZWN1cnNpb25MaW1pdDtcclxuICAgICAgICB2YXIgYW1vdW50ID0gbGltaXQgKyAxO1xyXG5cclxuICAgICAgICAvLyBUT0RPOiBBYnN0cmFjdCAwLjAwMSB0byBhIGxpbWl0aW5nIHZhcmlhYmxlXHJcbiAgICAgICAgLy8gRG9uJ3QgcmVjdXJzZSBpZiB0aGUgZW5kIHBvaW50cyBhcmUgaWRlbnRpY2FsXHJcbiAgICAgICAgaWYgKGFicyh4MSAtIHg0KSA8IDAuMDAxICYmIGFicyh5MSAtIHk0KSA8IDAuMDAxKSB7XHJcbiAgICAgICAgICByZXR1cm4gW25ldyBUd28uQW5jaG9yKHg0LCB5NCldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgdCA9IGkgLyBhbW91bnQ7XHJcbiAgICAgICAgICB2YXIgeCA9IGdldENvbXBvbmVudE9uQ3ViaWNCZXppZXIodCwgeDEsIHgyLCB4MywgeDQpO1xyXG4gICAgICAgICAgdmFyIHkgPSBnZXRDb21wb25lbnRPbkN1YmljQmV6aWVyKHQsIHkxLCB5MiwgeTMsIHk0KTtcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBUd28uQW5jaG9yKHgsIHkpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuYW1lIFR3by5VdGlscy5nZXRDb21wb25lbnRPbkN1YmljQmV6aWVyXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gdCAtIFplcm8tdG8tb25lIHZhbHVlIGRlc2NyaWJpbmcgd2hhdCBwZXJjZW50YWdlIHRvIGNhbGN1bGF0ZS5cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgLSBUaGUgZmlydCBwb2ludCdzIGNvbXBvbmVudCB2YWx1ZS5cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgLSBUaGUgZmlyc3QgcG9pbnQncyBiZXppZXIgY29tcG9uZW50IHZhbHVlLlxyXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gYyAtIFRoZSBzZWNvbmQgcG9pbnQncyBiZXppZXIgY29tcG9uZW50IHZhbHVlLlxyXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gZCAtIFRoZSBzZWNvbmQgcG9pbnQncyBjb21wb25lbnQgdmFsdWUuXHJcbiAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBjb29yZGluYXRlIHZhbHVlIGZvciBhIHNwZWNpZmljIGNvbXBvbmVudCBhbG9uZyBhIGN1YmljIGJlemllciBjdXJ2ZSBieSBgdGAuXHJcbiAgICAgICAqL1xyXG4gICAgICBnZXRDb21wb25lbnRPbkN1YmljQmV6aWVyOiBmdW5jdGlvbih0LCBhLCBiLCBjLCBkKSB7XHJcbiAgICAgICAgdmFyIGsgPSAxIC0gdDtcclxuICAgICAgICByZXR1cm4gKGsgKiBrICogayAqIGEpICsgKDMgKiBrICogayAqIHQgKiBiKSArICgzICogayAqIHQgKiB0ICogYykgK1xyXG4gICAgICAgICAgICh0ICogdCAqIHQgKiBkKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmFtZSBUd28uVXRpbHMuZ2V0Q3VydmVMZW5ndGhcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MSAtIHggcG9zaXRpb24gb2YgZmlyc3QgYW5jaG9yIHBvaW50LlxyXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0geTEgLSB5IHBvc2l0aW9uIG9mIGZpcnN0IGFuY2hvciBwb2ludC5cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHgyIC0geCBwb3NpdGlvbiBvZiBmaXJzdCBhbmNob3IgcG9pbnQncyBcInJpZ2h0XCIgYmV6aWVyIGhhbmRsZS5cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkyIC0geSBwb3NpdGlvbiBvZiBmaXJzdCBhbmNob3IgcG9pbnQncyBcInJpZ2h0XCIgYmV6aWVyIGhhbmRsZS5cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHgzIC0geCBwb3NpdGlvbiBvZiBzZWNvbmQgYW5jaG9yIHBvaW50J3MgXCJsZWZ0XCIgYmV6aWVyIGhhbmRsZS5cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkzIC0geSBwb3NpdGlvbiBvZiBzZWNvbmQgYW5jaG9yIHBvaW50J3MgXCJsZWZ0XCIgYmV6aWVyIGhhbmRsZS5cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHg0IC0geCBwb3NpdGlvbiBvZiBzZWNvbmQgYW5jaG9yIHBvaW50LlxyXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0geTQgLSB5IHBvc2l0aW9uIG9mIHNlY29uZCBhbmNob3IgcG9pbnQuXHJcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbGltaXQ9VHdvLlV0aWxzLkN1cnZlLlJlY3Vyc2lvbkxpbWl0XSAtIFRoZSBhbW91bnQgb2YgdmVydGljZXMgdG8gY3JlYXRlIGJ5IHN1YmRpdmlkaW5nLlxyXG4gICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbGVuZ3RoIG9mIGEgY3VydmUuXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBHaXZlbiAyIHBvaW50cyAoYSwgYikgYW5kIGNvcnJlc3BvbmRpbmcgY29udHJvbCBwb2ludCBmb3IgZWFjaCwgcmV0dXJuIGEgZmxvYXQgdGhhdCByZXByZXNlbnRzIHRoZSBsZW5ndGggb2YgdGhlIGN1cnZlIHVzaW5nIEdhdXNzLUxlZ2VuZHJlIGFsZ29yaXRobS4gTGltaXQgaXRlcmF0aW9ucyBvZiBjYWxjdWxhdGlvbiBieSBgbGltaXRgLlxyXG4gICAgICAgKi9cclxuICAgICAgZ2V0Q3VydmVMZW5ndGg6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgbGltaXQpIHtcclxuXHJcbiAgICAgICAgLy8gVE9ETzogQmV0dGVyIC8gZnV6emllciBlcXVhbGl0eSBjaGVja1xyXG4gICAgICAgIC8vIExpbmVhciBjYWxjdWxhdGlvblxyXG4gICAgICAgIGlmICh4MSA9PT0geDIgJiYgeTEgPT09IHkyICYmIHgzID09PSB4NCAmJiB5MyA9PT0geTQpIHtcclxuICAgICAgICAgIHZhciBkeCA9IHg0IC0geDE7XHJcbiAgICAgICAgICB2YXIgZHkgPSB5NCAtIHkxO1xyXG4gICAgICAgICAgcmV0dXJuIHNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjb2VmZmljaWVudHMgb2YgYSBCZXppZXIgZGVyaXZhdGl2ZS5cclxuICAgICAgICB2YXIgYXggPSA5ICogKHgyIC0geDMpICsgMyAqICh4NCAtIHgxKSxcclxuICAgICAgICAgIGJ4ID0gNiAqICh4MSArIHgzKSAtIDEyICogeDIsXHJcbiAgICAgICAgICBjeCA9IDMgKiAoeDIgLSB4MSksXHJcblxyXG4gICAgICAgICAgYXkgPSA5ICogKHkyIC0geTMpICsgMyAqICh5NCAtIHkxKSxcclxuICAgICAgICAgIGJ5ID0gNiAqICh5MSArIHkzKSAtIDEyICogeTIsXHJcbiAgICAgICAgICBjeSA9IDMgKiAoeTIgLSB5MSk7XHJcblxyXG4gICAgICAgIHZhciBpbnRlZ3JhbmQgPSBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgcXVhZHJhdGljIGVxdWF0aW9ucyBvZiBkZXJpdmF0aXZlcyBmb3IgeCBhbmQgeVxyXG4gICAgICAgICAgdmFyIGR4ID0gKGF4ICogdCArIGJ4KSAqIHQgKyBjeCxcclxuICAgICAgICAgICAgZHkgPSAoYXkgKiB0ICsgYnkpICogdCArIGN5O1xyXG4gICAgICAgICAgcmV0dXJuIHNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBpbnRlZ3JhdGUoXHJcbiAgICAgICAgICBpbnRlZ3JhbmQsIDAsIDEsIGxpbWl0IHx8IFR3by5VdGlscy5DdXJ2ZS5SZWN1cnNpb25MaW1pdFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuYW1lIFR3by5VdGlscy5nZXRDdXJ2ZUJvdW5kaW5nQm94XHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0geDEgLSB4IHBvc2l0aW9uIG9mIGZpcnN0IGFuY2hvciBwb2ludC5cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHkxIC0geSBwb3NpdGlvbiBvZiBmaXJzdCBhbmNob3IgcG9pbnQuXHJcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MiAtIHggcG9zaXRpb24gb2YgZmlyc3QgYW5jaG9yIHBvaW50J3MgXCJyaWdodFwiIGJlemllciBoYW5kbGUuXHJcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5MiAtIHkgcG9zaXRpb24gb2YgZmlyc3QgYW5jaG9yIHBvaW50J3MgXCJyaWdodFwiIGJlemllciBoYW5kbGUuXHJcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MyAtIHggcG9zaXRpb24gb2Ygc2Vjb25kIGFuY2hvciBwb2ludCdzIFwibGVmdFwiIGJlemllciBoYW5kbGUuXHJcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5MyAtIHkgcG9zaXRpb24gb2Ygc2Vjb25kIGFuY2hvciBwb2ludCdzIFwibGVmdFwiIGJlemllciBoYW5kbGUuXHJcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4NCAtIHggcG9zaXRpb24gb2Ygc2Vjb25kIGFuY2hvciBwb2ludC5cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHk0IC0geSBwb3NpdGlvbiBvZiBzZWNvbmQgYW5jaG9yIHBvaW50LlxyXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBPYmplY3QgY29udGFpbnMgbWluIGFuZCBtYXggYHhgIC8gYHlgIGJvdW5kcy5cclxuICAgICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Fkb2JlLXdlYnBsYXRmb3JtL1NuYXAuc3ZnL2Jsb2IvbWFzdGVyL3NyYy9wYXRoLmpzI0w4NTZ9XHJcbiAgICAgICAqL1xyXG4gICAgICBnZXRDdXJ2ZUJvdW5kaW5nQm94OiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQpIHtcclxuXHJcbiAgICAgICAgdmFyIHR2YWx1ZXMgPSBbXTtcclxuICAgICAgICB2YXIgYm91bmRzID0gW1tdLCBbXV07XHJcbiAgICAgICAgdmFyIGEsIGIsIGMsIHQsIHQxLCB0MiwgYjJhYywgc3FydGIyYWM7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChpID09IDApIHtcclxuICAgICAgICAgICAgICBiID0gNiAqIHgxIC0gMTIgKiB4MiArIDYgKiB4MztcclxuICAgICAgICAgICAgICBhID0gLTMgKiB4MSArIDkgKiB4MiAtIDkgKiB4MyArIDMgKiB4NDtcclxuICAgICAgICAgICAgICBjID0gMyAqIHgyIC0gMyAqIHgxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGIgPSA2ICogeTEgLSAxMiAqIHkyICsgNiAqIHkzO1xyXG4gICAgICAgICAgICAgIGEgPSAtMyAqIHkxICsgOSAqIHkyIC0gOSAqIHkzICsgMyAqIHk0O1xyXG4gICAgICAgICAgICAgIGMgPSAzICogeTIgLSAzICogeTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFicyhhKSA8IDFlLTEyKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFicyhiKSA8IDFlLTEyKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdCA9IC1jIC8gYjtcclxuICAgICAgICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcclxuICAgICAgICAgICAgICAgIHR2YWx1ZXMucHVzaCh0KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xyXG4gICAgICAgICAgICBzcXJ0YjJhYyA9IE1hdGguc3FydChiMmFjKTtcclxuICAgICAgICAgICAgaWYgKGIyYWMgPCAwKSB7XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdDEgPSAoLWIgKyBzcXJ0YjJhYykgLyAoMiAqIGEpO1xyXG4gICAgICAgICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xyXG4gICAgICAgICAgICAgIHR2YWx1ZXMucHVzaCh0MSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdDIgPSAoLWIgLSBzcXJ0YjJhYykgLyAoMiAqIGEpO1xyXG4gICAgICAgICAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xyXG4gICAgICAgICAgICAgIHR2YWx1ZXMucHVzaCh0Mik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB4LCB5LCBqID0gdHZhbHVlcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGpsZW4gPSBqO1xyXG4gICAgICAgIHZhciBtdDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGotLSkge1xyXG4gICAgICAgICAgdCA9IHR2YWx1ZXNbal07XHJcbiAgICAgICAgICBtdCA9IDEgLSB0O1xyXG4gICAgICAgICAgYm91bmRzWzBdW2pdID0gbXQgKiBtdCAqIG10ICogeDEgKyAzICogbXQgKiBtdCAqIHQgKiB4MiArIDMgKiBtdCAqIHQgKiB0ICogeDMgKyB0ICogdCAqIHQgKiB4NDtcclxuICAgICAgICAgIGJvdW5kc1sxXVtqXSA9IG10ICogbXQgKiBtdCAqIHkxICsgMyAqIG10ICogbXQgKiB0ICogeTIgKyAzICogbXQgKiB0ICogdCAqIHkzICsgdCAqIHQgKiB0ICogeTQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBib3VuZHNbMF1bamxlbl0gPSB4MTtcclxuICAgICAgICBib3VuZHNbMV1bamxlbl0gPSB5MTtcclxuICAgICAgICBib3VuZHNbMF1bamxlbiArIDFdID0geDQ7XHJcbiAgICAgICAgYm91bmRzWzFdW2psZW4gKyAxXSA9IHk0O1xyXG4gICAgICAgIGJvdW5kc1swXS5sZW5ndGggPSBib3VuZHNbMV0ubGVuZ3RoID0gamxlbiArIDI7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBtaW46IHsgeDogTWF0aC5taW4uYXBwbHkoMCwgYm91bmRzWzBdKSwgeTogTWF0aC5taW4uYXBwbHkoMCwgYm91bmRzWzFdKSB9LFxyXG4gICAgICAgICAgbWF4OiB7IHg6IE1hdGgubWF4LmFwcGx5KDAsIGJvdW5kc1swXSksIHk6IE1hdGgubWF4LmFwcGx5KDAsIGJvdW5kc1sxXSkgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuYW1lIFR3by5VdGlscy5pbnRlZ3JhdGVcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZcclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGFcclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGJcclxuICAgICAgICogQHBhcmFtIHtJbnRlZ2VyfSBuXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBJbnRlZ3JhdGlvbiBmb3IgYGdldEN1cnZlTGVuZ3RoYCBjYWxjdWxhdGlvbnMuXHJcbiAgICAgICAqIEBzZWUgW1BhcGVyLmpzXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGFwZXJqcy9wYXBlci5qcy9ibG9iL21hc3Rlci9zcmMvdXRpbC9OdW1lcmljYWwuanMjTDEwMX1cclxuICAgICAgICovXHJcbiAgICAgIGludGVncmF0ZTogZnVuY3Rpb24oZiwgYSwgYiwgbikge1xyXG4gICAgICAgIHZhciB4ID0gVHdvLlV0aWxzLkN1cnZlLmFic2Npc3Nhc1tuIC0gMl0sXHJcbiAgICAgICAgICB3ID0gVHdvLlV0aWxzLkN1cnZlLndlaWdodHNbbiAtIDJdLFxyXG4gICAgICAgICAgQSA9IDAuNSAqIChiIC0gYSksXHJcbiAgICAgICAgICBCID0gQSArIGEsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIG0gPSAobiArIDEpID4+IDEsXHJcbiAgICAgICAgICBzdW0gPSBuICYgMSA/IHdbaSsrXSAqIGYoQikgOiAwOyAvLyBIYW5kbGUgb2RkIG5cclxuICAgICAgICB3aGlsZSAoaSA8IG0pIHtcclxuICAgICAgICAgIHZhciBBeCA9IEEgKiB4W2ldO1xyXG4gICAgICAgICAgc3VtICs9IHdbaSsrXSAqIChmKEIgKyBBeCkgKyBmKEIgLSBBeCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQSAqIHN1bTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmFtZSBUd28uVXRpbHMuZ2V0Q3VydmVGcm9tUG9pbnRzXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKiBAcGFyYW0ge1R3by5BbmNob3JbXX0gcG9pbnRzXHJcbiAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xvc2VkXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBTZXRzIHRoZSBiZXppZXIgaGFuZGxlcyBvbiB7QGxpbmsgVHdvLkFuY2hvcn1zIGluIHRoZSBgcG9pbnRzYCBsaXN0IHdpdGggZXN0aW1hdGVkIHZhbHVlcyB0byBjcmVhdGUgYSBjYXRtdWxsLXJvbSBsaWtlIGN1cnZlLiBVc2VkIGJ5IHtAbGluayBUd28uUGF0aCNwbG90fS5cclxuICAgICAgICovXHJcbiAgICAgIGdldEN1cnZlRnJvbVBvaW50czogZnVuY3Rpb24ocG9pbnRzLCBjbG9zZWQpIHtcclxuXHJcbiAgICAgICAgdmFyIGwgPSBwb2ludHMubGVuZ3RoLCBsYXN0ID0gbCAtIDE7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xyXG5cclxuICAgICAgICAgIGlmICghXy5pc09iamVjdChwb2ludC5jb250cm9scykpIHtcclxuICAgICAgICAgICAgVHdvLkFuY2hvci5BcHBlbmRDdXJ2ZVByb3BlcnRpZXMocG9pbnQpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciBwcmV2ID0gY2xvc2VkID8gbW9kKGkgLSAxLCBsKSA6IG1heChpIC0gMSwgMCk7XHJcbiAgICAgICAgICB2YXIgbmV4dCA9IGNsb3NlZCA/IG1vZChpICsgMSwgbCkgOiBtaW4oaSArIDEsIGxhc3QpO1xyXG5cclxuICAgICAgICAgIHZhciBhID0gcG9pbnRzW3ByZXZdO1xyXG4gICAgICAgICAgdmFyIGIgPSBwb2ludDtcclxuICAgICAgICAgIHZhciBjID0gcG9pbnRzW25leHRdO1xyXG4gICAgICAgICAgZ2V0Q29udHJvbFBvaW50cyhhLCBiLCBjKTtcclxuXHJcbiAgICAgICAgICBiLmNvbW1hbmQgPSBpID09PSAwID8gVHdvLkNvbW1hbmRzLm1vdmUgOiBUd28uQ29tbWFuZHMuY3VydmU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5hbWUgVHdvLlV0aWxzLmdldENvbnRyb2xQb2ludHNcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIEBwYXJhbSB7VHdvLkFuY2hvcn0gYVxyXG4gICAgICAgKiBAcGFyYW0ge1R3by5BbmNob3J9IGJcclxuICAgICAgICogQHBhcmFtIHtUd28uQW5jaG9yfSBjXHJcbiAgICAgICAqIEByZXR1cm5zIHtUd28uQW5jaG9yfSBSZXR1cm5zIHRoZSBwYXNzZWQgbWlkZGxlIHBvaW50IGBiYC5cclxuICAgICAgICogQGRlc2NyaXB0aW9uIEdpdmVuIHRocmVlIGNvb3JkaW5hdGVzIHNldCB0aGUgY29udHJvbCBwb2ludHMgZm9yIHRoZSBtaWRkbGUsIGIsIHZlcnRleCBiYXNlZCBvbiBpdHMgcG9zaXRpb24gd2l0aCB0aGUgYWRqYWNlbnQgcG9pbnRzLlxyXG4gICAgICAgKi9cclxuICAgICAgZ2V0Q29udHJvbFBvaW50czogZnVuY3Rpb24oYSwgYiwgYykge1xyXG5cclxuICAgICAgICB2YXIgYTEgPSBUd28uVmVjdG9yLmFuZ2xlQmV0d2VlbihhLCBiKTtcclxuICAgICAgICB2YXIgYTIgPSBUd28uVmVjdG9yLmFuZ2xlQmV0d2VlbihjLCBiKTtcclxuXHJcbiAgICAgICAgdmFyIGQxID0gVHdvLlZlY3Rvci5kaXN0YW5jZUJldHdlZW4oYSwgYik7XHJcbiAgICAgICAgdmFyIGQyID0gVHdvLlZlY3Rvci5kaXN0YW5jZUJldHdlZW4oYywgYik7XHJcblxyXG4gICAgICAgIHZhciBtaWQgPSAoYTEgKyBhMikgLyAyO1xyXG5cclxuICAgICAgICAvLyBUT0RPOiBJc3N1ZSA3M1xyXG4gICAgICAgIGlmIChkMSA8IDAuMDAwMSB8fCBkMiA8IDAuMDAwMSkge1xyXG4gICAgICAgICAgaWYgKF8uaXNCb29sZWFuKGIucmVsYXRpdmUpICYmICFiLnJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIGIuY29udHJvbHMubGVmdC5jb3B5KGIpO1xyXG4gICAgICAgICAgICBiLmNvbnRyb2xzLnJpZ2h0LmNvcHkoYik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGQxICo9IDAuMzM7IC8vIFdoeSAwLjMzP1xyXG4gICAgICAgIGQyICo9IDAuMzM7XHJcblxyXG4gICAgICAgIGlmIChhMiA8IGExKSB7XHJcbiAgICAgICAgICBtaWQgKz0gSEFMRl9QSTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbWlkIC09IEhBTEZfUEk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBiLmNvbnRyb2xzLmxlZnQueCA9IGNvcyhtaWQpICogZDE7XHJcbiAgICAgICAgYi5jb250cm9scy5sZWZ0LnkgPSBzaW4obWlkKSAqIGQxO1xyXG5cclxuICAgICAgICBtaWQgLT0gUEk7XHJcblxyXG4gICAgICAgIGIuY29udHJvbHMucmlnaHQueCA9IGNvcyhtaWQpICogZDI7XHJcbiAgICAgICAgYi5jb250cm9scy5yaWdodC55ID0gc2luKG1pZCkgKiBkMjtcclxuXHJcbiAgICAgICAgaWYgKF8uaXNCb29sZWFuKGIucmVsYXRpdmUpICYmICFiLnJlbGF0aXZlKSB7XHJcbiAgICAgICAgICBiLmNvbnRyb2xzLmxlZnQueCArPSBiLng7XHJcbiAgICAgICAgICBiLmNvbnRyb2xzLmxlZnQueSArPSBiLnk7XHJcbiAgICAgICAgICBiLmNvbnRyb2xzLnJpZ2h0LnggKz0gYi54O1xyXG4gICAgICAgICAgYi5jb250cm9scy5yaWdodC55ICs9IGIueTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBiO1xyXG5cclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmFtZSBUd28uVXRpbHMuZ2V0UmVmbGVjdGlvblxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSBhXHJcbiAgICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gYlxyXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWxhdGl2ZT1mYWxzZV1cclxuICAgICAgICogQHJldHVybnMge1R3by5WZWN0b3J9IE5ldyB7QGxpbmsgVHdvLlZlY3Rvcn0gdGhhdCByZXByZXNlbnRzIHRoZSByZWZsZWN0aW9uIHBvaW50LlxyXG4gICAgICAgKiBAZGVzY3JpcHRpb24gR2V0IHRoZSByZWZsZWN0aW9uIG9mIGEgcG9pbnQgYGJgIGFib3V0IHBvaW50IGBhYC4gV2hlcmUgYGFgIGlzIGluIGFic29sdXRlIHNwYWNlIGFuZCBgYmAgaXMgcmVsYXRpdmUgdG8gYGFgLlxyXG4gICAgICAgKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9pbXBsbm90ZS5odG1sI1BhdGhFbGVtZW50SW1wbGVtZW50YXRpb25Ob3Rlc31cclxuICAgICAgICovXHJcbiAgICAgIGdldFJlZmxlY3Rpb246IGZ1bmN0aW9uKGEsIGIsIHJlbGF0aXZlKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgVHdvLlZlY3RvcihcclxuICAgICAgICAgIDIgKiBhLnggLSAoYi54ICsgYS54KSAtIChyZWxhdGl2ZSA/IGEueCA6IDApLFxyXG4gICAgICAgICAgMiAqIGEueSAtIChiLnkgKyBhLnkpIC0gKHJlbGF0aXZlID8gYS55IDogMClcclxuICAgICAgICApO1xyXG5cclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmFtZSBUd28uVXRpbHMuZ2V0QW5jaG9yc0Zyb21BcmNEYXRhXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IGNlbnRlclxyXG4gICAgICAgKiBAcGFyYW0ge1JhZGlhbnN9IHhBeGlzUm90YXRpb25cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHJ4IC0geCByYWRpdXNcclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHJ5IC0geSByYWRpdXNcclxuICAgICAgICogQHBhcmFtIHtSYWRpYW5zfSB0c1xyXG4gICAgICAgKiBAcGFyYW0ge1JhZGlhbnN9IHRkXHJcbiAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Njdz1mYWxzZV0gLSBTZXQgcGF0aCB0cmF2ZXJzYWwgdG8gY291bnRlci1jbG9ja3dpc2VcclxuICAgICAgICovXHJcbiAgICAgIGdldEFuY2hvcnNGcm9tQXJjRGF0YTogZnVuY3Rpb24oY2VudGVyLCB4QXhpc1JvdGF0aW9uLCByeCwgcnksIHRzLCB0ZCwgY2N3KSB7XHJcblxyXG4gICAgICAgIHZhciBsID0gVHdvLlJlc29sdXRpb247XHJcblxyXG4gICAgICAgIHJldHVybiBfLm1hcChfLnJhbmdlKGwpLCBmdW5jdGlvbihpKSB7XHJcblxyXG4gICAgICAgICAgdmFyIHBjdCA9IChpICsgMSkgLyBsO1xyXG4gICAgICAgICAgaWYgKGNjdykge1xyXG4gICAgICAgICAgICBwY3QgPSAxIC0gcGN0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciB0aGV0YSA9IHBjdCAqIHRkICsgdHM7XHJcbiAgICAgICAgICB2YXIgeCA9IHJ4ICogTWF0aC5jb3ModGhldGEpO1xyXG4gICAgICAgICAgdmFyIHkgPSByeSAqIE1hdGguc2luKHRoZXRhKTtcclxuXHJcbiAgICAgICAgICAvLyB4ICs9IGNlbnRlci54O1xyXG4gICAgICAgICAgLy8geSArPSBjZW50ZXIueTtcclxuXHJcbiAgICAgICAgICB2YXIgYW5jaG9yID0gbmV3IFR3by5BbmNob3IoeCwgeSk7XHJcbiAgICAgICAgICBUd28uQW5jaG9yLkFwcGVuZEN1cnZlUHJvcGVydGllcyhhbmNob3IpO1xyXG4gICAgICAgICAgYW5jaG9yLmNvbW1hbmQgPSBUd28uQ29tbWFuZHMubGluZTtcclxuXHJcbiAgICAgICAgICAvLyBUT0RPOiBDYWxjdWxhdGUgY29udHJvbCBwb2ludHMgaGVyZS4uLlxyXG5cclxuICAgICAgICAgIHJldHVybiBhbmNob3I7XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmFtZSBUd28uVXRpbHMubGVycFxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgLSBTdGFydCB2YWx1ZS5cclxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgLSBFbmQgdmFsdWUuXHJcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0IC0gWmVyby10by1vbmUgdmFsdWUgZGVzY3JpYmluZyBwZXJjZW50YWdlIGJldHdlZW4gYSBhbmQgYi5cclxuICAgICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAgICogQGRlc2NyaXB0aW9uIExpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZhbHVlcyBgYWAgYW5kIGBiYCBieSBhbiBhbW91bnQgYHRgLlxyXG4gICAgICAgKi9cclxuICAgICAgbGVycDogZnVuY3Rpb24oYSwgYiwgdCkge1xyXG4gICAgICAgIHJldHVybiB0ICogKGIgLSBhKSArIGE7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5hbWUgVHdvLlV0aWxzLnRvRml4ZWRcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2IC0gQW55IGZsb2F0XHJcbiAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoYXQgZmxvYXQgdHJpbW1lZCB0byB0aGUgdGhpcmQgZGVjaW1hbCBwbGFjZS5cclxuICAgICAgICogQGRlc2NyaXB0aW9uIEEgcHJldHR5IGZhc3QgdG9GaXhlZCgzKSBhbHRlcm5hdGl2ZS5cclxuICAgICAgICogQHNlZSB7QGxpbmsgaHR0cDovL2pzcGVyZi5jb20vcGFyc2VmbG9hdC10b2ZpeGVkLXZzLW1hdGgtcm91bmQvMTh9XHJcbiAgICAgICAqL1xyXG4gICAgICB0b0ZpeGVkOiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodiAqIDEwMDApIC8gMTAwMDtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmFtZSBUd28uVXRpbHMubW9kXHJcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2IC0gVGhlIHZhbHVlIHRvIG1vZHVsb1xyXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gbCAtIFRoZSB2YWx1ZSB0byBtb2R1bG8gYnlcclxuICAgICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAgICogQGRlc2NyaXB0aW9uIE1vZHVsbyB3aXRoIGFkZGVkIGZ1bmN0aW9uYWxpdHkgdG8gaGFuZGxlIG5lZ2F0aXZlIHZhbHVlcyBpbiBhIHBvc2l0aXZlIG1hbm5lci5cclxuICAgICAgICovXHJcbiAgICAgIG1vZDogZnVuY3Rpb24odiwgbCkge1xyXG5cclxuICAgICAgICB3aGlsZSAodiA8IDApIHtcclxuICAgICAgICAgIHYgKz0gbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB2ICUgbDtcclxuXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5hbWUgVHdvLlV0aWxzLkNvbGxlY3Rpb25cclxuICAgICAgICogQGNsYXNzXHJcbiAgICAgICAqIEBleHRlbmRzIFR3by5VdGlscy5FdmVudHNcclxuICAgICAgICogQGRlc2NyaXB0aW9uIEFuIGBBcnJheWAgbGlrZSBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsIGV2ZW50IHByb3BhZ2F0aW9uIG9uIGFjdGlvbnMuIGBwb3BgLCBgc2hpZnRgLCBhbmQgYHNwbGljZWAgdHJpZ2dlciBgcmVtb3ZlZGAgZXZlbnRzLiBgcHVzaGAsIGB1bnNoaWZ0YCwgYW5kIGBzcGxpY2VgIHdpdGggbW9yZSB0aGFuIDIgYXJndW1lbnRzIHRyaWdnZXIgJ2luc2VydGVkJy4gRmluYWxseSwgYHNvcnRgIGFuZCBgcmV2ZXJzZWAgdHJpZ2dlciBgb3JkZXJgIGV2ZW50cy5cclxuICAgICAgICovXHJcbiAgICAgIENvbGxlY3Rpb246IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBBcnJheS5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XHJcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLCBhcmd1bWVudHNbMF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5hbWUgVHdvLlV0aWxzLkVycm9yXHJcbiAgICAgICAqIEBjbGFzc1xyXG4gICAgICAgKiBAZGVzY3JpcHRpb24gQ3VzdG9tIGVycm9yIHRocm93aW5nIGZvciBUd28uanMgc3BlY2lmaWMgaWRlbnRpZmljYXRpb24uXHJcbiAgICAgICAqL1xyXG4gICAgICBFcnJvcjogZnVuY3Rpb24obWVzc2FnZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICdUd28uanMnO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5hbWUgVHdvLlV0aWxzLkV2ZW50c1xyXG4gICAgICAgKiBAaW50ZXJmYWNlXHJcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBPYmplY3QgaW5oZXJpdGVkIGJ5IG1hbnkgVHdvLmpzIG9iamVjdHMgaW4gb3JkZXIgdG8gZmFjaWxpdGF0ZSBjdXN0b20gZXZlbnRzLlxyXG4gICAgICAgKi9cclxuICAgICAgRXZlbnRzOiB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBuYW1lIFR3by5VdGlscy5FdmVudHMub25cclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBiaW5kIGEgZnVuY3Rpb24gdG8uXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciAtIFRoZSBmdW5jdGlvbiB0byBiZSBpbnZva2VkIHdoZW4gdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuXHJcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIENhbGwgdG8gYWRkIGEgbGlzdGVuZXIgdG8gYSBzcGVjaWZpYyBldmVudCBuYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9uOiBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XHJcblxyXG4gICAgICAgICAgdGhpcy5fZXZlbnRzIHx8ICh0aGlzLl9ldmVudHMgPSB7fSk7XHJcbiAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2V2ZW50c1tuYW1lXSB8fCAodGhpcy5fZXZlbnRzW25hbWVdID0gW10pO1xyXG5cclxuICAgICAgICAgIGxpc3QucHVzaChoYW5kbGVyKTtcclxuXHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG5hbWUgVHdvLlV0aWxzLkV2ZW50cy5vZmZcclxuICAgICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IGludGVuZGVkIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdIC0gVGhlIGhhbmRsZXIgaW50ZW5kZWQgdG8gYmUgcmVvbXZlZC5cclxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbCB0byByZW1vdmUgbGlzdGVuZXJzIGZyb20gYSBzcGVjaWZpYyBldmVudC4gSWYgb25seSBgbmFtZWAgaXMgcGFzc2VkIHRoZW4gYWxsIHRoZSBoYW5kbGVycyBhdHRhY2hlZCB0byB0aGF0IGBuYW1lYCB3aWxsIGJlIHJlbW92ZWQuIElmIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRoZW4gYWxsIGhhbmRsZXJzIGZvciBldmVyeSBldmVudCBvbiB0aGUgb2JlamN0IGFyZSByZW1vdmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9mZjogZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xyXG5cclxuICAgICAgICAgIGlmICghdGhpcy5fZXZlbnRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFuYW1lICYmICFoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB2YXIgbmFtZXMgPSBuYW1lID8gW25hbWVdIDogXy5rZXlzKHRoaXMuX2V2ZW50cyk7XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xyXG4gICAgICAgICAgICB2YXIgbGlzdCA9IHRoaXMuX2V2ZW50c1tuYW1lXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChsaXN0KSB7XHJcbiAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IGxpc3QubGVuZ3RoOyBqIDwgazsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZhciBldiA9IGxpc3Rbal07XHJcbiAgICAgICAgICAgICAgICAgIGV2ID0gZXYuaGFuZGxlciA/IGV2LmhhbmRsZXIgOiBldjtcclxuICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIgJiYgaGFuZGxlciAhPT0gZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudHMucHVzaChldik7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW25hbWVdID0gZXZlbnRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG5hbWUgVHdvLlV0aWxzLkV2ZW50cy50cmlnZ2VyXHJcbiAgICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZGlzcGF0Y2guXHJcbiAgICAgICAgICogQHBhcmFtIGFyZ3VtZW50cyAtIEFueXRoaW5nIGNhbiBiZSBwYXNzZWQgYWZ0ZXIgdGhlIG5hbWUgYW5kIHRob3NlIHdpbGwgYmUgcGFzc2VkIG9uIHRvIGhhbmRsZXJzIGF0dGFjaGVkIHRvIHRoZSBldmVudCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgcGFzc2VkLlxyXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsIHRvIHRyaWdnZXIgYSBjdXN0b20gZXZlbnQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBwYXNzZWQgYWZ0ZXIgdGhlIG5hbWUgd2lsbCBiZSBwYXNzZWQgYWxvbmcgdG8gdGhlIGF0dGFjaGVkIGhhbmRsZXJzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcclxuICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXTtcclxuICAgICAgICAgIGlmIChldmVudHMpIHRyaWdnZXIodGhpcywgZXZlbnRzLCBhcmdzKTtcclxuICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGxpc3RlbjogZnVuY3Rpb24ob2JqLCBuYW1lLCBoYW5kbGVyKSB7XHJcblxyXG4gICAgICAgICAgdmFyIGJvdW5kID0gdGhpcztcclxuXHJcbiAgICAgICAgICBpZiAob2JqKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgaGFuZGxlci5hcHBseShib3VuZCwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCByZWZlcmVuY2VzIGFib3V0IHRoZSBvYmplY3QgdGhhdCBhc3NpZ25lZCB0aGlzIGxpc3RlbmVyXHJcbiAgICAgICAgICAgIGV2ZW50Lm9iaiA9IG9iajtcclxuICAgICAgICAgICAgZXZlbnQubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgIGV2ZW50LmhhbmRsZXIgPSBoYW5kbGVyO1xyXG5cclxuICAgICAgICAgICAgb2JqLm9uKG5hbWUsIGV2ZW50KTtcclxuXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlnbm9yZTogZnVuY3Rpb24ob2JqLCBuYW1lLCBoYW5kbGVyKSB7XHJcblxyXG4gICAgICAgICAgb2JqLm9mZihuYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgfSlcclxuXHJcbiAgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuYW1lIFR3by5VdGlscy5FdmVudHMuYmluZFxyXG4gICAqIEBib3Jyb3dzIFR3by5VdGlscy5FdmVudHMub24gYXMgVHdvLlV0aWxzLkV2ZW50cy5iaW5kXHJcbiAgICovXHJcbiAgVHdvLlV0aWxzLkV2ZW50cy5iaW5kID0gVHdvLlV0aWxzLkV2ZW50cy5vbjtcclxuXHJcbiAgLyoqXHJcbiAgICogQG5hbWUgVHdvLlV0aWxzLkV2ZW50cy51bmJpbmRcclxuICAgKiBAYm9ycm93cyBUd28uVXRpbHMuRXZlbnRzLm9mZiBhcyBUd28uVXRpbHMuRXZlbnRzLnVuYmluZFxyXG4gICAqL1xyXG4gIFR3by5VdGlscy5FdmVudHMudW5iaW5kID0gVHdvLlV0aWxzLkV2ZW50cy5vZmY7XHJcblxyXG4gIHZhciB0cmlnZ2VyID0gZnVuY3Rpb24ob2JqLCBldmVudHMsIGFyZ3MpIHtcclxuICAgIHZhciBtZXRob2Q7XHJcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XHJcbiAgICBjYXNlIDA6XHJcbiAgICAgIG1ldGhvZCA9IGZ1bmN0aW9uKGkpIHtcclxuICAgICAgICBldmVudHNbaV0uY2FsbChvYmosIGFyZ3NbMF0pO1xyXG4gICAgICB9O1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMTpcclxuICAgICAgbWV0aG9kID0gZnVuY3Rpb24oaSkge1xyXG4gICAgICAgIGV2ZW50c1tpXS5jYWxsKG9iaiwgYXJnc1swXSwgYXJnc1sxXSk7XHJcbiAgICAgIH07XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSAyOlxyXG4gICAgICBtZXRob2QgPSBmdW5jdGlvbihpKSB7XHJcbiAgICAgICAgZXZlbnRzW2ldLmNhbGwob2JqLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcclxuICAgICAgfTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDM6XHJcbiAgICAgIG1ldGhvZCA9IGZ1bmN0aW9uKGkpIHtcclxuICAgICAgICBldmVudHNbaV0uY2FsbChvYmosIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xyXG4gICAgICB9O1xyXG4gICAgICBicmVhaztcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIG1ldGhvZCA9IGZ1bmN0aW9uKGkpIHtcclxuICAgICAgICBldmVudHNbaV0uYXBwbHkob2JqLCBhcmdzKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIG1ldGhvZChpKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBUd28uVXRpbHMuRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XHJcbiAgVHdvLlV0aWxzLkVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR3by5VdGlscy5FcnJvcjtcclxuXHJcbiAgVHdvLlV0aWxzLkNvbGxlY3Rpb24ucHJvdG90eXBlID0gbmV3IEFycmF5KCk7XHJcbiAgVHdvLlV0aWxzLkNvbGxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHdvLlV0aWxzLkNvbGxlY3Rpb247XHJcblxyXG4gIF8uZXh0ZW5kKFR3by5VdGlscy5Db2xsZWN0aW9uLnByb3RvdHlwZSwgVHdvLlV0aWxzLkV2ZW50cywge1xyXG5cclxuICAgIHBvcDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBwb3BwZWQgPSBBcnJheS5wcm90b3R5cGUucG9wLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLnJlbW92ZSwgW3BvcHBlZF0pO1xyXG4gICAgICByZXR1cm4gcG9wcGVkO1xyXG4gICAgfSxcclxuXHJcbiAgICBzaGlmdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBzaGlmdGVkID0gQXJyYXkucHJvdG90eXBlLnNoaWZ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLnJlbW92ZSwgW3NoaWZ0ZWRdKTtcclxuICAgICAgcmV0dXJuIHNoaWZ0ZWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIHB1c2g6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgcHVzaGVkID0gQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgdGhpcy50cmlnZ2VyKFR3by5FdmVudHMuaW5zZXJ0LCBhcmd1bWVudHMpO1xyXG4gICAgICByZXR1cm4gcHVzaGVkO1xyXG4gICAgfSxcclxuXHJcbiAgICB1bnNoaWZ0OiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIHVuc2hpZnRlZCA9IEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLmluc2VydCwgYXJndW1lbnRzKTtcclxuICAgICAgcmV0dXJuIHVuc2hpZnRlZDtcclxuICAgIH0sXHJcblxyXG4gICAgc3BsaWNlOiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIHNwbGljZWQgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHZhciBpbnNlcnRlZDtcclxuXHJcbiAgICAgIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLnJlbW92ZSwgc3BsaWNlZCk7XHJcblxyXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICBpbnNlcnRlZCA9IHRoaXMuc2xpY2UoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMF0gKyBhcmd1bWVudHMubGVuZ3RoIC0gMik7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKFR3by5FdmVudHMuaW5zZXJ0LCBpbnNlcnRlZCk7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKFR3by5FdmVudHMub3JkZXIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzcGxpY2VkO1xyXG4gICAgfSxcclxuXHJcbiAgICBzb3J0OiBmdW5jdGlvbigpIHtcclxuICAgICAgQXJyYXkucHJvdG90eXBlLnNvcnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgdGhpcy50cmlnZ2VyKFR3by5FdmVudHMub3JkZXIpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLm9yZGVyKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gIH0pO1xyXG5cclxuICAvLyBMb2NhbGl6ZSB1dGlsc1xyXG5cclxuICB2YXIgZ2V0QW5jaG9yc0Zyb21BcmNEYXRhID0gVHdvLlV0aWxzLmdldEFuY2hvcnNGcm9tQXJjRGF0YSxcclxuICAgIGdldENvbnRyb2xQb2ludHMgPSBUd28uVXRpbHMuZ2V0Q29udHJvbFBvaW50cyxcclxuICAgIGdldEN1cnZlRnJvbVBvaW50cyA9IFR3by5VdGlscy5nZXRDdXJ2ZUZyb21Qb2ludHMsXHJcbiAgICBzb2x2ZVNlZ21lbnRJbnRlcnNlY3Rpb24gPSBUd28uVXRpbHMuc29sdmVTZWdtZW50SW50ZXJzZWN0aW9uLFxyXG4gICAgZGVjb3VwbGVTaGFwZXMgPSBUd28uVXRpbHMuZGVjb3VwbGVTaGFwZXMsXHJcbiAgICBtb2QgPSBUd28uVXRpbHMubW9kLFxyXG4gICAgZ2V0QmFja2luZ1N0b3JlUmF0aW8gPSBUd28uVXRpbHMuZ2V0QmFja2luZ1N0b3JlUmF0aW8sXHJcbiAgICBnZXRDb21wb25lbnRPbkN1YmljQmV6aWVyID0gVHdvLlV0aWxzLmdldENvbXBvbmVudE9uQ3ViaWNCZXppZXIsXHJcbiAgICBnZXRDdXJ2ZUxlbmd0aCA9IFR3by5VdGlscy5nZXRDdXJ2ZUxlbmd0aCxcclxuICAgIGludGVncmF0ZSA9IFR3by5VdGlscy5pbnRlZ3JhdGUsXHJcbiAgICBnZXRSZWZsZWN0aW9uID0gVHdvLlV0aWxzLmdldFJlZmxlY3Rpb247XHJcblxyXG4gIF8uZXh0ZW5kKFR3by5wcm90b3R5cGUsIFR3by5VdGlscy5FdmVudHMsIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVHdvLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvI2FwcGVuZFRvXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbSAtIFRoZSBET00gZWxlbWVudCB0byBhcHBlbmQgdGhlIFR3by5qcyBzdGFnZSB0by5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBTaG9ydGhhbmQgbWV0aG9kIHRvIGFwcGVuZCB5b3VyIGluc3RhbmNlIG9mIFR3by5qcyB0byB0aGUgYGRvY3VtZW50YC5cclxuICAgICAqL1xyXG4gICAgYXBwZW5kVG86IGZ1bmN0aW9uKGVsZW0pIHtcclxuXHJcbiAgICAgIGVsZW0uYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3byNwbGF5XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBmaXJlcyBUd28uRXZlbnRzLnBsYXkgZXZlbnRcclxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsIHRvIHN0YXJ0IGFuIGludGVybmFsIGFuaW1hdGlvbiBsb29wLlxyXG4gICAgICogQG5vdGEtYmVuZSBUaGlzIGZ1bmN0aW9uIGluaXRpYXRlcyBhIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGxvb3AuXHJcbiAgICAgKi9cclxuICAgIHBsYXk6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgVHdvLlV0aWxzLnNldFBsYXlpbmcuY2FsbCh0aGlzLCB0cnVlKTtcclxuICAgICAgcmFmLmluaXQoKTtcclxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLnBsYXkpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28jcGF1c2VcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGZpcmVzIFR3by5FdmVudHMucGF1c2UgZXZlbnRcclxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsIHRvIHN0b3AgdGhlIGludGVybmFsIGFuaW1hdGlvbiBsb29wIGZvciBhIHNwZWNpZmljIGluc3RhbmNlIG9mIFR3by5qcy5cclxuICAgICAqL1xyXG4gICAgcGF1c2U6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoVHdvLkV2ZW50cy5wYXVzZSk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3byN1cGRhdGVcclxuICAgICAqIEBmaXJlcyBUd28uRXZlbnRzLnVwZGF0ZSBldmVudFxyXG4gICAgICogQGRlc2NyaXB0aW9uIFVwZGF0ZSBwb3NpdGlvbnMgYW5kIGNhbGN1bGF0aW9ucyBpbiBvbmUgcGFzcyBiZWZvcmUgcmVuZGVyaW5nLiBUaGVuIHJlbmRlciB0byB0aGUgY2FudmFzLlxyXG4gICAgICogQG5vdGEtYmVuZSBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGlmIHVzaW5nIHtAbGluayBUd28jcGxheX0gb3IgdGhlIGBhdXRvc3RhcnRgIHBhcmFtZXRlciBpbiBjb25zdHJ1Y3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB2YXIgYW5pbWF0ZWQgPSAhIXRoaXMuX2xhc3RGcmFtZTtcclxuICAgICAgdmFyIG5vdyA9IHBlcmYubm93KCk7XHJcblxyXG4gICAgICBpZiAoYW5pbWF0ZWQpIHtcclxuICAgICAgICB0aGlzLnRpbWVEZWx0YSA9IHBhcnNlRmxvYXQoKG5vdyAtIHRoaXMuX2xhc3RGcmFtZSkudG9GaXhlZCgzKSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fbGFzdEZyYW1lID0gbm93O1xyXG5cclxuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xyXG5cclxuICAgICAgLy8gVXBkYXRlIHdpZHRoIC8gaGVpZ2h0IGZvciB0aGUgcmVuZGVyZXJcclxuICAgICAgaWYgKHdpZHRoICE9PSByZW5kZXJlci53aWR0aCB8fCBoZWlnaHQgIT09IHJlbmRlcmVyLmhlaWdodCkge1xyXG4gICAgICAgIHJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodCwgdGhpcy5yYXRpbyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLnVwZGF0ZSwgdGhpcy5mcmFtZUNvdW50LCB0aGlzLnRpbWVEZWx0YSk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXIoKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvI3JlbmRlclxyXG4gICAgICogQGZpcmVzIFR3by5FdmVudHMucmVuZGVyIGV2ZW50XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUmVuZGVyIGFsbCBkcmF3YWJsZSBhbmQgdmlzaWJsZSBvYmplY3RzIG9mIHRoZSBzY2VuZS5cclxuICAgICAqL1xyXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKCk7XHJcbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoVHdvLkV2ZW50cy5yZW5kZXIsIHRoaXMuZnJhbWVDb3VudCsrKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIENvbnZlbmllbmNlIE1ldGhvZHNcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3byNhZGRcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHsoVHdvLlNoYXBlW118Li4uVHdvLlNoYXBlKX19IFtvYmplY3RzXSAtIEFuIGFycmF5IG9mIFR3by5qcyBvYmplY3RzLiBBbHRlcm5hdGl2ZWx5IGNhbiBhZGQgb2JqZWN0cyBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cy5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBBIHNob3J0aGFuZCBtZXRob2QgdG8gYWRkIHNwZWNpZmljIFR3by5qcyBvYmplY3RzIHRvIHRoZSBzY2VuZS5cclxuICAgICAqL1xyXG4gICAgYWRkOiBmdW5jdGlvbihvKSB7XHJcblxyXG4gICAgICB2YXIgb2JqZWN0cyA9IG87XHJcbiAgICAgIGlmICghKG9iamVjdHMgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICBvYmplY3RzID0gXy50b0FycmF5KGFyZ3VtZW50cyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuc2NlbmUuYWRkKG9iamVjdHMpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvI3JlbW92ZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyhUd28uU2hhcGVbXXwuLi5Ud28uU2hhcGUpfSBbb2JqZWN0c10gLSBBbiBhcnJheSBvZiBUd28uanMgb2JqZWN0cy5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBBIHNob3J0aGFuZCBtZXRob2QgdG8gcmVtb3ZlIHNwZWNpZmljIFR3by5qcyBvYmplY3RzIGZyb20gdGhlIHNjZW5lLlxyXG4gICAgICovXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uKG8pIHtcclxuXHJcbiAgICAgIHZhciBvYmplY3RzID0gbztcclxuICAgICAgaWYgKCEob2JqZWN0cyBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICAgIG9iamVjdHMgPSBfLnRvQXJyYXkoYXJndW1lbnRzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUob2JqZWN0cyk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvI2NsZWFyXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW1vdmUgYWxsIGFsbCBUd28uanMgb2JqZWN0cyBmcm9tIHRoZSBzY2VuZS5cclxuICAgICAqL1xyXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUodGhpcy5zY2VuZS5jaGlsZHJlbik7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28jbWFrZUxpbmVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHgxXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geTFcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkyXHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLkxpbmV9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyBsaW5lIGFuZCBhZGRzIGl0IHRvIHRoZSBzY2VuZS5cclxuICAgICAqL1xyXG4gICAgbWFrZUxpbmU6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XHJcblxyXG4gICAgICB2YXIgbGluZSA9IG5ldyBUd28uTGluZSh4MSwgeTEsIHgyLCB5Mik7XHJcbiAgICAgIHRoaXMuc2NlbmUuYWRkKGxpbmUpO1xyXG5cclxuICAgICAgcmV0dXJuIGxpbmU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3byNtYWtlQXJyb3dcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHgxXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geTFcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkyXHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLlBhdGh9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyBhcnJvdyBhbmQgYWRkcyBpdCB0byB0aGUgc2NlbmUuXHJcbiAgICAgKi9cclxuICAgIG1ha2VBcnJvdzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHNpemUpIHtcclxuXHJcbiAgICAgIHZhciBoZWFkbGVuID0gXy5pc051bWJlcihzaXplICkgPyBzaXplIDogMTA7XHJcblxyXG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpO1xyXG5cclxuICAgICAgdmFyIHZlcnRpY2VzID0gW1xyXG5cclxuICAgICAgICBuZXcgVHdvLkFuY2hvcih4MSwgeTEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgVHdvLkNvbW1hbmRzLm1vdmUpLFxyXG4gICAgICAgIG5ldyBUd28uQW5jaG9yKHgyLCB5MiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBUd28uQ29tbWFuZHMubGluZSksXHJcbiAgICAgICAgbmV3IFR3by5BbmNob3IoXHJcbiAgICAgICAgICB4MiAtIGhlYWRsZW4gKiBNYXRoLmNvcyhhbmdsZSAtIE1hdGguUEkgLyA0KSxcclxuICAgICAgICAgIHkyIC0gaGVhZGxlbiAqIE1hdGguc2luKGFuZ2xlIC0gTWF0aC5QSSAvIDQpLFxyXG4gICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBUd28uQ29tbWFuZHMubGluZVxyXG4gICAgICAgICksXHJcblxyXG4gICAgICAgIG5ldyBUd28uQW5jaG9yKHgyLCB5MiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBUd28uQ29tbWFuZHMubW92ZSksXHJcbiAgICAgICAgbmV3IFR3by5BbmNob3IoXHJcbiAgICAgICAgICB4MiAtIGhlYWRsZW4gKiBNYXRoLmNvcyhhbmdsZSArIE1hdGguUEkgLyA0KSxcclxuICAgICAgICAgIHkyIC0gaGVhZGxlbiAqIE1hdGguc2luKGFuZ2xlICsgTWF0aC5QSSAvIDQpLFxyXG4gICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBUd28uQ29tbWFuZHMubGluZVxyXG4gICAgICAgIClcclxuXHJcbiAgICAgIF07XHJcblxyXG4gICAgICB2YXIgcGF0aCA9IG5ldyBUd28uUGF0aCh2ZXJ0aWNlcywgZmFsc2UsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgcGF0aC5ub0ZpbGwoKTtcclxuICAgICAgcGF0aC5jYXAgPSAncm91bmQnO1xyXG4gICAgICBwYXRoLmpvaW4gPSAncm91bmQnO1xyXG5cclxuICAgICAgdGhpcy5zY2VuZS5hZGQocGF0aCk7XHJcblxyXG4gICAgICByZXR1cm4gcGF0aDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28jbWFrZVJlY3RhbmdsZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxyXG4gICAgICogQHJldHVybnMge1R3by5SZWN0YW5nbGV9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyByZWN0YW5nbGUgYW5kIGFkZHMgaXQgdG8gdGhlIHNjZW5lLlxyXG4gICAgICovXHJcbiAgICBtYWtlUmVjdGFuZ2xlOiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcblxyXG4gICAgICB2YXIgcmVjdCA9IG5ldyBUd28uUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICB0aGlzLnNjZW5lLmFkZChyZWN0KTtcclxuXHJcbiAgICAgIHJldHVybiByZWN0O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28jbWFrZVJvdW5kZWRSZWN0YW5nbGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaWRlc1xyXG4gICAgICogQHJldHVybnMge1R3by5SZWN0YW5nbGV9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyByb3VuZGVkIHJlY3RhbmdsZSBhbmQgYWRkcyBpdCB0byB0aGUgc2NlbmUuXHJcbiAgICAgKi9cclxuICAgIG1ha2VSb3VuZGVkUmVjdGFuZ2xlOiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzaWRlcykge1xyXG5cclxuICAgICAgdmFyIHJlY3QgPSBuZXcgVHdvLlJvdW5kZWRSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgc2lkZXMpO1xyXG4gICAgICB0aGlzLnNjZW5lLmFkZChyZWN0KTtcclxuXHJcbiAgICAgIHJldHVybiByZWN0O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28jbWFrZUNpcmNsZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmVzb2x1dGlvbj00XVxyXG4gICAgICogQHJldHVybnMge1R3by5DaXJjbGV9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyBjaXJjbGUgYW5kIGFkZHMgaXQgdG8gdGhlIHNjZW5lLlxyXG4gICAgICovXHJcbiAgICBtYWtlQ2lyY2xlOiBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHJlc29sdXRpb24pIHtcclxuXHJcbiAgICAgIHZhciBjaXJjbGUgPSBuZXcgVHdvLkNpcmNsZSh4LCB5LCByYWRpdXMsIHJlc29sdXRpb24pO1xyXG4gICAgICB0aGlzLnNjZW5lLmFkZChjaXJjbGUpO1xyXG5cclxuICAgICAgcmV0dXJuIGNpcmNsZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvI21ha2VFbGxpcHNlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJ4XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcnlcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmVzb2x1dGlvbj00XVxyXG4gICAgICogQHJldHVybnMge1R3by5FbGxpcHNlfVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgZWxsaXBzZSBhbmQgYWRkcyBpdCB0byB0aGUgc2NlbmUuXHJcbiAgICAgKi9cclxuICAgIG1ha2VFbGxpcHNlOiBmdW5jdGlvbih4LCB5LCByeCwgcnksIHJlc29sdXRpb24pIHtcclxuXHJcbiAgICAgIHZhciBlbGxpcHNlID0gbmV3IFR3by5FbGxpcHNlKHgsIHksIHJ4LCByeSwgcmVzb2x1dGlvbik7XHJcbiAgICAgIHRoaXMuc2NlbmUuYWRkKGVsbGlwc2UpO1xyXG5cclxuICAgICAgcmV0dXJuIGVsbGlwc2U7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3byNtYWtlU3RhclxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvdXRlclJhZGl1c1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlubmVyUmFkaXVzXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2lkZXNcclxuICAgICAqIEByZXR1cm5zIHtUd28uU3Rhcn1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgVHdvLmpzIHN0YXIgYW5kIGFkZHMgaXQgdG8gdGhlIHNjZW5lLlxyXG4gICAgICovXHJcbiAgICBtYWtlU3RhcjogZnVuY3Rpb24ob3gsIG95LCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMsIHNpZGVzKSB7XHJcblxyXG4gICAgICB2YXIgc3RhciA9IG5ldyBUd28uU3RhcihveCwgb3ksIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1cywgc2lkZXMpO1xyXG4gICAgICB0aGlzLnNjZW5lLmFkZChzdGFyKTtcclxuXHJcbiAgICAgIHJldHVybiBzdGFyO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28jbWFrZUN1cnZlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7VHdvLkFuY2hvcltdfSBbcG9pbnRzXSAtIEFuIGFycmF5IG9mIHtAbGluayBUd28uQW5jaG9yfSBwb2ludHMuXHJcbiAgICAgKiBAcGFyYW0gey4uLk51bWJlcn0gLSBBbHRlcm5hdGl2ZWx5IHlvdSBjYW4gcGFzcyBhbHRlcm5hdGluZyBgeGAgLyBgeWAgY29vcmRpbmF0ZSB2YWx1ZXMgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMuIFRoZXNlIHdpbGwgYmUgY29tYmluZWQgaW50byB7QGxpbmsgVHdvLkFuY2hvcn1zIGZvciB1c2UgaW4gdGhlIHBhdGguXHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLlBhdGh9IC0gV2hlcmUgYHBhdGguY3VydmVkYCBpcyBzZXQgdG8gYHRydWVgLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgcGF0aCB0aGF0IGlzIGN1cnZlZCBhbmQgYWRkcyBpdCB0byB0aGUgc2NlbmUuXHJcbiAgICAgKiBAbm90YS1iZW5lIEluIGVpdGhlciBjYXNlIG9mIHBhc3NpbmcgYW4gYXJyYXkgb3IgcGFzc2luZyBudW1iZXJlZCBhcmd1bWVudHMgdGhlIGxhc3QgYXJndW1lbnQgaXMgYW4gb3B0aW9uYWwgYEJvb2xlYW5gIHRoYXQgZGVmaW5lcyB3aGV0aGVyIHRoZSBwYXRoIHNob3VsZCBiZSBvcGVuIG9yIGNsb3NlZC5cclxuICAgICAqL1xyXG4gICAgbWFrZUN1cnZlOiBmdW5jdGlvbihwKSB7XHJcblxyXG4gICAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGgsIHBvaW50cyA9IHA7XHJcbiAgICAgIGlmICghXy5pc0FycmF5KHApKSB7XHJcbiAgICAgICAgcG9pbnRzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKz0yKSB7XHJcbiAgICAgICAgICB2YXIgeCA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgIGlmICghXy5pc051bWJlcih4KSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhciB5ID0gYXJndW1lbnRzW2kgKyAxXTtcclxuICAgICAgICAgIHBvaW50cy5wdXNoKG5ldyBUd28uQW5jaG9yKHgsIHkpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBsYXN0ID0gYXJndW1lbnRzW2wgLSAxXTtcclxuICAgICAgdmFyIGN1cnZlID0gbmV3IFR3by5QYXRoKHBvaW50cywgIShfLmlzQm9vbGVhbihsYXN0KSA/IGxhc3QgOiB1bmRlZmluZWQpLCB0cnVlKTtcclxuICAgICAgdmFyIHJlY3QgPSBjdXJ2ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgY3VydmUuY2VudGVyKCkudHJhbnNsYXRpb25cclxuICAgICAgICAuc2V0KHJlY3QubGVmdCArIHJlY3Qud2lkdGggLyAyLCByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC8gMik7XHJcblxyXG4gICAgICB0aGlzLnNjZW5lLmFkZChjdXJ2ZSk7XHJcblxyXG4gICAgICByZXR1cm4gY3VydmU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3byNtYWtlUG9seWdvblxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaWRlc1xyXG4gICAgICogQHJldHVybnMge1R3by5Qb2x5Z29ufVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgcG9seWdvbiBhbmQgYWRkcyBpdCB0byB0aGUgc2NlbmUuXHJcbiAgICAgKi9cclxuICAgIG1ha2VQb2x5Z29uOiBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHNpZGVzKSB7XHJcblxyXG4gICAgICB2YXIgcG9seSA9IG5ldyBUd28uUG9seWdvbih4LCB5LCByYWRpdXMsIHNpZGVzKTtcclxuICAgICAgdGhpcy5zY2VuZS5hZGQocG9seSk7XHJcblxyXG4gICAgICByZXR1cm4gcG9seTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvI21ha2VBcmNTZWdtZW50XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlubmVyUmFkaXVzXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3V0ZXJSYWRpdXNcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZW5kQW5nbGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmVzb2x1dGlvbj1Ud28uUmVzb2x1dGlvbl0gLSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHRoYXQgc2hvdWxkIGNvbXByaXNlIHRoZSBhcmMgc2VnbWVudC5cclxuICAgICAqL1xyXG4gICAgbWFrZUFyY1NlZ21lbnQ6IGZ1bmN0aW9uKG94LCBveSwgaXIsIG9yLCBzYSwgZWEsIHJlcykge1xyXG4gICAgICB2YXIgYXJjU2VnbWVudCA9IG5ldyBUd28uQXJjU2VnbWVudChveCwgb3ksIGlyLCBvciwgc2EsIGVhLCByZXMpO1xyXG4gICAgICB0aGlzLnNjZW5lLmFkZChhcmNTZWdtZW50KTtcclxuICAgICAgcmV0dXJuIGFyY1NlZ21lbnQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvI21ha2VQYXRoXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7VHdvLkFuY2hvcltdfSBbcG9pbnRzXSAtIEFuIGFycmF5IG9mIHtAbGluayBUd28uQW5jaG9yfSBwb2ludHMuXHJcbiAgICAgKiBAcGFyYW0gey4uLk51bWJlcn0gLSBBbHRlcm5hdGl2ZWx5IHlvdSBjYW4gcGFzcyBhbHRlcm5hdGluZyBgeGAgLyBgeWAgY29vcmRpbmF0ZSB2YWx1ZXMgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMuIFRoZXNlIHdpbGwgYmUgY29tYmluZWQgaW50byB7QGxpbmsgVHdvLkFuY2hvcn1zIGZvciB1c2UgaW4gdGhlIHBhdGguXHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLlBhdGh9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyBwYXRoIGFuZCBhZGRzIGl0IHRvIHRoZSBzY2VuZS5cclxuICAgICAqIEBub3RhLWJlbmUgSW4gZWl0aGVyIGNhc2Ugb2YgcGFzc2luZyBhbiBhcnJheSBvciBwYXNzaW5nIG51bWJlcmVkIGFyZ3VtZW50cyB0aGUgbGFzdCBhcmd1bWVudCBpcyBhbiBvcHRpb25hbCBgQm9vbGVhbmAgdGhhdCBkZWZpbmVzIHdoZXRoZXIgdGhlIHBhdGggc2hvdWxkIGJlIG9wZW4gb3IgY2xvc2VkLlxyXG4gICAgICovXHJcbiAgICBtYWtlUGF0aDogZnVuY3Rpb24ocCkge1xyXG5cclxuICAgICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoLCBwb2ludHMgPSBwO1xyXG4gICAgICBpZiAoIV8uaXNBcnJheShwKSkge1xyXG4gICAgICAgIHBvaW50cyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSs9Mikge1xyXG4gICAgICAgICAgdmFyIHggPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICBpZiAoIV8uaXNOdW1iZXIoeCkpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB2YXIgeSA9IGFyZ3VtZW50c1tpICsgMV07XHJcbiAgICAgICAgICBwb2ludHMucHVzaChuZXcgVHdvLkFuY2hvcih4LCB5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgbGFzdCA9IGFyZ3VtZW50c1tsIC0gMV07XHJcbiAgICAgIHZhciBwYXRoID0gbmV3IFR3by5QYXRoKHBvaW50cywgIShfLmlzQm9vbGVhbihsYXN0KSA/IGxhc3QgOiB1bmRlZmluZWQpKTtcclxuICAgICAgdmFyIHJlY3QgPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuICAgICAgaWYgKF8uaXNOdW1iZXIocmVjdC50b3ApICAgJiYgXy5pc051bWJlcihyZWN0LmxlZnQpICAgJiZcclxuICAgICAgICAgIF8uaXNOdW1iZXIocmVjdC5yaWdodCkgJiYgXy5pc051bWJlcihyZWN0LmJvdHRvbSkpIHtcclxuICAgICAgICBwYXRoLmNlbnRlcigpLnRyYW5zbGF0aW9uXHJcbiAgICAgICAgICAuc2V0KHJlY3QubGVmdCArIHJlY3Qud2lkdGggLyAyLCByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC8gMik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuc2NlbmUuYWRkKHBhdGgpO1xyXG5cclxuICAgICAgcmV0dXJuIHBhdGg7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3byNtYWtlVGV4dFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlc10gLSBBbiBvYmplY3QgdG8gZGVzY3JpYmUgYW55IG9mIHRoZSB7QGxpbmsgVHdvLlRleHQuUHJvcGVydGllc30gaW5jbHVkaW5nIGBmaWxsYCwgYHN0cm9rZWAsIGBsaW5ld2lkdGhgLCBgZmFtaWx5YCwgYGFsaWdubWVudGAsIGBsZWFkaW5nYCwgYG9wYWNpdHlgLCBldGMuLlxyXG4gICAgICogQHJldHVybnMge1R3by5UZXh0fVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgdGV4dCBvYmplY3QgYW5kIGFkZHMgaXQgdG8gdGhlIHNjZW5lLlxyXG4gICAgICovXHJcbiAgICBtYWtlVGV4dDogZnVuY3Rpb24obWVzc2FnZSwgeCwgeSwgc3R5bGVzKSB7XHJcbiAgICAgIHZhciB0ZXh0ID0gbmV3IFR3by5UZXh0KG1lc3NhZ2UsIHgsIHksIHN0eWxlcyk7XHJcbiAgICAgIHRoaXMuYWRkKHRleHQpO1xyXG4gICAgICByZXR1cm4gdGV4dDtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28jbWFrZUxpbmVhckdyYWRpZW50XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkxXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geDJcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5MlxyXG4gICAgICogQHBhcmFtIHsuLi5Ud28uU3RvcH0gW3N0b3BzXSAtIEFueSBudW1iZXIgb2YgY29sb3Igc3RvcHMgc29tZXRpbWVzIHJlZmZlcmVkIHRvIGFzIHJhbXAgc3RvcHMuIElmIG5vbmUgYXJlIHN1cHBsaWVkIHRoZW4gdGhlIGRlZmF1bHQgYmxhY2stdG8td2hpdGUgdHdvIHN0b3AgZ3JhZGllbnQgaXMgYXBwbGllZC5cclxuICAgICAqIEByZXR1cm5zIHtUd28uTGluZWFyR3JhZGllbnR9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyBsaW5lYXIgZ3JhZGllbnQgYW5kIGFkcyBpdCB0byB0aGUgc2NlbmUuIEluIHRoZSBjYXNlIG9mIGFuIGVmZmVjdCBpdCdzIGFkZGVkIHRvIGFuIGludmlzaWJsZSBcImRlZmluaXRpb25zXCIgZ3JvdXAuXHJcbiAgICAgKi9cclxuICAgIG1ha2VMaW5lYXJHcmFkaWVudDogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIgLyogc3RvcHMgKi8pIHtcclxuXHJcbiAgICAgIHZhciBzdG9wcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCA0KTtcclxuICAgICAgdmFyIGdyYWRpZW50ID0gbmV3IFR3by5MaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5Miwgc3RvcHMpO1xyXG5cclxuICAgICAgdGhpcy5hZGQoZ3JhZGllbnQpO1xyXG5cclxuICAgICAgcmV0dXJuIGdyYWRpZW50O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28jbWFrZVJhZGlhbEdyYWRpZW50XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkxXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXHJcbiAgICAgKiBAcGFyYW0gey4uLlR3by5TdG9wfSBbc3RvcHNdIC0gQW55IG51bWJlciBvZiBjb2xvciBzdG9wcyBzb21ldGltZXMgcmVmZmVyZWQgdG8gYXMgcmFtcCBzdG9wcy4gSWYgbm9uZSBhcmUgc3VwcGxpZWQgdGhlbiB0aGUgZGVmYXVsdCBibGFjay10by13aGl0ZSB0d28gc3RvcCBncmFkaWVudCBpcyBhcHBsaWVkLlxyXG4gICAgICogQHJldHVybnMge1R3by5SYWRpYWxHcmFkaWVudH1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgVHdvLmpzIGxpbmVhci1ncmFkaWVudCBvYmplY3QgYW5kIGFkcyBpdCB0byB0aGUgc2NlbmUuIEluIHRoZSBjYXNlIG9mIGFuIGVmZmVjdCBpdCdzIGFkZGVkIHRvIGFuIGludmlzaWJsZSBcImRlZmluaXRpb25zXCIgZ3JvdXAuXHJcbiAgICAgKi9cclxuICAgIG1ha2VSYWRpYWxHcmFkaWVudDogZnVuY3Rpb24oeDEsIHkxLCByIC8qIHN0b3BzICovKSB7XHJcblxyXG4gICAgICB2YXIgc3RvcHMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XHJcbiAgICAgIHZhciBncmFkaWVudCA9IG5ldyBUd28uUmFkaWFsR3JhZGllbnQoeDEsIHkxLCByLCBzdG9wcyk7XHJcblxyXG4gICAgICB0aGlzLmFkZChncmFkaWVudCk7XHJcblxyXG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3byNtYWtlU3ByaXRlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7KFN0cmluZ3xUd28uVGV4dHVyZSl9IHBhdGhPclRleHR1cmUgLSBUaGUgVVJMIHBhdGggdG8gYW4gaW1hZ2Ugb3IgYW4gYWxyZWFkeSBjcmVhdGVkIHtAbGluayBUd28uVGV4dHVyZX0uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29sdW1ucz0xXVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyb3dzPTFdXHJcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IFtmcmFtZVJhdGU9MF1cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2F1dG9zdGFydD1mYWxzZV1cclxuICAgICAqIEByZXR1cm5zIHtUd28uU3ByaXRlfVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgc3ByaXRlIG9iamVjdCBhbmQgYWRkcyBpdCB0byB0aGUgc2NlbmUuIFNwcml0ZXMgY2FuIGJlIHVzZWQgZm9yIHN0aWxsIGltYWdlcyBhcyB3ZWxsIGFzIGFuaW1hdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIG1ha2VTcHJpdGU6IGZ1bmN0aW9uKHBhdGgsIHgsIHksIGNvbHMsIHJvd3MsIGZyYW1lUmF0ZSwgYXV0b3N0YXJ0KSB7XHJcblxyXG4gICAgICB2YXIgc3ByaXRlID0gbmV3IFR3by5TcHJpdGUocGF0aCwgeCwgeSwgY29scywgcm93cywgZnJhbWVSYXRlKTtcclxuICAgICAgaWYgKGF1dG9zdGFydCkge1xyXG4gICAgICAgIHNwcml0ZS5wbGF5KCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5hZGQoc3ByaXRlKTtcclxuXHJcbiAgICAgIHJldHVybiBzcHJpdGU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3byNtYWtlSW1hZ2VTZXF1ZW5jZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyhTdHJpbmdbXXxUd28uVGV4dHVyZVtdKX0gcGF0aHNPclRleHR1cmVzIC0gQW4gYXJyYXkgb2YgcGF0aHMgb3Igb2Yge0BsaW5rIFR3by5UZXh0dXJlc30uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJhbWVSYXRlPTBdXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthdXRvc3RhcnQ9ZmFsc2VdXHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLkltYWdlU2VxdWVuY2V9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyBpbWFnZSBzZXF1ZW5jZSBvYmplY3QgYW5kIGFkZHMgaXQgdG8gdGhlIHNjZW5lLlxyXG4gICAgICovXHJcbiAgICBtYWtlSW1hZ2VTZXF1ZW5jZTogZnVuY3Rpb24ocGF0aHMsIHgsIHksIGZyYW1lUmF0ZSwgYXV0b3N0YXJ0KSB7XHJcblxyXG4gICAgICB2YXIgaW1hZ2VTZXF1ZW5jZSA9IG5ldyBUd28uSW1hZ2VTZXF1ZW5jZShwYXRocywgeCwgeSwgZnJhbWVSYXRlKTtcclxuICAgICAgaWYgKGF1dG9zdGFydCkge1xyXG4gICAgICAgIGltYWdlU2VxdWVuY2UucGxheSgpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuYWRkKGltYWdlU2VxdWVuY2UpO1xyXG5cclxuICAgICAgcmV0dXJuIGltYWdlU2VxdWVuY2U7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3byNtYWtlVGV4dHVyZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyhTdHJpbmd8SW1hZ2V8Q2FudmFzfFZpZGVvKX0gW3BhdGhPclNvdXJjZV0gLSBUaGUgVVJMIHBhdGggdG8gYW4gaW1hZ2Ugb3IgYSBET00gaW1hZ2UtbGlrZSBlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgaW1hZ2UgaXMgbG9hZGVkLlxyXG4gICAgICogQHJldHVybnMge1R3by5UZXh0dXJlfVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgdGV4dHVyZSBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIG1ha2VUZXh0dXJlOiBmdW5jdGlvbihwYXRoLCBjYWxsYmFjaykge1xyXG5cclxuICAgICAgdmFyIHRleHR1cmUgPSBuZXcgVHdvLlRleHR1cmUocGF0aCwgY2FsbGJhY2spO1xyXG4gICAgICByZXR1cm4gdGV4dHVyZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvI21ha2VHcm91cFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0geyhUd28uU2hhcGVbXXwuLi5Ud28uU2hhcGUpfSBbb2JqZWN0c10gLSBUd28uanMgb2JqZWN0cyB0byBiZSBhZGRlZCB0byB0aGUgZ3JvdXAgaW4gdGhlIGZvcm0gb2YgYW4gYXJyYXkgb3IgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMuXHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLkdyb3VwfVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgZ3JvdXAgb2JqZWN0IGFuZCBhZGRzIGl0IHRvIHRoZSBzY2VuZS5cclxuICAgICAqL1xyXG4gICAgbWFrZUdyb3VwOiBmdW5jdGlvbihvKSB7XHJcblxyXG4gICAgICB2YXIgb2JqZWN0cyA9IG87XHJcbiAgICAgIGlmICghKG9iamVjdHMgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICBvYmplY3RzID0gXy50b0FycmF5KGFyZ3VtZW50cyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBncm91cCA9IG5ldyBUd28uR3JvdXAoKTtcclxuICAgICAgdGhpcy5zY2VuZS5hZGQoZ3JvdXApO1xyXG4gICAgICBncm91cC5hZGQob2JqZWN0cyk7XHJcblxyXG4gICAgICByZXR1cm4gZ3JvdXA7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3byNpbnRlcnByZXRcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtTdmdOb2RlfSBzdmdOb2RlIC0gVGhlIFNWRyBub2RlIHRvIGJlIHBhcnNlZC5cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hhbGxvdyAtIERvbid0IGNyZWF0ZSBhIHRvcC1tb3N0IGdyb3VwIGJ1dCBhcHBlbmQgYWxsIGNvbnRlbnQgZGlyZWN0bHkuXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFkZCDigJMgQXV0b21hdGljYWxseSBhZGQgdGhlIHJlY29uc3RydWN0ZWQgU1ZHIG5vZGUgdG8gc2NlbmUuXHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLkdyb3VwfVxyXG4gICAgICogQGRlc2NyaXB0aW9uIEludGVycHJldCBhbiBTVkcgTm9kZSBhbmQgYWRkIGl0IHRvIHRoaXMgaW5zdGFuY2UncyBzY2VuZS4gVGhlIGRpc3RpbmN0aW9uIHNob3VsZCBiZSBtYWRlIHRoYXQgdGhpcyBkb2Vzbid0IGBpbXBvcnRgIHN2ZydzLCBpdCBzb2xlbHkgaW50ZXJwcmV0cyB0aGVtIGludG8gc29tZXRoaW5nIGNvbXBhdGlibGUgZm9yIFR3by5qcyAtIHRoaXMgaXMgc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW4gYSBkaXJlY3QgdHJhbnNjcmlwdGlvbi5cclxuICAgICAqL1xyXG4gICAgaW50ZXJwcmV0OiBmdW5jdGlvbihzdmdOb2RlLCBzaGFsbG93LCBhZGQpIHtcclxuXHJcbiAgICAgIHZhciB0YWcgPSBzdmdOb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICAgIGFkZCA9ICh0eXBlb2YgYWRkICE9PSAndW5kZWZpbmVkJykgPyBhZGQgOiB0cnVlO1xyXG5cclxuICAgICAgaWYgKCEodGFnIGluIFR3by5VdGlscy5yZWFkKSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgbm9kZSA9IFR3by5VdGlscy5yZWFkW3RhZ10uY2FsbCh0aGlzLCBzdmdOb2RlKTtcclxuXHJcbiAgICAgIGlmIChhZGQpIHtcclxuICAgICAgICB0aGlzLmFkZChzaGFsbG93ICYmIG5vZGUgaW5zdGFuY2VvZiBUd28uR3JvdXAgPyBub2RlLmNoaWxkcmVuIDogbm9kZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBub2RlO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28jbG9hZFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xTdmdOb2RlfSBwYXRoT3JTVkdDb250ZW50IC0gVGhlIFVSTCBwYXRoIG9mIGFuIFNWRyBmaWxlIG9yIGFuIFNWRyBkb2N1bWVudCBhcyB0ZXh0LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsIG9uY2UgbG9hZGluZyBoYXMgY29tcGxldGVkLlxyXG4gICAgICogQHJldHVybnMge1R3by5Hcm91cH1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBMb2FkIGFuIFNWRyBmaWxlIG9yIFNWRyB0ZXh0IGFuZCBpbnRlcnByZXQgaXQgaW50byBUd28uanMgbGVnaWJsZSBvYmplY3RzLlxyXG4gICAgICovXHJcbiAgICBsb2FkOiBmdW5jdGlvbih0ZXh0LCBjYWxsYmFjaykge1xyXG5cclxuICAgICAgdmFyIGdyb3VwID0gbmV3IFR3by5Hcm91cCgpO1xyXG4gICAgICB2YXIgZWxlbSwgaSwgajtcclxuXHJcbiAgICAgIHZhciBhdHRhY2ggPSBfLmJpbmQoZnVuY3Rpb24oZGF0YSkge1xyXG5cclxuICAgICAgICBkb20udGVtcC5pbm5lckhUTUwgPSBkYXRhO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZG9tLnRlbXAuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGVsZW0gPSBkb20udGVtcC5jaGlsZHJlbltpXTtcclxuICAgICAgICAgIGlmICgvc3ZnL2kudGVzdChlbGVtLm5vZGVOYW1lKSkge1xyXG4gICAgICAgICAgICAvLyBUd28uVXRpbHMuYXBwbHlTdmdWaWV3Qm94LmNhbGwodGhpcywgZ3JvdXAsIGVsZW0uZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykpO1xyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZWxlbS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgIGdyb3VwLmFkZCh0aGlzLmludGVycHJldChlbGVtLmNoaWxkcmVuW2pdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGdyb3VwLmFkZCh0aGlzLmludGVycHJldChlbGVtKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICAgICAgdmFyIHN2ZyA9IGRvbS50ZW1wLmNoaWxkcmVuLmxlbmd0aCA8PSAxXHJcbiAgICAgICAgICAgID8gZG9tLnRlbXAuY2hpbGRyZW5bMF0gOiBkb20udGVtcC5jaGlsZHJlbjtcclxuICAgICAgICAgIGNhbGxiYWNrKGdyb3VwLCBzdmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgaWYgKC8uKlxcLnN2ZyQvaWcudGVzdCh0ZXh0KSkge1xyXG5cclxuICAgICAgICBUd28uVXRpbHMueGhyKHRleHQsIGF0dGFjaCk7XHJcblxyXG4gICAgICAgIHJldHVybiBncm91cDtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGF0dGFjaCh0ZXh0KTtcclxuXHJcbiAgICAgIHJldHVybiBncm91cDtcclxuXHJcbiAgICB9XHJcblxyXG4gIH0pO1xyXG5cclxuICBmdW5jdGlvbiBmaXRUb1dpbmRvdygpIHtcclxuXHJcbiAgICB2YXIgd3IgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGggPSB3ci53aWR0aDtcclxuICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodCA9IHdyLmhlaWdodDtcclxuXHJcbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodCwgdGhpcy5yYXRpbyk7XHJcblxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdXBkYXRlRGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLnJlc2l6ZSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgfVxyXG5cclxuICAvLyBSZXF1ZXN0IEFuaW1hdGlvbiBGcmFtZVxyXG5cclxuICB2YXIgcmFmID0gZG9tLmdldFJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xyXG5cclxuICBmdW5jdGlvbiBsb29wKCkge1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVHdvLkluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgdCA9IFR3by5JbnN0YW5jZXNbaV07XHJcbiAgICAgIGlmICh0LnBsYXlpbmcpIHtcclxuICAgICAgICB0LnVwZGF0ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgVHdvLm5leHRGcmFtZUlEID0gcmFmKGxvb3ApO1xyXG5cclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFR3bztcclxuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKCd0d28nLCBbXSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBUd287XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBUd287XHJcblxyXG59KSgodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiAodGhpcyB8fCBzZWxmIHx8IHdpbmRvdykpLlR3byk7XHJcblxuKGZ1bmN0aW9uKFR3bykge1xyXG5cclxuICB2YXIgXyA9IFR3by5VdGlscztcclxuXHJcbiAgLyoqXHJcbiAgICogQG5hbWUgVHdvLlJlZ2lzdHJ5XHJcbiAgICogQGNsYXNzXHJcbiAgICogQGRlc2NyaXB0aW9uIEFuIGFyYml0cmFyeSBjbGFzcyB0byBtYW5hZ2UgYSBkaXJlY3Rvcnkgb2YgdGhpbmdzLiBNYWlubHkgdXNlZCBmb3Iga2VlcGluZyB0YWJzIG9mIHRleHR1cmVzIGluIFR3by5qcy5cclxuICAgKi9cclxuICB2YXIgUmVnaXN0cnkgPSBUd28uUmVnaXN0cnkgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICB0aGlzLm1hcCA9IHt9O1xyXG5cclxuICB9O1xyXG5cclxuICBfLmV4dGVuZChSZWdpc3RyeS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogUmVnaXN0cnksXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUmVnaXN0cnkjYWRkXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIEEgdW5pcXVlIGlkZW50aWZpZXIuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBBbnkgdHlwZSBvZiB2YXJpYWJsZSB0byBiZSByZWdpc3RlcmVkIHRvIHRoZSBkaXJlY3RvcnkuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkcyBhbnkgdmFsdWUgdG8gdGhlIGRpcmVjdG9yeS4gQXNzaWduZWQgYnkgdGhlIGBpZGAuXHJcbiAgICAgKi9cclxuICAgIGFkZDogZnVuY3Rpb24oaWQsIG9iaikge1xyXG4gICAgICB0aGlzLm1hcFtpZF0gPSBvYmo7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5SZWdpc3RyeSNyZW1vdmVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gQSB1bmlxdWUgaWRlbnRpZmllci5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW1vdmUgYW55IHZhbHVlIGZyb20gdGhlIGRpcmVjdG9yeSBieSBpdHMgYGlkYC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihpZCkge1xyXG4gICAgICBkZWxldGUgdGhpcy5tYXBbaWRdO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUmVnaXN0cnkjZ2V0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIEEgdW5pcXVlIGlkZW50aWZpZXIuXHJcbiAgICAgKiBAcmV0dXJucyB2YWx1ZSAtIFRoZSBhc3NvY2lhdGVkIHZhbHVlLiBJZiB1bmF2YWlsYWJsZSB0aGVuIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIEdldCBhIHJlZ2lzdGVyZWQgdmFsdWUgYnkgaXRzIGBpZGAuXHJcbiAgICAgKi9cclxuICAgIGdldDogZnVuY3Rpb24oaWQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubWFwW2lkXTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUmVnaXN0cnkjY29udGFpbnNcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gQSB1bmlxdWUgaWRlbnRpZmllci5cclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIG1ldGhvZCB0byBzZWUgaWYgYSB2YWx1ZSBpcyByZWdpc3RlcmVkIHRvIGFuIGBpZGAgYWxyZWFkeS5cclxuICAgICAqL1xyXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgIHJldHVybiBpZCBpbiB0aGlzLm1hcDtcclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG59KSgodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiAodGhpcyB8fCBzZWxmIHx8IHdpbmRvdykpLlR3byk7XHJcblxuKGZ1bmN0aW9uKFR3bykge1xyXG5cclxuICB2YXIgXyA9IFR3by5VdGlscztcclxuXHJcbiAgLyoqXHJcbiAgICogQG5hbWUgVHdvLlZlY3RvclxyXG4gICAqIEBjbGFzc1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSAtIEFueSBudW1iZXIgdG8gcmVwcmVzZW50IHRoZSBob3Jpem9udGFsIHgtY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIC0gQW55IG51bWJlciB0byByZXByZXNlbnQgdGhlIHZlcnRpY2FsIHktY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IuXHJcbiAgICogQGRlc2NyaXB0aW9uIEEgY2xhc3MgdG8gc3RvcmUgeCAvIHkgY29tcG9uZW50IHZlY3RvciBkYXRhLiBJbiBhZGRpdGlvbiB0byBzdG9yaW5nIGRhdGEgYFR3by5WZWN0b3JgIGhhcyBzdXBlZCB1cCBtZXRob2RzIGZvciBjb21tb25wbGFjZSBtYXRoZW1hdGljYWwgb3BlcmF0aW9ucy5cclxuICAgKi9cclxuICB2YXIgVmVjdG9yID0gVHdvLlZlY3RvciA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjeFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGhvcml6b250YWwgeC1jb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgdGhpcy54ID0geCB8fCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciN5XHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgdmVydGljYWwgeS1jb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgdGhpcy55ID0geSB8fCAwO1xyXG5cclxuICB9O1xyXG5cclxuICBfLmV4dGVuZChWZWN0b3IsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IuemVyb1xyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAcHJvcGVydHkge1R3by5WZWN0b3J9IC0gSGFuZHkgcmVmZXJlbmNlIHRvIGEgdmVjdG9yIHdpdGggY29tcG9uZW50IHZhbHVlcyAwLCAwIGF0IGFsbCB0aW1lcy5cclxuICAgICAqL1xyXG4gICAgemVybzogbmV3IFR3by5WZWN0b3IoKSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IuYWRkXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gdjFcclxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gdjJcclxuICAgICAqIEByZXR1cm5zIHtUd28uVmVjdG9yfVxyXG4gICAgICogQGRlc2NyaXB0aW9uIEFkZCB0d28gdmVjdG9ycyB0b2dldGhlci5cclxuICAgICAqL1xyXG4gICAgYWRkOiBmdW5jdGlvbih2MSwgdjIpIHtcclxuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodjEueCArIHYyLngsIHYxLnkgKyB2Mi55KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yLnN1YlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHYxXHJcbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHYyXHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLlZlY3Rvcn1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBTdWJ0cmFjdCB0d28gdmVjdG9yczogYHYyYCBmcm9tIGB2MWAuXHJcbiAgICAgKi9cclxuICAgIHN1YjogZnVuY3Rpb24odjEsIHYyKSB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yKHYxLnggLSB2Mi54LCB2MS55IC0gdjIueSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3Rvci5zdWJ0cmFjdFxyXG4gICAgICogQGJvcnJvd3MgVHdvLlZlY3Rvci5zdWIgYXMgVHdvLlZlY3Rvci5zdWJ0cmFjdFxyXG4gICAgICovXHJcbiAgICBzdWJ0cmFjdDogZnVuY3Rpb24odjEsIHYyKSB7XHJcbiAgICAgIHJldHVybiBWZWN0b3Iuc3ViKHYxLCB2Mik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3Rvci5yYXRpb0JldHdlZW5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSBBXHJcbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IEJcclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSByYXRpbyBiZXR3ZW4gdHdvIHBvaW50cyBgdjFgIGFuZCBgdjJgLlxyXG4gICAgICovXHJcbiAgICByYXRpb0JldHdlZW46IGZ1bmN0aW9uKHYxLCB2Mikge1xyXG5cclxuICAgICAgcmV0dXJuICh2MS54ICogdjIueCArIHYxLnkgKiB2Mi55KSAvICh2MS5sZW5ndGgoKSAqIHYyLmxlbmd0aCgpKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3Rvci5hbmdsZUJldHdlZW5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSB2MVxyXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSB2MlxyXG4gICAgICogQHJldHVybnMge1JhZGlhbnN9IFRoZSBhbmdsZSBiZXR3ZWVuIHBvaW50cyBgdjFgIGFuZCBgdjJgLlxyXG4gICAgICovXHJcbiAgICBhbmdsZUJldHdlZW46IGZ1bmN0aW9uKHYxLCB2Mikge1xyXG5cclxuICAgICAgdmFyIGR4LCBkeTtcclxuXHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIHtcclxuXHJcbiAgICAgICAgZHggPSBhcmd1bWVudHNbMF0gLSBhcmd1bWVudHNbMl07XHJcbiAgICAgICAgZHkgPSBhcmd1bWVudHNbMV0gLSBhcmd1bWVudHNbM107XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKGR5LCBkeCk7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgICBkeCA9IHYxLnggLSB2Mi54O1xyXG4gICAgICBkeSA9IHYxLnkgLSB2Mi55O1xyXG5cclxuICAgICAgcmV0dXJuIE1hdGguYXRhbjIoZHksIGR4KTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3Rvci5kaXN0YW5jZUJldHdlZW5cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSB2MVxyXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSB2MlxyXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIGRpc3RhbmNlIGJldHdlZW4gcG9pbnRzIGB2MWAgYW5kIGB2MmAuIERpc3RhbmNlIGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgICAqL1xyXG4gICAgZGlzdGFuY2VCZXR3ZWVuOiBmdW5jdGlvbih2MSwgdjIpIHtcclxuXHJcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoVmVjdG9yLmRpc3RhbmNlQmV0d2VlblNxdWFyZWQodjEsIHYyKSk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IuZGlzdGFuY2VCZXR3ZWVuU3F1YXJlZFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHYxXHJcbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHYyXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50cyBgdjFgIGFuZCBgdjJgLlxyXG4gICAgICovXHJcbiAgICBkaXN0YW5jZUJldHdlZW5TcXVhcmVkOiBmdW5jdGlvbih2MSwgdjIpIHtcclxuXHJcbiAgICAgIHZhciBkeCA9IHYxLnggLSB2Mi54O1xyXG4gICAgICB2YXIgZHkgPSB2MS55IC0gdjIueTtcclxuXHJcbiAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3Rvci5NYWtlT2JzZXJ2YWJsZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYXBwbHkgb2JzZXJ2YWJsZSBxdWFsaXRpZXMgb2YgYSB7QGxpbmsgVHdvLlZlY3Rvcn0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uVmVjdG9yfSBjbGFzcyBvbiBhIGN1c3RvbSBjbGFzcy5cclxuICAgICAqL1xyXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iamVjdCkge1xyXG5cclxuICAgICAgLy8gLyoqXHJcbiAgICAgIC8vICAqIE92ZXJyaWRlIEJhY2tib25lIGJpbmQgLyBvbiBpbiBvcmRlciB0byBhZGQgcHJvcGVybHkgYnJvYWRjYXN0aW5nLlxyXG4gICAgICAvLyAgKiBUaGlzIGFsbG93cyBUd28uVmVjdG9yIHRvIG5vdCBicm9hZGNhc3QgZXZlbnRzIHVubGVzcyBldmVudCBsaXN0ZW5lcnNcclxuICAgICAgLy8gICogYXJlIGV4cGxpY2l0eSBib3VuZCB0byBpdC5cclxuICAgICAgLy8gICovXHJcblxyXG4gICAgICBvYmplY3QuYmluZCA9IG9iamVjdC5vbiA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX2JvdW5kKSB7XHJcbiAgICAgICAgICB0aGlzLl94ID0gdGhpcy54O1xyXG4gICAgICAgICAgdGhpcy5feSA9IHRoaXMueTtcclxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAneCcsIHhncyk7XHJcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3knLCB5Z3MpO1xyXG4gICAgICAgICAgXy5leHRlbmQodGhpcywgQm91bmRQcm90byk7XHJcbiAgICAgICAgICB0aGlzLl9ib3VuZCA9IHRydWU7IC8vIFJlc2VydmVkIGZvciBldmVudCBpbml0aWFsaXphdGlvbiBjaGVja1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgVHdvLlV0aWxzLkV2ZW50cy5iaW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgfTtcclxuXHJcbiAgICB9XHJcblxyXG4gIH0pO1xyXG5cclxuICBfLmV4dGVuZChWZWN0b3IucHJvdG90eXBlLCBUd28uVXRpbHMuRXZlbnRzLCB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFZlY3RvcixcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZWN0b3Ijc2V0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxyXG4gICAgICogQHJldHVybnMge1R3by5WZWN0b3J9IC0gQW4gaW5zdGFuY2Ugb2YgaXRzZWxmIGZvciB0aGUgcHVycG9zZSBvZiBjaGFpbmluZy5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgdGhlIHggLyB5IGNvbXBvbmVudHMgb2YgYSB2ZWN0b3IgdG8gc3BlY2lmaWMgbnVtYmVyIHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgc2V0OiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjY29weVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHZcclxuICAgICAqIEByZXR1cm5zIHtUd28uVmVjdG9yfSAtIEFuIGluc3RhbmNlIG9mIGl0c2VsZiBmb3IgdGhlIHB1cnBvc2Ugb2YgY2hhaW5pbmcuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ29weSB0aGUgeCAvIHkgY29tcG9uZW50cyBvZiBhbm90aGVyIG9iamVjdCBgdmAuXHJcbiAgICAgKi9cclxuICAgIGNvcHk6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgdGhpcy54ID0gdi54O1xyXG4gICAgICB0aGlzLnkgPSB2Lnk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjY2xlYXJcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHJldHVybnMge1R3by5WZWN0b3J9IC0gQW4gaW5zdGFuY2Ugb2YgaXRzZWxmIGZvciB0aGUgcHVycG9zZSBvZiBjaGFpbmluZy5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgdGhlIHggLyB5IGNvbXBvbmVudCB2YWx1ZXMgb2YgdGhlIHZlY3RvciB0byB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMueCA9IDA7XHJcbiAgICAgIHRoaXMueSA9IDA7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjY2xvbmVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHJldHVybnMge1R3by5WZWN0b3J9IC0gQSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3by5WZWN0b3J9LlxyXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyB2ZWN0b3IgYW5kIGNvcHkgdGhlIGV4aXN0aW5nIHZhbHVlcyBvbnRvIHRoZSBuZXdseSBjcmVhdGVkIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCwgdGhpcy55KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI2FkZFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHZcclxuICAgICAqIEByZXR1cm5zIHtUd28uVmVjdG9yfSAtIEFuIGluc3RhbmNlIG9mIGl0c2VsZiBmb3IgdGhlIHB1cnBvc2Ugb2YgY2hhaW5pbmcuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkIGFuIG9iamVjdCB3aXRoIHggLyB5IGNvbXBvbmVudCB2YWx1ZXMgdG8gdGhlIGluc3RhbmNlLlxyXG4gICAgICogQG92ZXJsb2FkZWRcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNhZGRcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZcclxuICAgICAqIEByZXR1cm5zIHtUd28uVmVjdG9yfSAtIEFuIGluc3RhbmNlIG9mIGl0c2VsZiBmb3IgdGhlIHB1cnBvc2Ugb2YgY2hhaW5pbmcuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkIHRoZSAqKnNhbWUqKiBudW1iZXIgdG8gYm90aCB4IC8geSBjb21wb25lbnQgdmFsdWVzIG9mIHRoZSBpbnN0YW5jZS5cclxuICAgICAqIEBvdmVybG9hZGVkXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjYWRkXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxyXG4gICAgICogQHJldHVybnMge1R3by5WZWN0b3J9IC0gQW4gaW5zdGFuY2Ugb2YgaXRzZWxmIGZvciB0aGUgcHVycG9zZSBvZiBjaGFpbmluZy5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBBZGQgYHhgIC8gYHlgIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGNvbXBvbmVudCB2YWx1ZSBvbiB0aGUgaW5zdGFuY2UuXHJcbiAgICAgKiBAb3ZlcmxvYWRlZFxyXG4gICAgICovXHJcbiAgICBhZGQ6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgIGlmIChfLmlzTnVtYmVyKHgpKSB7XHJcbiAgICAgICAgICB0aGlzLnggKz0geDtcclxuICAgICAgICAgIHRoaXMueSArPSB4O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoeCAmJiBfLmlzTnVtYmVyKHgueCkgJiYgXy5pc051bWJlcih4LnkpKSB7XHJcbiAgICAgICAgICB0aGlzLnggKz0geC54O1xyXG4gICAgICAgICAgdGhpcy55ICs9IHgueTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy54ICs9IHg7XHJcbiAgICAgICAgdGhpcy55ICs9IHk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNhZGRTZWxmXHJcbiAgICAgKiBAYm9ycm93cyBUd28uVmVjdG9yI2FkZCBhcyBUd28uVmVjdG9yI2FkZFNlbGZcclxuICAgICAqL1xyXG4gICAgYWRkU2VsZjogZnVuY3Rpb24odikge1xyXG4gICAgICByZXR1cm4gdGhpcy5hZGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI3N1YlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHZcclxuICAgICAqIEByZXR1cm5zIHtUd28uVmVjdG9yfSAtIEFuIGluc3RhbmNlIG9mIGl0c2VsZiBmb3IgdGhlIHB1cnBvc2Ugb2YgY2hhaW5pbmcuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gU3VidHJhY3QgYW4gb2JqZWN0IHdpdGggeCAvIHkgY29tcG9uZW50IHZhbHVlcyB0byB0aGUgaW5zdGFuY2UuXHJcbiAgICAgKiBAb3ZlcmxvYWRlZFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI3N1YlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdlxyXG4gICAgICogQHJldHVybnMge1R3by5WZWN0b3J9IC0gQW4gaW5zdGFuY2Ugb2YgaXRzZWxmIGZvciB0aGUgcHVycG9zZSBvZiBjaGFpbmluZy5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBTdWJ0cmFjdCB0aGUgKipzYW1lKiogbnVtYmVyIHRvIGJvdGggeCAvIHkgY29tcG9uZW50IHZhbHVlcyBvZiB0aGUgaW5zdGFuY2UuXHJcbiAgICAgKiBAb3ZlcmxvYWRlZFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI3N1YlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICAgICAqIEByZXR1cm5zIHtUd28uVmVjdG9yfSAtIEFuIGluc3RhbmNlIG9mIGl0c2VsZiBmb3IgdGhlIHB1cnBvc2Ugb2YgY2hhaW5pbmcuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gU3VidHJhY3QgYHhgIC8gYHlgIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGNvbXBvbmVudCB2YWx1ZSBvbiB0aGUgaW5zdGFuY2UuXHJcbiAgICAgKiBAb3ZlcmxvYWRlZFxyXG4gICAgICovXHJcbiAgICBzdWI6IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xyXG4gICAgICAgIGlmIChfLmlzTnVtYmVyKHgpKSB7XHJcbiAgICAgICAgICB0aGlzLnggLT0geDtcclxuICAgICAgICAgIHRoaXMueSAtPSB4O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoeCAmJiBfLmlzTnVtYmVyKHgueCkgJiYgXy5pc051bWJlcih4LnkpKSB7XHJcbiAgICAgICAgICB0aGlzLnggLT0geC54O1xyXG4gICAgICAgICAgdGhpcy55IC09IHgueTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy54IC09IHg7XHJcbiAgICAgICAgdGhpcy55IC09IHk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNzdWJ0cmFjdFxyXG4gICAgICogQGJvcnJvd3MgVHdvLlZlY3RvciNzdWIgYXMgVHdvLlZlY3RvciNzdWJ0cmFjdFxyXG4gICAgICovXHJcbiAgICBzdWJ0cmFjdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnN1Yi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZWN0b3Ijc3ViU2VsZlxyXG4gICAgICogQGJvcnJvd3MgVHdvLlZlY3RvciNzdWIgYXMgVHdvLlZlY3RvciNzdWJTZWxmXHJcbiAgICAgKi9cclxuICAgIHN1YlNlbGY6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc3ViLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNzdWJ0cmFjdFNlbGZcclxuICAgICAqIEBib3Jyb3dzIFR3by5WZWN0b3Ijc3ViIGFzIFR3by5WZWN0b3Ijc3VidHJhY3RTZWxmXHJcbiAgICAgKi9cclxuICAgIHN1YnRyYWN0U2VsZjogZnVuY3Rpb24odikge1xyXG4gICAgICByZXR1cm4gdGhpcy5zdWIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI211bHRpcGx5XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gdlxyXG4gICAgICogQHJldHVybnMge1R3by5WZWN0b3J9IC0gQW4gaW5zdGFuY2Ugb2YgaXRzZWxmIGZvciB0aGUgcHVycG9zZSBvZiBjaGFpbmluZy5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBNdWx0aXBseSBhbiBvYmplY3Qgd2l0aCB4IC8geSBjb21wb25lbnQgdmFsdWVzIHRvIHRoZSBpbnN0YW5jZS5cclxuICAgICAqIEBvdmVybG9hZGVkXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjbXVsdGlwbHlcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZcclxuICAgICAqIEByZXR1cm5zIHtUd28uVmVjdG9yfSAtIEFuIGluc3RhbmNlIG9mIGl0c2VsZiBmb3IgdGhlIHB1cnBvc2Ugb2YgY2hhaW5pbmcuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gTXVsdGlwbHkgdGhlICoqc2FtZSoqIG51bWJlciB0byBib3RoIHggLyB5IGNvbXBvbmVudCB2YWx1ZXMgb2YgdGhlIGluc3RhbmNlLlxyXG4gICAgICogQG92ZXJsb2FkZWRcclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNtdWx0aXBseVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICAgICAqIEByZXR1cm5zIHtUd28uVmVjdG9yfSAtIEFuIGluc3RhbmNlIG9mIGl0c2VsZiBmb3IgdGhlIHB1cnBvc2Ugb2YgY2hhaW5pbmcuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gTXVsdGlwbHkgYHhgIC8gYHlgIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGNvbXBvbmVudCB2YWx1ZSBvbiB0aGUgaW5zdGFuY2UuXHJcbiAgICAgKiBAb3ZlcmxvYWRlZFxyXG4gICAgICovXHJcbiAgICBtdWx0aXBseTogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgaWYgKF8uaXNOdW1iZXIoeCkpIHtcclxuICAgICAgICAgIHRoaXMueCAqPSB4O1xyXG4gICAgICAgICAgdGhpcy55ICo9IHg7XHJcbiAgICAgICAgfSBlbHNlIGlmICh4ICYmIF8uaXNOdW1iZXIoeC54KSAmJiBfLmlzTnVtYmVyKHgueSkpIHtcclxuICAgICAgICAgIHRoaXMueCAqPSB4Lng7XHJcbiAgICAgICAgICB0aGlzLnkgKj0geC55O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnggKj0geDtcclxuICAgICAgICB0aGlzLnkgKj0geTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI211bHRpcGx5U2VsZlxyXG4gICAgICogQGJvcnJvd3MgVHdvLlZlY3RvciNtdWx0aXBseSBhcyBUd28uVmVjdG9yI211bHRpcGx5U2VsZlxyXG4gICAgICovXHJcbiAgICBtdWx0aXBseVNlbGY6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI211bHRpcGx5U2NhbGFyXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzIC0gVGhlIHNjYWxhciB0byBtdWx0aXBseSBieS5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBNdWxpdGlwbHkgdGhlIHZlY3RvciBieSBhIHNpbmdsZSBudW1iZXIuIFNob3J0aGFuZCB0byBjYWxsIHtAbGluayBUd28uVmVjdG9yI211bHRpcGx5fSBkaXJlY3RseS5cclxuICAgICAqL1xyXG4gICAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uKHMpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkocyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNkaXZpZGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSB2XHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLlZlY3Rvcn0gLSBBbiBpbnN0YW5jZSBvZiBpdHNlbGYgZm9yIHRoZSBwdXJwb3NlIG9mIGNoYWluaW5nLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIERpdmlkZSBhbiBvYmplY3Qgd2l0aCB4IC8geSBjb21wb25lbnQgdmFsdWVzIHRvIHRoZSBpbnN0YW5jZS5cclxuICAgICAqIEBvdmVybG9hZGVkXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjZGl2aWRlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2XHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLlZlY3Rvcn0gLSBBbiBpbnN0YW5jZSBvZiBpdHNlbGYgZm9yIHRoZSBwdXJwb3NlIG9mIGNoYWluaW5nLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIERpdmlkZSB0aGUgKipzYW1lKiogbnVtYmVyIHRvIGJvdGggeCAvIHkgY29tcG9uZW50IHZhbHVlcyBvZiB0aGUgaW5zdGFuY2UuXHJcbiAgICAgKiBAb3ZlcmxvYWRlZFxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI2RpdmlkZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcclxuICAgICAqIEByZXR1cm5zIHtUd28uVmVjdG9yfSAtIEFuIGluc3RhbmNlIG9mIGl0c2VsZiBmb3IgdGhlIHB1cnBvc2Ugb2YgY2hhaW5pbmcuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gRGl2aWRlIGB4YCAvIGB5YCB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBjb21wb25lbnQgdmFsdWUgb24gdGhlIGluc3RhbmNlLlxyXG4gICAgICogQG92ZXJsb2FkZWRcclxuICAgICAqL1xyXG4gICAgZGl2aWRlOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDApIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICBpZiAoXy5pc051bWJlcih4KSkge1xyXG4gICAgICAgICAgdGhpcy54IC89IHg7XHJcbiAgICAgICAgICB0aGlzLnkgLz0geDtcclxuICAgICAgICB9IGVsc2UgaWYgKHggJiYgXy5pc051bWJlcih4LngpICYmIF8uaXNOdW1iZXIoeC55KSkge1xyXG4gICAgICAgICAgdGhpcy54IC89IHgueDtcclxuICAgICAgICAgIHRoaXMueSAvPSB4Lnk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMueCAvPSB4O1xyXG4gICAgICAgIHRoaXMueSAvPSB5O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChfLmlzTmFOKHRoaXMueCkpIHtcclxuICAgICAgICB0aGlzLnggPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChfLmlzTmFOKHRoaXMueSkpIHtcclxuICAgICAgICB0aGlzLnkgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjZGl2aWRlU2VsZlxyXG4gICAgICogQGJvcnJvd3MgVHdvLlZlY3RvciNkaXZpZGUgYXMgVHdvLlZlY3RvciNkaXZpZGVTZWxmXHJcbiAgICAgKi9cclxuICAgIGRpdmlkZVNlbGY6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNkaXZpZGVTY2FsYXJcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHMgLSBUaGUgc2NhbGFyIHRvIGRpdmlkZSBieS5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBEaXZpZGUgdGhlIHZlY3RvciBieSBhIHNpbmdsZSBudW1iZXIuIFNob3J0aGFuZCB0byBjYWxsIHtAbGluayBUd28uVmVjdG9yI2RpdmlkZX0gZGlyZWN0bHkuXHJcbiAgICAgKi9cclxuICAgIGRpdmlkZVNjYWxhcjogZnVuY3Rpb24ocykge1xyXG4gICAgICByZXR1cm4gdGhpcy5kaXZpZGUocyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNuZWdhdGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIEludmVydCBlYWNoIGNvbXBvbmVudCdzIHNpZ24gdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIG5lZ2F0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KC0xKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI25lZ2F0ZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gICAgICogQGRlc2NyaXB0aW9uIEdldCB0aGUgW2RvdCBwcm9kdWN0XXtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3RfcHJvZHVjdH0gb2YgdGhlIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgZG90OiBmdW5jdGlvbih2KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNsZW5ndGhcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgbGVuZ3RoOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmxlbmd0aFNxdWFyZWQoKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNsZW5ndGhTcXVhcmVkXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gR2V0IHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvciB0byB0aGUgcG93ZXIgb2YgdHdvLiBXaWRlbHkgdXNlZCBhcyBsZXNzIGV4cGVuc2l2ZSB0aGFuIHtAbGluayBUd28uVmVjdG9yI2xlbmd0aH0sIGJlY2F1c2UgaXQgaXNuJ3Qgc3F1YXJlLXJvb3RpbmcgYW55IG51bWJlcnMuXHJcbiAgICAgKi9cclxuICAgIGxlbmd0aFNxdWFyZWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZWN0b3Ijbm9ybWFsaXplXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBkZXNjcmlwdGlvbiBOb3JtYWxpemUgdGhlIHZlY3RvciBmcm9tIG5lZ2F0aXZlIG9uZSB0byBvbmUuXHJcbiAgICAgKi9cclxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI2Rpc3RhbmNlVG9cclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHJldHVybnMge051bWJlcn1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlY3RvcnMuXHJcbiAgICAgKi9cclxuICAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKHYpKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI2Rpc3RhbmNlVG9TcXVhcmVkXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gR2V0IHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWN0b3JzIHRvIHRoZSBwb3dlciBvZiB0d28uIFdpZGVseSB1c2VkIGFzIGxlc3MgZXhwZW5zaXZlIHRoYW4ge0BsaW5rIFR3by5WZWN0b3IjZGlzdGFuY2VUb30sIGJlY2F1c2UgaXQgaXNuJ3Qgc3F1YXJlLXJvb3RpbmcgYW55IG51bWJlcnMuXHJcbiAgICAgKi9cclxuICAgIGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbih2KSB7XHJcbiAgICAgIHZhciBkeCA9IHRoaXMueCAtIHYueCxcclxuICAgICAgICAgIGR5ID0gdGhpcy55IC0gdi55O1xyXG4gICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNzZXRMZW5ndGhcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGwgLSBsZW5ndGggdG8gc2V0IHZlY3RvciB0by5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgc2V0TGVuZ3RoOiBmdW5jdGlvbihsKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKGwpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjZXF1YWxzXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gdiAtIFRoZSB2ZWN0b3IgdG8gY29tcGFyZSBhZ2FpbnN0LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlcHM9MC4wMDAxXSAtIEFuIG9wdGlvbnMgZXBzaWxvbiBmb3IgcHJlY2lzaW9uLlxyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUXVhbGlmeSBpZiBvbmUgdmVjdG9yIHJvdWdobHkgZXF1YWwgYW5vdGhlci4gV2l0aCBhIG1hcmdpbiBvZiBlcnJvciBkZWZpbmVkIGJ5IGVwc2lsb24uXHJcbiAgICAgKi9cclxuICAgIGVxdWFsczogZnVuY3Rpb24odiwgZXBzKSB7XHJcbiAgICAgIGVwcyA9ICh0eXBlb2YgZXBzID09PSAndW5kZWZpbmVkJykgPyAgMC4wMDAxIDogZXBzO1xyXG4gICAgICByZXR1cm4gKHRoaXMuZGlzdGFuY2VUbyh2KSA8IGVwcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNsZXJwXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gdiAtIFRoZSBkZXN0aW5hdGlvbiB2ZWN0b3IgdG8gc3RlcCB0b3dhcmRzLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHQgLSBUaGUgemVybyB0byBvbmUgdmFsdWUgb2YgaG93IGNsb3NlIHRoZSBjdXJyZW50IHZlY3RvciBnZXRzIHRvIHRoZSBkZXN0aW5hdGlvbiB2ZWN0b3IuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gTGluZWFyIGludGVycG9sYXRlIG9uZSB2ZWN0b3IgdG8gYW5vdGhlciBieSBhbiBhbW91bnQgYHRgIGRlZmluZWQgYXMgYSB6ZXJvIHRvIG9uZSBudW1iZXIuXHJcbiAgICAgKiBAc2VlIFtNYXR0IERlc0xhdXJpZXJzXXtAbGluayBodHRwczovL3R3aXR0ZXIuY29tL21hdHRkZXNsL3N0YXR1cy8xMDMxMzA1Mjc5MjI3NDc4MDE2fSBoYXMgYSBnb29kIHRocmVhZCBhYm91dCB0aGlzLlxyXG4gICAgICovXHJcbiAgICBsZXJwOiBmdW5jdGlvbih2LCB0KSB7XHJcbiAgICAgIHZhciB4ID0gKHYueCAtIHRoaXMueCkgKiB0ICsgdGhpcy54O1xyXG4gICAgICB2YXIgeSA9ICh2LnkgLSB0aGlzLnkpICogdCArIHRoaXMueTtcclxuICAgICAgcmV0dXJuIHRoaXMuc2V0KHgsIHkpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjaXNaZXJvXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZXBzPTAuMDAwMV0gLSBPcHRpb25hbCBwcmVjaXNpb24gYW1vdW50IHRvIGNoZWNrIGFnYWluc3QuXHJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDaGVjayB0byBzZWUgaWYgdmVjdG9yIGlzIHJvdWdobHkgemVybywgYmFzZWQgb24gdGhlIGBlcHNpbG9uYCBwcmVjaXNpb24gdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGlzWmVybzogZnVuY3Rpb24oZXBzKSB7XHJcbiAgICAgIGVwcyA9ICh0eXBlb2YgZXBzID09PSAndW5kZWZpbmVkJykgPyAgMC4wMDAxIDogZXBzO1xyXG4gICAgICByZXR1cm4gKHRoaXMubGVuZ3RoKCkgPCBlcHMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjdG9TdHJpbmdcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cclxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBjb21tYS1zZXBhcmF0ZWQgc3RyaW5nIG9mIHgsIHkgdmFsdWUuIEdyZWF0IGZvciBzdG9yaW5nIGluIGEgZGF0YWJhc2UuXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMueCArICcsICcgKyB0aGlzLnk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciN0b09iamVjdFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHsgeDogdGhpcy54LCB5OiB0aGlzLnkgfTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI3JvdGF0ZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1JhZGlhbnN9IHJhZGlhbnMgLSBUaGUgYW1vdW4gdG8gcm90YXRlIHRoZSB2ZWN0b3IgYnkuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUm90YXRlIGEgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICByb3RhdGU6IGZ1bmN0aW9uKHJhZGlhbnMpIHtcclxuICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHJhZGlhbnMpO1xyXG4gICAgICB2YXIgc2luID0gTWF0aC5zaW4ocmFkaWFucyk7XHJcbiAgICAgIHRoaXMueCA9IHRoaXMueCAqIGNvcyAtIHRoaXMueSAqIHNpbjtcclxuICAgICAgdGhpcy55ID0gdGhpcy54ICogc2luICsgdGhpcy55ICogY29zO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIC8vIFRoZSBzYW1lIHNldCBvZiBwcm90b3R5cGljYWwgZnVuY3Rpb25zLCBidXQgdXNpbmcgdGhlIHVuZGVybHlpbmdcclxuICAvLyBnZXR0ZXIgb3Igc2V0dGVyIGZvciBgeGAgYW5kIGB5YCB2YWx1ZXMuIFRoaXMgc2V0IG9mIGZ1bmN0aW9uc1xyXG4gIC8vIGlzIHVzZWQgaW5zdGVhZCBvZiB0aGUgcHJldmlvdXNseSBkb2N1bWVudGVkIG9uZXMgYWJvdmUgd2hlblxyXG4gIC8vIFR3by5WZWN0b3IjYmluZCBpcyBpbnZva2VkIGFuZCB0aGVyZSBpcyBldmVudCBkaXNwYXRjaGluZyBwcm9jZXNzZWRcclxuICAvLyBvbiB4IC8geSBwcm9wZXJ0eSBjaGFuZ2VzLlxyXG4gIHZhciBCb3VuZFByb3RvID0ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBWZWN0b3IsXHJcblxyXG4gICAgc2V0OiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgIHRoaXMuX3ggPSB4O1xyXG4gICAgICB0aGlzLl95ID0geTtcclxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLmNoYW5nZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNvcHk6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgdGhpcy5feCA9IHYueDtcclxuICAgICAgdGhpcy5feSA9IHYueTtcclxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLmNoYW5nZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5feCA9IDA7XHJcbiAgICAgIHRoaXMuX3kgPSAwO1xyXG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKFR3by5FdmVudHMuY2hhbmdlKTtcclxuICAgIH0sXHJcblxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLl94LCB0aGlzLl95KTtcclxuICAgIH0sXHJcblxyXG4gICAgYWRkOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDApIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICBpZiAoXy5pc051bWJlcih4KSkge1xyXG4gICAgICAgICAgdGhpcy5feCArPSB4O1xyXG4gICAgICAgICAgdGhpcy5feSArPSB4O1xyXG4gICAgICAgIH0gIGVsc2UgaWYgKHggJiYgXy5pc051bWJlcih4LngpICYmIF8uaXNOdW1iZXIoeC55KSkge1xyXG4gICAgICAgICAgdGhpcy5feCArPSB4Lng7XHJcbiAgICAgICAgICB0aGlzLl95ICs9IHgueTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5feCArPSB4O1xyXG4gICAgICAgIHRoaXMuX3kgKz0geTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKFR3by5FdmVudHMuY2hhbmdlKTtcclxuICAgIH0sXHJcblxyXG4gICAgc3ViOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDApIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICBpZiAoXy5pc051bWJlcih4KSkge1xyXG4gICAgICAgICAgdGhpcy5feCAtPSB4O1xyXG4gICAgICAgICAgdGhpcy5feSAtPSB4O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoeCAmJiBfLmlzTnVtYmVyKHgueCkgJiYgXy5pc051bWJlcih4LnkpKSB7XHJcbiAgICAgICAgICB0aGlzLl94IC09IHgueDtcclxuICAgICAgICAgIHRoaXMuX3kgLT0geC55O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl94IC09IHg7XHJcbiAgICAgICAgdGhpcy5feSAtPSB5O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoVHdvLkV2ZW50cy5jaGFuZ2UpO1xyXG4gICAgfSxcclxuXHJcbiAgICBtdWx0aXBseTogZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XHJcbiAgICAgICAgaWYgKF8uaXNOdW1iZXIoeCkpIHtcclxuICAgICAgICAgIHRoaXMuX3ggKj0geDtcclxuICAgICAgICAgIHRoaXMuX3kgKj0geDtcclxuICAgICAgICB9IGVsc2UgaWYgKHggJiYgXy5pc051bWJlcih4LngpICYmIF8uaXNOdW1iZXIoeC55KSkge1xyXG4gICAgICAgICAgdGhpcy5feCAqPSB4Lng7XHJcbiAgICAgICAgICB0aGlzLl95ICo9IHgueTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5feCAqPSB4O1xyXG4gICAgICAgIHRoaXMuX3kgKj0geTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKFR3by5FdmVudHMuY2hhbmdlKTtcclxuICAgIH0sXHJcblxyXG4gICAgZGl2aWRlOiBmdW5jdGlvbih4LCB5KSB7XHJcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDApIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICBpZiAoXy5pc051bWJlcih4KSkge1xyXG4gICAgICAgICAgdGhpcy5feCAvPSB4O1xyXG4gICAgICAgICAgdGhpcy5feSAvPSB4O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoeCAmJiBfLmlzTnVtYmVyKHgueCkgJiYgXy5pc051bWJlcih4LnkpKSB7XHJcbiAgICAgICAgICB0aGlzLl94IC89IHgueDtcclxuICAgICAgICAgIHRoaXMuX3kgLz0geC55O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl94IC89IHg7XHJcbiAgICAgICAgdGhpcy5feSAvPSB5O1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChfLmlzTmFOKHRoaXMuX3gpKSB7XHJcbiAgICAgICAgdGhpcy5feCA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKF8uaXNOYU4odGhpcy5feSkpIHtcclxuICAgICAgICB0aGlzLl95ID0gMDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKFR3by5FdmVudHMuY2hhbmdlKTtcclxuICAgIH0sXHJcblxyXG4gICAgZG90OiBmdW5jdGlvbih2KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl94ICogdi54ICsgdGhpcy5feSAqIHYueTtcclxuICAgIH0sXHJcblxyXG4gICAgbGVuZ3RoU3F1YXJlZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95O1xyXG4gICAgfSxcclxuXHJcbiAgICBkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24odikge1xyXG4gICAgICB2YXIgZHggPSB0aGlzLl94IC0gdi54LFxyXG4gICAgICAgICAgZHkgPSB0aGlzLl95IC0gdi55O1xyXG4gICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XHJcbiAgICB9LFxyXG5cclxuICAgIGxlcnA6IGZ1bmN0aW9uKHYsIHQpIHtcclxuICAgICAgdmFyIHggPSAodi54IC0gdGhpcy5feCkgKiB0ICsgdGhpcy5feDtcclxuICAgICAgdmFyIHkgPSAodi55IC0gdGhpcy5feSkgKiB0ICsgdGhpcy5feTtcclxuICAgICAgcmV0dXJuIHRoaXMuc2V0KHgsIHkpO1xyXG4gICAgfSxcclxuXHJcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl94ICsgJywgJyArIHRoaXMuX3k7XHJcbiAgICB9LFxyXG5cclxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHsgeDogdGhpcy5feCwgeTogdGhpcy5feSB9O1xyXG4gICAgfSxcclxuXHJcbiAgICByb3RhdGU6IGZ1bmN0aW9uIChyYWRpYW5zKSB7XHJcbiAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhyYWRpYW5zKTtcclxuICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHJhZGlhbnMpO1xyXG4gICAgICB0aGlzLl94ID0gdGhpcy5feCAqIGNvcyAtIHRoaXMuX3kgKiBzaW47XHJcbiAgICAgIHRoaXMuX3kgPSB0aGlzLl94ICogc2luICsgdGhpcy5feSAqIGNvcztcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gIH07XHJcblxyXG4gIHZhciB4Z3MgPSB7XHJcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3g7XHJcbiAgICB9LFxyXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XHJcbiAgICAgIHRoaXMuX3ggPSB2O1xyXG4gICAgICB0aGlzLnRyaWdnZXIoVHdvLkV2ZW50cy5jaGFuZ2UsICd4Jyk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIHlncyA9IHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5feTtcclxuICAgIH0sXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgdGhpcy5feSA9IHY7XHJcbiAgICAgIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLmNoYW5nZSwgJ3knKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBWZWN0b3IuTWFrZU9ic2VydmFibGUoVmVjdG9yLnByb3RvdHlwZSk7XHJcblxyXG59KSgodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiAodGhpcyB8fCBzZWxmIHx8IHdpbmRvdykpLlR3byk7XHJcblxuKGZ1bmN0aW9uKFR3bykge1xyXG5cclxuICAvLyBMb2NhbGl6ZWQgdmFyaWFibGVzXHJcbiAgdmFyIGNvbW1hbmRzID0gVHdvLkNvbW1hbmRzO1xyXG4gIHZhciBfID0gVHdvLlV0aWxzO1xyXG5cclxuICAvKipcclxuICAgKiBAY2xhc3NcclxuICAgKiBAbmFtZSBUd28uQW5jaG9yXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHJvb3QgYW5jaG9yIHBvaW50LlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSByb290IGFuY2hvciBwb2ludC5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2x4PTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIGxlZnQgaGFuZGxlIHBvaW50LlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbHk9MF0gLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgbGVmdCBoYW5kbGUgcG9pbnQuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyeD0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSByaWdodCBoYW5kbGUgcG9pbnQuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyeT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSByaWdodCBoYW5kbGUgcG9pbnQuXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb21tYW5kPVR3by5Db21tYW5kcy5tb3ZlXSAtIFRoZSBjb21tYW5kIHRvIGRlc2NyaWJlIGhvdyB0byByZW5kZXIuIEFwcGxpY2FibGUgY29tbWFuZHMgYXJlIHtAbGluayBUd28uQ29tbWFuZHN9XHJcbiAgICogQGV4dGVuZHMgVHdvLlZlY3RvclxyXG4gICAqIEBkZXNjcmlwdGlvbiBBbiBvYmplY3QgdGhhdCBob2xkcyAzIHtAbGluayBUd28uVmVjdG9yfXMsIHRoZSBhbmNob3IgcG9pbnQgYW5kIGl0cyBjb3JyZXNwb25kaW5nIGhhbmRsZXM6IGBsZWZ0YCBhbmQgYHJpZ2h0YC4gSW4gb3JkZXIgdG8gcHJvcGVybHkgZGVzY3JpYmUgdGhlIGJlemllciBjdXJ2ZSBhYm91dCB0aGUgcG9pbnQgdGhlcmUgaXMgYWxzbyBhIGNvbW1hbmQgcHJvcGVydHkgdG8gZGVzY3JpYmUgd2hhdCB0eXBlIG9mIGRyYXdpbmcgc2hvdWxkIG9jY3VyIHdoZW4gVHdvLmpzIHJlbmRlcnMgdGhlIGFuY2hvcnMuXHJcbiAgICovXHJcbiAgdmFyIEFuY2hvciA9IFR3by5BbmNob3IgPSBmdW5jdGlvbih4LCB5LCBseCwgbHksIHJ4LCByeSwgY29tbWFuZCkge1xyXG5cclxuICAgIFR3by5WZWN0b3IuY2FsbCh0aGlzLCB4LCB5KTtcclxuXHJcbiAgICB0aGlzLl9icm9hZGNhc3QgPSBfLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLmNoYW5nZSk7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLl9jb21tYW5kID0gY29tbWFuZCB8fCBjb21tYW5kcy5tb3ZlO1xyXG4gICAgdGhpcy5fcmVsYXRpdmUgPSB0cnVlO1xyXG5cclxuICAgIHZhciBpbHggPSBfLmlzTnVtYmVyKGx4KTtcclxuICAgIHZhciBpbHkgPSBfLmlzTnVtYmVyKGx5KTtcclxuICAgIHZhciBpcnggPSBfLmlzTnVtYmVyKHJ4KTtcclxuICAgIHZhciBpcnkgPSBfLmlzTnVtYmVyKHJ5KTtcclxuXHJcbiAgICAvLyBBcHBlbmQgdGhlIGBjb250cm9sc2Agb2JqZWN0IG9ubHkgaWYgY29udHJvbCBwb2ludHMgYXJlIHNwZWNpZmllZCxcclxuICAgIC8vIGtlZXBpbmcgdGhlIFR3by5BbmNob3IgaW5saW5lIHdpdGggYSBUd28uVmVjdG9yIHVudGlsIGl0IG5lZWRzIHRvXHJcbiAgICAvLyBldm9sdmUgYmV5b25kIHRob3NlIGZ1bmN0aW9ucyAtIGUuZzogYSBzaW1wbGUgMiBjb21wb25lbnQgdmVjdG9yLlxyXG4gICAgaWYgKGlseCB8fCBpbHkgfHwgaXJ4IHx8IGlyeSkge1xyXG4gICAgICBUd28uQW5jaG9yLkFwcGVuZEN1cnZlUHJvcGVydGllcyh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaWx4KSB7XHJcbiAgICAgIHRoaXMuY29udHJvbHMubGVmdC54ID0gbHg7XHJcbiAgICB9XHJcbiAgICBpZiAoaWx5KSB7XHJcbiAgICAgIHRoaXMuY29udHJvbHMubGVmdC55ID0gbHk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXJ4KSB7XHJcbiAgICAgIHRoaXMuY29udHJvbHMucmlnaHQueCA9IHJ4O1xyXG4gICAgfVxyXG4gICAgaWYgKGlyeSkge1xyXG4gICAgICB0aGlzLmNvbnRyb2xzLnJpZ2h0LnkgPSByeTtcclxuICAgIH1cclxuXHJcbiAgfTtcclxuXHJcbiAgXy5leHRlbmQoVHdvLkFuY2hvciwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkFuY2hvci5BcHBlbmRDdXJ2ZVByb3BlcnRpZXNcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtUd28uQW5jaG9yfSBhbmNob3IgLSBUaGUgaW5zdGFuY2UgdG8gYXBwZW5kIHRoZSBgY29udHJvbGBvYmplY3QgdG8uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkcyB0aGUgYGNvbnRyb2xzYCBwcm9wZXJ0eSBhcyBhbiBvYmplY3Qgd2l0aCBgbGVmdGAgYW5kIGByaWdodGAgcHJvcGVydGllcyB0byBhY2Nlc3MgdGhlIGJlemllciBjb250cm9sIGhhbmRsZXMgdGhhdCBkZWZpbmUgaG93IHRoZSBjdXJ2ZSBpcyBkcmF3bi4gSXQgYWxzbyBzZXRzIHRoZSBgcmVsYXRpdmVgIHByb3BlcnR5IHRvIGB0cnVlYCBtYWtpbmcgdmVjdG9ycyBpbiB0aGUgYGNvbnRyb2xzYCBvYmplY3QgcmVsYXRpdmUgdG8gdGhlaXIgY29ycmVzcG9uZGluZyByb290IGFuY2hvciBwb2ludC5cclxuICAgICAqL1xyXG4gICAgQXBwZW5kQ3VydmVQcm9wZXJ0aWVzOiBmdW5jdGlvbihhbmNob3IpIHtcclxuXHJcbiAgICAgIGFuY2hvci5yZWxhdGl2ZSA9IHRydWU7XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5hbWUgVHdvLkFuY2hvciNjb250cm9sc1xyXG4gICAgICAgKiBAcHJvcGVydHkge09iamVjdH0gY29udHJvbHNcclxuICAgICAgICogQGRlc2NyaXB0aW9uIEFuIHBsYWluIG9iamVjdCB0aGF0IGhvbGRzIHRoZSBjb250cm9scyBoYW5kbGVzIGZvciBhIHtAbGluayBUd28uQW5jaG9yfS5cclxuICAgICAgICovXHJcbiAgICAgIGFuY2hvci5jb250cm9scyA9IHt9O1xyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuYW1lIFR3by5BbmNob3IjY29udHJvbHMjbGVmdFxyXG4gICAgICAgKiBAcHJvcGVydHkge1R3by5WZWN0b3J9IGxlZnRcclxuICAgICAgICogQGRlc2NyaXB0aW9uIFRoZSBcImxlZnRcIiBjb250cm9sIHBvaW50IHRvIGRlZmluZSBoYW5kbGVzIG9uIGEgYmV6aWVyIGN1cnZlLlxyXG4gICAgICAgKi9cclxuICAgICAgYW5jaG9yLmNvbnRyb2xzLmxlZnQgPSBuZXcgVHdvLlZlY3RvcigwLCAwKTtcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmFtZSBUd28uQW5jaG9yI2NvbnRyb2xzI3JpZ2h0XHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7VHdvLlZlY3Rvcn0gcmlnaHRcclxuICAgICAgICogQGRlc2NyaXB0aW9uIFRoZSBcImxlZnRcIiBjb250cm9sIHBvaW50IHRvIGRlZmluZSBoYW5kbGVzIG9uIGEgYmV6aWVyIGN1cnZlLlxyXG4gICAgICAgKi9cclxuICAgICAgYW5jaG9yLmNvbnRyb2xzLnJpZ2h0ID0gbmV3IFR3by5WZWN0b3IoMCwgMCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5BbmNob3IuTWFrZU9ic2VydmFibGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5BbmNob3J9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIHRoZSB7QGxpbmsgVHdvLkFuY2hvcn0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXHJcbiAgICAgKi9cclxuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmplY3QpIHtcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmFtZSBUd28uQW5jaG9yI2NvbW1hbmRcclxuICAgICAgICogQHByb3BlcnR5IHtUd28uQ29tbWFuZHN9XHJcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBBIGRyYXcgY29tbWFuZCBhc3NvY2lhdGVkIHdpdGggdGhlIGFuY2hvciBwb2ludC5cclxuICAgICAgICovXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdjb21tYW5kJywge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbihjKSB7XHJcbiAgICAgICAgICB0aGlzLl9jb21tYW5kID0gYztcclxuICAgICAgICAgIGlmICh0aGlzLl9jb21tYW5kID09PSBjb21tYW5kcy5jdXJ2ZSAmJiAhXy5pc09iamVjdCh0aGlzLmNvbnRyb2xzKSkge1xyXG4gICAgICAgICAgICBBbmNob3IuQXBwZW5kQ3VydmVQcm9wZXJ0aWVzKHRoaXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLmNoYW5nZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5hbWUgVHdvLkFuY2hvciNyZWxhdGl2ZVxyXG4gICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59XHJcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBBIGJvb2xlYW4gdG8gcmVuZGVyIGNvbnRyb2wgcG9pbnRzIHJlbGF0aXZlIHRvIHRoZSByb290IGFuY2hvciBwb2ludCBvciBpbiBnbG9iYWwgY29vcmRpbmF0ZS1zcGFjZSB0byB0aGUgcmVzdCBvZiB0aGUgc2NlbmUuXHJcbiAgICAgICAqL1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAncmVsYXRpdmUnLCB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVsYXRpdmU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbihiKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5fcmVsYXRpdmUgPT0gYikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuX3JlbGF0aXZlID0gISFiO1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLmNoYW5nZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBfLmV4dGVuZChvYmplY3QsIFR3by5WZWN0b3IucHJvdG90eXBlLCBBbmNob3JQcm90byk7XHJcblxyXG4gICAgICAvLyBNYWtlIGl0IHBvc3NpYmxlIHRvIGJpbmQgYW5kIHN0aWxsIGhhdmUgdGhlIEFuY2hvciBzcGVjaWZpY1xyXG4gICAgICAvLyBpbmhlcml0YW5jZSBmcm9tIFR3by5WZWN0b3IuIEluIHRoaXMgY2FzZSByZWx5aW5nIG9uIGBUd28uVmVjdG9yYFxyXG4gICAgICAvLyB0byBkbyBtdWNoIG9mIHRoZSBoZWF2eSBldmVudC1saXN0ZW5lciBiaW5kaW5nIC8gdW5iaW5kaW5nLlxyXG4gICAgICBvYmplY3QuYmluZCA9IG9iamVjdC5vbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBib3VuZCA9IHRoaXMuX2JvdW5kO1xyXG4gICAgICAgIFR3by5WZWN0b3IucHJvdG90eXBlLmJpbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICBpZiAoIWJvdW5kKSB7XHJcbiAgICAgICAgICBfLmV4dGVuZCh0aGlzLCBBbmNob3JQcm90byk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIHZhciBBbmNob3JQcm90byA9IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVHdvLkFuY2hvcixcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5BbmNob3IjbGlzdGVuXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBtZXRob2QgdXNlZCBtYWlubHkgYnkge0BsaW5rIFR3by5QYXRoI3ZlcnRpY2VzfSB0byBsaXN0ZW4gYW5kIHByb3BhZ2F0ZSBjaGFuZ2VzIGZyb20gY29udHJvbCBwb2ludHMgdXAgdG8gdGhlaXIgcmVzcGVjdGl2ZSBhbmNob3JzIGFuZCBmdXJ0aGVyIGlmIG5lY2Vzc2FyeS5cclxuICAgICAqL1xyXG4gICAgbGlzdGVuOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIGlmICghXy5pc09iamVjdCh0aGlzLmNvbnRyb2xzKSkge1xyXG4gICAgICAgIFR3by5BbmNob3IuQXBwZW5kQ3VydmVQcm9wZXJ0aWVzKHRoaXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmNvbnRyb2xzLmxlZnQuYmluZChUd28uRXZlbnRzLmNoYW5nZSwgdGhpcy5fYnJvYWRjYXN0KTtcclxuICAgICAgdGhpcy5jb250cm9scy5yaWdodC5iaW5kKFR3by5FdmVudHMuY2hhbmdlLCB0aGlzLl9icm9hZGNhc3QpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5BbmNob3IjaWdub3JlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBtZXRob2QgdXNlZCBtYWlubHkgYnkge0BsaW5rIFR3by5QYXRoI3ZlcnRpY2VzfSB0byBpZ25vcmUgY2hhbmdlcyBmcm9tIGEgc3BlY2lmaWMgYW5jaG9yJ3MgY29udHJvbCBwb2ludHMuXHJcbiAgICAgKi9cclxuICAgIGlnbm9yZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB0aGlzLmNvbnRyb2xzLmxlZnQudW5iaW5kKFR3by5FdmVudHMuY2hhbmdlLCB0aGlzLl9icm9hZGNhc3QpO1xyXG4gICAgICB0aGlzLmNvbnRyb2xzLnJpZ2h0LnVuYmluZChUd28uRXZlbnRzLmNoYW5nZSwgdGhpcy5fYnJvYWRjYXN0KTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uQW5jaG9yI2NvcHlcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtUd28uQW5jaG9yfSB2IC0gVGhlIGFuY2hvciB0byBhcHBseSB2YWx1ZXMgdG8uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ29weSB0aGUgcHJvcGVydGllcyBvZiBvbmUge0BsaW5rIFR3by5BbmNob3J9IG9udG8gYW5vdGhlci5cclxuICAgICAqL1xyXG4gICAgY29weTogZnVuY3Rpb24odikge1xyXG5cclxuICAgICAgdGhpcy54ID0gdi54O1xyXG4gICAgICB0aGlzLnkgPSB2Lnk7XHJcblxyXG4gICAgICBpZiAoXy5pc1N0cmluZyh2LmNvbW1hbmQpKSB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kID0gdi5jb21tYW5kO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChfLmlzT2JqZWN0KHYuY29udHJvbHMpKSB7XHJcbiAgICAgICAgaWYgKCFfLmlzT2JqZWN0KHRoaXMuY29udHJvbHMpKSB7XHJcbiAgICAgICAgICBUd28uQW5jaG9yLkFwcGVuZEN1cnZlUHJvcGVydGllcyh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogRG8gd2UgbmVlZCB0byBsaXN0ZW4gaGVyZT9cclxuICAgICAgICB0aGlzLmNvbnRyb2xzLmxlZnQuY29weSh2LmNvbnRyb2xzLmxlZnQpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbHMucmlnaHQuY29weSh2LmNvbnRyb2xzLnJpZ2h0KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoXy5pc0Jvb2xlYW4odi5yZWxhdGl2ZSkpIHtcclxuICAgICAgICB0aGlzLnJlbGF0aXZlID0gdi5yZWxhdGl2ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVE9ETzogSGFjayBmb3IgYFR3by5Db21tYW5kcy5hcmNgXHJcbiAgICAgIGlmICh0aGlzLmNvbW1hbmQgPT09IFR3by5Db21tYW5kcy5hcmMpIHtcclxuICAgICAgICB0aGlzLnJ4ID0gdi5yeDtcclxuICAgICAgICB0aGlzLnJ5ID0gdi5yeTtcclxuICAgICAgICB0aGlzLnhBeGlzUm90YXRpb24gPSB2LnhBeGlzUm90YXRpb247XHJcbiAgICAgICAgdGhpcy5sYXJnZUFyY0ZsYWcgPSB2LmxhcmdlQXJjRmxhZztcclxuICAgICAgICB0aGlzLnN3ZWVwRmxhZyA9IHYuc3dlZXBGbGFnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkFuY2hvciNjbG9uZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLkFuY2hvcn1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcge0BsaW5rIFR3by5BbmNob3J9LCBzZXQgYWxsIGl0cyB2YWx1ZXMgdG8gdGhlIGN1cnJlbnQgaW5zdGFuY2UgYW5kIHJldHVybiBpdCBmb3IgdXNlLlxyXG4gICAgICovXHJcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB2YXIgY29udHJvbHMgPSB0aGlzLmNvbnRyb2xzO1xyXG5cclxuICAgICAgdmFyIGNsb25lID0gbmV3IFR3by5BbmNob3IoXHJcbiAgICAgICAgdGhpcy54LFxyXG4gICAgICAgIHRoaXMueSxcclxuICAgICAgICBjb250cm9scyAmJiBjb250cm9scy5sZWZ0LngsXHJcbiAgICAgICAgY29udHJvbHMgJiYgY29udHJvbHMubGVmdC55LFxyXG4gICAgICAgIGNvbnRyb2xzICYmIGNvbnRyb2xzLnJpZ2h0LngsXHJcbiAgICAgICAgY29udHJvbHMgJiYgY29udHJvbHMucmlnaHQueSxcclxuICAgICAgICB0aGlzLmNvbW1hbmRcclxuICAgICAgKTtcclxuICAgICAgY2xvbmUucmVsYXRpdmUgPSB0aGlzLl9yZWxhdGl2ZTtcclxuICAgICAgcmV0dXJuIGNsb25lO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uQW5jaG9yI3RvT2JqZWN0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IC0gQW4gb2JqZWN0IHdpdGggcHJvcGVydGllcyBmaWxsZWQgb3V0IHRvIG1pcnJvciB7QGxpbmsgVHdvLkFuY2hvcn0uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCBvZiB0aGUgY3VycmVudCBpbnN0YW5jZS4gSW50ZW5kZWQgZm9yIHVzZSB3aXRoIHN0b3JpbmcgdmFsdWVzIGluIGEgZGF0YWJhc2UuXHJcbiAgICAgKi9cclxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIG8gPSB7XHJcbiAgICAgICAgeDogdGhpcy54LFxyXG4gICAgICAgIHk6IHRoaXMueVxyXG4gICAgICB9O1xyXG4gICAgICBpZiAodGhpcy5fY29tbWFuZCkge1xyXG4gICAgICAgIG8uY29tbWFuZCA9IHRoaXMuX2NvbW1hbmQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuX3JlbGF0aXZlKSB7XHJcbiAgICAgICAgby5yZWxhdGl2ZSA9IHRoaXMuX3JlbGF0aXZlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLmNvbnRyb2xzKSB7XHJcbiAgICAgICAgby5jb250cm9scyA9IHtcclxuICAgICAgICAgIGxlZnQ6IHRoaXMuY29udHJvbHMubGVmdC50b09iamVjdCgpLFxyXG4gICAgICAgICAgcmlnaHQ6IHRoaXMuY29udHJvbHMucmlnaHQudG9PYmplY3QoKVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG87XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkFuY2hvciN0b1N0cmluZ1xyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSAtIEEgU3RyaW5nIHdpdGggY29tbWEtc2VwYXJhdGVkIHZhbHVlcyByZWZsZWN0aW5nIHRoZSB2YXJpb3VzIHZhbHVlcyBvbiB0aGUgY3VycmVudCBpbnN0YW5jZS5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBzdHJpbmcgZm9ybSBvZiB0aGUgY3VycmVudCBpbnN0YW5jZS4gSW50ZW5kZWQgZm9yIHVzZSB3aXRoIHN0b3JpbmcgdmFsdWVzIGluIGEgZGF0YWJhc2UuIFRoaXMgaXMgbGlnaHRlciB0byBzdG9yZSB0aGFuIHRoZSBKU09OIGNvbXBhdGlibGUge0BsaW5rIFR3by5BbmNob3IjdG9PYmplY3R9LlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICghdGhpcy5jb250cm9scykge1xyXG4gICAgICAgIHJldHVybiBbdGhpcy5feCwgdGhpcy5feV0uam9pbignLCAnKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gW3RoaXMuX3gsIHRoaXMuX3ksIHRoaXMuY29udHJvbHMubGVmdC54LCB0aGlzLmNvbnRyb2xzLmxlZnQueSxcclxuICAgICAgICB0aGlzLmNvbnRyb2xzLnJpZ2h0LngsIHRoaXMuY29udHJvbHMucmlnaHQueSwgdGhpcy5fY29tbWFuZCxcclxuICAgICAgICB0aGlzLl9yZWxhdGl2ZSA/IDEgOiAwXS5qb2luKCcsICcpO1xyXG4gICAgfVxyXG5cclxuICB9O1xyXG5cclxuICBUd28uQW5jaG9yLk1ha2VPYnNlcnZhYmxlKFR3by5BbmNob3IucHJvdG90eXBlKTtcclxuXHJcbn0pKCh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6ICh0aGlzIHx8IHNlbGYgfHwgd2luZG93KSkuVHdvKTtcclxuXG4oZnVuY3Rpb24oVHdvKSB7XHJcblxyXG4gIC8vIENvbnN0YW50c1xyXG5cclxuICB2YXIgY29zID0gTWF0aC5jb3MsIHNpbiA9IE1hdGguc2luLCB0YW4gPSBNYXRoLnRhbjtcclxuICB2YXIgXyA9IFR3by5VdGlscztcclxuICB2YXIgYXJyYXkgPSBbXTtcclxuXHJcbiAgLyoqXHJcbiAgICogQG5hbWUgVHdvLk1hdHJpeFxyXG4gICAqIEBjbGFzc1xyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbYT0xXSAtIFRoZSB2YWx1ZSBmb3IgZWxlbWVudCBhdCB0aGUgZmlyc3QgY29sdW1uIGFuZCBmaXJzdCByb3cuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtiPTBdIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSBzZWNvbmQgY29sdW1uIGFuZCBmaXJzdCByb3cuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjPTBdIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSB0aGlyZCBjb2x1bW4gYW5kIGZpcnN0IHJvdy5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2Q9MF0gLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIGZpcnN0IGNvbHVtbiBhbmQgc2Vjb25kIHJvdy5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2U9MV0gLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIHNlY29uZCBjb2x1bW4gYW5kIHNlY29uZCByb3cuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmPTBdIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSB0aGlyZCBjb2x1bW4gYW5kIHNlY29uZCByb3cuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtnPTBdIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSBmaXJzdCBjb2x1bW4gYW5kIHRoaXJkIHJvdy5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2g9MF0gLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIHNlY29uZCBjb2x1bW4gYW5kIHRoaXJkIHJvdy5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2k9MV0gLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIHRoaXJkIGNvbHVtbiBhbmQgdGhpcmQgcm93LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBBIGNsYXNzIHRvIHN0b3JlIDMgeCAzIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBpbmZvcm1hdGlvbi4gSW4gYWRkaXRpb24gdG8gc3RvcmluZyBkYXRhIGBUd28uTWF0cml4YCBoYXMgc3VwZWQgdXAgbWV0aG9kcyBmb3IgY29tbW9ucGxhY2UgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbnMuXHJcbiAgICogQG5vdGEtYmVuZSBPcmRlciBpcyBiYXNlZCBvbiBob3cgdG8gY29uc3RydWN0IHRyYW5zZm9ybWF0aW9uIHN0cmluZ3MgZm9yIHRoZSBicm93c2VyLlxyXG4gICAqL1xyXG4gIHZhciBNYXRyaXggPSBUd28uTWF0cml4ID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZikge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCNlbGVtZW50c1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJbXX0gLSBUaGUgdW5kZXJseWluZyBkYXRhIHN0b3JlZCBhcyBhbiBhcnJheS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyBUd28uQXJyYXkoOSk7XHJcblxyXG4gICAgdmFyIGVsZW1lbnRzID0gYTtcclxuICAgIGlmICghXy5pc0FycmF5KGVsZW1lbnRzKSkge1xyXG4gICAgICBlbGVtZW50cyA9IF8udG9BcnJheShhcmd1bWVudHMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGluaXRpYWxpemUgdGhlIGVsZW1lbnRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXHJcbiAgICB0aGlzLmlkZW50aXR5KCk7XHJcblxyXG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgdGhpcy5zZXQoZWxlbWVudHMpO1xyXG4gICAgfVxyXG5cclxuICB9O1xyXG5cclxuICBfLmV4dGVuZChNYXRyaXgsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5NYXRyaXguSWRlbnRpdHlcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyW119IC0gQSBzdG9yZWQgcmVmZXJlbmNlIHRvIHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgMyB4IDMgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBJZGVudGl0eTogW1xyXG4gICAgICAxLCAwLCAwLFxyXG4gICAgICAwLCAxLCAwLFxyXG4gICAgICAwLCAwLCAxXHJcbiAgICBdLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeC5NdWx0aXBseVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1R3by5NYXRyaXh9IEFcclxuICAgICAqIEBwYXJhbSB7VHdvLk1hdHJpeH0gQlxyXG4gICAgICogQHBhcmFtIHtUd28uTWF0cml4fSBbQ10gLSBBbiBvcHRpb25hbCBtYXRyaXggdG8gYXBwbHkgdGhlIG11bHRpcGxpY2F0aW9uIHRvLlxyXG4gICAgICogQHJldHVybnMge1R3by5NYXRyaXh9IC0gSWYgYW4gb3B0aW9uYWwgYENgIG1hdHJpeCBpc24ndCBwYXNzZWQgdGhlbiBhIG5ldyBvbmUgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gTXVsdGlwbHkgdHdvIG1hdHJpY2VzIHRvZ2V0aGVyIGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cclxuICAgICAqL1xyXG4gICAgTXVsdGlwbHk6IGZ1bmN0aW9uKEEsIEIsIEMpIHtcclxuXHJcbiAgICAgIGlmIChCLmxlbmd0aCA8PSAzKSB7IC8vIE11bHRpcGx5IFZlY3RvclxyXG5cclxuICAgICAgICB2YXIgeCwgeSwgeiwgZSA9IEE7XHJcblxyXG4gICAgICAgIHZhciBhID0gQlswXSB8fCAwLFxyXG4gICAgICAgICAgICBiID0gQlsxXSB8fCAwLFxyXG4gICAgICAgICAgICBjID0gQlsyXSB8fCAwO1xyXG5cclxuICAgICAgICAvLyBHbyBkb3duIHJvd3MgZmlyc3RcclxuICAgICAgICAvLyBhLCBkLCBnLCBiLCBlLCBoLCBjLCBmLCBpXHJcblxyXG4gICAgICAgIHggPSBlWzBdICogYSArIGVbMV0gKiBiICsgZVsyXSAqIGM7XHJcbiAgICAgICAgeSA9IGVbM10gKiBhICsgZVs0XSAqIGIgKyBlWzVdICogYztcclxuICAgICAgICB6ID0gZVs2XSAqIGEgKyBlWzddICogYiArIGVbOF0gKiBjO1xyXG5cclxuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5LCB6OiB6IH07XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgQTAgPSBBWzBdLCBBMSA9IEFbMV0sIEEyID0gQVsyXTtcclxuICAgICAgdmFyIEEzID0gQVszXSwgQTQgPSBBWzRdLCBBNSA9IEFbNV07XHJcbiAgICAgIHZhciBBNiA9IEFbNl0sIEE3ID0gQVs3XSwgQTggPSBBWzhdO1xyXG5cclxuICAgICAgdmFyIEIwID0gQlswXSwgQjEgPSBCWzFdLCBCMiA9IEJbMl07XHJcbiAgICAgIHZhciBCMyA9IEJbM10sIEI0ID0gQls0XSwgQjUgPSBCWzVdO1xyXG4gICAgICB2YXIgQjYgPSBCWzZdLCBCNyA9IEJbN10sIEI4ID0gQls4XTtcclxuXHJcbiAgICAgIEMgPSBDIHx8IG5ldyBUd28uQXJyYXkoOSk7XHJcblxyXG4gICAgICBDWzBdID0gQTAgKiBCMCArIEExICogQjMgKyBBMiAqIEI2O1xyXG4gICAgICBDWzFdID0gQTAgKiBCMSArIEExICogQjQgKyBBMiAqIEI3O1xyXG4gICAgICBDWzJdID0gQTAgKiBCMiArIEExICogQjUgKyBBMiAqIEI4O1xyXG4gICAgICBDWzNdID0gQTMgKiBCMCArIEE0ICogQjMgKyBBNSAqIEI2O1xyXG4gICAgICBDWzRdID0gQTMgKiBCMSArIEE0ICogQjQgKyBBNSAqIEI3O1xyXG4gICAgICBDWzVdID0gQTMgKiBCMiArIEE0ICogQjUgKyBBNSAqIEI4O1xyXG4gICAgICBDWzZdID0gQTYgKiBCMCArIEE3ICogQjMgKyBBOCAqIEI2O1xyXG4gICAgICBDWzddID0gQTYgKiBCMSArIEE3ICogQjQgKyBBOCAqIEI3O1xyXG4gICAgICBDWzhdID0gQTYgKiBCMiArIEE3ICogQjUgKyBBOCAqIEI4O1xyXG5cclxuICAgICAgcmV0dXJuIEM7XHJcblxyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbiAgXy5leHRlbmQoTWF0cml4LnByb3RvdHlwZSwgVHdvLlV0aWxzLkV2ZW50cywge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBNYXRyaXgsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I21hbnVhbFxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciBUd28uanMgYXV0b21hdGljYWxseSBjYWxjdWxhdGVzIHRoZSB2YWx1ZXMgZm9yIHRoZSBtYXRyaXggb3IgaWYgdGhlIGRldmVsb3BlciBpbnRlbmRzIHRvIG1hbmFnZSB0aGUgbWF0cml4LlxyXG4gICAgICogQG5vdGEtYmVuZSAtIFNldHRpbmcgdG8gYHRydWVgIG51bGxpZmllcyB7QGxpbmsgVHdvLlNoYXBlI3RyYW5zbGF0aW9ufSwge0BsaW5rIFR3by5TaGFwZSNyb3RhdGlvbn0sIGFuZCB7QGxpbmsgVHdvLlNoYXBlI3NjYWxlfS5cclxuICAgICAqL1xyXG4gICAgbWFudWFsOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5NYXRyaXgjc2V0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSBmaXJzdCBjb2x1bW4gYW5kIGZpcnN0IHJvdy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSBzZWNvbmQgY29sdW1uIGFuZCBmaXJzdCByb3cuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYyAtIFRoZSB2YWx1ZSBmb3IgZWxlbWVudCBhdCB0aGUgdGhpcmQgY29sdW1uIGFuZCBmaXJzdCByb3cuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZCAtIFRoZSB2YWx1ZSBmb3IgZWxlbWVudCBhdCB0aGUgZmlyc3QgY29sdW1uIGFuZCBzZWNvbmQgcm93LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGUgLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIHNlY29uZCBjb2x1bW4gYW5kIHNlY29uZCByb3cuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZiAtIFRoZSB2YWx1ZSBmb3IgZWxlbWVudCBhdCB0aGUgdGhpcmQgY29sdW1uIGFuZCBzZWNvbmQgcm93LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGcgLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIGZpcnN0IGNvbHVtbiBhbmQgdGhpcmQgcm93LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGggLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIHNlY29uZCBjb2x1bW4gYW5kIHRoaXJkIHJvdy5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSB0aGlyZCBjb2x1bW4gYW5kIHRoaXJkIHJvdy5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgYW4gYXJyYXkgb2YgdmFsdWVzIG9udG8gdGhlIG1hdHJpeC4gT3JkZXIgZGVzY3JpYmVkIGluIHtAbGluayBUd28uTWF0cml4fS5cclxuICAgICAqL1xyXG5cclxuICAgICAvKipcclxuICAgICAgKiBAbmFtZSBUd28uTWF0cml4I3NldFxyXG4gICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGEgLSBUaGUgYXJyYXkgb2YgZWxlbWVudHMgdG8gYXBwbHkuXHJcbiAgICAgICogQGRlc2NyaXB0aW9uIFNldCBhbiBhcnJheSBvZiB2YWx1ZXMgb250byB0aGUgbWF0cml4LiBPcmRlciBkZXNjcmliZWQgaW4ge0BsaW5rIFR3by5NYXRyaXh9LlxyXG4gICAgICAqL1xyXG4gICAgc2V0OiBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpKSB7XHJcblxyXG4gICAgICB2YXIgZWxlbWVudHM7XHJcblxyXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChiKSkge1xyXG4gICAgICAgIGVsZW1lbnRzID0gYTtcclxuICAgICAgICBhID0gZWxlbWVudHNbMF07XHJcbiAgICAgICAgYiA9IGVsZW1lbnRzWzFdO1xyXG4gICAgICAgIGMgPSBlbGVtZW50c1syXTtcclxuICAgICAgICBkID0gZWxlbWVudHNbM107XHJcbiAgICAgICAgZSA9IGVsZW1lbnRzWzRdO1xyXG4gICAgICAgIGYgPSBlbGVtZW50c1s1XTtcclxuICAgICAgICBnID0gZWxlbWVudHNbNl07XHJcbiAgICAgICAgaCA9IGVsZW1lbnRzWzddO1xyXG4gICAgICAgIGkgPSBlbGVtZW50c1s4XTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5lbGVtZW50c1swXSA9IGE7XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbMV0gPSBiO1xyXG4gICAgICB0aGlzLmVsZW1lbnRzWzJdID0gYztcclxuICAgICAgdGhpcy5lbGVtZW50c1szXSA9IGQ7XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbNF0gPSBlO1xyXG4gICAgICB0aGlzLmVsZW1lbnRzWzVdID0gZjtcclxuICAgICAgdGhpcy5lbGVtZW50c1s2XSA9IGc7XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbN10gPSBoO1xyXG4gICAgICB0aGlzLmVsZW1lbnRzWzhdID0gaTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoVHdvLkV2ZW50cy5jaGFuZ2UpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I2NvcHlcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIENvcHkgdGhlIG1hdHJpeCBvZiBvbmUgdG8gdGhlIGN1cnJlbnQgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGNvcHk6IGZ1bmN0aW9uKG0pIHtcclxuXHJcbiAgICAgIHRoaXMuZWxlbWVudHNbMF0gPSBtLmVsZW1lbnRzWzBdO1xyXG4gICAgICB0aGlzLmVsZW1lbnRzWzFdID0gbS5lbGVtZW50c1sxXTtcclxuICAgICAgdGhpcy5lbGVtZW50c1syXSA9IG0uZWxlbWVudHNbMl07XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbM10gPSBtLmVsZW1lbnRzWzNdO1xyXG4gICAgICB0aGlzLmVsZW1lbnRzWzRdID0gbS5lbGVtZW50c1s0XTtcclxuICAgICAgdGhpcy5lbGVtZW50c1s1XSA9IG0uZWxlbWVudHNbNV07XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbNl0gPSBtLmVsZW1lbnRzWzZdO1xyXG4gICAgICB0aGlzLmVsZW1lbnRzWzddID0gbS5lbGVtZW50c1s3XTtcclxuICAgICAgdGhpcy5lbGVtZW50c1s4XSA9IG0uZWxlbWVudHNbOF07XHJcblxyXG4gICAgICB0aGlzLm1hbnVhbCA9IG0ubWFudWFsO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLmNoYW5nZSk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5NYXRyaXgjaWRlbnRpdHlcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIFR1cm4gbWF0cml4IHRvIHRoZSBpZGVudGl0eSwgbGlrZSByZXNldHRpbmcuXHJcbiAgICAgKi9cclxuICAgIGlkZW50aXR5OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHRoaXMuZWxlbWVudHNbMF0gPSBNYXRyaXguSWRlbnRpdHlbMF07XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbMV0gPSBNYXRyaXguSWRlbnRpdHlbMV07XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbMl0gPSBNYXRyaXguSWRlbnRpdHlbMl07XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbM10gPSBNYXRyaXguSWRlbnRpdHlbM107XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbNF0gPSBNYXRyaXguSWRlbnRpdHlbNF07XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbNV0gPSBNYXRyaXguSWRlbnRpdHlbNV07XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbNl0gPSBNYXRyaXguSWRlbnRpdHlbNl07XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbN10gPSBNYXRyaXguSWRlbnRpdHlbN107XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbOF0gPSBNYXRyaXguSWRlbnRpdHlbOF07XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKFR3by5FdmVudHMuY2hhbmdlKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeC5tdWx0aXBseVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYSAtIFRoZSBzY2FsYXIgdG8gYmUgbXVsdGlwbGllZC5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBNdWx0aXBseSBhbGwgY29tcG9uZW50cyBvZiB0aGUgbWF0cml4IGFnYWluc3QgYSBzaW5nbGUgc2NhbGFyIHZhbHVlLlxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4Lm11bHRpcGx5XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIC0gVGhlIHggY29tcG9uZW50IHRvIGJlIG11bHRpcGxpZWQuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiAtIFRoZSB5IGNvbXBvbmVudCB0byBiZSBtdWx0aXBsaWVkLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGMgLSBUaGUgeiBjb21wb25lbnQgdG8gYmUgbXVsdGlwbGllZC5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBNdWx0aXBseSBhbGwgY29tcG9uZW50cyBvZiBhIG1hdHJpeCBhZ2FpbnN0IGEgMyBjb21wb25lbnQgdmVjdG9yLlxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4Lm11bHRpcGx5XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIC0gVGhlIHZhbHVlIGF0IHRoZSBmaXJzdCBjb2x1bW4gYW5kIGZpcnN0IHJvdyBvZiB0aGUgbWF0cml4IHRvIGJlIG11bHRpcGxpZWQuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiAtIFRoZSB2YWx1ZSBhdCB0aGUgc2Vjb25kIGNvbHVtbiBhbmQgZmlyc3Qgcm93IG9mIHRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIC0gVGhlIHZhbHVlIGF0IHRoZSB0aGlyZCBjb2x1bW4gYW5kIGZpcnN0IHJvdyBvZiB0aGUgbWF0cml4IHRvIGJlIG11bHRpcGxpZWQuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZCAtIFRoZSB2YWx1ZSBhdCB0aGUgZmlyc3QgY29sdW1uIGFuZCBzZWNvbmQgcm93IG9mIHRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlIC0gVGhlIHZhbHVlIGF0IHRoZSBzZWNvbmQgY29sdW1uIGFuZCBzZWNvbmQgcm93IG9mIHRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmIC0gVGhlIHZhbHVlIGF0IHRoZSB0aGlyZCBjb2x1bW4gYW5kIHNlY29uZCByb3cgb2YgdGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGcgLSBUaGUgdmFsdWUgYXQgdGhlIGZpcnN0IGNvbHVtbiBhbmQgdGhpcmQgcm93IG9mIHRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZC5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoIC0gVGhlIHZhbHVlIGF0IHRoZSBzZWNvbmQgY29sdW1uIGFuZCB0aGlyZCByb3cgb2YgdGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGkgLSBUaGUgdmFsdWUgYXQgdGhlIHRoaXJkIGNvbHVtbiBhbmQgdGhpcmQgcm93IG9mIHRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZC5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBNdWx0aXBseSBhbGwgY29tcG9uZW50cyBvZiBhIG1hdHJpeCBhZ2FpbnN0IGFub3RoZXIgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBtdWx0aXBseTogZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSkge1xyXG5cclxuICAgICAgLy8gTXVsdGlwbHkgc2NhbGFyXHJcblxyXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChiKSkge1xyXG5cclxuICAgICAgICB0aGlzLmVsZW1lbnRzWzBdICo9IGE7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1sxXSAqPSBhO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudHNbMl0gKj0gYTtcclxuICAgICAgICB0aGlzLmVsZW1lbnRzWzNdICo9IGE7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1s0XSAqPSBhO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudHNbNV0gKj0gYTtcclxuICAgICAgICB0aGlzLmVsZW1lbnRzWzZdICo9IGE7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1s3XSAqPSBhO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudHNbOF0gKj0gYTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLmNoYW5nZSk7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChkKSkgeyAvLyBNdWx0aXBseSBWZWN0b3JcclxuXHJcbiAgICAgICAgdmFyIHgsIHksIHo7XHJcbiAgICAgICAgYSA9IGEgfHwgMDtcclxuICAgICAgICBiID0gYiB8fCAwO1xyXG4gICAgICAgIGMgPSBjIHx8IDA7XHJcbiAgICAgICAgZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG4gICAgICAgIC8vIEdvIGRvd24gcm93cyBmaXJzdFxyXG4gICAgICAgIC8vIGEsIGQsIGcsIGIsIGUsIGgsIGMsIGYsIGlcclxuXHJcbiAgICAgICAgeCA9IGVbMF0gKiBhICsgZVsxXSAqIGIgKyBlWzJdICogYztcclxuICAgICAgICB5ID0gZVszXSAqIGEgKyBlWzRdICogYiArIGVbNV0gKiBjO1xyXG4gICAgICAgIHogPSBlWzZdICogYSArIGVbN10gKiBiICsgZVs4XSAqIGM7XHJcblxyXG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHksIHo6IHogfTtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE11bHRpcGxlIG1hdHJpeFxyXG5cclxuICAgICAgdmFyIEEgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgICB2YXIgQiA9IFthLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpXTtcclxuXHJcbiAgICAgIHZhciBBMCA9IEFbMF0sIEExID0gQVsxXSwgQTIgPSBBWzJdO1xyXG4gICAgICB2YXIgQTMgPSBBWzNdLCBBNCA9IEFbNF0sIEE1ID0gQVs1XTtcclxuICAgICAgdmFyIEE2ID0gQVs2XSwgQTcgPSBBWzddLCBBOCA9IEFbOF07XHJcblxyXG4gICAgICB2YXIgQjAgPSBCWzBdLCBCMSA9IEJbMV0sIEIyID0gQlsyXTtcclxuICAgICAgdmFyIEIzID0gQlszXSwgQjQgPSBCWzRdLCBCNSA9IEJbNV07XHJcbiAgICAgIHZhciBCNiA9IEJbNl0sIEI3ID0gQls3XSwgQjggPSBCWzhdO1xyXG5cclxuICAgICAgdGhpcy5lbGVtZW50c1swXSA9IEEwICogQjAgKyBBMSAqIEIzICsgQTIgKiBCNjtcclxuICAgICAgdGhpcy5lbGVtZW50c1sxXSA9IEEwICogQjEgKyBBMSAqIEI0ICsgQTIgKiBCNztcclxuICAgICAgdGhpcy5lbGVtZW50c1syXSA9IEEwICogQjIgKyBBMSAqIEI1ICsgQTIgKiBCODtcclxuXHJcbiAgICAgIHRoaXMuZWxlbWVudHNbM10gPSBBMyAqIEIwICsgQTQgKiBCMyArIEE1ICogQjY7XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbNF0gPSBBMyAqIEIxICsgQTQgKiBCNCArIEE1ICogQjc7XHJcbiAgICAgIHRoaXMuZWxlbWVudHNbNV0gPSBBMyAqIEIyICsgQTQgKiBCNSArIEE1ICogQjg7XHJcblxyXG4gICAgICB0aGlzLmVsZW1lbnRzWzZdID0gQTYgKiBCMCArIEE3ICogQjMgKyBBOCAqIEI2O1xyXG4gICAgICB0aGlzLmVsZW1lbnRzWzddID0gQTYgKiBCMSArIEE3ICogQjQgKyBBOCAqIEI3O1xyXG4gICAgICB0aGlzLmVsZW1lbnRzWzhdID0gQTYgKiBCMiArIEE3ICogQjUgKyBBOCAqIEI4O1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLmNoYW5nZSk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5NYXRyaXgjaW52ZXJzZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1R3by5NYXRyaXh9IFtvdXRdIC0gVGhlIG9wdGlvbmFsIG1hdHJpeCB0byBhcHBseSB0aGUgaW52ZXJzaW9uIHRvLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhbiBpbnZlcnRlZCB2ZXJzaW9uIG9mIHRoZSBtYXRyaXguIElmIG5vIG9wdGlvbmFsIG9uZSBpcyBwYXNzZWQgYSBuZXcgbWF0cml4IGlzIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxyXG4gICAgICovXHJcbiAgICBpbnZlcnNlOiBmdW5jdGlvbihvdXQpIHtcclxuXHJcbiAgICAgIHZhciBhID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgb3V0ID0gb3V0IHx8IG5ldyBUd28uTWF0cml4KCk7XHJcblxyXG4gICAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXTtcclxuICAgICAgdmFyIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV07XHJcbiAgICAgIHZhciBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xyXG5cclxuICAgICAgdmFyIGIwMSA9IGEyMiAqIGExMSAtIGExMiAqIGEyMTtcclxuICAgICAgdmFyIGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjA7XHJcbiAgICAgIHZhciBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjA7XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XHJcbiAgICAgIHZhciBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XHJcblxyXG4gICAgICBpZiAoIWRldCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkZXQgPSAxLjAgLyBkZXQ7XHJcblxyXG4gICAgICBvdXQuZWxlbWVudHNbMF0gPSBiMDEgKiBkZXQ7XHJcbiAgICAgIG91dC5lbGVtZW50c1sxXSA9ICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldDtcclxuICAgICAgb3V0LmVsZW1lbnRzWzJdID0gKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQ7XHJcbiAgICAgIG91dC5lbGVtZW50c1szXSA9IGIxMSAqIGRldDtcclxuICAgICAgb3V0LmVsZW1lbnRzWzRdID0gKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQ7XHJcbiAgICAgIG91dC5lbGVtZW50c1s1XSA9ICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldDtcclxuICAgICAgb3V0LmVsZW1lbnRzWzZdID0gYjIxICogZGV0O1xyXG4gICAgICBvdXQuZWxlbWVudHNbN10gPSAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQ7XHJcbiAgICAgIG91dC5lbGVtZW50c1s4XSA9IChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0O1xyXG5cclxuICAgICAgcmV0dXJuIG91dDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCNzY2FsZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgLSBUaGUgb25lIGRpbWVuc2lvbmFsIHNjYWxlIHRvIGFwcGx5IHRvIHRoZSBtYXRyaXguXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gVW5pZm9ybWx5IHNjYWxlIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5NYXRyaXgjc2NhbGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN4IC0gVGhlIGhvcml6b250YWwgc2NhbGUgZmFjdG9yLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN5IC0gVGhlIHZlcnRpY2FsIHNjYWxlIGZhY3RvclxyXG4gICAgICogQGRlc2NyaXB0aW9uIFNjYWxlIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggaW4gdHdvIGRpbWVuc2lvbnMuXHJcbiAgICAgKi9cclxuICAgIHNjYWxlOiBmdW5jdGlvbihzeCwgc3kpIHtcclxuXHJcbiAgICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgICAgaWYgKGwgPD0gMSkge1xyXG4gICAgICAgIHN5ID0gc3g7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KHN4LCAwLCAwLCAwLCBzeSwgMCwgMCwgMCwgMSk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5NYXRyaXgjcm90YXRlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7UmFkaWFuc30gcmFkaWFucyAtIFRoZSBhbW91bnQgdG8gcm90YXRlIGluIHJhZGlhbnMuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUm90YXRlIHRoZSBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZTogZnVuY3Rpb24ocmFkaWFucykge1xyXG5cclxuICAgICAgdmFyIGMgPSBjb3MocmFkaWFucyk7XHJcbiAgICAgIHZhciBzID0gc2luKHJhZGlhbnMpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoYywgLXMsIDAsIHMsIGMsIDAsIDAsIDAsIDEpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I3RyYW5zbGF0ZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFRoZSBob3Jpem9udGFsIHRyYW5zbGF0aW9uIHZhbHVlIHRvIGFwcGx5LlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdmVydGljYWwgdHJhbnNsYXRpb24gdmFsdWUgdG8gYXBwbHkuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gVHJhbnNsYXRlIHRoZSBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oeCwgeSkge1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoMSwgMCwgeCwgMCwgMSwgeSwgMCwgMCwgMSk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5NYXRyaXgjc2tld1hcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtSYWRpYW5zfSByYWRpYW5zIC0gVGhlIGFtb3VudCB0byBza2V3IGluIHJhZGlhbnMuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gU2tldyB0aGUgbWF0cml4IGJ5IGFuIGFuZ2xlIGluIHRoZSB4IGF4aXMgZGlyZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBza2V3WDogZnVuY3Rpb24ocmFkaWFucykge1xyXG5cclxuICAgICAgdmFyIGEgPSB0YW4ocmFkaWFucyk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5tdWx0aXBseSgxLCBhLCAwLCAwLCAxLCAwLCAwLCAwLCAxKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCNza2V3WVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1JhZGlhbnN9IHJhZGlhbnMgLSBUaGUgYW1vdW50IHRvIHNrZXcgaW4gcmFkaWFucy5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBTa2V3IHRoZSBtYXRyaXggYnkgYW4gYW5nbGUgaW4gdGhlIHkgYXhpcyBkaXJlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHNrZXdZOiBmdW5jdGlvbihyYWRpYW5zKSB7XHJcblxyXG4gICAgICB2YXIgYSA9IHRhbihyYWRpYW5zKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KDEsIDAsIDAsIGEsIDEsIDAsIDAsIDAsIDEpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I3RvU3RyaW5nXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Z1bGxNYXRyaXg9ZmFsc2VdIC0gUmV0dXJuIHRoZSBmdWxsIDkgZWxlbWVudHMgb2YgdGhlIG1hdHJpeCBvciBqdXN0IDYgZm9yIDJEIHRyYW5zZm9ybWF0aW9ucy5cclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IC0gVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBhcyBhIDYgY29tcG9uZW50IHN0cmluZyBzZXBhcmF0ZWQgYnkgc3BhY2VzLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIHRyYW5zZm9ybSBzdHJpbmcuIFVzZWQgZm9yIHRoZSBUd28uanMgcmVuZGVyaW5nIEFQSXMuXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbihmdWxsTWF0cml4KSB7XHJcblxyXG4gICAgICBhcnJheS5sZW5ndGggPSAwO1xyXG4gICAgICB0aGlzLnRvVHJhbnNmb3JtQXJyYXkoZnVsbE1hdHJpeCwgYXJyYXkpO1xyXG5cclxuICAgICAgcmV0dXJuIGFycmF5Lm1hcChUd28uVXRpbHMudG9GaXhlZCkuam9pbignICcpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I3RvVHJhbnNmb3JtQXJyYXlcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZnVsbE1hdHJpeD1mYWxzZV0gLSBSZXR1cm4gdGhlIGZ1bGwgOSBlbGVtZW50cyBvZiB0aGUgbWF0cml4IG9yIGp1c3QgNiBpbiB0aGUgZm9ybWF0IGZvciAyRCB0cmFuc2Zvcm1hdGlvbnMuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbb3V0cHV0XSAtIEFuIGFycmF5IGVtcHR5IG9yIG90aGVyd2lzZSB0byBhcHBseSB0aGUgdmFsdWVzIHRvLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIHRyYW5zZm9ybSBhcnJheS4gVXNlZCBmb3IgdGhlIFR3by5qcyByZW5kZXJpbmcgQVBJcy5cclxuICAgICAqL1xyXG4gICAgdG9UcmFuc2Zvcm1BcnJheTogZnVuY3Rpb24oZnVsbE1hdHJpeCwgb3V0cHV0KSB7XHJcblxyXG4gICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgdmFyIGhhc091dHB1dCA9ICEhb3V0cHV0O1xyXG5cclxuICAgICB2YXIgYSA9IGVsZW1lbnRzWzBdO1xyXG4gICAgIHZhciBiID0gZWxlbWVudHNbMV07XHJcbiAgICAgdmFyIGMgPSBlbGVtZW50c1syXTtcclxuICAgICB2YXIgZCA9IGVsZW1lbnRzWzNdO1xyXG4gICAgIHZhciBlID0gZWxlbWVudHNbNF07XHJcbiAgICAgdmFyIGYgPSBlbGVtZW50c1s1XTtcclxuXHJcbiAgICAgIGlmIChmdWxsTWF0cml4KSB7XHJcblxyXG4gICAgICAgIHZhciBnID0gZWxlbWVudHNbNl07XHJcbiAgICAgICAgdmFyIGggPSBlbGVtZW50c1s3XTtcclxuICAgICAgICB2YXIgaSA9IGVsZW1lbnRzWzhdO1xyXG5cclxuICAgICAgICBpZiAoaGFzT3V0cHV0KSB7XHJcbiAgICAgICAgICBvdXRwdXRbMF0gPSBhO1xyXG4gICAgICAgICAgb3V0cHV0WzFdID0gZDtcclxuICAgICAgICAgIG91dHB1dFsyXSA9IGc7XHJcbiAgICAgICAgICBvdXRwdXRbM10gPSBiO1xyXG4gICAgICAgICAgb3V0cHV0WzRdID0gZTtcclxuICAgICAgICAgIG91dHB1dFs1XSA9IGg7XHJcbiAgICAgICAgICBvdXRwdXRbNl0gPSBjO1xyXG4gICAgICAgICAgb3V0cHV0WzddID0gZjtcclxuICAgICAgICAgIG91dHB1dFs4XSA9IGk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgYSwgZCwgZywgYiwgZSwgaCwgYywgZiwgaVxyXG4gICAgICAgIF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChoYXNPdXRwdXQpIHtcclxuICAgICAgICBvdXRwdXRbMF0gPSBhO1xyXG4gICAgICAgIG91dHB1dFsxXSA9IGQ7XHJcbiAgICAgICAgb3V0cHV0WzJdID0gYjtcclxuICAgICAgICBvdXRwdXRbM10gPSBlO1xyXG4gICAgICAgIG91dHB1dFs0XSA9IGM7XHJcbiAgICAgICAgb3V0cHV0WzVdID0gZjtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBbXHJcbiAgICAgICAgYSwgZCwgYiwgZSwgYywgZiAgLy8gU3BlY2lmaWMgZm9ybWF0IHNlZSBMTjoxOVxyXG4gICAgICBdO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I3RvQXJyYXlcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZnVsbE1hdHJpeD1mYWxzZV0gLSBSZXR1cm4gdGhlIGZ1bGwgOSBlbGVtZW50cyBvZiB0aGUgbWF0cml4IG9yIGp1c3QgNiBmb3IgMkQgdHJhbnNmb3JtYXRpb25zLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gW291dHB1dF0gLSBBbiBhcnJheSBlbXB0eSBvciBvdGhlcndpc2UgdG8gYXBwbHkgdGhlIHZhbHVlcyB0by5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSB0cmFuc2Zvcm0gYXJyYXkuIFVzZWQgZm9yIHRoZSBUd28uanMgcmVuZGVyaW5nIEFQSXMuXHJcbiAgICAgKi9cclxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKGZ1bGxNYXRyaXgsIG91dHB1dCkge1xyXG5cclxuICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgIHZhciBoYXNPdXRwdXQgPSAhIW91dHB1dDtcclxuXHJcbiAgICAgdmFyIGEgPSBlbGVtZW50c1swXTtcclxuICAgICB2YXIgYiA9IGVsZW1lbnRzWzFdO1xyXG4gICAgIHZhciBjID0gZWxlbWVudHNbMl07XHJcbiAgICAgdmFyIGQgPSBlbGVtZW50c1szXTtcclxuICAgICB2YXIgZSA9IGVsZW1lbnRzWzRdO1xyXG4gICAgIHZhciBmID0gZWxlbWVudHNbNV07XHJcblxyXG4gICAgICBpZiAoZnVsbE1hdHJpeCkge1xyXG5cclxuICAgICAgICB2YXIgZyA9IGVsZW1lbnRzWzZdO1xyXG4gICAgICAgIHZhciBoID0gZWxlbWVudHNbN107XHJcbiAgICAgICAgdmFyIGkgPSBlbGVtZW50c1s4XTtcclxuXHJcbiAgICAgICAgaWYgKGhhc091dHB1dCkge1xyXG4gICAgICAgICAgb3V0cHV0WzBdID0gYTtcclxuICAgICAgICAgIG91dHB1dFsxXSA9IGI7XHJcbiAgICAgICAgICBvdXRwdXRbMl0gPSBjO1xyXG4gICAgICAgICAgb3V0cHV0WzNdID0gZDtcclxuICAgICAgICAgIG91dHB1dFs0XSA9IGU7XHJcbiAgICAgICAgICBvdXRwdXRbNV0gPSBmO1xyXG4gICAgICAgICAgb3V0cHV0WzZdID0gZztcclxuICAgICAgICAgIG91dHB1dFs3XSA9IGg7XHJcbiAgICAgICAgICBvdXRwdXRbOF0gPSBpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgIGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGlcclxuICAgICAgICBdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaGFzT3V0cHV0KSB7XHJcbiAgICAgICAgb3V0cHV0WzBdID0gYTtcclxuICAgICAgICBvdXRwdXRbMV0gPSBiO1xyXG4gICAgICAgIG91dHB1dFsyXSA9IGM7XHJcbiAgICAgICAgb3V0cHV0WzNdID0gZDtcclxuICAgICAgICBvdXRwdXRbNF0gPSBlO1xyXG4gICAgICAgIG91dHB1dFs1XSA9IGY7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gW1xyXG4gICAgICAgIGEsIGIsIGMsIGQsIGUsIGZcclxuICAgICAgXTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCN0b09iamVjdFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgSlNPTiBjb21wYXRpYmxlIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgaW5mb3JtYXRpb24gb2YgdGhlIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGVsZW1lbnRzOiB0aGlzLnRvQXJyYXkodHJ1ZSksXHJcbiAgICAgICAgbWFudWFsOiAhIXRoaXMubWFudWFsXHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCNjbG9uZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2xvbmUgdGhlIGN1cnJlbnQgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IFR3by5NYXRyaXgoKS5jb3B5KHRoaXMpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG59KSgodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiAodGhpcyB8fCBzZWxmIHx8IHdpbmRvdykpLlR3byk7XHJcblxuKGZ1bmN0aW9uKFR3bykge1xyXG5cclxuICAvLyBMb2NhbGl6ZSB2YXJpYWJsZXNcclxuICB2YXIgbW9kID0gVHdvLlV0aWxzLm1vZCwgdG9GaXhlZCA9IFR3by5VdGlscy50b0ZpeGVkO1xyXG4gIHZhciBfID0gVHdvLlV0aWxzO1xyXG5cclxuICB2YXIgc3ZnID0ge1xyXG5cclxuICAgIHZlcnNpb246IDEuMSxcclxuXHJcbiAgICBuczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcclxuICAgIHhsaW5rOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXHJcblxyXG4gICAgYWxpZ25tZW50czoge1xyXG4gICAgICBsZWZ0OiAnc3RhcnQnLFxyXG4gICAgICBjZW50ZXI6ICdtaWRkbGUnLFxyXG4gICAgICByaWdodDogJ2VuZCdcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gc3ZnIG5hbWVzcGFjZWQgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24obmFtZSwgYXR0cnMpIHtcclxuICAgICAgdmFyIHRhZyA9IG5hbWU7XHJcbiAgICAgIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Zy5ucywgdGFnKTtcclxuICAgICAgaWYgKHRhZyA9PT0gJ3N2ZycpIHtcclxuICAgICAgICBhdHRycyA9IF8uZGVmYXVsdHMoYXR0cnMgfHwge30sIHtcclxuICAgICAgICAgIHZlcnNpb246IHN2Zy52ZXJzaW9uXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFfLmlzRW1wdHkoYXR0cnMpKSB7XHJcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZXMoZWxlbSwgYXR0cnMpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBlbGVtO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhdHRyaWJ1dGVzIGZyb20gYW4gc3ZnIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHNldEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGVsZW0sIGF0dHJzKSB7XHJcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoL2hyZWYvLnRlc3Qoa2V5c1tpXSkpIHtcclxuICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlTlMoc3ZnLnhsaW5rLCBrZXlzW2ldLCBhdHRyc1trZXlzW2ldXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKGtleXNbaV0sIGF0dHJzW2tleXNbaV1dKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGF0dHJpYnV0ZXMgZnJvbSBhbiBzdmcgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQXR0cmlidXRlczogZnVuY3Rpb24oZWxlbSwgYXR0cnMpIHtcclxuICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUdXJuIGEgc2V0IG9mIHZlcnRpY2VzIGludG8gYSBzdHJpbmcgZm9yIHRoZSBkIHByb3BlcnR5IG9mIGEgcGF0aFxyXG4gICAgICogZWxlbWVudC4gSXQgaXMgaW1wZXJhdGl2ZSB0aGF0IHRoZSBzdHJpbmcgY29sbGF0aW9uIGlzIGFzIGZhc3QgYXNcclxuICAgICAqIHBvc3NpYmxlLCBiZWNhdXNlIHRoaXMgY2FsbCB3aWxsIGJlIGhhcHBlbmluZyBtdWx0aXBsZSB0aW1lcyBhXHJcbiAgICAgKiBzZWNvbmQuXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbihwb2ludHMsIGNsb3NlZCkge1xyXG5cclxuICAgICAgdmFyIGwgPSBwb2ludHMubGVuZ3RoLFxyXG4gICAgICAgIGxhc3QgPSBsIC0gMSxcclxuICAgICAgICBkLCAvLyBUaGUgZWx1c2l2ZSBsYXN0IFR3by5Db21tYW5kcy5tb3ZlIHBvaW50XHJcbiAgICAgICAgc3RyaW5nID0gJyc7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHZhciBiID0gcG9pbnRzW2ldO1xyXG4gICAgICAgIHZhciBjb21tYW5kO1xyXG4gICAgICAgIHZhciBwcmV2ID0gY2xvc2VkID8gbW9kKGkgLSAxLCBsKSA6IE1hdGgubWF4KGkgLSAxLCAwKTtcclxuICAgICAgICB2YXIgbmV4dCA9IGNsb3NlZCA/IG1vZChpICsgMSwgbCkgOiBNYXRoLm1pbihpICsgMSwgbGFzdCk7XHJcblxyXG4gICAgICAgIHZhciBhID0gcG9pbnRzW3ByZXZdO1xyXG4gICAgICAgIHZhciBjID0gcG9pbnRzW25leHRdO1xyXG5cclxuICAgICAgICB2YXIgdngsIHZ5LCB1eCwgdXksIGFyLCBibCwgYnIsIGNsO1xyXG4gICAgICAgIHZhciByeCwgcnksIHhBeGlzUm90YXRpb24sIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnO1xyXG5cclxuICAgICAgICAvLyBBY2Nlc3MgeCBhbmQgeSBkaXJlY3RseSxcclxuICAgICAgICAvLyBieXBhc3NpbmcgdGhlIGdldHRlclxyXG4gICAgICAgIHZhciB4ID0gdG9GaXhlZChiLngpO1xyXG4gICAgICAgIHZhciB5ID0gdG9GaXhlZChiLnkpO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKGIuY29tbWFuZCkge1xyXG5cclxuICAgICAgICAgIGNhc2UgVHdvLkNvbW1hbmRzLmNsb3NlOlxyXG4gICAgICAgICAgICBjb21tYW5kID0gVHdvLkNvbW1hbmRzLmNsb3NlO1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBjYXNlIFR3by5Db21tYW5kcy5hcmM6XHJcblxyXG4gICAgICAgICAgICByeCA9IGIucng7XHJcbiAgICAgICAgICAgIHJ5ID0gYi5yeTtcclxuICAgICAgICAgICAgeEF4aXNSb3RhdGlvbiA9IGIueEF4aXNSb3RhdGlvbjtcclxuICAgICAgICAgICAgbGFyZ2VBcmNGbGFnID0gYi5sYXJnZUFyY0ZsYWc7XHJcbiAgICAgICAgICAgIHN3ZWVwRmxhZyA9IGIuc3dlZXBGbGFnO1xyXG5cclxuICAgICAgICAgICAgY29tbWFuZCA9IFR3by5Db21tYW5kcy5hcmMgKyAnICcgKyByeCArICcgJyArIHJ5ICsgJyAnXHJcbiAgICAgICAgICAgICAgKyB4QXhpc1JvdGF0aW9uICsgJyAnICsgbGFyZ2VBcmNGbGFnICsgJyAnICsgc3dlZXBGbGFnICsgJyAnXHJcbiAgICAgICAgICAgICAgKyB4ICsgJyAnICsgeTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSBUd28uQ29tbWFuZHMuY3VydmU6XHJcblxyXG4gICAgICAgICAgICBhciA9IChhLmNvbnRyb2xzICYmIGEuY29udHJvbHMucmlnaHQpIHx8IFR3by5WZWN0b3IuemVybztcclxuICAgICAgICAgICAgYmwgPSAoYi5jb250cm9scyAmJiBiLmNvbnRyb2xzLmxlZnQpIHx8IFR3by5WZWN0b3IuemVybztcclxuXHJcbiAgICAgICAgICAgIGlmIChhLnJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgdnggPSB0b0ZpeGVkKChhci54ICsgYS54KSk7XHJcbiAgICAgICAgICAgICAgdnkgPSB0b0ZpeGVkKChhci55ICsgYS55KSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdnggPSB0b0ZpeGVkKGFyLngpO1xyXG4gICAgICAgICAgICAgIHZ5ID0gdG9GaXhlZChhci55KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGIucmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgICB1eCA9IHRvRml4ZWQoKGJsLnggKyBiLngpKTtcclxuICAgICAgICAgICAgICB1eSA9IHRvRml4ZWQoKGJsLnkgKyBiLnkpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB1eCA9IHRvRml4ZWQoYmwueCk7XHJcbiAgICAgICAgICAgICAgdXkgPSB0b0ZpeGVkKGJsLnkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb21tYW5kID0gKChpID09PSAwKSA/IFR3by5Db21tYW5kcy5tb3ZlIDogVHdvLkNvbW1hbmRzLmN1cnZlKSArXHJcbiAgICAgICAgICAgICAgJyAnICsgdnggKyAnICcgKyB2eSArICcgJyArIHV4ICsgJyAnICsgdXkgKyAnICcgKyB4ICsgJyAnICsgeTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgY2FzZSBUd28uQ29tbWFuZHMubW92ZTpcclxuICAgICAgICAgICAgZCA9IGI7XHJcbiAgICAgICAgICAgIGNvbW1hbmQgPSBUd28uQ29tbWFuZHMubW92ZSArICcgJyArIHggKyAnICcgKyB5O1xyXG4gICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBjb21tYW5kID0gYi5jb21tYW5kICsgJyAnICsgeCArICcgJyArIHk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIGEgZmluYWwgcG9pbnQgYW5kIGNsb3NlIGl0IG9mZlxyXG5cclxuICAgICAgICBpZiAoaSA+PSBsYXN0ICYmIGNsb3NlZCkge1xyXG5cclxuICAgICAgICAgIGlmIChiLmNvbW1hbmQgPT09IFR3by5Db21tYW5kcy5jdXJ2ZSkge1xyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGNsb3NlIHRvIHRoZSBtb3N0IHByZXZpb3VzIFR3by5Db21tYW5kcy5tb3ZlXHJcbiAgICAgICAgICAgIGMgPSBkO1xyXG5cclxuICAgICAgICAgICAgYnIgPSAoYi5jb250cm9scyAmJiBiLmNvbnRyb2xzLnJpZ2h0KSB8fCBiO1xyXG4gICAgICAgICAgICBjbCA9IChjLmNvbnRyb2xzICYmIGMuY29udHJvbHMubGVmdCkgfHwgYztcclxuXHJcbiAgICAgICAgICAgIGlmIChiLnJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgdnggPSB0b0ZpeGVkKChici54ICsgYi54KSk7XHJcbiAgICAgICAgICAgICAgdnkgPSB0b0ZpeGVkKChici55ICsgYi55KSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdnggPSB0b0ZpeGVkKGJyLngpO1xyXG4gICAgICAgICAgICAgIHZ5ID0gdG9GaXhlZChici55KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGMucmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgICB1eCA9IHRvRml4ZWQoKGNsLnggKyBjLngpKTtcclxuICAgICAgICAgICAgICB1eSA9IHRvRml4ZWQoKGNsLnkgKyBjLnkpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB1eCA9IHRvRml4ZWQoY2wueCk7XHJcbiAgICAgICAgICAgICAgdXkgPSB0b0ZpeGVkKGNsLnkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB4ID0gdG9GaXhlZChjLngpO1xyXG4gICAgICAgICAgICB5ID0gdG9GaXhlZChjLnkpO1xyXG5cclxuICAgICAgICAgICAgY29tbWFuZCArPVxyXG4gICAgICAgICAgICAgICcgQyAnICsgdnggKyAnICcgKyB2eSArICcgJyArIHV4ICsgJyAnICsgdXkgKyAnICcgKyB4ICsgJyAnICsgeTtcclxuXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGIuY29tbWFuZCAhPT0gVHdvLkNvbW1hbmRzLmNsb3NlKSB7XHJcbiAgICAgICAgICAgIGNvbW1hbmQgKz0gJyBaJztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHJpbmcgKz0gY29tbWFuZCArICcgJztcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzdHJpbmc7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRDbGlwOiBmdW5jdGlvbihzaGFwZSkge1xyXG5cclxuICAgICAgdmFyIGNsaXAgPSBzaGFwZS5fcmVuZGVyZXIuY2xpcDtcclxuXHJcbiAgICAgIGlmICghY2xpcCkge1xyXG5cclxuICAgICAgICB2YXIgcm9vdCA9IHNoYXBlO1xyXG5cclxuICAgICAgICB3aGlsZSAocm9vdC5wYXJlbnQpIHtcclxuICAgICAgICAgIHJvb3QgPSByb290LnBhcmVudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNsaXAgPSBzaGFwZS5fcmVuZGVyZXIuY2xpcCA9IHN2Zy5jcmVhdGVFbGVtZW50KCdjbGlwUGF0aCcpO1xyXG4gICAgICAgIHJvb3QuZGVmcy5hcHBlbmRDaGlsZChjbGlwKTtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBjbGlwO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgZ3JvdXA6IHtcclxuXHJcbiAgICAgIC8vIFRPRE86IENhbiBzcGVlZCB1cC5cclxuICAgICAgLy8gVE9ETzogSG93IGRvZXMgdGhpcyBlZmZlY3QgYSBmXHJcbiAgICAgIGFwcGVuZENoaWxkOiBmdW5jdGlvbihvYmplY3QpIHtcclxuXHJcbiAgICAgICAgdmFyIGVsZW0gPSBvYmplY3QuX3JlbmRlcmVyLmVsZW07XHJcblxyXG4gICAgICAgIGlmICghZWxlbSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRhZyA9IGVsZW0ubm9kZU5hbWU7XHJcblxyXG4gICAgICAgIGlmICghdGFnIHx8IC8ocmFkaWFsfGxpbmVhcilncmFkaWVudC9pLnRlc3QodGFnKSB8fCBvYmplY3QuX2NsaXApIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZWxlbS5hcHBlbmRDaGlsZChlbGVtKTtcclxuXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24ob2JqZWN0KSB7XHJcblxyXG4gICAgICAgIHZhciBlbGVtID0gb2JqZWN0Ll9yZW5kZXJlci5lbGVtO1xyXG5cclxuICAgICAgICBpZiAoIWVsZW0gfHwgZWxlbS5wYXJlbnROb2RlICE9IHRoaXMuZWxlbSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRhZyA9IGVsZW0ubm9kZU5hbWU7XHJcblxyXG4gICAgICAgIGlmICghdGFnKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWZlciBzdWJ0cmFjdGlvbnMgd2hpbGUgY2xpcHBpbmcuXHJcbiAgICAgICAgaWYgKG9iamVjdC5fY2xpcCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5lbGVtLnJlbW92ZUNoaWxkKGVsZW0pO1xyXG5cclxuICAgICAgfSxcclxuXHJcbiAgICAgIG9yZGVyQ2hpbGQ6IGZ1bmN0aW9uKG9iamVjdCkge1xyXG4gICAgICAgIHRoaXMuZWxlbS5hcHBlbmRDaGlsZChvYmplY3QuX3JlbmRlcmVyLmVsZW0pO1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgcmVuZGVyQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgc3ZnW2NoaWxkLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChjaGlsZCwgdGhpcyk7XHJcbiAgICAgIH0sXHJcblxyXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGRvbUVsZW1lbnQpIHtcclxuXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcblxyXG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBoaWRkZW4gb2JqZWN0cy5cclxuICAgICAgICAvLyBEb2Vzbid0IHJlc2V0IHRoZSBmbGFncywgc28gY2hhbmdlcyBhcmUgc3RvcmVkIGFuZFxyXG4gICAgICAgIC8vIGFwcGxpZWQgb25jZSB0aGUgb2JqZWN0IGlzIHZpc2libGUgYWdhaW5cclxuICAgICAgICBpZiAodGhpcy5fb3BhY2l0eSA9PT0gMCAmJiAhdGhpcy5fZmxhZ09wYWNpdHkpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlci5lbGVtKSB7XHJcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtID0gc3ZnLmNyZWF0ZUVsZW1lbnQoJ2cnLCB7XHJcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fcmVuZGVyZXIuZWxlbSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBfVXBkYXRlIHN0eWxlcyBmb3IgdGhlIDxnPlxyXG4gICAgICAgIHZhciBmbGFnTWF0cml4ID0gdGhpcy5fbWF0cml4Lm1hbnVhbCB8fCB0aGlzLl9mbGFnTWF0cml4O1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0ge1xyXG4gICAgICAgICAgZG9tRWxlbWVudDogZG9tRWxlbWVudCxcclxuICAgICAgICAgIGVsZW06IHRoaXMuX3JlbmRlcmVyLmVsZW1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoZmxhZ01hdHJpeCkge1xyXG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICdtYXRyaXgoJyArIHRoaXMuX21hdHJpeC50b1N0cmluZygpICsgJyknKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcclxuICAgICAgICAgIHN2Z1tjaGlsZC5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwoY2hpbGQsIGRvbUVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdPcGFjaXR5KSB7XHJcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsIHRoaXMuX29wYWNpdHkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdDbGFzc05hbWUpIHtcclxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0uc2V0QXR0cmlidXRlKCdjbGFzcycsIHRoaXMuY2xhc3NMaXN0LmpvaW4oJyAnKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fZmxhZ0FkZGl0aW9ucykge1xyXG4gICAgICAgICAgdGhpcy5hZGRpdGlvbnMuZm9yRWFjaChzdmcuZ3JvdXAuYXBwZW5kQ2hpbGQsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdTdWJ0cmFjdGlvbnMpIHtcclxuICAgICAgICAgIHRoaXMuc3VidHJhY3Rpb25zLmZvckVhY2goc3ZnLmdyb3VwLnJlbW92ZUNoaWxkLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9mbGFnT3JkZXIpIHtcclxuICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChzdmcuZ3JvdXAub3JkZXJDaGlsZCwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb21tZW50ZWQgdHdvLXdheSBmdW5jdGlvbmFsaXR5IG9mIGNsaXBzIC8gbWFza3Mgd2l0aCBncm91cHMgYW5kXHJcbiAgICAgICAgICogcG9seWdvbnMuIFVuY29tbWVudCB3aGVuIHRoaXMgYnVnIGlzIGZpeGVkOlxyXG4gICAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzA5NTFcclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLy8gaWYgKHRoaXMuX2ZsYWdDbGlwKSB7XHJcblxyXG4gICAgICAgIC8vICAgY2xpcCA9IHN2Zy5nZXRDbGlwKHRoaXMpO1xyXG4gICAgICAgIC8vICAgZWxlbSA9IHRoaXMuX3JlbmRlcmVyLmVsZW07XHJcblxyXG4gICAgICAgIC8vICAgaWYgKHRoaXMuX2NsaXApIHtcclxuICAgICAgICAvLyAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XHJcbiAgICAgICAgLy8gICAgIGNsaXAuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuaWQpO1xyXG4gICAgICAgIC8vICAgICBjbGlwLmFwcGVuZENoaWxkKGVsZW0pO1xyXG4gICAgICAgIC8vICAgfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgY2xpcC5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XHJcbiAgICAgICAgLy8gICAgIGVsZW0uc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuaWQpO1xyXG4gICAgICAgIC8vICAgICB0aGlzLnBhcmVudC5fcmVuZGVyZXIuZWxlbS5hcHBlbmRDaGlsZChlbGVtKTsgLy8gVE9ETzogc2hvdWxkIGJlIGluc2VydEJlZm9yZVxyXG4gICAgICAgIC8vICAgfVxyXG5cclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9mbGFnTWFzaykge1xyXG4gICAgICAgICAgaWYgKHRoaXMuX21hc2spIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbS5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICd1cmwoIycgKyB0aGlzLl9tYXNrLmlkICsgJyknKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0ucmVtb3ZlQXR0cmlidXRlKCdjbGlwLXBhdGgnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xyXG5cclxuICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcGF0aDoge1xyXG5cclxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihkb21FbGVtZW50KSB7XHJcblxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICAgICAgICAvLyBTaG9ydGN1dCBmb3IgaGlkZGVuIG9iamVjdHMuXHJcbiAgICAgICAgLy8gRG9lc24ndCByZXNldCB0aGUgZmxhZ3MsIHNvIGNoYW5nZXMgYXJlIHN0b3JlZCBhbmRcclxuICAgICAgICAvLyBhcHBsaWVkIG9uY2UgdGhlIG9iamVjdCBpcyB2aXNpYmxlIGFnYWluXHJcbiAgICAgICAgaWYgKHRoaXMuX29wYWNpdHkgPT09IDAgJiYgIXRoaXMuX2ZsYWdPcGFjaXR5KSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbGxlY3QgYW55IGF0dHJpYnV0ZSB0aGF0IG5lZWRzIHRvIGJlIGNoYW5nZWQgaGVyZVxyXG4gICAgICAgIHZhciBjaGFuZ2VkID0ge307XHJcblxyXG4gICAgICAgIHZhciBmbGFnTWF0cml4ID0gdGhpcy5fbWF0cml4Lm1hbnVhbCB8fCB0aGlzLl9mbGFnTWF0cml4O1xyXG5cclxuICAgICAgICBpZiAoZmxhZ01hdHJpeCkge1xyXG4gICAgICAgICAgY2hhbmdlZC50cmFuc2Zvcm0gPSAnbWF0cml4KCcgKyB0aGlzLl9tYXRyaXgudG9TdHJpbmcoKSArICcpJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9mbGFnVmVydGljZXMpIHtcclxuICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IHN2Zy50b1N0cmluZyh0aGlzLl9yZW5kZXJlci52ZXJ0aWNlcywgdGhpcy5fY2xvc2VkKTtcclxuICAgICAgICAgIGNoYW5nZWQuZCA9IHZlcnRpY2VzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZpbGwgJiYgdGhpcy5fZmlsbC5fcmVuZGVyZXIpIHtcclxuICAgICAgICAgIHRoaXMuX2ZpbGwuX3VwZGF0ZSgpO1xyXG4gICAgICAgICAgc3ZnW3RoaXMuX2ZpbGwuX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKHRoaXMuX2ZpbGwsIGRvbUVsZW1lbnQsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdGaWxsKSB7XHJcbiAgICAgICAgICBjaGFuZ2VkLmZpbGwgPSB0aGlzLl9maWxsICYmIHRoaXMuX2ZpbGwuaWRcclxuICAgICAgICAgICAgPyAndXJsKCMnICsgdGhpcy5fZmlsbC5pZCArICcpJyA6IHRoaXMuX2ZpbGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fc3Ryb2tlICYmIHRoaXMuX3N0cm9rZS5fcmVuZGVyZXIpIHtcclxuICAgICAgICAgIHRoaXMuX3N0cm9rZS5fdXBkYXRlKCk7XHJcbiAgICAgICAgICBzdmdbdGhpcy5fc3Ryb2tlLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbCh0aGlzLl9zdHJva2UsIGRvbUVsZW1lbnQsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdTdHJva2UpIHtcclxuICAgICAgICAgIGNoYW5nZWQuc3Ryb2tlID0gdGhpcy5fc3Ryb2tlICYmIHRoaXMuX3N0cm9rZS5pZFxyXG4gICAgICAgICAgICA/ICd1cmwoIycgKyB0aGlzLl9zdHJva2UuaWQgKyAnKScgOiB0aGlzLl9zdHJva2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fZmxhZ0xpbmV3aWR0aCkge1xyXG4gICAgICAgICAgY2hhbmdlZFsnc3Ryb2tlLXdpZHRoJ10gPSB0aGlzLl9saW5ld2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fZmxhZ09wYWNpdHkpIHtcclxuICAgICAgICAgIGNoYW5nZWRbJ3N0cm9rZS1vcGFjaXR5J10gPSB0aGlzLl9vcGFjaXR5O1xyXG4gICAgICAgICAgY2hhbmdlZFsnZmlsbC1vcGFjaXR5J10gPSB0aGlzLl9vcGFjaXR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdDbGFzc05hbWUpIHtcclxuICAgICAgICAgIGNoYW5nZWRbJ2NsYXNzJ10gPSB0aGlzLmNsYXNzTGlzdC5qb2luKCcgJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fZmxhZ1Zpc2libGUpIHtcclxuICAgICAgICAgIGNoYW5nZWQudmlzaWJpbGl0eSA9IHRoaXMuX3Zpc2libGUgPyAndmlzaWJsZScgOiAnaGlkZGVuJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9mbGFnQ2FwKSB7XHJcbiAgICAgICAgICBjaGFuZ2VkWydzdHJva2UtbGluZWNhcCddID0gdGhpcy5fY2FwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdKb2luKSB7XHJcbiAgICAgICAgICBjaGFuZ2VkWydzdHJva2UtbGluZWpvaW4nXSA9IHRoaXMuX2pvaW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fZmxhZ01pdGVyKSB7XHJcbiAgICAgICAgICBjaGFuZ2VkWydzdHJva2UtbWl0ZXJsaW1pdCddID0gdGhpcy5fbWl0ZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5kYXNoZXMgJiYgdGhpcy5kYXNoZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY2hhbmdlZFsnc3Ryb2tlLWRhc2hhcnJheSddID0gdGhpcy5kYXNoZXMuam9pbignICcpO1xyXG4gICAgICAgICAgY2hhbmdlZFsnc3Ryb2tlLWRhc2hvZmZzZXQnXSA9IHRoaXMuZGFzaGVzLm9mZnNldCB8fCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gYXR0YWNoZWQgRE9NIGVsZW1lbnQgeWV0LFxyXG4gICAgICAgIC8vIGNyZWF0ZSBpdCB3aXRoIGFsbCBuZWNlc3NhcnkgYXR0cmlidXRlcy5cclxuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLmVsZW0pIHtcclxuXHJcbiAgICAgICAgICBjaGFuZ2VkLmlkID0gdGhpcy5pZDtcclxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0gPSBzdmcuY3JlYXRlRWxlbWVudCgncGF0aCcsIGNoYW5nZWQpO1xyXG4gICAgICAgICAgZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9yZW5kZXJlci5lbGVtKTtcclxuXHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGFwcGx5IGFsbCBwZW5kaW5nIGF0dHJpYnV0ZXNcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZXModGhpcy5fcmVuZGVyZXIuZWxlbSwgY2hhbmdlZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fZmxhZ0NsaXApIHtcclxuXHJcbiAgICAgICAgICB2YXIgY2xpcCA9IHN2Zy5nZXRDbGlwKHRoaXMpO1xyXG4gICAgICAgICAgdmFyIGVsZW0gPSB0aGlzLl9yZW5kZXJlci5lbGVtO1xyXG5cclxuICAgICAgICAgIGlmICh0aGlzLl9jbGlwKSB7XHJcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xyXG4gICAgICAgICAgICBjbGlwLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmlkKTtcclxuICAgICAgICAgICAgY2xpcC5hcHBlbmRDaGlsZChlbGVtKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNsaXAucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xyXG4gICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmlkKTtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuX3JlbmRlcmVyLmVsZW0uYXBwZW5kQ2hpbGQoZWxlbSk7IC8vIFRPRE86IHNob3VsZCBiZSBpbnNlcnRCZWZvcmVcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb21tZW50ZWQgdHdvLXdheSBmdW5jdGlvbmFsaXR5IG9mIGNsaXBzIC8gbWFza3Mgd2l0aCBncm91cHMgYW5kXHJcbiAgICAgICAgICogcG9seWdvbnMuIFVuY29tbWVudCB3aGVuIHRoaXMgYnVnIGlzIGZpeGVkOlxyXG4gICAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzA5NTFcclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLy8gaWYgKHRoaXMuX2ZsYWdNYXNrKSB7XHJcbiAgICAgICAgLy8gICBpZiAodGhpcy5fbWFzaykge1xyXG4gICAgICAgIC8vICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnY2xpcC1wYXRoJywgJ3VybCgjJyArIHRoaXMuX21hc2suaWQgKyAnKScpO1xyXG4gICAgICAgIC8vICAgfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcpO1xyXG4gICAgICAgIC8vICAgfVxyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0ZXh0OiB7XHJcblxyXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGRvbUVsZW1lbnQpIHtcclxuXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcblxyXG4gICAgICAgIHZhciBjaGFuZ2VkID0ge307XHJcblxyXG4gICAgICAgIHZhciBmbGFnTWF0cml4ID0gdGhpcy5fbWF0cml4Lm1hbnVhbCB8fCB0aGlzLl9mbGFnTWF0cml4O1xyXG5cclxuICAgICAgICBpZiAoZmxhZ01hdHJpeCkge1xyXG4gICAgICAgICAgY2hhbmdlZC50cmFuc2Zvcm0gPSAnbWF0cml4KCcgKyB0aGlzLl9tYXRyaXgudG9TdHJpbmcoKSArICcpJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9mbGFnRmFtaWx5KSB7XHJcbiAgICAgICAgICBjaGFuZ2VkWydmb250LWZhbWlseSddID0gdGhpcy5fZmFtaWx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZmxhZ1NpemUpIHtcclxuICAgICAgICAgIGNoYW5nZWRbJ2ZvbnQtc2l6ZSddID0gdGhpcy5fc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdMZWFkaW5nKSB7XHJcbiAgICAgICAgICBjaGFuZ2VkWydsaW5lLWhlaWdodCddID0gdGhpcy5fbGVhZGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdBbGlnbm1lbnQpIHtcclxuICAgICAgICAgIGNoYW5nZWRbJ3RleHQtYW5jaG9yJ10gPSBzdmcuYWxpZ25tZW50c1t0aGlzLl9hbGlnbm1lbnRdIHx8IHRoaXMuX2FsaWdubWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdCYXNlbGluZSkge1xyXG4gICAgICAgICAgY2hhbmdlZFsnYWxpZ25tZW50LWJhc2VsaW5lJ10gPSBjaGFuZ2VkWydkb21pbmFudC1iYXNlbGluZSddID0gdGhpcy5fYmFzZWxpbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9mbGFnU3R5bGUpIHtcclxuICAgICAgICAgIGNoYW5nZWRbJ2ZvbnQtc3R5bGUnXSA9IHRoaXMuX3N0eWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZmxhZ1dlaWdodCkge1xyXG4gICAgICAgICAgY2hhbmdlZFsnZm9udC13ZWlnaHQnXSA9IHRoaXMuX3dlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdEZWNvcmF0aW9uKSB7XHJcbiAgICAgICAgICBjaGFuZ2VkWyd0ZXh0LWRlY29yYXRpb24nXSA9IHRoaXMuX2RlY29yYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9maWxsICYmIHRoaXMuX2ZpbGwuX3JlbmRlcmVyKSB7XHJcbiAgICAgICAgICB0aGlzLl9maWxsLl91cGRhdGUoKTtcclxuICAgICAgICAgIHN2Z1t0aGlzLl9maWxsLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbCh0aGlzLl9maWxsLCBkb21FbGVtZW50LCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdGaWxsKSB7XHJcbiAgICAgICAgICBjaGFuZ2VkLmZpbGwgPSB0aGlzLl9maWxsICYmIHRoaXMuX2ZpbGwuaWRcclxuICAgICAgICAgICAgPyAndXJsKCMnICsgdGhpcy5fZmlsbC5pZCArICcpJyA6IHRoaXMuX2ZpbGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9zdHJva2UgJiYgdGhpcy5fc3Ryb2tlLl9yZW5kZXJlcikge1xyXG4gICAgICAgICAgdGhpcy5fc3Ryb2tlLl91cGRhdGUoKTtcclxuICAgICAgICAgIHN2Z1t0aGlzLl9zdHJva2UuX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKHRoaXMuX3N0cm9rZSwgZG9tRWxlbWVudCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9mbGFnU3Ryb2tlKSB7XHJcbiAgICAgICAgICBjaGFuZ2VkLnN0cm9rZSA9IHRoaXMuX3N0cm9rZSAmJiB0aGlzLl9zdHJva2UuaWRcclxuICAgICAgICAgICAgPyAndXJsKCMnICsgdGhpcy5fc3Ryb2tlLmlkICsgJyknIDogdGhpcy5fc3Ryb2tlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZmxhZ0xpbmV3aWR0aCkge1xyXG4gICAgICAgICAgY2hhbmdlZFsnc3Ryb2tlLXdpZHRoJ10gPSB0aGlzLl9saW5ld2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9mbGFnT3BhY2l0eSkge1xyXG4gICAgICAgICAgY2hhbmdlZC5vcGFjaXR5ID0gdGhpcy5fb3BhY2l0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdDbGFzc05hbWUpIHtcclxuICAgICAgICAgIGNoYW5nZWRbJ2NsYXNzJ10gPSB0aGlzLmNsYXNzTGlzdC5qb2luKCcgJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9mbGFnVmlzaWJsZSkge1xyXG4gICAgICAgICAgY2hhbmdlZC52aXNpYmlsaXR5ID0gdGhpcy5fdmlzaWJsZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kYXNoZXMgJiYgdGhpcy5kYXNoZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY2hhbmdlZFsnc3Ryb2tlLWRhc2hhcnJheSddID0gdGhpcy5kYXNoZXMuam9pbignICcpO1xyXG4gICAgICAgICAgY2hhbmdlZFsnc3Ryb2tlLWRhc2hvZmZzZXQnXSA9IHRoaXMuZGFzaGVzLm9mZnNldCB8fCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlci5lbGVtKSB7XHJcblxyXG4gICAgICAgICAgY2hhbmdlZC5pZCA9IHRoaXMuaWQ7XHJcblxyXG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbSA9IHN2Zy5jcmVhdGVFbGVtZW50KCd0ZXh0JywgY2hhbmdlZCk7XHJcbiAgICAgICAgICBkb21FbGVtZW50LmRlZnMuYXBwZW5kQ2hpbGQodGhpcy5fcmVuZGVyZXIuZWxlbSk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZXModGhpcy5fcmVuZGVyZXIuZWxlbSwgY2hhbmdlZCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdDbGlwKSB7XHJcblxyXG4gICAgICAgICAgdmFyIGNsaXAgPSBzdmcuZ2V0Q2xpcCh0aGlzKTtcclxuICAgICAgICAgIHZhciBlbGVtID0gdGhpcy5fcmVuZGVyZXIuZWxlbTtcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5fY2xpcCkge1xyXG4gICAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTtcclxuICAgICAgICAgICAgY2xpcC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5pZCk7XHJcbiAgICAgICAgICAgIGNsaXAuYXBwZW5kQ2hpbGQoZWxlbSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjbGlwLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTtcclxuICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5pZCk7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50Ll9yZW5kZXJlci5lbGVtLmFwcGVuZENoaWxkKGVsZW0pOyAvLyBUT0RPOiBzaG91bGQgYmUgaW5zZXJ0QmVmb3JlXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdWYWx1ZSkge1xyXG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbS50ZXh0Q29udGVudCA9IHRoaXMuX3ZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAnbGluZWFyLWdyYWRpZW50Jzoge1xyXG5cclxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihkb21FbGVtZW50LCBzaWxlbnQpIHtcclxuXHJcbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcclxuICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGNoYW5nZWQgPSB7fTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdFbmRQb2ludHMpIHtcclxuICAgICAgICAgIGNoYW5nZWQueDEgPSB0aGlzLmxlZnQuX3g7XHJcbiAgICAgICAgICBjaGFuZ2VkLnkxID0gdGhpcy5sZWZ0Ll95O1xyXG4gICAgICAgICAgY2hhbmdlZC54MiA9IHRoaXMucmlnaHQuX3g7XHJcbiAgICAgICAgICBjaGFuZ2VkLnkyID0gdGhpcy5yaWdodC5feTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9mbGFnU3ByZWFkKSB7XHJcbiAgICAgICAgICBjaGFuZ2VkLnNwcmVhZE1ldGhvZCA9IHRoaXMuX3NwcmVhZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGF0dGFjaGVkIERPTSBlbGVtZW50IHlldCxcclxuICAgICAgICAvLyBjcmVhdGUgaXQgd2l0aCBhbGwgbmVjZXNzYXJ5IGF0dHJpYnV0ZXMuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlci5lbGVtKSB7XHJcblxyXG4gICAgICAgICAgY2hhbmdlZC5pZCA9IHRoaXMuaWQ7XHJcbiAgICAgICAgICBjaGFuZ2VkLmdyYWRpZW50VW5pdHMgPSAndXNlclNwYWNlT25Vc2UnO1xyXG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbSA9IHN2Zy5jcmVhdGVFbGVtZW50KCdsaW5lYXJHcmFkaWVudCcsIGNoYW5nZWQpO1xyXG4gICAgICAgICAgZG9tRWxlbWVudC5kZWZzLmFwcGVuZENoaWxkKHRoaXMuX3JlbmRlcmVyLmVsZW0pO1xyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UgYXBwbHkgYWxsIHBlbmRpbmcgYXR0cmlidXRlc1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZXModGhpcy5fcmVuZGVyZXIuZWxlbSwgY2hhbmdlZCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdTdG9wcykge1xyXG5cclxuICAgICAgICAgIHZhciBsZW5ndGhDaGFuZ2VkID0gdGhpcy5fcmVuZGVyZXIuZWxlbS5jaGlsZE5vZGVzLmxlbmd0aFxyXG4gICAgICAgICAgICAhPT0gdGhpcy5zdG9wcy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgaWYgKGxlbmd0aENoYW5nZWQpIHtcclxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3JlbmRlcmVyLmVsZW0ubGFzdENoaWxkKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbS5yZW1vdmVDaGlsZCh0aGlzLl9yZW5kZXJlci5lbGVtLmxhc3RDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RvcHMubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdG9wID0gdGhpcy5zdG9wc1tpXTtcclxuICAgICAgICAgICAgdmFyIGF0dHJzID0ge307XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RvcC5fZmxhZ09mZnNldCkge1xyXG4gICAgICAgICAgICAgIGF0dHJzLm9mZnNldCA9IDEwMCAqIHN0b3AuX29mZnNldCArICclJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RvcC5fZmxhZ0NvbG9yKSB7XHJcbiAgICAgICAgICAgICAgYXR0cnNbJ3N0b3AtY29sb3InXSA9IHN0b3AuX2NvbG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdG9wLl9mbGFnT3BhY2l0eSkge1xyXG4gICAgICAgICAgICAgIGF0dHJzWydzdG9wLW9wYWNpdHknXSA9IHN0b3AuX29wYWNpdHk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghc3RvcC5fcmVuZGVyZXIuZWxlbSkge1xyXG4gICAgICAgICAgICAgIHN0b3AuX3JlbmRlcmVyLmVsZW0gPSBzdmcuY3JlYXRlRWxlbWVudCgnc3RvcCcsIGF0dHJzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBzdmcuc2V0QXR0cmlidXRlcyhzdG9wLl9yZW5kZXJlci5lbGVtLCBhdHRycyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChsZW5ndGhDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbS5hcHBlbmRDaGlsZChzdG9wLl9yZW5kZXJlci5lbGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdG9wLmZsYWdSZXNldCgpO1xyXG5cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5mbGFnUmVzZXQoKTtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgICdyYWRpYWwtZ3JhZGllbnQnOiB7XHJcblxyXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGRvbUVsZW1lbnQsIHNpbGVudCkge1xyXG5cclxuICAgICAgICBpZiAoIXNpbGVudCkge1xyXG4gICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY2hhbmdlZCA9IHt9O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fZmxhZ0NlbnRlcikge1xyXG4gICAgICAgICAgY2hhbmdlZC5jeCA9IHRoaXMuY2VudGVyLl94O1xyXG4gICAgICAgICAgY2hhbmdlZC5jeSA9IHRoaXMuY2VudGVyLl95O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZmxhZ0ZvY2FsKSB7XHJcbiAgICAgICAgICBjaGFuZ2VkLmZ4ID0gdGhpcy5mb2NhbC5feDtcclxuICAgICAgICAgIGNoYW5nZWQuZnkgPSB0aGlzLmZvY2FsLl95O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdSYWRpdXMpIHtcclxuICAgICAgICAgIGNoYW5nZWQuciA9IHRoaXMuX3JhZGl1cztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9mbGFnU3ByZWFkKSB7XHJcbiAgICAgICAgICBjaGFuZ2VkLnNwcmVhZE1ldGhvZCA9IHRoaXMuX3NwcmVhZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGF0dGFjaGVkIERPTSBlbGVtZW50IHlldCxcclxuICAgICAgICAvLyBjcmVhdGUgaXQgd2l0aCBhbGwgbmVjZXNzYXJ5IGF0dHJpYnV0ZXMuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlci5lbGVtKSB7XHJcblxyXG4gICAgICAgICAgY2hhbmdlZC5pZCA9IHRoaXMuaWQ7XHJcbiAgICAgICAgICBjaGFuZ2VkLmdyYWRpZW50VW5pdHMgPSAndXNlclNwYWNlT25Vc2UnO1xyXG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbSA9IHN2Zy5jcmVhdGVFbGVtZW50KCdyYWRpYWxHcmFkaWVudCcsIGNoYW5nZWQpO1xyXG4gICAgICAgICAgZG9tRWxlbWVudC5kZWZzLmFwcGVuZENoaWxkKHRoaXMuX3JlbmRlcmVyLmVsZW0pO1xyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UgYXBwbHkgYWxsIHBlbmRpbmcgYXR0cmlidXRlc1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZXModGhpcy5fcmVuZGVyZXIuZWxlbSwgY2hhbmdlZCk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdTdG9wcykge1xyXG5cclxuICAgICAgICAgIHZhciBsZW5ndGhDaGFuZ2VkID0gdGhpcy5fcmVuZGVyZXIuZWxlbS5jaGlsZE5vZGVzLmxlbmd0aFxyXG4gICAgICAgICAgICAhPT0gdGhpcy5zdG9wcy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgaWYgKGxlbmd0aENoYW5nZWQpIHtcclxuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3JlbmRlcmVyLmVsZW0ubGFzdENoaWxkKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbS5yZW1vdmVDaGlsZCh0aGlzLl9yZW5kZXJlci5lbGVtLmxhc3RDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RvcHMubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIHZhciBzdG9wID0gdGhpcy5zdG9wc1tpXTtcclxuICAgICAgICAgICAgdmFyIGF0dHJzID0ge307XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RvcC5fZmxhZ09mZnNldCkge1xyXG4gICAgICAgICAgICAgIGF0dHJzLm9mZnNldCA9IDEwMCAqIHN0b3AuX29mZnNldCArICclJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RvcC5fZmxhZ0NvbG9yKSB7XHJcbiAgICAgICAgICAgICAgYXR0cnNbJ3N0b3AtY29sb3InXSA9IHN0b3AuX2NvbG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdG9wLl9mbGFnT3BhY2l0eSkge1xyXG4gICAgICAgICAgICAgIGF0dHJzWydzdG9wLW9wYWNpdHknXSA9IHN0b3AuX29wYWNpdHk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghc3RvcC5fcmVuZGVyZXIuZWxlbSkge1xyXG4gICAgICAgICAgICAgIHN0b3AuX3JlbmRlcmVyLmVsZW0gPSBzdmcuY3JlYXRlRWxlbWVudCgnc3RvcCcsIGF0dHJzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBzdmcuc2V0QXR0cmlidXRlcyhzdG9wLl9yZW5kZXJlci5lbGVtLCBhdHRycyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChsZW5ndGhDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbS5hcHBlbmRDaGlsZChzdG9wLl9yZW5kZXJlci5lbGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdG9wLmZsYWdSZXNldCgpO1xyXG5cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5mbGFnUmVzZXQoKTtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRleHR1cmU6IHtcclxuXHJcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24oZG9tRWxlbWVudCwgc2lsZW50KSB7XHJcblxyXG4gICAgICAgIGlmICghc2lsZW50KSB7XHJcbiAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjaGFuZ2VkID0ge307XHJcbiAgICAgICAgdmFyIHN0eWxlcyA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9mbGFnTG9hZGVkICYmIHRoaXMubG9hZGVkKSB7XHJcblxyXG4gICAgICAgICAgc3dpdGNoIChpbWFnZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdjYW52YXMnOlxyXG4gICAgICAgICAgICAgIHN0eWxlcy5ocmVmID0gc3R5bGVzWyd4bGluazpocmVmJ10gPSBpbWFnZS50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdpbWcnOlxyXG4gICAgICAgICAgICBjYXNlICdpbWFnZSc6XHJcbiAgICAgICAgICAgICAgc3R5bGVzLmhyZWYgPSBzdHlsZXNbJ3hsaW5rOmhyZWYnXSA9IHRoaXMuc3JjO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fZmxhZ09mZnNldCB8fCB0aGlzLl9mbGFnTG9hZGVkIHx8IHRoaXMuX2ZsYWdTY2FsZSkge1xyXG5cclxuICAgICAgICAgIGNoYW5nZWQueCA9IHRoaXMuX29mZnNldC54O1xyXG4gICAgICAgICAgY2hhbmdlZC55ID0gdGhpcy5fb2Zmc2V0Lnk7XHJcblxyXG4gICAgICAgICAgaWYgKGltYWdlKSB7XHJcblxyXG4gICAgICAgICAgICBjaGFuZ2VkLnggLT0gaW1hZ2Uud2lkdGggLyAyO1xyXG4gICAgICAgICAgICBjaGFuZ2VkLnkgLT0gaW1hZ2UuaGVpZ2h0IC8gMjtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2FsZSBpbnN0YW5jZW9mIFR3by5WZWN0b3IpIHtcclxuICAgICAgICAgICAgICBjaGFuZ2VkLnggKj0gdGhpcy5fc2NhbGUueDtcclxuICAgICAgICAgICAgICBjaGFuZ2VkLnkgKj0gdGhpcy5fc2NhbGUueTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBjaGFuZ2VkLnggKj0gdGhpcy5fc2NhbGU7XHJcbiAgICAgICAgICAgICAgY2hhbmdlZC55ICo9IHRoaXMuX3NjYWxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGNoYW5nZWQueCA+IDApIHtcclxuICAgICAgICAgICAgY2hhbmdlZC54ICo9IC0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChjaGFuZ2VkLnkgPiAwKSB7XHJcbiAgICAgICAgICAgIGNoYW5nZWQueSAqPSAtIDE7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdTY2FsZSB8fCB0aGlzLl9mbGFnTG9hZGVkIHx8IHRoaXMuX2ZsYWdSZXBlYXQpIHtcclxuXHJcbiAgICAgICAgICBjaGFuZ2VkLndpZHRoID0gMDtcclxuICAgICAgICAgIGNoYW5nZWQuaGVpZ2h0ID0gMDtcclxuXHJcbiAgICAgICAgICBpZiAoaW1hZ2UpIHtcclxuXHJcbiAgICAgICAgICAgIHN0eWxlcy53aWR0aCA9IGNoYW5nZWQud2lkdGggPSBpbWFnZS53aWR0aDtcclxuICAgICAgICAgICAgc3R5bGVzLmhlaWdodCA9IGNoYW5nZWQuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgLy8gVE9ETzogSGFjayAvIEJhbmQtYWlkXHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcmVwZWF0KSB7XHJcbiAgICAgICAgICAgICAgY2FzZSAnbm8tcmVwZWF0JzpcclxuICAgICAgICAgICAgICAgIGNoYW5nZWQud2lkdGggKz0gMTtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWQuaGVpZ2h0ICs9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3NjYWxlIGluc3RhbmNlb2YgVHdvLlZlY3Rvcikge1xyXG4gICAgICAgICAgICAgIGNoYW5nZWQud2lkdGggKj0gdGhpcy5fc2NhbGUueDtcclxuICAgICAgICAgICAgICBjaGFuZ2VkLmhlaWdodCAqPSB0aGlzLl9zY2FsZS55O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNoYW5nZWQud2lkdGggKj0gdGhpcy5fc2NhbGU7XHJcbiAgICAgICAgICAgICAgY2hhbmdlZC5oZWlnaHQgKj0gdGhpcy5fc2NhbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fZmxhZ1NjYWxlIHx8IHRoaXMuX2ZsYWdMb2FkZWQpIHtcclxuICAgICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIuaW1hZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuaW1hZ2UgPSBzdmcuY3JlYXRlRWxlbWVudCgnaW1hZ2UnLCBzdHlsZXMpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICghXy5pc0VtcHR5KHN0eWxlcykpIHtcclxuICAgICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZXModGhpcy5fcmVuZGVyZXIuaW1hZ2UsIHN0eWxlcyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLmVsZW0pIHtcclxuXHJcbiAgICAgICAgICBjaGFuZ2VkLmlkID0gdGhpcy5pZDtcclxuICAgICAgICAgIGNoYW5nZWQucGF0dGVyblVuaXRzID0gJ3VzZXJTcGFjZU9uVXNlJztcclxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0gPSBzdmcuY3JlYXRlRWxlbWVudCgncGF0dGVybicsIGNoYW5nZWQpO1xyXG4gICAgICAgICAgZG9tRWxlbWVudC5kZWZzLmFwcGVuZENoaWxkKHRoaXMuX3JlbmRlcmVyLmVsZW0pO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKCFfLmlzRW1wdHkoY2hhbmdlZCkpIHtcclxuXHJcbiAgICAgICAgICBzdmcuc2V0QXR0cmlidXRlcyh0aGlzLl9yZW5kZXJlci5lbGVtLCBjaGFuZ2VkKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyZXIuZWxlbSAmJiB0aGlzLl9yZW5kZXJlci5pbWFnZSAmJiAhdGhpcy5fcmVuZGVyZXIuYXBwZW5kZWQpIHtcclxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0uYXBwZW5kQ2hpbGQodGhpcy5fcmVuZGVyZXIuaW1hZ2UpO1xyXG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuYXBwZW5kZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBAbmFtZSBUd28uU1ZHUmVuZGVyZXJcclxuICAgKiBAY2xhc3NcclxuICAgKiBAZXh0ZW5kcyBUd28uVXRpbHMuRXZlbnRzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXSAtIFRoaXMgb2JqZWN0IGlzIGluaGVyaXRlZCB3aGVuIGNvbnN0cnVjdGluZyBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvfS5cclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtwYXJhbWV0ZXJzLmRvbUVsZW1lbnRdIC0gVGhlIGA8c3ZnIC8+YCB0byBkcmF3IHRvLiBJZiBub25lIGdpdmVuIGEgbmV3IG9uZSB3aWxsIGJlIGNvbnN0cnVjdGVkLlxyXG4gICAqIEBkZXNjcmlwdGlvbiBUaGlzIGNsYXNzIGlzIHVzZWQgYnkge0BsaW5rIFR3b30gd2hlbiBjb25zdHJ1Y3Rpbmcgd2l0aCBgdHlwZWAgb2YgYFR3by5UeXBlcy5zdmdgICh0aGUgZGVmYXVsdCB0eXBlKS4gSXQgdGFrZXMgVHdvLmpzJyBzY2VuZWdyYXBoIGFuZCByZW5kZXJzIGl0IHRvIGEgYDxzdmcgLz5gLlxyXG4gICAqL1xyXG4gIHZhciBSZW5kZXJlciA9IFR3b1tUd28uVHlwZXMuc3ZnXSA9IGZ1bmN0aW9uKHBhcmFtcykge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNWR1JlbmRlcmVyI2RvbUVsZW1lbnRcclxuICAgICAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gLSBUaGUgYDxzdmcgLz5gIGFzc29jaWF0ZWQgd2l0aCB0aGUgVHdvLmpzIHNjZW5lLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBwYXJhbXMuZG9tRWxlbWVudCB8fCBzdmcuY3JlYXRlRWxlbWVudCgnc3ZnJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU1ZHUmVuZGVyZXIjc2NlbmVcclxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLkdyb3VwfSAtIFRoZSByb290IGdyb3VwIG9mIHRoZSBzY2VuZWdyYXBoLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNjZW5lID0gbmV3IFR3by5Hcm91cCgpO1xyXG4gICAgdGhpcy5zY2VuZS5wYXJlbnQgPSB0aGlzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNWR1JlbmRlcmVyI2RlZnNcclxuICAgICAqIEBwcm9wZXJ0eSB7U3ZnRGVmaW50aW9uc0VsZW1lbnR9IC0gVGhlIGA8ZGVmcyAvPmAgdG8gYXBwbHkgZ3JhZGllbnRzLCBwYXR0ZXJucywgYW5kIGJpdG1hcCBpbWFnZXJ5LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmRlZnMgPSBzdmcuY3JlYXRlRWxlbWVudCgnZGVmcycpO1xyXG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuZGVmcyk7XHJcbiAgICB0aGlzLmRvbUVsZW1lbnQuZGVmcyA9IHRoaXMuZGVmcztcclxuICAgIHRoaXMuZG9tRWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xyXG5cclxuICB9O1xyXG5cclxuICBfLmV4dGVuZChSZW5kZXJlciwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNWR1JlbmRlcmVyLlV0aWxzXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gLSBBIG1hc3NpdmUgb2JqZWN0IGZpbGxlZCB3aXRoIHV0aWxpdHkgZnVuY3Rpb25zIGFuZCBwcm9wZXJ0aWVzIHRvIHJlbmRlciBUd28uanMgb2JqZWN0cyB0byBhIGA8c3ZnIC8+YC5cclxuICAgICAqL1xyXG4gICAgVXRpbHM6IHN2Z1xyXG5cclxuICB9KTtcclxuXHJcbiAgXy5leHRlbmQoUmVuZGVyZXIucHJvdG90eXBlLCBUd28uVXRpbHMuRXZlbnRzLCB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IFJlbmRlcmVyLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNWR1JlbmRlcmVyI3NldFNpemVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIG5ldyB3aWR0aCBvZiB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHJlbmRlcmVyLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIENoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKiBAbm90YS1iZW5lIFRyaWdnZXJzIGEgYFR3by5FdmVudHMucmVzaXplYC5cclxuICAgICAqL1xyXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xyXG5cclxuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGVzKHRoaXMuZG9tRWxlbWVudCwge1xyXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoVHdvLkV2ZW50cy5yZXNpemUsIHdpZHRoLCBoZWlnaHQpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU1ZHUmVuZGVyZXIjcmVuZGVyXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW5kZXIgdGhlIGN1cnJlbnQgc2NlbmUgdG8gdGhlIGA8c3ZnIC8+YC5cclxuICAgICAqL1xyXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHN2Zy5ncm91cC5yZW5kZXIuY2FsbCh0aGlzLnNjZW5lLCB0aGlzLmRvbUVsZW1lbnQpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbn0pKCh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6ICh0aGlzIHx8IHNlbGYgfHwgd2luZG93KSkuVHdvKTtcclxuXG4oZnVuY3Rpb24oVHdvKSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG4gIHZhciBtb2QgPSBUd28uVXRpbHMubW9kO1xyXG4gIHZhciBnZXRSYXRpbyA9IFR3by5VdGlscy5nZXRSYXRpbztcclxuICB2YXIgXyA9IFR3by5VdGlscztcclxuICB2YXIgZW1wdHlBcnJheSA9IFtdO1xyXG4gIHZhciBUV09fUEkgPSBNYXRoLlBJICogMixcclxuICAgIG1heCA9IE1hdGgubWF4LFxyXG4gICAgbWluID0gTWF0aC5taW4sXHJcbiAgICBhYnMgPSBNYXRoLmFicyxcclxuICAgIHNpbiA9IE1hdGguc2luLFxyXG4gICAgY29zID0gTWF0aC5jb3MsXHJcbiAgICBhY29zID0gTWF0aC5hY29zLFxyXG4gICAgc3FydCA9IE1hdGguc3FydDtcclxuXHJcbiAgLy8gUmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgYSBub24tdHJhbnNmb3JtaW5nIG1hdHJpeFxyXG4gIHZhciBpc0RlZmF1bHRNYXRyaXggPSBmdW5jdGlvbiAobSkge1xyXG4gICAgcmV0dXJuIChtWzBdID09IDEgJiYgbVszXSA9PSAwICYmIG1bMV0gPT0gMCAmJiBtWzRdID09IDEgJiYgbVsyXSA9PSAwICYmIG1bNV0gPT0gMCk7XHJcbiAgfTtcclxuXHJcbiAgdmFyIGNhbnZhcyA9IHtcclxuXHJcbiAgICBpc0hpZGRlbjogLyh1bmRlZmluZWR8bm9uZXx0cmFuc3BhcmVudCkvaSxcclxuXHJcbiAgICBhbGlnbm1lbnRzOiB7XHJcbiAgICAgIGxlZnQ6ICdzdGFydCcsXHJcbiAgICAgIG1pZGRsZTogJ2NlbnRlcicsXHJcbiAgICAgIHJpZ2h0OiAnZW5kJ1xyXG4gICAgfSxcclxuXHJcbiAgICBzaGltOiBmdW5jdGlvbihlbGVtLCBuYW1lKSB7XHJcbiAgICAgIGVsZW0udGFnTmFtZSA9IGVsZW0ubm9kZU5hbWUgPSBuYW1lIHx8ICdjYW52YXMnO1xyXG4gICAgICBlbGVtLm5vZGVUeXBlID0gMTtcclxuICAgICAgZWxlbS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihwcm9wKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXNbcHJvcF07XHJcbiAgICAgIH07XHJcbiAgICAgIGVsZW0uc2V0QXR0cmlidXRlID0gZnVuY3Rpb24ocHJvcCwgdmFsKSB7XHJcbiAgICAgICAgdGhpc1twcm9wXSA9IHZhbDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIGVsZW07XHJcbiAgICB9LFxyXG5cclxuICAgIGdyb3VwOiB7XHJcblxyXG4gICAgICByZW5kZXJDaGlsZDogZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgICBjYW52YXNbY2hpbGQuX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKGNoaWxkLCB0aGlzLmN0eCwgdHJ1ZSwgdGhpcy5jbGlwKTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4KSB7XHJcblxyXG4gICAgICAgIC8vIFRPRE86IEFkZCBhIGNoZWNrIGhlcmUgdG8gb25seSBpbnZva2UgX3VwZGF0ZSBpZiBuZWVkIGJlLlxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4LmVsZW1lbnRzO1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlci5vcGFjaXR5ID0gdGhpcy5fb3BhY2l0eVxyXG4gICAgICAgICAgKiAocGFyZW50ICYmIHBhcmVudC5fcmVuZGVyZXIgPyBwYXJlbnQuX3JlbmRlcmVyLm9wYWNpdHkgOiAxKTtcclxuXHJcbiAgICAgICAgdmFyIG1hc2sgPSB0aGlzLl9tYXNrO1xyXG4gICAgICAgIC8vIHZhciBjbGlwID0gdGhpcy5fY2xpcDtcclxuXHJcbiAgICAgICAgdmFyIGRlZmF1bHRNYXRyaXggPSBpc0RlZmF1bHRNYXRyaXgobWF0cml4KTtcclxuICAgICAgICB2YXIgc2hvdWxkSXNvbGF0ZSA9ICFkZWZhdWx0TWF0cml4IHx8ICEhbWFzaztcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlci5jb250ZXh0KSB7XHJcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5jb250ZXh0ID0ge307XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9yZW5kZXJlci5jb250ZXh0LmN0eCA9IGN0eDtcclxuICAgICAgICAvLyB0aGlzLl9yZW5kZXJlci5jb250ZXh0LmNsaXAgPSBjbGlwO1xyXG5cclxuICAgICAgICBpZiAoc2hvdWxkSXNvbGF0ZSkge1xyXG4gICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgIGlmICghZGVmYXVsdE1hdHJpeCkge1xyXG4gICAgICAgICAgICBjdHgudHJhbnNmb3JtKCAgbWF0cml4WzBdLCBtYXRyaXhbM10sIG1hdHJpeFsxXSxcclxuICAgICAgICAgICAgICBtYXRyaXhbNF0sIG1hdHJpeFsyXSwgbWF0cml4WzVdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtYXNrKSB7XHJcbiAgICAgICAgICBjYW52YXNbbWFzay5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwobWFzaywgY3R4LCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm9wYWNpdHkgPiAwICYmIHRoaXMuc2NhbGUgIT09IDApIHtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBjYW52YXNbY2hpbGQuX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKGNoaWxkLCBjdHgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNob3VsZElzb2xhdGUpIHtcclxuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbW1lbnRlZCB0d28td2F5IGZ1bmN0aW9uYWxpdHkgb2YgY2xpcHMgLyBtYXNrcyB3aXRoIGdyb3VwcyBhbmRcclxuICAgICAgICAgKiBwb2x5Z29ucy4gVW5jb21tZW50IHdoZW4gdGhpcyBidWcgaXMgZml4ZWQ6XHJcbiAgICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3MDk1MVxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvLyBpZiAoY2xpcCkge1xyXG4gICAgICAgIC8vICAgY3R4LmNsaXAoKTtcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xyXG5cclxuICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcGF0aDoge1xyXG5cclxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihjdHgsIGZvcmNlZCwgcGFyZW50Q2xpcHBlZCkge1xyXG5cclxuICAgICAgICB2YXIgbWF0cml4LCBzdHJva2UsIGxpbmV3aWR0aCwgZmlsbCwgb3BhY2l0eSwgdmlzaWJsZSwgY2FwLCBqb2luLCBtaXRlcixcclxuICAgICAgICAgICAgY2xvc2VkLCBjb21tYW5kcywgbGVuZ3RoLCBsYXN0LCBuZXh0LCBwcmV2LCBhLCBiLCBjLCBkLCB1eCwgdXksIHZ4LCB2eSxcclxuICAgICAgICAgICAgYXIsIGJsLCBiciwgY2wsIHgsIHksIG1hc2ssIGNsaXAsIGRlZmF1bHRNYXRyaXgsIGlzT2Zmc2V0LCBkYXNoZXM7XHJcblxyXG4gICAgICAgIC8vIFRPRE86IEFkZCBhIGNoZWNrIGhlcmUgdG8gb25seSBpbnZva2UgX3VwZGF0ZSBpZiBuZWVkIGJlLlxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICAgICAgICBtYXRyaXggPSB0aGlzLl9tYXRyaXguZWxlbWVudHM7XHJcbiAgICAgICAgc3Ryb2tlID0gdGhpcy5fc3Ryb2tlO1xyXG4gICAgICAgIGxpbmV3aWR0aCA9IHRoaXMuX2xpbmV3aWR0aDtcclxuICAgICAgICBmaWxsID0gdGhpcy5fZmlsbDtcclxuICAgICAgICBvcGFjaXR5ID0gdGhpcy5fb3BhY2l0eSAqIHRoaXMucGFyZW50Ll9yZW5kZXJlci5vcGFjaXR5O1xyXG4gICAgICAgIHZpc2libGUgPSB0aGlzLl92aXNpYmxlO1xyXG4gICAgICAgIGNhcCA9IHRoaXMuX2NhcDtcclxuICAgICAgICBqb2luID0gdGhpcy5fam9pbjtcclxuICAgICAgICBtaXRlciA9IHRoaXMuX21pdGVyO1xyXG4gICAgICAgIGNsb3NlZCA9IHRoaXMuX2Nsb3NlZDtcclxuICAgICAgICBjb21tYW5kcyA9IHRoaXMuX3JlbmRlcmVyLnZlcnRpY2VzOyAvLyBDb21tYW5kc1xyXG4gICAgICAgIGxlbmd0aCA9IGNvbW1hbmRzLmxlbmd0aDtcclxuICAgICAgICBsYXN0ID0gbGVuZ3RoIC0gMTtcclxuICAgICAgICBkZWZhdWx0TWF0cml4ID0gaXNEZWZhdWx0TWF0cml4KG1hdHJpeCk7XHJcbiAgICAgICAgZGFzaGVzID0gdGhpcy5kYXNoZXM7XHJcblxyXG4gICAgICAgIC8vIG1hc2sgPSB0aGlzLl9tYXNrO1xyXG4gICAgICAgIGNsaXAgPSB0aGlzLl9jbGlwO1xyXG5cclxuICAgICAgICBpZiAoIWZvcmNlZCAmJiAoIXZpc2libGUgfHwgY2xpcCkpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVHJhbnNmb3JtXHJcbiAgICAgICAgaWYgKCFkZWZhdWx0TWF0cml4KSB7XHJcbiAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgY3R4LnRyYW5zZm9ybShtYXRyaXhbMF0sIG1hdHJpeFszXSwgbWF0cml4WzFdLCBtYXRyaXhbNF0sIG1hdHJpeFsyXSwgbWF0cml4WzVdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgLyoqXHJcbiAgICAgICAgICogQ29tbWVudGVkIHR3by13YXkgZnVuY3Rpb25hbGl0eSBvZiBjbGlwcyAvIG1hc2tzIHdpdGggZ3JvdXBzIGFuZFxyXG4gICAgICAgICAqIHBvbHlnb25zLiBVbmNvbW1lbnQgd2hlbiB0aGlzIGJ1ZyBpcyBmaXhlZDpcclxuICAgICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzcwOTUxXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8vIGlmIChtYXNrKSB7XHJcbiAgICAgICAgLy8gICBjYW52YXNbbWFzay5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwobWFzaywgY3R4LCB0cnVlKTtcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIC8vIFN0eWxlc1xyXG4gICAgICAgIGlmIChmaWxsKSB7XHJcbiAgICAgICAgICBpZiAoXy5pc1N0cmluZyhmaWxsKSkge1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNhbnZhc1tmaWxsLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChmaWxsLCBjdHgpO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbC5fcmVuZGVyZXIuZWZmZWN0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3Ryb2tlKSB7XHJcbiAgICAgICAgICBpZiAoXy5pc1N0cmluZyhzdHJva2UpKSB7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNhbnZhc1tzdHJva2UuX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKHN0cm9rZSwgY3R4KTtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlLl9yZW5kZXJlci5lZmZlY3Q7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAobGluZXdpZHRoKSB7XHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5ld2lkdGg7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAobWl0ZXIpIHtcclxuICAgICAgICAgICAgY3R4Lm1pdGVyTGltaXQgPSBtaXRlcjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChqb2luKSB7XHJcbiAgICAgICAgICAgIGN0eC5saW5lSm9pbiA9IGpvaW47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoIWNsb3NlZCAmJiBjYXApIHtcclxuICAgICAgICAgICAgY3R4LmxpbmVDYXAgPSBjYXA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfLmlzTnVtYmVyKG9wYWNpdHkpKSB7XHJcbiAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRhc2hlcyAmJiBkYXNoZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZGFzaGVzLm9mZnNldCB8fCAwO1xyXG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgICBiID0gY29tbWFuZHNbaV07XHJcblxyXG4gICAgICAgICAgeCA9IGIueDtcclxuICAgICAgICAgIHkgPSBiLnk7XHJcblxyXG4gICAgICAgICAgc3dpdGNoIChiLmNvbW1hbmQpIHtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgVHdvLkNvbW1hbmRzLmNsb3NlOlxyXG4gICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgVHdvLkNvbW1hbmRzLmFyYzpcclxuXHJcbiAgICAgICAgICAgICAgdmFyIHJ4ID0gYi5yeDtcclxuICAgICAgICAgICAgICB2YXIgcnkgPSBiLnJ5O1xyXG4gICAgICAgICAgICAgIHZhciB4QXhpc1JvdGF0aW9uID0gYi54QXhpc1JvdGF0aW9uO1xyXG4gICAgICAgICAgICAgIHZhciBsYXJnZUFyY0ZsYWcgPSBiLmxhcmdlQXJjRmxhZztcclxuICAgICAgICAgICAgICB2YXIgc3dlZXBGbGFnID0gYi5zd2VlcEZsYWc7XHJcblxyXG4gICAgICAgICAgICAgIHByZXYgPSBjbG9zZWQgPyBtb2QoaSAtIDEsIGxlbmd0aCkgOiBtYXgoaSAtIDEsIDApO1xyXG4gICAgICAgICAgICAgIGEgPSBjb21tYW5kc1twcmV2XTtcclxuXHJcbiAgICAgICAgICAgICAgdmFyIGF4ID0gYS54O1xyXG4gICAgICAgICAgICAgIHZhciBheSA9IGEueTtcclxuXHJcbiAgICAgICAgICAgICAgY2FudmFzLnJlbmRlclN2Z0FyY0NvbW1hbmQoY3R4LCBheCwgYXksIHJ4LCByeSwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHhBeGlzUm90YXRpb24sIHgsIHkpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBUd28uQ29tbWFuZHMuY3VydmU6XHJcblxyXG4gICAgICAgICAgICAgIHByZXYgPSBjbG9zZWQgPyBtb2QoaSAtIDEsIGxlbmd0aCkgOiBNYXRoLm1heChpIC0gMSwgMCk7XHJcbiAgICAgICAgICAgICAgbmV4dCA9IGNsb3NlZCA/IG1vZChpICsgMSwgbGVuZ3RoKSA6IE1hdGgubWluKGkgKyAxLCBsYXN0KTtcclxuXHJcbiAgICAgICAgICAgICAgYSA9IGNvbW1hbmRzW3ByZXZdO1xyXG4gICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tuZXh0XTtcclxuICAgICAgICAgICAgICBhciA9IChhLmNvbnRyb2xzICYmIGEuY29udHJvbHMucmlnaHQpIHx8IFR3by5WZWN0b3IuemVybztcclxuICAgICAgICAgICAgICBibCA9IChiLmNvbnRyb2xzICYmIGIuY29udHJvbHMubGVmdCkgfHwgVHdvLlZlY3Rvci56ZXJvO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoYS5fcmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIHZ4ID0gKGFyLnggKyBhLngpO1xyXG4gICAgICAgICAgICAgICAgdnkgPSAoYXIueSArIGEueSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZ4ID0gYXIueDtcclxuICAgICAgICAgICAgICAgIHZ5ID0gYXIueTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChiLl9yZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdXggPSAoYmwueCArIGIueCk7XHJcbiAgICAgICAgICAgICAgICB1eSA9IChibC55ICsgYi55KTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXggPSBibC54O1xyXG4gICAgICAgICAgICAgICAgdXkgPSBibC55O1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8odngsIHZ5LCB1eCwgdXksIHgsIHkpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoaSA+PSBsYXN0ICYmIGNsb3NlZCkge1xyXG5cclxuICAgICAgICAgICAgICAgIGMgPSBkO1xyXG5cclxuICAgICAgICAgICAgICAgIGJyID0gKGIuY29udHJvbHMgJiYgYi5jb250cm9scy5yaWdodCkgfHwgVHdvLlZlY3Rvci56ZXJvO1xyXG4gICAgICAgICAgICAgICAgY2wgPSAoYy5jb250cm9scyAmJiBjLmNvbnRyb2xzLmxlZnQpIHx8IFR3by5WZWN0b3IuemVybztcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYi5fcmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgdnggPSAoYnIueCArIGIueCk7XHJcbiAgICAgICAgICAgICAgICAgIHZ5ID0gKGJyLnkgKyBiLnkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgdnggPSBici54O1xyXG4gICAgICAgICAgICAgICAgICB2eSA9IGJyLnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGMuX3JlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgIHV4ID0gKGNsLnggKyBjLngpO1xyXG4gICAgICAgICAgICAgICAgICB1eSA9IChjbC55ICsgYy55KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIHV4ID0gY2wueDtcclxuICAgICAgICAgICAgICAgICAgdXkgPSBjbC55O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHggPSBjLng7XHJcbiAgICAgICAgICAgICAgICB5ID0gYy55O1xyXG5cclxuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHZ4LCB2eSwgdXgsIHV5LCB4LCB5KTtcclxuXHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgVHdvLkNvbW1hbmRzLmxpbmU6XHJcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgVHdvLkNvbW1hbmRzLm1vdmU6XHJcbiAgICAgICAgICAgICAgZCA9IGI7XHJcbiAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBMb29zZSBlbmRzXHJcblxyXG4gICAgICAgIGlmIChjbG9zZWQpIHtcclxuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghY2xpcCAmJiAhcGFyZW50Q2xpcHBlZCkge1xyXG4gICAgICAgICAgaWYgKCFjYW52YXMuaXNIaWRkZW4udGVzdChmaWxsKSkge1xyXG4gICAgICAgICAgICBpc09mZnNldCA9IGZpbGwuX3JlbmRlcmVyICYmIGZpbGwuX3JlbmRlcmVyLm9mZnNldDtcclxuICAgICAgICAgICAgaWYgKGlzT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKFxyXG4gICAgICAgICAgICAgICAgLSBmaWxsLl9yZW5kZXJlci5vZmZzZXQueCwgLSBmaWxsLl9yZW5kZXJlci5vZmZzZXQueSk7XHJcbiAgICAgICAgICAgICAgY3R4LnNjYWxlKGZpbGwuX3JlbmRlcmVyLnNjYWxlLngsIGZpbGwuX3JlbmRlcmVyLnNjYWxlLnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgIGlmIChpc09mZnNldCkge1xyXG4gICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghY2FudmFzLmlzSGlkZGVuLnRlc3Qoc3Ryb2tlKSkge1xyXG4gICAgICAgICAgICBpc09mZnNldCA9IHN0cm9rZS5fcmVuZGVyZXIgJiYgc3Ryb2tlLl9yZW5kZXJlci5vZmZzZXQ7XHJcbiAgICAgICAgICAgIGlmIChpc09mZnNldCkge1xyXG4gICAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShcclxuICAgICAgICAgICAgICAgIC0gc3Ryb2tlLl9yZW5kZXJlci5vZmZzZXQueCwgLSBzdHJva2UuX3JlbmRlcmVyLm9mZnNldC55KTtcclxuICAgICAgICAgICAgICBjdHguc2NhbGUoc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS54LCBzdHJva2UuX3JlbmRlcmVyLnNjYWxlLnkpO1xyXG4gICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5ld2lkdGggLyBzdHJva2UuX3JlbmRlcmVyLnNjYWxlLng7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICBpZiAoaXNPZmZzZXQpIHtcclxuICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWRlZmF1bHRNYXRyaXgpIHtcclxuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2xpcCAmJiAhcGFyZW50Q2xpcHBlZCkge1xyXG4gICAgICAgICAgY3R4LmNsaXAoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChkYXNoZXMgJiYgZGFzaGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChlbXB0eUFycmF5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xyXG5cclxuICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdGV4dDoge1xyXG5cclxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihjdHgsIGZvcmNlZCwgcGFyZW50Q2xpcHBlZCkge1xyXG5cclxuICAgICAgICAvLyBUT0RPOiBBZGQgYSBjaGVjayBoZXJlIHRvIG9ubHkgaW52b2tlIF91cGRhdGUgaWYgbmVlZCBiZS5cclxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcclxuXHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeC5lbGVtZW50cztcclxuICAgICAgICB2YXIgc3Ryb2tlID0gdGhpcy5fc3Ryb2tlO1xyXG4gICAgICAgIHZhciBsaW5ld2lkdGggPSB0aGlzLl9saW5ld2lkdGg7XHJcbiAgICAgICAgdmFyIGZpbGwgPSB0aGlzLl9maWxsO1xyXG4gICAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5fb3BhY2l0eSAqIHRoaXMucGFyZW50Ll9yZW5kZXJlci5vcGFjaXR5O1xyXG4gICAgICAgIHZhciB2aXNpYmxlID0gdGhpcy5fdmlzaWJsZTtcclxuICAgICAgICB2YXIgZGVmYXVsdE1hdHJpeCA9IGlzRGVmYXVsdE1hdHJpeChtYXRyaXgpO1xyXG4gICAgICAgIHZhciBpc09mZnNldCA9IGZpbGwuX3JlbmRlcmVyICYmIGZpbGwuX3JlbmRlcmVyLm9mZnNldFxyXG4gICAgICAgICAgJiYgc3Ryb2tlLl9yZW5kZXJlciAmJiBzdHJva2UuX3JlbmRlcmVyLm9mZnNldDtcclxuICAgICAgICB2YXIgZGFzaGVzID0gdGhpcy5kYXNoZXM7XHJcblxyXG4gICAgICAgIHZhciBhLCBiLCBjLCBkLCBlLCBzeCwgc3k7XHJcblxyXG4gICAgICAgIC8vIG1hc2sgPSB0aGlzLl9tYXNrO1xyXG4gICAgICAgIHZhciBjbGlwID0gdGhpcy5fY2xpcDtcclxuXHJcbiAgICAgICAgaWYgKCFmb3JjZWQgJiYgKCF2aXNpYmxlIHx8IGNsaXApKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRyYW5zZm9ybVxyXG4gICAgICAgIGlmICghZGVmYXVsdE1hdHJpeCkge1xyXG4gICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgIGN0eC50cmFuc2Zvcm0obWF0cml4WzBdLCBtYXRyaXhbM10sIG1hdHJpeFsxXSwgbWF0cml4WzRdLCBtYXRyaXhbMl0sIG1hdHJpeFs1XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbW1lbnRlZCB0d28td2F5IGZ1bmN0aW9uYWxpdHkgb2YgY2xpcHMgLyBtYXNrcyB3aXRoIGdyb3VwcyBhbmRcclxuICAgICAgICAgKiBwb2x5Z29ucy4gVW5jb21tZW50IHdoZW4gdGhpcyBidWcgaXMgZml4ZWQ6XHJcbiAgICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3MDk1MVxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvLyBpZiAobWFzaykge1xyXG4gICAgICAgIC8vICAgY2FudmFzW21hc2suX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKG1hc2ssIGN0eCwgdHJ1ZSk7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICBpZiAoIWlzT2Zmc2V0KSB7XHJcbiAgICAgICAgICBjdHguZm9udCA9IFt0aGlzLl9zdHlsZSwgdGhpcy5fd2VpZ2h0LCB0aGlzLl9zaXplICsgJ3B4LycgK1xyXG4gICAgICAgICAgICB0aGlzLl9sZWFkaW5nICsgJ3B4JywgdGhpcy5fZmFtaWx5XS5qb2luKCcgJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjdHgudGV4dEFsaWduID0gY2FudmFzLmFsaWdubWVudHNbdGhpcy5fYWxpZ25tZW50XSB8fCB0aGlzLl9hbGlnbm1lbnQ7XHJcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRoaXMuX2Jhc2VsaW5lO1xyXG5cclxuICAgICAgICAvLyBTdHlsZXNcclxuICAgICAgICBpZiAoZmlsbCkge1xyXG4gICAgICAgICAgaWYgKF8uaXNTdHJpbmcoZmlsbCkpIHtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGw7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjYW52YXNbZmlsbC5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwoZmlsbCwgY3R4KTtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGwuX3JlbmRlcmVyLmVmZmVjdDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0cm9rZSkge1xyXG4gICAgICAgICAgaWYgKF8uaXNTdHJpbmcoc3Ryb2tlKSkge1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2U7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjYW52YXNbc3Ryb2tlLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChzdHJva2UsIGN0eCk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZS5fcmVuZGVyZXIuZWZmZWN0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGxpbmV3aWR0aCkge1xyXG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZXdpZHRoO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoXy5pc051bWJlcihvcGFjaXR5KSkge1xyXG4gICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhc2hlcyAmJiBkYXNoZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZGFzaGVzLm9mZnNldCB8fCAwO1xyXG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNsaXAgJiYgIXBhcmVudENsaXBwZWQpIHtcclxuXHJcbiAgICAgICAgICBpZiAoIWNhbnZhcy5pc0hpZGRlbi50ZXN0KGZpbGwpKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoZmlsbC5fcmVuZGVyZXIgJiYgZmlsbC5fcmVuZGVyZXIub2Zmc2V0KSB7XHJcblxyXG4gICAgICAgICAgICAgIHN4ID0gZmlsbC5fcmVuZGVyZXIuc2NhbGUueDtcclxuICAgICAgICAgICAgICBzeSA9IGZpbGwuX3JlbmRlcmVyLnNjYWxlLnk7XHJcblxyXG4gICAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSggLSBmaWxsLl9yZW5kZXJlci5vZmZzZXQueCxcclxuICAgICAgICAgICAgICAgIC0gZmlsbC5fcmVuZGVyZXIub2Zmc2V0LnkpO1xyXG4gICAgICAgICAgICAgIGN0eC5zY2FsZShzeCwgc3kpO1xyXG5cclxuICAgICAgICAgICAgICBhID0gdGhpcy5fc2l6ZSAvIGZpbGwuX3JlbmRlcmVyLnNjYWxlLnk7XHJcbiAgICAgICAgICAgICAgYiA9IHRoaXMuX2xlYWRpbmcgLyBmaWxsLl9yZW5kZXJlci5zY2FsZS55O1xyXG4gICAgICAgICAgICAgIGN0eC5mb250ID0gW3RoaXMuX3N0eWxlLCB0aGlzLl93ZWlnaHQsIGEgKyAncHgvJyxcclxuICAgICAgICAgICAgICAgIGIgKyAncHgnLCB0aGlzLl9mYW1pbHldLmpvaW4oJyAnKTtcclxuXHJcbiAgICAgICAgICAgICAgYyA9IGZpbGwuX3JlbmRlcmVyLm9mZnNldC54IC8gZmlsbC5fcmVuZGVyZXIuc2NhbGUueDtcclxuICAgICAgICAgICAgICBkID0gZmlsbC5fcmVuZGVyZXIub2Zmc2V0LnkgLyBmaWxsLl9yZW5kZXJlci5zY2FsZS55O1xyXG5cclxuICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy52YWx1ZSwgYywgZCk7XHJcbiAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMudmFsdWUsIDAsIDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICghY2FudmFzLmlzSGlkZGVuLnRlc3Qoc3Ryb2tlKSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0cm9rZS5fcmVuZGVyZXIgJiYgc3Ryb2tlLl9yZW5kZXJlci5vZmZzZXQpIHtcclxuXHJcbiAgICAgICAgICAgICAgc3ggPSBzdHJva2UuX3JlbmRlcmVyLnNjYWxlLng7XHJcbiAgICAgICAgICAgICAgc3kgPSBzdHJva2UuX3JlbmRlcmVyLnNjYWxlLnk7XHJcblxyXG4gICAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtIHN0cm9rZS5fcmVuZGVyZXIub2Zmc2V0LngsXHJcbiAgICAgICAgICAgICAgICAtIHN0cm9rZS5fcmVuZGVyZXIub2Zmc2V0LnkpO1xyXG4gICAgICAgICAgICAgIGN0eC5zY2FsZShzeCwgc3kpO1xyXG5cclxuICAgICAgICAgICAgICBhID0gdGhpcy5fc2l6ZSAvIHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueTtcclxuICAgICAgICAgICAgICBiID0gdGhpcy5fbGVhZGluZyAvIHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueTtcclxuICAgICAgICAgICAgICBjdHguZm9udCA9IFt0aGlzLl9zdHlsZSwgdGhpcy5fd2VpZ2h0LCBhICsgJ3B4LycsXHJcbiAgICAgICAgICAgICAgICBiICsgJ3B4JywgdGhpcy5fZmFtaWx5XS5qb2luKCcgJyk7XHJcblxyXG4gICAgICAgICAgICAgIGMgPSBzdHJva2UuX3JlbmRlcmVyLm9mZnNldC54IC8gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS54O1xyXG4gICAgICAgICAgICAgIGQgPSBzdHJva2UuX3JlbmRlcmVyLm9mZnNldC55IC8gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS55O1xyXG4gICAgICAgICAgICAgIGUgPSBsaW5ld2lkdGggLyBzdHJva2UuX3JlbmRlcmVyLnNjYWxlLng7XHJcblxyXG4gICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBlO1xyXG4gICAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KHRoaXMudmFsdWUsIGMsIGQpO1xyXG4gICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcblxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KHRoaXMudmFsdWUsIDAsIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWRlZmF1bHRNYXRyaXgpIHtcclxuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUT0RPOiBUZXN0IGZvciB0ZXh0XHJcbiAgICAgICAgaWYgKGNsaXAgJiYgIXBhcmVudENsaXBwZWQpIHtcclxuICAgICAgICAgIGN0eC5jbGlwKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGFzaGVzICYmIGRhc2hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjdHguc2V0TGluZURhc2goZW1wdHlBcnJheSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5mbGFnUmVzZXQoKTtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgICdsaW5lYXItZ3JhZGllbnQnOiB7XHJcblxyXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xyXG5cclxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlci5lZmZlY3QgfHwgdGhpcy5fZmxhZ0VuZFBvaW50cyB8fCB0aGlzLl9mbGFnU3RvcHMpIHtcclxuXHJcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lZmZlY3QgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoXHJcbiAgICAgICAgICAgIHRoaXMubGVmdC5feCwgdGhpcy5sZWZ0Ll95LFxyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0Ll94LCB0aGlzLnJpZ2h0Ll95XHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdG9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc3RvcCA9IHRoaXMuc3RvcHNbaV07XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVmZmVjdC5hZGRDb2xvclN0b3Aoc3RvcC5fb2Zmc2V0LCBzdG9wLl9jb2xvcik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAncmFkaWFsLWdyYWRpZW50Jzoge1xyXG5cclxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIuZWZmZWN0IHx8IHRoaXMuX2ZsYWdDZW50ZXIgfHwgdGhpcy5fZmxhZ0ZvY2FsXHJcbiAgICAgICAgICAgIHx8IHRoaXMuX2ZsYWdSYWRpdXMgfHwgdGhpcy5fZmxhZ1N0b3BzKSB7XHJcblxyXG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWZmZWN0ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KFxyXG4gICAgICAgICAgICB0aGlzLmNlbnRlci5feCwgdGhpcy5jZW50ZXIuX3ksIDAsXHJcbiAgICAgICAgICAgIHRoaXMuZm9jYWwuX3gsIHRoaXMuZm9jYWwuX3ksIHRoaXMuX3JhZGl1c1xyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHN0b3AgPSB0aGlzLnN0b3BzW2ldO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lZmZlY3QuYWRkQ29sb3JTdG9wKHN0b3AuX29mZnNldCwgc3RvcC5fY29sb3IpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xyXG5cclxuICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgdGV4dHVyZToge1xyXG5cclxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcblxyXG4gICAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XHJcbiAgICAgICAgdmFyIHJlcGVhdDtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlci5lZmZlY3QgfHwgKCh0aGlzLl9mbGFnTG9hZGVkIHx8IHRoaXMuX2ZsYWdJbWFnZSB8fCB0aGlzLl9mbGFnVmlkZW8gfHwgdGhpcy5fZmxhZ1JlcGVhdCkgJiYgdGhpcy5sb2FkZWQpKSB7XHJcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lZmZlY3QgPSBjdHguY3JlYXRlUGF0dGVybih0aGlzLmltYWdlLCB0aGlzLl9yZXBlYXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdPZmZzZXQgfHwgdGhpcy5fZmxhZ0xvYWRlZCB8fCB0aGlzLl9mbGFnU2NhbGUpIHtcclxuXHJcbiAgICAgICAgICBpZiAoISh0aGlzLl9yZW5kZXJlci5vZmZzZXQgaW5zdGFuY2VvZiBUd28uVmVjdG9yKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5vZmZzZXQgPSBuZXcgVHdvLlZlY3RvcigpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC54ID0gLSB0aGlzLl9vZmZzZXQueDtcclxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC55ID0gLSB0aGlzLl9vZmZzZXQueTtcclxuXHJcbiAgICAgICAgICBpZiAoaW1hZ2UpIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC54ICs9IGltYWdlLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0LnkgKz0gaW1hZ2UuaGVpZ2h0IC8gMjtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2FsZSBpbnN0YW5jZW9mIFR3by5WZWN0b3IpIHtcclxuICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5vZmZzZXQueCAqPSB0aGlzLl9zY2FsZS54O1xyXG4gICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC55ICo9IHRoaXMuX3NjYWxlLnk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0LnggKj0gdGhpcy5fc2NhbGU7XHJcbiAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0LnkgKj0gdGhpcy5fc2NhbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fZmxhZ1NjYWxlIHx8IHRoaXMuX2ZsYWdMb2FkZWQpIHtcclxuXHJcbiAgICAgICAgICBpZiAoISh0aGlzLl9yZW5kZXJlci5zY2FsZSBpbnN0YW5jZW9mIFR3by5WZWN0b3IpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlID0gbmV3IFR3by5WZWN0b3IoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5fc2NhbGUgaW5zdGFuY2VvZiBUd28uVmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLmNvcHkodGhpcy5fc2NhbGUpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUuc2V0KHRoaXMuX3NjYWxlLCB0aGlzLl9zY2FsZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICByZW5kZXJTdmdBcmNDb21tYW5kOiBmdW5jdGlvbihjdHgsIGF4LCBheSwgcngsIHJ5LCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeEF4aXNSb3RhdGlvbiwgeCwgeSkge1xyXG5cclxuICAgICAgeEF4aXNSb3RhdGlvbiA9IHhBeGlzUm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xyXG5cclxuICAgICAgLy8gRW5zdXJlIHJhZGlpIGFyZSBwb3NpdGl2ZVxyXG4gICAgICByeCA9IGFicyhyeCk7XHJcbiAgICAgIHJ5ID0gYWJzKHJ5KTtcclxuXHJcbiAgICAgIC8vIENvbXB1dGUgKHgx4oCyLCB5MeKAsilcclxuICAgICAgdmFyIGR4MiA9IChheCAtIHgpIC8gMi4wO1xyXG4gICAgICB2YXIgZHkyID0gKGF5IC0geSkgLyAyLjA7XHJcbiAgICAgIHZhciB4MXAgPSBjb3MoeEF4aXNSb3RhdGlvbikgKiBkeDIgKyBzaW4oeEF4aXNSb3RhdGlvbikgKiBkeTI7XHJcbiAgICAgIHZhciB5MXAgPSAtIHNpbih4QXhpc1JvdGF0aW9uKSAqIGR4MiArIGNvcyh4QXhpc1JvdGF0aW9uKSAqIGR5MjtcclxuXHJcbiAgICAgIC8vIENvbXB1dGUgKGN44oCyLCBjeeKAsilcclxuICAgICAgdmFyIHJ4cyA9IHJ4ICogcng7XHJcbiAgICAgIHZhciByeXMgPSByeSAqIHJ5O1xyXG4gICAgICB2YXIgeDFwcyA9IHgxcCAqIHgxcDtcclxuICAgICAgdmFyIHkxcHMgPSB5MXAgKiB5MXA7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgcmFkaWkgYXJlIGxhcmdlIGVub3VnaFxyXG4gICAgICB2YXIgY3IgPSB4MXBzIC8gcnhzICsgeTFwcyAvIHJ5cztcclxuXHJcbiAgICAgIGlmIChjciA+IDEpIHtcclxuXHJcbiAgICAgICAgLy8gc2NhbGUgdXAgcngscnkgZXF1YWxseSBzbyBjciA9PSAxXHJcbiAgICAgICAgdmFyIHMgPSBzcXJ0KGNyKTtcclxuICAgICAgICByeCA9IHMgKiByeDtcclxuICAgICAgICByeSA9IHMgKiByeTtcclxuICAgICAgICByeHMgPSByeCAqIHJ4O1xyXG4gICAgICAgIHJ5cyA9IHJ5ICogcnk7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZHEgPSAocnhzICogeTFwcyArIHJ5cyAqIHgxcHMpO1xyXG4gICAgICB2YXIgcHEgPSAocnhzICogcnlzIC0gZHEpIC8gZHE7XHJcbiAgICAgIHZhciBxID0gc3FydChtYXgoMCwgcHEpKTtcclxuICAgICAgaWYgKGxhcmdlQXJjRmxhZyA9PT0gc3dlZXBGbGFnKSBxID0gLSBxO1xyXG4gICAgICB2YXIgY3hwID0gcSAqIHJ4ICogeTFwIC8gcnk7XHJcbiAgICAgIHZhciBjeXAgPSAtIHEgKiByeSAqIHgxcCAvIHJ4O1xyXG5cclxuICAgICAgLy8gU3RlcCAzOiBDb21wdXRlIChjeCwgY3kpIGZyb20gKGN44oCyLCBjeeKAsilcclxuICAgICAgdmFyIGN4ID0gY29zKHhBeGlzUm90YXRpb24pICogY3hwXHJcbiAgICAgICAgLSBzaW4oeEF4aXNSb3RhdGlvbikgKiBjeXAgKyAoYXggKyB4KSAvIDI7XHJcbiAgICAgIHZhciBjeSA9IHNpbih4QXhpc1JvdGF0aW9uKSAqIGN4cFxyXG4gICAgICAgICsgY29zKHhBeGlzUm90YXRpb24pICogY3lwICsgKGF5ICsgeSkgLyAyO1xyXG5cclxuICAgICAgLy8gU3RlcCA0OiBDb21wdXRlIM64MSBhbmQgzpTOuFxyXG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IHN2Z0FuZ2xlKDEsIDAsICh4MXAgLSBjeHApIC8gcngsICh5MXAgLSBjeXApIC8gcnkpO1xyXG4gICAgICB2YXIgZGVsdGEgPSBzdmdBbmdsZSgoeDFwIC0gY3hwKSAvIHJ4LCAoeTFwIC0gY3lwKSAvIHJ5LFxyXG4gICAgICAgICgtIHgxcCAtIGN4cCkgLyByeCwgKC0geTFwIC0gY3lwKSAvIHJ5KSAlIFRXT19QSTtcclxuXHJcbiAgICAgIHZhciBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBkZWx0YTtcclxuXHJcbiAgICAgIHZhciBjbG9ja3dpc2UgPSBzd2VlcEZsYWcgPT09IDA7XHJcblxyXG4gICAgICByZW5kZXJBcmNFc3RpbWF0ZShjdHgsIGN4LCBjeSwgcngsIHJ5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSxcclxuICAgICAgICBjbG9ja3dpc2UsIHhBeGlzUm90YXRpb24pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQG5hbWUgVHdvLkNhbnZhc1JlbmRlcmVyXHJcbiAgICogQGNsYXNzXHJcbiAgICogQGV4dGVuZHMgVHdvLlV0aWxzLkV2ZW50c1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1ldGVyc10gLSBUaGlzIG9iamVjdCBpcyBpbmhlcml0ZWQgd2hlbiBjb25zdHJ1Y3RpbmcgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3b30uXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBbcGFyYW1ldGVycy5kb21FbGVtZW50XSAtIFRoZSBgPGNhbnZhcyAvPmAgdG8gZHJhdyB0by4gSWYgbm9uZSBnaXZlbiBhIG5ldyBvbmUgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbWV0ZXJzLm92ZXJkcmF3XSAtIERldGVybWluZXMgd2hldGhlciB0aGUgY2FudmFzIHNob3VsZCBjbGVhciB0aGUgYmFja2dyb3VuZCBvciBub3QuIERlZmF1bHRzIHRvIGB0cnVlYC5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbWV0ZXJzLnNtb290aGluZz10cnVlXSAtIERldGVybWluZXMgd2hldGhlciB0aGUgY2FudmFzIHNob3VsZCBhbnRpYWxpYXMgZHJhd2luZy4gU2V0IGl0IHRvIGBmYWxzZWAgd2hlbiB3b3JraW5nIHdpdGggcGl4ZWwgYXJ0LiBgZmFsc2VgIGNhbiBsZWFkIHRvIGJldHRlciBwZXJmb3JtYW5jZSwgc2luY2UgaXQgd291bGQgdXNlIGEgY2hlYXBlciBpbnRlcnBvbGF0aW9uIGFsZ29yaXRobS5cclxuICAgKiBAZGVzY3JpcHRpb24gVGhpcyBjbGFzcyBpcyB1c2VkIGJ5IHtAbGluayBUd299IHdoZW4gY29uc3RydWN0aW5nIHdpdGggYHR5cGVgIG9mIGBUd28uVHlwZXMuY2FudmFzYC4gSXQgdGFrZXMgVHdvLmpzJyBzY2VuZWdyYXBoIGFuZCByZW5kZXJzIGl0IHRvIGEgYDxjYW52YXMgLz5gLlxyXG4gICAqL1xyXG4gIHZhciBSZW5kZXJlciA9IFR3b1tUd28uVHlwZXMuY2FudmFzXSA9IGZ1bmN0aW9uKHBhcmFtcykge1xyXG5cclxuICAgIC8vIEl0IG1pZ2h0IG5vdCBtYWtlIGEgYmlnIGRpZmZlcmVuY2Ugb24gR1BVIGJhY2tlZCBjYW52YXNlcy5cclxuICAgIHZhciBzbW9vdGhpbmcgPSAocGFyYW1zLnNtb290aGluZyAhPT0gZmFsc2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkNhbnZhc1JlbmRlcmVyI2RvbUVsZW1lbnRcclxuICAgICAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gLSBUaGUgYDxjYW52YXMgLz5gIGFzc29jaWF0ZWQgd2l0aCB0aGUgVHdvLmpzIHNjZW5lLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBwYXJhbXMuZG9tRWxlbWVudCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5DYW52YXNSZW5kZXJlciNjdHhcclxuICAgICAqIEBwcm9wZXJ0eSB7Q2FudmFzMkRDb250ZXh0fSAtIEFzc29jaWF0ZWQgdHdvIGRpbWVuc2lvbmFsIGNvbnRleHQgdG8gcmVuZGVyIG9uIHRoZSBgPGNhbnZhcyAvPmAuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3R4ID0gdGhpcy5kb21FbGVtZW50LmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uQ2FudmFzUmVuZGVyZXIjb3ZlcmRyYXdcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNhbnZhcyBjbGVhcnMgdGhlIGJhY2tncm91bmQgZWFjaCBkcmF3IGNhbGwuXHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKi9cclxuICAgIHRoaXMub3ZlcmRyYXcgPSBwYXJhbXMub3ZlcmRyYXcgfHwgZmFsc2U7XHJcblxyXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHRoaXMuY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCkpIHtcclxuICAgICAgdGhpcy5jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gc21vb3RoaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkNhbnZhc1JlbmRlcmVyI3NjZW5lXHJcbiAgICAgKiBAcHJvcGVydHkge1R3by5Hcm91cH0gLSBUaGUgcm9vdCBncm91cCBvZiB0aGUgc2NlbmVncmFwaC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zY2VuZSA9IG5ldyBUd28uR3JvdXAoKTtcclxuICAgIHRoaXMuc2NlbmUucGFyZW50ID0gdGhpcztcclxuICB9O1xyXG5cclxuXHJcbiAgXy5leHRlbmQoUmVuZGVyZXIsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5DYW52YXNSZW5kZXJlci5VdGlsc1xyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IC0gQSBtYXNzaXZlIG9iamVjdCBmaWxsZWQgd2l0aCB1dGlsaXR5IGZ1bmN0aW9ucyBhbmQgcHJvcGVydGllcyB0byByZW5kZXIgVHdvLmpzIG9iamVjdHMgdG8gYSBgPGNhbnZhcyAvPmAuXHJcbiAgICAgKi9cclxuICAgIFV0aWxzOiBjYW52YXNcclxuXHJcbiAgfSk7XHJcblxyXG4gIF8uZXh0ZW5kKFJlbmRlcmVyLnByb3RvdHlwZSwgVHdvLlV0aWxzLkV2ZW50cywge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBSZW5kZXJlcixcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5DYW52YXNSZW5kZXJlciNzZXRTaXplXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSBuZXcgd2lkdGggb2YgdGhlIHJlbmRlcmVyLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSByZW5kZXJlci5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmF0aW9dIC0gVGhlIG5ldyBwaXhlbCByYXRpbyAocGl4ZWwgZGVuc2l0eSkgb2YgdGhlIHJlbmRlcmVyLiBEZWZhdWx0cyB0byBjYWxjdWxhdGUgdGhlIHBpeGVsIGRlbnNpdHkgb2YgdGhlIHVzZXIncyBzY3JlZW4uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2hhbmdlIHRoZSBzaXplIG9mIHRoZSByZW5kZXJlci5cclxuICAgICAqIEBub3RhLWJlbmUgVHJpZ2dlcnMgYSBgVHdvLkV2ZW50cy5yZXNpemVgLlxyXG4gICAgICovXHJcbiAgICBzZXRTaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCByYXRpbykge1xyXG5cclxuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgIHRoaXMucmF0aW8gPSBfLmlzVW5kZWZpbmVkKHJhdGlvKSA/IGdldFJhdGlvKHRoaXMuY3R4KSA6IHJhdGlvO1xyXG5cclxuICAgICAgdGhpcy5kb21FbGVtZW50LndpZHRoID0gd2lkdGggKiB0aGlzLnJhdGlvO1xyXG4gICAgICB0aGlzLmRvbUVsZW1lbnQuaGVpZ2h0ID0gaGVpZ2h0ICogdGhpcy5yYXRpbztcclxuXHJcbiAgICAgIGlmICh0aGlzLmRvbUVsZW1lbnQuc3R5bGUpIHtcclxuICAgICAgICBfLmV4dGVuZCh0aGlzLmRvbUVsZW1lbnQuc3R5bGUsIHtcclxuICAgICAgICAgIHdpZHRoOiB3aWR0aCArICdweCcsXHJcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCArICdweCdcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLnJlc2l6ZSwgd2lkdGgsIGhlaWdodCwgcmF0aW8pO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uQ2FudmFzUmVuZGVyZXIjcmVuZGVyXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW5kZXIgdGhlIGN1cnJlbnQgc2NlbmUgdG8gdGhlIGA8Y2FudmFzIC8+YC5cclxuICAgICAqL1xyXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHZhciBpc09uZSA9IHRoaXMucmF0aW8gPT09IDE7XHJcblxyXG4gICAgICBpZiAoIWlzT25lKSB7XHJcbiAgICAgICAgdGhpcy5jdHguc2F2ZSgpO1xyXG4gICAgICAgIHRoaXMuY3R4LnNjYWxlKHRoaXMucmF0aW8sIHRoaXMucmF0aW8pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXRoaXMub3ZlcmRyYXcpIHtcclxuICAgICAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjYW52YXMuZ3JvdXAucmVuZGVyLmNhbGwodGhpcy5zY2VuZSwgdGhpcy5jdHgpO1xyXG5cclxuICAgICAgaWYgKCFpc09uZSkge1xyXG4gICAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbiAgZnVuY3Rpb24gcmVuZGVyQXJjRXN0aW1hdGUoY3R4LCBveCwgb3ksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZSwgeEF4aXNSb3RhdGlvbikge1xyXG5cclxuICAgIHZhciBlcHNpbG9uID0gVHdvLlV0aWxzLkN1cnZlLlRvbGVyYW5jZS5lcHNpbG9uO1xyXG4gICAgdmFyIGRlbHRhQW5nbGUgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XHJcbiAgICB2YXIgc2FtZVBvaW50cyA9IE1hdGguYWJzKGRlbHRhQW5nbGUpIDwgZXBzaWxvbjtcclxuXHJcbiAgICAvLyBlbnN1cmVzIHRoYXQgZGVsdGFBbmdsZSBpcyAwIC4uIDIgUElcclxuICAgIGRlbHRhQW5nbGUgPSBtb2QoZGVsdGFBbmdsZSwgVFdPX1BJKTtcclxuXHJcbiAgICBpZiAoZGVsdGFBbmdsZSA8IGVwc2lsb24pIHtcclxuXHJcbiAgICAgIGlmIChzYW1lUG9pbnRzKSB7XHJcblxyXG4gICAgICAgIGRlbHRhQW5nbGUgPSAwO1xyXG5cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgZGVsdGFBbmdsZSA9IFRXT19QSTtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNsb2Nrd2lzZSA9PT0gdHJ1ZSAmJiAhIHNhbWVQb2ludHMpIHtcclxuXHJcbiAgICAgIGlmIChkZWx0YUFuZ2xlID09PSBUV09fUEkpIHtcclxuXHJcbiAgICAgICAgZGVsdGFBbmdsZSA9IC0gVFdPX1BJO1xyXG5cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgZGVsdGFBbmdsZSA9IGRlbHRhQW5nbGUgLSBUV09fUEk7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVHdvLlJlc29sdXRpb247IGkrKykge1xyXG5cclxuICAgICAgdmFyIHQgPSBpIC8gKFR3by5SZXNvbHV0aW9uIC0gMSk7XHJcblxyXG4gICAgICB2YXIgYW5nbGUgPSBzdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XHJcbiAgICAgIHZhciB4ID0gb3ggKyByeCAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgdmFyIHkgPSBveSArIHJ5ICogTWF0aC5zaW4oYW5nbGUpO1xyXG5cclxuICAgICAgaWYgKHhBeGlzUm90YXRpb24gIT09IDApIHtcclxuXHJcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHhBeGlzUm90YXRpb24pO1xyXG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbih4QXhpc1JvdGF0aW9uKTtcclxuXHJcbiAgICAgICAgdmFyIHR4ID0geCAtIG94O1xyXG4gICAgICAgIHZhciB0eSA9IHkgLSBveTtcclxuXHJcbiAgICAgICAgLy8gUm90YXRlIHRoZSBwb2ludCBhYm91dCB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxyXG4gICAgICAgIHggPSB0eCAqIGNvcyAtIHR5ICogc2luICsgb3g7XHJcbiAgICAgICAgeSA9IHR4ICogc2luICsgdHkgKiBjb3MgKyBveTtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XHJcblxyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHN2Z0FuZ2xlKHV4LCB1eSwgdngsIHZ5KSB7XHJcblxyXG4gICAgdmFyIGRvdCA9IHV4ICogdnggKyB1eSAqIHZ5O1xyXG4gICAgdmFyIGxlbiA9IHNxcnQodXggKiB1eCArIHV5ICogdXkpICogIHNxcnQodnggKiB2eCArIHZ5ICogdnkpO1xyXG4gICAgLy8gZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uLCBzbGlnaHRseSBvdmVyIHZhbHVlcyBhcHBlYXJcclxuICAgIHZhciBhbmcgPSBhY29zKG1heCgtMSwgbWluKDEsIGRvdCAvIGxlbikpKTtcclxuICAgIGlmICgodXggKiB2eSAtIHV5ICogdngpIDwgMCkge1xyXG4gICAgICBhbmcgPSAtIGFuZztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYW5nO1xyXG5cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlc2V0VHJhbnNmb3JtKGN0eCkge1xyXG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcclxuICB9XHJcblxyXG59KSgodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiAodGhpcyB8fCBzZWxmIHx8IHdpbmRvdykpLlR3byk7XHJcblxuKGZ1bmN0aW9uKFR3bykge1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgdmFyIHJvb3QgPSBUd28ucm9vdCxcclxuICAgIG11bHRpcGx5TWF0cml4ID0gVHdvLk1hdHJpeC5NdWx0aXBseSxcclxuICAgIG1vZCA9IFR3by5VdGlscy5tb2QsXHJcbiAgICBpZGVudGl0eSA9IFsxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxXSxcclxuICAgIHRyYW5zZm9ybWF0aW9uID0gbmV3IFR3by5BcnJheSg5KSxcclxuICAgIGdldFJhdGlvID0gVHdvLlV0aWxzLmdldFJhdGlvLFxyXG4gICAgZ2V0Q29tcHV0ZWRNYXRyaXggPSBUd28uVXRpbHMuZ2V0Q29tcHV0ZWRNYXRyaXgsXHJcbiAgICBDYW52YXNVdGlscyA9IFR3b1tUd28uVHlwZXMuY2FudmFzXS5VdGlscyxcclxuICAgIF8gPSBUd28uVXRpbHM7XHJcblxyXG4gIHZhciB3ZWJnbCA9IHtcclxuXHJcbiAgICBpc0hpZGRlbjogLyh1bmRlZmluZWR8bm9uZXx0cmFuc3BhcmVudCkvaSxcclxuXHJcbiAgICBjYW52YXM6IChyb290LmRvY3VtZW50ID8gcm9vdC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSA6IHsgZ2V0Q29udGV4dDogXy5pZGVudGl0eSB9KSxcclxuXHJcbiAgICBhbGlnbm1lbnRzOiB7XHJcbiAgICAgIGxlZnQ6ICdzdGFydCcsXHJcbiAgICAgIG1pZGRsZTogJ2NlbnRlcicsXHJcbiAgICAgIHJpZ2h0OiAnZW5kJ1xyXG4gICAgfSxcclxuXHJcbiAgICBtYXRyaXg6IG5ldyBUd28uTWF0cml4KCksXHJcblxyXG4gICAgZ3JvdXA6IHtcclxuXHJcbiAgICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbihjaGlsZCwgZ2wpIHtcclxuICAgICAgICBpZiAoY2hpbGQuY2hpbGRyZW4pIHtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgd2ViZ2wuZ3JvdXAucmVtb3ZlQ2hpbGQoY2hpbGQuY2hpbGRyZW5baV0sIGdsKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRGVhbGxvY2F0ZSB0ZXh0dXJlIHRvIGZyZWUgdXAgZ2wgbWVtb3J5LlxyXG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUoY2hpbGQuX3JlbmRlcmVyLnRleHR1cmUpO1xyXG4gICAgICAgIGRlbGV0ZSBjaGlsZC5fcmVuZGVyZXIudGV4dHVyZTtcclxuICAgICAgfSxcclxuXHJcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcclxuXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcblxyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICB2YXIgZmxhZ1BhcmVudE1hdHJpeCA9IChwYXJlbnQuX21hdHJpeCAmJiBwYXJlbnQuX21hdHJpeC5tYW51YWwpIHx8IHBhcmVudC5fZmxhZ01hdHJpeDtcclxuICAgICAgICB2YXIgZmxhZ01hdHJpeCA9IHRoaXMuX21hdHJpeC5tYW51YWwgfHwgdGhpcy5fZmxhZ01hdHJpeDtcclxuXHJcbiAgICAgICAgaWYgKGZsYWdQYXJlbnRNYXRyaXggfHwgZmxhZ01hdHJpeCkge1xyXG5cclxuICAgICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIubWF0cml4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm1hdHJpeCA9IG5ldyBUd28uQXJyYXkoOSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVkdWNlIGFtb3VudCBvZiBvYmplY3QgLyBhcnJheSBjcmVhdGlvbiAvIGRlbGV0aW9uXHJcbiAgICAgICAgICB0aGlzLl9tYXRyaXgudG9UcmFuc2Zvcm1BcnJheSh0cnVlLCB0cmFuc2Zvcm1hdGlvbik7XHJcblxyXG4gICAgICAgICAgbXVsdGlwbHlNYXRyaXgodHJhbnNmb3JtYXRpb24sIHBhcmVudC5fcmVuZGVyZXIubWF0cml4LCB0aGlzLl9yZW5kZXJlci5tYXRyaXgpO1xyXG5cclxuICAgICAgICAgIGlmICghKHRoaXMuX3JlbmRlcmVyLnNjYWxlIGluc3RhbmNlb2YgVHdvLlZlY3RvcikpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUgPSBuZXcgVHdvLlZlY3RvcigpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGlmICh0aGlzLl9zY2FsZSBpbnN0YW5jZW9mIFR3by5WZWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUueCA9IHRoaXMuX3NjYWxlLng7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnkgPSB0aGlzLl9zY2FsZS55O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUueCA9IHRoaXMuX3NjYWxlO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZS55ID0gdGhpcy5fc2NhbGU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKCEoL3JlbmRlcmVyL2kudGVzdChwYXJlbnQuX3JlbmRlcmVyLnR5cGUpKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZS54ICo9IHBhcmVudC5fcmVuZGVyZXIuc2NhbGUueDtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUueSAqPSBwYXJlbnQuX3JlbmRlcmVyLnNjYWxlLnk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKGZsYWdQYXJlbnRNYXRyaXgpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmxhZ01hdHJpeCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX21hc2spIHtcclxuXHJcbiAgICAgICAgICAvLyBTdGVuY2lsIGF3YXkgZXZlcnl0aGluZyB0aGF0IGlzbid0IHJlbmRlcmVkIGJ5IHRoZSBtYXNrXHJcblxyXG4gICAgICAgICAgZ2wuY2xlYXIoZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcclxuICAgICAgICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xyXG5cclxuICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkFMV0FZUywgMSwgMCk7XHJcbiAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuUkVQTEFDRSk7XHJcblxyXG4gICAgICAgICAgd2ViZ2xbdGhpcy5fbWFzay5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwodGhpcy5fbWFzaywgZ2wsIHByb2dyYW0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAxLCAweGZmKTtcclxuICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5LRUVQKTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9mbGFnT3BhY2l0eSA9IHBhcmVudC5fZmxhZ09wYWNpdHkgfHwgdGhpcy5fZmxhZ09wYWNpdHk7XHJcblxyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLm9wYWNpdHkgPSB0aGlzLl9vcGFjaXR5XHJcbiAgICAgICAgICAqIChwYXJlbnQgJiYgcGFyZW50Ll9yZW5kZXJlciA/IHBhcmVudC5fcmVuZGVyZXIub3BhY2l0eSA6IDEpO1xyXG5cclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAodGhpcy5fZmxhZ1N1YnRyYWN0aW9ucykge1xyXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc3VidHJhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHdlYmdsLmdyb3VwLnJlbW92ZUNoaWxkKHRoaXMuc3VidHJhY3Rpb25zW2ldLCBnbCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcclxuICAgICAgICAgIHdlYmdsW2NoaWxkLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChjaGlsZCwgZ2wsIHByb2dyYW0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX21hc2spIHtcclxuICAgICAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xyXG5cclxuICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgcGF0aDoge1xyXG5cclxuICAgICAgdXBkYXRlQ2FudmFzOiBmdW5jdGlvbihlbGVtKSB7XHJcblxyXG4gICAgICAgIHZhciBuZXh0LCBwcmV2LCBhLCBjLCB1eCwgdXksIHZ4LCB2eSwgYXIsIGJsLCBiciwgY2wsIHgsIHk7XHJcbiAgICAgICAgdmFyIGlzT2Zmc2V0O1xyXG5cclxuICAgICAgICB2YXIgY29tbWFuZHMgPSBlbGVtLl9yZW5kZXJlci52ZXJ0aWNlcztcclxuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XHJcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xyXG5cclxuICAgICAgICAvLyBTdHlsZXNcclxuICAgICAgICB2YXIgc2NhbGUgPSBlbGVtLl9yZW5kZXJlci5zY2FsZTtcclxuICAgICAgICB2YXIgc3Ryb2tlID0gZWxlbS5fc3Ryb2tlO1xyXG4gICAgICAgIHZhciBsaW5ld2lkdGggPSBlbGVtLl9saW5ld2lkdGg7XHJcbiAgICAgICAgdmFyIGZpbGwgPSBlbGVtLl9maWxsO1xyXG4gICAgICAgIHZhciBvcGFjaXR5ID0gZWxlbS5fcmVuZGVyZXIub3BhY2l0eSB8fCBlbGVtLl9vcGFjaXR5O1xyXG4gICAgICAgIHZhciBjYXAgPSBlbGVtLl9jYXA7XHJcbiAgICAgICAgdmFyIGpvaW4gPSBlbGVtLl9qb2luO1xyXG4gICAgICAgIHZhciBtaXRlciA9IGVsZW0uX21pdGVyO1xyXG4gICAgICAgIHZhciBjbG9zZWQgPSBlbGVtLl9jbG9zZWQ7XHJcbiAgICAgICAgdmFyIGRhc2hlcyA9IGVsZW0uZGFzaGVzO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBjb21tYW5kcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGxhc3QgPSBsZW5ndGggLSAxO1xyXG5cclxuICAgICAgICBjYW52YXMud2lkdGggPSBNYXRoLm1heChNYXRoLmNlaWwoZWxlbS5fcmVuZGVyZXIucmVjdC53aWR0aCAqIHNjYWxlLngpLCAxKTtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5jZWlsKGVsZW0uX3JlbmRlcmVyLnJlY3QuaGVpZ2h0ICogc2NhbGUueSksIDEpO1xyXG5cclxuICAgICAgICB2YXIgY2VudHJvaWQgPSBlbGVtLl9yZW5kZXJlci5yZWN0LmNlbnRyb2lkO1xyXG4gICAgICAgIHZhciBjeCA9IGNlbnRyb2lkLng7XHJcbiAgICAgICAgdmFyIGN5ID0gY2VudHJvaWQueTtcclxuXHJcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICBpZiAoZmlsbCkge1xyXG4gICAgICAgICAgaWYgKF8uaXNTdHJpbmcoZmlsbCkpIHtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGw7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB3ZWJnbFtmaWxsLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChmaWxsLCBjdHgsIGVsZW0pO1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbC5fcmVuZGVyZXIuZWZmZWN0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3Ryb2tlKSB7XHJcbiAgICAgICAgICBpZiAoXy5pc1N0cmluZyhzdHJva2UpKSB7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHdlYmdsW3N0cm9rZS5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwoc3Ryb2tlLCBjdHgsIGVsZW0pO1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2UuX3JlbmRlcmVyLmVmZmVjdDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChsaW5ld2lkdGgpIHtcclxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmV3aWR0aDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmIChtaXRlcikge1xyXG4gICAgICAgICAgICBjdHgubWl0ZXJMaW1pdCA9IG1pdGVyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGpvaW4pIHtcclxuICAgICAgICAgICAgY3R4LmxpbmVKb2luID0gam9pbjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICghY2xvc2VkICYmIGNhcCkge1xyXG4gICAgICAgICAgICBjdHgubGluZUNhcCA9IGNhcDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF8uaXNOdW1iZXIob3BhY2l0eSkpIHtcclxuICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZGFzaGVzICYmIGRhc2hlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoZXMub2Zmc2V0IHx8IDA7XHJcbiAgICAgICAgICBjdHguc2V0TGluZURhc2goZGFzaGVzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBkO1xyXG4gICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlLngsIHNjYWxlLnkpO1xyXG5cclxuICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XHJcblxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgdmFyIGIgPSBjb21tYW5kc1tpXTtcclxuXHJcbiAgICAgICAgICB4ID0gYi54O1xyXG4gICAgICAgICAgeSA9IGIueTtcclxuXHJcbiAgICAgICAgICBzd2l0Y2ggKGIuY29tbWFuZCkge1xyXG5cclxuICAgICAgICAgICAgY2FzZSBUd28uQ29tbWFuZHMuY2xvc2U6XHJcbiAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBUd28uQ29tbWFuZHMuYXJjOlxyXG5cclxuICAgICAgICAgICAgICB2YXIgcnggPSBiLnJ4O1xyXG4gICAgICAgICAgICAgIHZhciByeSA9IGIucnk7XHJcbiAgICAgICAgICAgICAgdmFyIHhBeGlzUm90YXRpb24gPSBiLnhBeGlzUm90YXRpb247XHJcbiAgICAgICAgICAgICAgdmFyIGxhcmdlQXJjRmxhZyA9IGIubGFyZ2VBcmNGbGFnO1xyXG4gICAgICAgICAgICAgIHZhciBzd2VlcEZsYWcgPSBiLnN3ZWVwRmxhZztcclxuXHJcbiAgICAgICAgICAgICAgcHJldiA9IGNsb3NlZCA/IG1vZChpIC0gMSwgbGVuZ3RoKSA6IE1hdGgubWF4KGkgLSAxLCAwKTtcclxuICAgICAgICAgICAgICBhID0gY29tbWFuZHNbcHJldl07XHJcblxyXG4gICAgICAgICAgICAgIHZhciBheCA9IGEueDtcclxuICAgICAgICAgICAgICB2YXIgYXkgPSBhLnk7XHJcblxyXG4gICAgICAgICAgICAgIENhbnZhc1V0aWxzLnJlbmRlclN2Z0FyY0NvbW1hbmQoY3R4LCBheCwgYXksIHJ4LCByeSwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHhBeGlzUm90YXRpb24sIHgsIHkpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBUd28uQ29tbWFuZHMuY3VydmU6XHJcblxyXG4gICAgICAgICAgICAgIHByZXYgPSBjbG9zZWQgPyBtb2QoaSAtIDEsIGxlbmd0aCkgOiBNYXRoLm1heChpIC0gMSwgMCk7XHJcbiAgICAgICAgICAgICAgbmV4dCA9IGNsb3NlZCA/IG1vZChpICsgMSwgbGVuZ3RoKSA6IE1hdGgubWluKGkgKyAxLCBsYXN0KTtcclxuXHJcbiAgICAgICAgICAgICAgYSA9IGNvbW1hbmRzW3ByZXZdO1xyXG4gICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tuZXh0XTtcclxuICAgICAgICAgICAgICBhciA9IChhLmNvbnRyb2xzICYmIGEuY29udHJvbHMucmlnaHQpIHx8IFR3by5WZWN0b3IuemVybztcclxuICAgICAgICAgICAgICBibCA9IChiLmNvbnRyb2xzICYmIGIuY29udHJvbHMubGVmdCkgfHwgVHdvLlZlY3Rvci56ZXJvO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoYS5fcmVsYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIHZ4ID0gYXIueCArIGEueDtcclxuICAgICAgICAgICAgICAgIHZ5ID0gYXIueSArIGEueTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdnggPSBhci54O1xyXG4gICAgICAgICAgICAgICAgdnkgPSBhci55O1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKGIuX3JlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB1eCA9IGJsLnggKyBiLng7XHJcbiAgICAgICAgICAgICAgICB1eSA9IGJsLnkgKyBiLnk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHV4ID0gYmwueDtcclxuICAgICAgICAgICAgICAgIHV5ID0gYmwueTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHZ4LCB2eSwgdXgsIHV5LCB4LCB5KTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGkgPj0gbGFzdCAmJiBjbG9zZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjID0gZDtcclxuXHJcbiAgICAgICAgICAgICAgICBiciA9IChiLmNvbnRyb2xzICYmIGIuY29udHJvbHMucmlnaHQpIHx8IFR3by5WZWN0b3IuemVybztcclxuICAgICAgICAgICAgICAgIGNsID0gKGMuY29udHJvbHMgJiYgYy5jb250cm9scy5sZWZ0KSB8fCBUd28uVmVjdG9yLnplcm87XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGIuX3JlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgIHZ4ID0gYnIueCArIGIueDtcclxuICAgICAgICAgICAgICAgICAgdnkgPSBici55ICsgYi55O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgdnggPSBici54O1xyXG4gICAgICAgICAgICAgICAgICB2eSA9IGJyLnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGMuX3JlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgIHV4ID0gY2wueCArIGMueDtcclxuICAgICAgICAgICAgICAgICAgdXkgPSBjbC55ICsgYy55O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgdXggPSBjbC54O1xyXG4gICAgICAgICAgICAgICAgICB1eSA9IGNsLnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgeCA9IGMueDtcclxuICAgICAgICAgICAgICAgIHkgPSBjLnk7XHJcblxyXG4gICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8odngsIHZ5LCB1eCwgdXksIHgsIHkpO1xyXG5cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBUd28uQ29tbWFuZHMubGluZTpcclxuICAgICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBUd28uQ29tbWFuZHMubW92ZTpcclxuICAgICAgICAgICAgICBkID0gYjtcclxuICAgICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBMb29zZSBlbmRzXHJcblxyXG4gICAgICAgIGlmIChjbG9zZWQpIHtcclxuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghd2ViZ2wuaXNIaWRkZW4udGVzdChmaWxsKSkge1xyXG4gICAgICAgICAgaXNPZmZzZXQgPSBmaWxsLl9yZW5kZXJlciAmJiBmaWxsLl9yZW5kZXJlci5vZmZzZXQ7XHJcbiAgICAgICAgICBpZiAoaXNPZmZzZXQpIHtcclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShcclxuICAgICAgICAgICAgICAtIGZpbGwuX3JlbmRlcmVyLm9mZnNldC54LCAtIGZpbGwuX3JlbmRlcmVyLm9mZnNldC55KTtcclxuICAgICAgICAgICAgY3R4LnNjYWxlKGZpbGwuX3JlbmRlcmVyLnNjYWxlLngsIGZpbGwuX3JlbmRlcmVyLnNjYWxlLnkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgIGlmIChpc09mZnNldCkge1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF3ZWJnbC5pc0hpZGRlbi50ZXN0KHN0cm9rZSkpIHtcclxuICAgICAgICAgIGlzT2Zmc2V0ID0gc3Ryb2tlLl9yZW5kZXJlciAmJiBzdHJva2UuX3JlbmRlcmVyLm9mZnNldDtcclxuICAgICAgICAgIGlmIChpc09mZnNldCkge1xyXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKFxyXG4gICAgICAgICAgICAgIC0gc3Ryb2tlLl9yZW5kZXJlci5vZmZzZXQueCwgLSBzdHJva2UuX3JlbmRlcmVyLm9mZnNldC55KTtcclxuICAgICAgICAgICAgY3R4LnNjYWxlKHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueCwgc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS55KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmV3aWR0aCAvIHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgIGlmIChpc09mZnNldCkge1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogUmV0dXJucyB0aGUgcmVjdCBvZiBhIHNldCBvZiB2ZXJ0cy4gVHlwaWNhbGx5IHRha2VzIHZlcnRpY2VzIHRoYXQgYXJlXHJcbiAgICAgICAqIFwiY2VudGVyZWRcIiBhcm91bmQgMCBhbmQgcmV0dXJucyB0aGVtIHRvIGJlIGFuY2hvcmVkIHVwcGVyLWxlZnQuXHJcbiAgICAgICAqL1xyXG4gICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IGZ1bmN0aW9uKHZlcnRpY2VzLCBib3JkZXIsIHJlY3QpIHtcclxuXHJcbiAgICAgICAgdmFyIGxlZnQgPSBJbmZpbml0eSwgcmlnaHQgPSAtSW5maW5pdHksXHJcbiAgICAgICAgICAgIHRvcCA9IEluZmluaXR5LCBib3R0b20gPSAtSW5maW5pdHksXHJcbiAgICAgICAgICAgIHdpZHRoLCBoZWlnaHQ7XHJcblxyXG4gICAgICAgIHZlcnRpY2VzLmZvckVhY2goZnVuY3Rpb24odikge1xyXG5cclxuICAgICAgICAgIHZhciB4ID0gdi54LCB5ID0gdi55LCBjb250cm9scyA9IHYuY29udHJvbHM7XHJcbiAgICAgICAgICB2YXIgYSwgYiwgYywgZCwgY2wsIGNyO1xyXG5cclxuICAgICAgICAgIHRvcCA9IE1hdGgubWluKHksIHRvcCk7XHJcbiAgICAgICAgICBsZWZ0ID0gTWF0aC5taW4oeCwgbGVmdCk7XHJcbiAgICAgICAgICByaWdodCA9IE1hdGgubWF4KHgsIHJpZ2h0KTtcclxuICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KHksIGJvdHRvbSk7XHJcblxyXG4gICAgICAgICAgaWYgKCF2LmNvbnRyb2xzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBjbCA9IGNvbnRyb2xzLmxlZnQ7XHJcbiAgICAgICAgICBjciA9IGNvbnRyb2xzLnJpZ2h0O1xyXG5cclxuICAgICAgICAgIGlmICghY2wgfHwgIWNyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBhID0gdi5fcmVsYXRpdmUgPyBjbC54ICsgeCA6IGNsLng7XHJcbiAgICAgICAgICBiID0gdi5fcmVsYXRpdmUgPyBjbC55ICsgeSA6IGNsLnk7XHJcbiAgICAgICAgICBjID0gdi5fcmVsYXRpdmUgPyBjci54ICsgeCA6IGNyLng7XHJcbiAgICAgICAgICBkID0gdi5fcmVsYXRpdmUgPyBjci55ICsgeSA6IGNyLnk7XHJcblxyXG4gICAgICAgICAgaWYgKCFhIHx8ICFiIHx8ICFjIHx8ICFkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0b3AgPSBNYXRoLm1pbihiLCBkLCB0b3ApO1xyXG4gICAgICAgICAgbGVmdCA9IE1hdGgubWluKGEsIGMsIGxlZnQpO1xyXG4gICAgICAgICAgcmlnaHQgPSBNYXRoLm1heChhLCBjLCByaWdodCk7XHJcbiAgICAgICAgICBib3R0b20gPSBNYXRoLm1heChiLCBkLCBib3R0b20pO1xyXG5cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gRXhwYW5kIGJvcmRlcnNcclxuXHJcbiAgICAgICAgaWYgKF8uaXNOdW1iZXIoYm9yZGVyKSkge1xyXG4gICAgICAgICAgdG9wIC09IGJvcmRlcjtcclxuICAgICAgICAgIGxlZnQgLT0gYm9yZGVyO1xyXG4gICAgICAgICAgcmlnaHQgKz0gYm9yZGVyO1xyXG4gICAgICAgICAgYm90dG9tICs9IGJvcmRlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xyXG4gICAgICAgIGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcclxuXHJcbiAgICAgICAgcmVjdC50b3AgPSB0b3A7XHJcbiAgICAgICAgcmVjdC5sZWZ0ID0gbGVmdDtcclxuICAgICAgICByZWN0LnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICAgICAgcmVjdC5ib3R0b20gPSBib3R0b207XHJcbiAgICAgICAgcmVjdC53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAoIXJlY3QuY2VudHJvaWQpIHtcclxuICAgICAgICAgIHJlY3QuY2VudHJvaWQgPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlY3QuY2VudHJvaWQueCA9IC0gbGVmdDtcclxuICAgICAgICByZWN0LmNlbnRyb2lkLnkgPSAtIHRvcDtcclxuXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCBmb3JjZWRQYXJlbnQpIHtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl92aXNpYmxlIHx8ICF0aGlzLl9vcGFjaXR5KSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgd2hhdCBjaGFuZ2VkXHJcblxyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICB2YXIgZmxhZ1BhcmVudE1hdHJpeCA9IHBhcmVudC5fbWF0cml4Lm1hbnVhbCB8fCBwYXJlbnQuX2ZsYWdNYXRyaXg7XHJcbiAgICAgICAgdmFyIGZsYWdNYXRyaXggPSB0aGlzLl9tYXRyaXgubWFudWFsIHx8IHRoaXMuX2ZsYWdNYXRyaXg7XHJcbiAgICAgICAgdmFyIGZsYWdUZXh0dXJlID0gdGhpcy5fZmxhZ1ZlcnRpY2VzIHx8IHRoaXMuX2ZsYWdGaWxsXHJcbiAgICAgICAgICB8fCAodGhpcy5fZmlsbCBpbnN0YW5jZW9mIFR3by5MaW5lYXJHcmFkaWVudCAmJiAodGhpcy5fZmlsbC5fZmxhZ1NwcmVhZCB8fCB0aGlzLl9maWxsLl9mbGFnU3RvcHMgfHwgdGhpcy5fZmlsbC5fZmxhZ0VuZFBvaW50cykpXHJcbiAgICAgICAgICB8fCAodGhpcy5fZmlsbCBpbnN0YW5jZW9mIFR3by5SYWRpYWxHcmFkaWVudCAmJiAodGhpcy5fZmlsbC5fZmxhZ1NwcmVhZCB8fCB0aGlzLl9maWxsLl9mbGFnU3RvcHMgfHwgdGhpcy5fZmlsbC5fZmxhZ1JhZGl1cyB8fCB0aGlzLl9maWxsLl9mbGFnQ2VudGVyIHx8IHRoaXMuX2ZpbGwuX2ZsYWdGb2NhbCkpXHJcbiAgICAgICAgICB8fCAodGhpcy5fZmlsbCBpbnN0YW5jZW9mIFR3by5UZXh0dXJlICYmICh0aGlzLl9maWxsLl9mbGFnTG9hZGVkICYmIHRoaXMuX2ZpbGwubG9hZGVkIHx8IHRoaXMuX2ZpbGwuX2ZsYWdJbWFnZSB8fCB0aGlzLl9maWxsLl9mbGFnVmlkZW8gfHwgdGhpcy5fZmlsbC5fZmxhZ1JlcGVhdCB8fCB0aGlzLl9maWxsLl9mbGFnT2Zmc2V0IHx8IHRoaXMuX2ZpbGwuX2ZsYWdTY2FsZSkpXHJcbiAgICAgICAgICB8fCAodGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgVHdvLkxpbmVhckdyYWRpZW50ICYmICh0aGlzLl9zdHJva2UuX2ZsYWdTcHJlYWQgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnU3RvcHMgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnRW5kUG9pbnRzKSlcclxuICAgICAgICAgIHx8ICh0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBUd28uUmFkaWFsR3JhZGllbnQgJiYgKHRoaXMuX3N0cm9rZS5fZmxhZ1NwcmVhZCB8fCB0aGlzLl9zdHJva2UuX2ZsYWdTdG9wcyB8fCB0aGlzLl9zdHJva2UuX2ZsYWdSYWRpdXMgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnQ2VudGVyIHx8IHRoaXMuX3N0cm9rZS5fZmxhZ0ZvY2FsKSlcclxuICAgICAgICAgIHx8ICh0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBUd28uVGV4dHVyZSAmJiAodGhpcy5fc3Ryb2tlLl9mbGFnTG9hZGVkICYmIHRoaXMuX3N0cm9rZS5sb2FkZWQgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnSW1hZ2UgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnVmlkZW8gfHwgdGhpcy5fc3Ryb2tlLl9mbGFnUmVwZWF0IHx8IHRoaXMuX3N0cm9rZS5fZmxhZ09mZnNldCB8fCB0aGlzLl9maWxsLl9mbGFnU2NhbGUpKVxyXG4gICAgICAgICAgfHwgdGhpcy5fZmxhZ1N0cm9rZSB8fCB0aGlzLl9mbGFnTGluZXdpZHRoIHx8IHRoaXMuX2ZsYWdPcGFjaXR5XHJcbiAgICAgICAgICB8fCBwYXJlbnQuX2ZsYWdPcGFjaXR5IHx8IHRoaXMuX2ZsYWdWaXNpYmxlIHx8IHRoaXMuX2ZsYWdDYXBcclxuICAgICAgICAgIHx8IHRoaXMuX2ZsYWdKb2luIHx8IHRoaXMuX2ZsYWdNaXRlciB8fCB0aGlzLl9mbGFnU2NhbGVcclxuICAgICAgICAgIHx8ICh0aGlzLmRhc2hlcyAmJiB0aGlzLmRhc2hlcy5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgfHwgIXRoaXMuX3JlbmRlcmVyLnRleHR1cmU7XHJcblxyXG4gICAgICAgIGlmIChmbGFnUGFyZW50TWF0cml4IHx8IGZsYWdNYXRyaXgpIHtcclxuXHJcbiAgICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLm1hdHJpeCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5tYXRyaXggPSBuZXcgVHdvLkFycmF5KDkpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlZHVjZSBhbW91bnQgb2Ygb2JqZWN0IC8gYXJyYXkgY3JlYXRpb24gLyBkZWxldGlvblxyXG5cclxuICAgICAgICAgIHRoaXMuX21hdHJpeC50b1RyYW5zZm9ybUFycmF5KHRydWUsIHRyYW5zZm9ybWF0aW9uKTtcclxuXHJcbiAgICAgICAgICBtdWx0aXBseU1hdHJpeCh0cmFuc2Zvcm1hdGlvbiwgcGFyZW50Ll9yZW5kZXJlci5tYXRyaXgsIHRoaXMuX3JlbmRlcmVyLm1hdHJpeCk7XHJcblxyXG4gICAgICAgICAgaWYgKCEodGhpcy5fcmVuZGVyZXIuc2NhbGUgaW5zdGFuY2VvZiBUd28uVmVjdG9yKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZSA9IG5ldyBUd28uVmVjdG9yKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodGhpcy5fc2NhbGUgaW5zdGFuY2VvZiBUd28uVmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnggPSB0aGlzLl9zY2FsZS54ICogcGFyZW50Ll9yZW5kZXJlci5zY2FsZS54O1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZS55ID0gdGhpcy5fc2NhbGUueSAqIHBhcmVudC5fcmVuZGVyZXIuc2NhbGUueTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnggPSB0aGlzLl9zY2FsZSAqIHBhcmVudC5fcmVuZGVyZXIuc2NhbGUueDtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUueSA9IHRoaXMuX3NjYWxlICogcGFyZW50Ll9yZW5kZXJlci5zY2FsZS55O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChmbGFnVGV4dHVyZSkge1xyXG5cclxuICAgICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIucmVjdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZWN0ID0ge307XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIub3BhY2l0eSA9IHRoaXMuX29wYWNpdHkgKiBwYXJlbnQuX3JlbmRlcmVyLm9wYWNpdHk7XHJcblxyXG4gICAgICAgICAgd2ViZ2wucGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy5fcmVuZGVyZXIudmVydGljZXMsIHRoaXMuX2xpbmV3aWR0aCwgdGhpcy5fcmVuZGVyZXIucmVjdCk7XHJcblxyXG4gICAgICAgICAgd2ViZ2wudXBkYXRlVGV4dHVyZS5jYWxsKHdlYmdsLCBnbCwgdGhpcyk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gV2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgY2hpbGQgVHdvIGVsZW1lbnRzIG9uIHRoZSBmaWxsIGFuZFxyXG4gICAgICAgICAgLy8gc3Ryb2tlIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICBpZiAodGhpcy5fZmlsbCAmJiB0aGlzLl9maWxsLl91cGRhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlsbC5fdXBkYXRlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodGhpcy5fc3Ryb2tlICYmIHRoaXMuX3N0cm9rZS5fdXBkYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZS5fdXBkYXRlKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYgKHRoaXMuX21hc2spIHtcclxuICAgICAgICAvLyAgIHdlYmdsW3RoaXMuX21hc2suX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKG1hc2ssIGdsLCBwcm9ncmFtLCB0aGlzKTtcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9jbGlwICYmICFmb3JjZWRQYXJlbnQpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERyYXcgVGV4dHVyZVxyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3JlbmRlcmVyLnRleHR1cmUpO1xyXG5cclxuICAgICAgICAvLyBEcmF3IFJlY3RcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuX3JlbmRlcmVyLnJlY3Q7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdihwcm9ncmFtLm1hdHJpeCwgZmFsc2UsIHRoaXMuX3JlbmRlcmVyLm1hdHJpeCk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTRmKHByb2dyYW0ucmVjdCwgcmVjdC5sZWZ0LCByZWN0LnRvcCwgcmVjdC5yaWdodCwgcmVjdC5ib3R0b20pO1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCA2KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB0ZXh0OiB7XHJcblxyXG4gICAgICB1cGRhdGVDYW52YXM6IGZ1bmN0aW9uKGVsZW0pIHtcclxuXHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xyXG4gICAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcclxuXHJcbiAgICAgICAgLy8gU3R5bGVzXHJcbiAgICAgICAgdmFyIHNjYWxlID0gZWxlbS5fcmVuZGVyZXIuc2NhbGU7XHJcbiAgICAgICAgdmFyIHN0cm9rZSA9IGVsZW0uX3N0cm9rZTtcclxuICAgICAgICB2YXIgbGluZXdpZHRoID0gZWxlbS5fbGluZXdpZHRoICogc2NhbGU7XHJcbiAgICAgICAgdmFyIGZpbGwgPSBlbGVtLl9maWxsO1xyXG4gICAgICAgIHZhciBvcGFjaXR5ID0gZWxlbS5fcmVuZGVyZXIub3BhY2l0eSB8fCBlbGVtLl9vcGFjaXR5O1xyXG4gICAgICAgIHZhciBkYXNoZXMgPSBlbGVtLmRhc2hlcztcclxuXHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gTWF0aC5tYXgoTWF0aC5jZWlsKGVsZW0uX3JlbmRlcmVyLnJlY3Qud2lkdGggKiBzY2FsZS54KSwgMSk7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IE1hdGgubWF4KE1hdGguY2VpbChlbGVtLl9yZW5kZXJlci5yZWN0LmhlaWdodCAqIHNjYWxlLnkpLCAxKTtcclxuXHJcbiAgICAgICAgdmFyIGNlbnRyb2lkID0gZWxlbS5fcmVuZGVyZXIucmVjdC5jZW50cm9pZDtcclxuICAgICAgICB2YXIgY3ggPSBjZW50cm9pZC54O1xyXG4gICAgICAgIHZhciBjeSA9IGNlbnRyb2lkLnk7XHJcblxyXG4gICAgICAgIHZhciBhLCBiLCBjLCBkLCBlLCBzeCwgc3k7XHJcbiAgICAgICAgdmFyIGlzT2Zmc2V0ID0gZmlsbC5fcmVuZGVyZXIgJiYgZmlsbC5fcmVuZGVyZXIub2Zmc2V0XHJcbiAgICAgICAgICAmJiBzdHJva2UuX3JlbmRlcmVyICYmIHN0cm9rZS5fcmVuZGVyZXIub2Zmc2V0O1xyXG5cclxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblxyXG4gICAgICAgIGlmICghaXNPZmZzZXQpIHtcclxuICAgICAgICAgIGN0eC5mb250ID0gW2VsZW0uX3N0eWxlLCBlbGVtLl93ZWlnaHQsIGVsZW0uX3NpemUgKyAncHgvJyArXHJcbiAgICAgICAgICAgIGVsZW0uX2xlYWRpbmcgKyAncHgnLCBlbGVtLl9mYW1pbHldLmpvaW4oJyAnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XHJcblxyXG4gICAgICAgIC8vIFN0eWxlc1xyXG4gICAgICAgIGlmIChmaWxsKSB7XHJcbiAgICAgICAgICBpZiAoXy5pc1N0cmluZyhmaWxsKSkge1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHdlYmdsW2ZpbGwuX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKGZpbGwsIGN0eCwgZWxlbSk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsLl9yZW5kZXJlci5lZmZlY3Q7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHJva2UpIHtcclxuICAgICAgICAgIGlmIChfLmlzU3RyaW5nKHN0cm9rZSkpIHtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgd2ViZ2xbc3Ryb2tlLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChzdHJva2UsIGN0eCwgZWxlbSk7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZS5fcmVuZGVyZXIuZWZmZWN0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGxpbmV3aWR0aCkge1xyXG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZXdpZHRoO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoXy5pc051bWJlcihvcGFjaXR5KSkge1xyXG4gICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhc2hlcyAmJiBkYXNoZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZGFzaGVzLm9mZnNldCB8fCAwO1xyXG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hlcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgIGN0eC5zY2FsZShzY2FsZS54LCBzY2FsZS55KTtcclxuICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XHJcblxyXG4gICAgICAgIGlmICghd2ViZ2wuaXNIaWRkZW4udGVzdChmaWxsKSkge1xyXG5cclxuICAgICAgICAgIGlmIChmaWxsLl9yZW5kZXJlciAmJiBmaWxsLl9yZW5kZXJlci5vZmZzZXQpIHtcclxuXHJcbiAgICAgICAgICAgIHN4ID0gZmlsbC5fcmVuZGVyZXIuc2NhbGUueDtcclxuICAgICAgICAgICAgc3kgPSBmaWxsLl9yZW5kZXJlci5zY2FsZS55O1xyXG5cclxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSggLSBmaWxsLl9yZW5kZXJlci5vZmZzZXQueCxcclxuICAgICAgICAgICAgICAtIGZpbGwuX3JlbmRlcmVyLm9mZnNldC55KTtcclxuICAgICAgICAgICAgY3R4LnNjYWxlKHN4LCBzeSk7XHJcblxyXG4gICAgICAgICAgICBhID0gZWxlbS5fc2l6ZSAvIGZpbGwuX3JlbmRlcmVyLnNjYWxlLnk7XHJcbiAgICAgICAgICAgIGIgPSBlbGVtLl9sZWFkaW5nIC8gZmlsbC5fcmVuZGVyZXIuc2NhbGUueTtcclxuICAgICAgICAgICAgY3R4LmZvbnQgPSBbZWxlbS5fc3R5bGUsIGVsZW0uX3dlaWdodCwgYSArICdweC8nLFxyXG4gICAgICAgICAgICAgIGIgKyAncHgnLCBlbGVtLl9mYW1pbHldLmpvaW4oJyAnKTtcclxuXHJcbiAgICAgICAgICAgIGMgPSBmaWxsLl9yZW5kZXJlci5vZmZzZXQueCAvIGZpbGwuX3JlbmRlcmVyLnNjYWxlLng7XHJcbiAgICAgICAgICAgIGQgPSBmaWxsLl9yZW5kZXJlci5vZmZzZXQueSAvIGZpbGwuX3JlbmRlcmVyLnNjYWxlLnk7XHJcblxyXG4gICAgICAgICAgICBjdHguZmlsbFRleHQoZWxlbS52YWx1ZSwgYywgZCk7XHJcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcblxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGVsZW0udmFsdWUsIDAsIDApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghd2ViZ2wuaXNIaWRkZW4udGVzdChzdHJva2UpKSB7XHJcblxyXG4gICAgICAgICAgaWYgKHN0cm9rZS5fcmVuZGVyZXIgJiYgc3Ryb2tlLl9yZW5kZXJlci5vZmZzZXQpIHtcclxuXHJcbiAgICAgICAgICAgIHN4ID0gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS54O1xyXG4gICAgICAgICAgICBzeSA9IHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueTtcclxuXHJcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLSBzdHJva2UuX3JlbmRlcmVyLm9mZnNldC54LFxyXG4gICAgICAgICAgICAgIC0gc3Ryb2tlLl9yZW5kZXJlci5vZmZzZXQueSk7XHJcbiAgICAgICAgICAgIGN0eC5zY2FsZShzeCwgc3kpO1xyXG5cclxuICAgICAgICAgICAgYSA9IGVsZW0uX3NpemUgLyBzdHJva2UuX3JlbmRlcmVyLnNjYWxlLnk7XHJcbiAgICAgICAgICAgIGIgPSBlbGVtLl9sZWFkaW5nIC8gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS55O1xyXG4gICAgICAgICAgICBjdHguZm9udCA9IFtlbGVtLl9zdHlsZSwgZWxlbS5fd2VpZ2h0LCBhICsgJ3B4LycsXHJcbiAgICAgICAgICAgICAgYiArICdweCcsIGVsZW0uX2ZhbWlseV0uam9pbignICcpO1xyXG5cclxuICAgICAgICAgICAgYyA9IHN0cm9rZS5fcmVuZGVyZXIub2Zmc2V0LnggLyBzdHJva2UuX3JlbmRlcmVyLnNjYWxlLng7XHJcbiAgICAgICAgICAgIGQgPSBzdHJva2UuX3JlbmRlcmVyLm9mZnNldC55IC8gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS55O1xyXG4gICAgICAgICAgICBlID0gbGluZXdpZHRoIC8gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS54O1xyXG5cclxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGU7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KGVsZW0udmFsdWUsIGMsIGQpO1xyXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG5cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KGVsZW0udmFsdWUsIDAsIDApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcblxyXG4gICAgICB9LFxyXG5cclxuICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBmdW5jdGlvbihlbGVtLCByZWN0KSB7XHJcblxyXG4gICAgICAgIHZhciBjdHggPSB3ZWJnbC5jdHg7XHJcblxyXG4gICAgICAgIGN0eC5mb250ID0gW2VsZW0uX3N0eWxlLCBlbGVtLl93ZWlnaHQsIGVsZW0uX3NpemUgKyAncHgvJyArXHJcbiAgICAgICAgICBlbGVtLl9sZWFkaW5nICsgJ3B4JywgZWxlbS5fZmFtaWx5XS5qb2luKCcgJyk7XHJcblxyXG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gZWxlbS5fYmFzZWxpbmU7XHJcblxyXG4gICAgICAgIC8vIFRPRE86IEVzdGltYXRlIHRoaXMgYmV0dGVyXHJcbiAgICAgICAgdmFyIHdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGVsZW0uX3ZhbHVlKS53aWR0aCAqIDEuMjU7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IE1hdGgubWF4KGVsZW0uX3NpemUsIGVsZW0uX2xlYWRpbmcpICogMS4yNTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2xpbmV3aWR0aCAmJiAhd2ViZ2wuaXNIaWRkZW4udGVzdCh0aGlzLl9zdHJva2UpKSB7XHJcbiAgICAgICAgICB3aWR0aCArPSB0aGlzLl9saW5ld2lkdGggKiAyO1xyXG4gICAgICAgICAgaGVpZ2h0ICs9IHRoaXMuX2xpbmV3aWR0aCAqIDI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdyA9IHdpZHRoIC8gMjtcclxuICAgICAgICB2YXIgaCA9IGhlaWdodCAvIDI7XHJcblxyXG4gICAgICAgIHN3aXRjaCAod2ViZ2wuYWxpZ25tZW50c1tlbGVtLl9hbGlnbm1lbnRdIHx8IGVsZW0uX2FsaWdubWVudCkge1xyXG5cclxuICAgICAgICAgIGNhc2Ugd2ViZ2wuYWxpZ25tZW50cy5sZWZ0OlxyXG4gICAgICAgICAgICByZWN0LmxlZnQgPSAwO1xyXG4gICAgICAgICAgICByZWN0LnJpZ2h0ID0gd2lkdGg7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSB3ZWJnbC5hbGlnbm1lbnRzLnJpZ2h0OlxyXG4gICAgICAgICAgICByZWN0LmxlZnQgPSAtIHdpZHRoO1xyXG4gICAgICAgICAgICByZWN0LnJpZ2h0ID0gMDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZWN0LmxlZnQgPSAtIHc7XHJcbiAgICAgICAgICAgIHJlY3QucmlnaHQgPSB3O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVE9ETzogR3JhZGllbnRzIGFyZW4ndCBpbmhlcml0ZWQuLi5cclxuICAgICAgICBzd2l0Y2ggKGVsZW0uX2Jhc2VsaW5lKSB7XHJcbiAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICByZWN0LnRvcCA9IC0gaGVpZ2h0O1xyXG4gICAgICAgICAgICByZWN0LmJvdHRvbSA9IDA7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgcmVjdC50b3AgPSAwO1xyXG4gICAgICAgICAgICByZWN0LmJvdHRvbSA9IGhlaWdodDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZWN0LnRvcCA9IC0gaDtcclxuICAgICAgICAgICAgcmVjdC5ib3R0b20gPSBoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVjdC53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgICBpZiAoIXJlY3QuY2VudHJvaWQpIHtcclxuICAgICAgICAgIHJlY3QuY2VudHJvaWQgPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRPRE86XHJcbiAgICAgICAgcmVjdC5jZW50cm9pZC54ID0gdztcclxuICAgICAgICByZWN0LmNlbnRyb2lkLnkgPSBoO1xyXG5cclxuICAgICAgfSxcclxuXHJcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGZvcmNlZFBhcmVudCkge1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX3Zpc2libGUgfHwgIXRoaXMuX29wYWNpdHkpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSB3aGF0IGNoYW5nZWRcclxuXHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIHZhciBmbGFnUGFyZW50TWF0cml4ID0gcGFyZW50Ll9tYXRyaXgubWFudWFsIHx8IHBhcmVudC5fZmxhZ01hdHJpeDtcclxuICAgICAgICB2YXIgZmxhZ01hdHJpeCA9IHRoaXMuX21hdHJpeC5tYW51YWwgfHwgdGhpcy5fZmxhZ01hdHJpeDtcclxuICAgICAgICB2YXIgZmxhZ1RleHR1cmUgPSB0aGlzLl9mbGFnVmVydGljZXMgfHwgdGhpcy5fZmxhZ0ZpbGxcclxuICAgICAgICAgIHx8ICh0aGlzLl9maWxsIGluc3RhbmNlb2YgVHdvLkxpbmVhckdyYWRpZW50ICYmICh0aGlzLl9maWxsLl9mbGFnU3ByZWFkIHx8IHRoaXMuX2ZpbGwuX2ZsYWdTdG9wcyB8fCB0aGlzLl9maWxsLl9mbGFnRW5kUG9pbnRzKSlcclxuICAgICAgICAgIHx8ICh0aGlzLl9maWxsIGluc3RhbmNlb2YgVHdvLlJhZGlhbEdyYWRpZW50ICYmICh0aGlzLl9maWxsLl9mbGFnU3ByZWFkIHx8IHRoaXMuX2ZpbGwuX2ZsYWdTdG9wcyB8fCB0aGlzLl9maWxsLl9mbGFnUmFkaXVzIHx8IHRoaXMuX2ZpbGwuX2ZsYWdDZW50ZXIgfHwgdGhpcy5fZmlsbC5fZmxhZ0ZvY2FsKSlcclxuICAgICAgICAgIHx8ICh0aGlzLl9maWxsIGluc3RhbmNlb2YgVHdvLlRleHR1cmUgJiYgKHRoaXMuX2ZpbGwuX2ZsYWdMb2FkZWQgJiYgdGhpcy5fZmlsbC5sb2FkZWQgfHwgdGhpcy5fZmlsbC5fZmxhZ0ltYWdlIHx8IHRoaXMuX2ZpbGwuX2ZsYWdWaWRlbyB8fCB0aGlzLl9maWxsLl9mbGFnUmVwZWF0IHx8IHRoaXMuX2ZpbGwuX2ZsYWdPZmZzZXQgfHwgdGhpcy5fZmlsbC5fZmxhZ1NjYWxlKSlcclxuICAgICAgICAgIHx8ICh0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBUd28uTGluZWFyR3JhZGllbnQgJiYgKHRoaXMuX3N0cm9rZS5fZmxhZ1NwcmVhZCB8fCB0aGlzLl9zdHJva2UuX2ZsYWdTdG9wcyB8fCB0aGlzLl9zdHJva2UuX2ZsYWdFbmRQb2ludHMpKVxyXG4gICAgICAgICAgfHwgKHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIFR3by5SYWRpYWxHcmFkaWVudCAmJiAodGhpcy5fc3Ryb2tlLl9mbGFnU3ByZWFkIHx8IHRoaXMuX3N0cm9rZS5fZmxhZ1N0b3BzIHx8IHRoaXMuX3N0cm9rZS5fZmxhZ1JhZGl1cyB8fCB0aGlzLl9zdHJva2UuX2ZsYWdDZW50ZXIgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnRm9jYWwpKVxyXG4gICAgICAgICAgfHwgKHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIFR3by5UZXh0dXJlICYmICh0aGlzLl9zdHJva2UuX2ZsYWdMb2FkZWQgJiYgdGhpcy5fc3Ryb2tlLmxvYWRlZCB8fCB0aGlzLl9zdHJva2UuX2ZsYWdJbWFnZSB8fCB0aGlzLl9zdHJva2UuX2ZsYWdWaWRlbyB8fCB0aGlzLl9zdHJva2UuX2ZsYWdSZXBlYXQgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnT2Zmc2V0IHx8IHRoaXMuX2ZpbGwuX2ZsYWdTY2FsZSkpXHJcbiAgICAgICAgICB8fCB0aGlzLl9mbGFnU3Ryb2tlIHx8IHRoaXMuX2ZsYWdMaW5ld2lkdGggfHwgdGhpcy5fZmxhZ09wYWNpdHlcclxuICAgICAgICAgIHx8IHBhcmVudC5fZmxhZ09wYWNpdHkgfHwgdGhpcy5fZmxhZ1Zpc2libGUgfHwgdGhpcy5fZmxhZ1NjYWxlXHJcbiAgICAgICAgICB8fCB0aGlzLl9mbGFnVmFsdWUgfHwgdGhpcy5fZmxhZ0ZhbWlseSB8fCB0aGlzLl9mbGFnU2l6ZVxyXG4gICAgICAgICAgfHwgdGhpcy5fZmxhZ0xlYWRpbmcgfHwgdGhpcy5fZmxhZ0FsaWdubWVudCB8fCB0aGlzLl9mbGFnQmFzZWxpbmVcclxuICAgICAgICAgIHx8IHRoaXMuX2ZsYWdTdHlsZSB8fCB0aGlzLl9mbGFnV2VpZ2h0IHx8IHRoaXMuX2ZsYWdEZWNvcmF0aW9uXHJcbiAgICAgICAgICB8fCAodGhpcy5kYXNoZXMgJiYgdGhpcy5kYXNoZXMubGVuZ3RoID4gMClcclxuICAgICAgICAgIHx8ICF0aGlzLl9yZW5kZXJlci50ZXh0dXJlO1xyXG5cclxuICAgICAgICBpZiAoZmxhZ1BhcmVudE1hdHJpeCB8fCBmbGFnTWF0cml4KSB7XHJcblxyXG4gICAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlci5tYXRyaXgpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIubWF0cml4ID0gbmV3IFR3by5BcnJheSg5KTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZWR1Y2UgYW1vdW50IG9mIG9iamVjdCAvIGFycmF5IGNyZWF0aW9uIC8gZGVsZXRpb25cclxuXHJcbiAgICAgICAgICB0aGlzLl9tYXRyaXgudG9UcmFuc2Zvcm1BcnJheSh0cnVlLCB0cmFuc2Zvcm1hdGlvbik7XHJcblxyXG4gICAgICAgICAgbXVsdGlwbHlNYXRyaXgodHJhbnNmb3JtYXRpb24sIHBhcmVudC5fcmVuZGVyZXIubWF0cml4LCB0aGlzLl9yZW5kZXJlci5tYXRyaXgpO1xyXG5cclxuICAgICAgICAgIGlmICghKHRoaXMuX3JlbmRlcmVyLnNjYWxlIGluc3RhbmNlb2YgVHdvLlZlY3RvcikpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUgPSBuZXcgVHdvLlZlY3RvcigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHRoaXMuX3NjYWxlIGluc3RhbmNlb2YgVHdvLlZlY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZS54ID0gdGhpcy5fc2NhbGUueCAqIHBhcmVudC5fcmVuZGVyZXIuc2NhbGUueDtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUueSA9IHRoaXMuX3NjYWxlLnkgKiBwYXJlbnQuX3JlbmRlcmVyLnNjYWxlLnk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZS54ID0gdGhpcy5fc2NhbGUgKiBwYXJlbnQuX3JlbmRlcmVyLnNjYWxlLng7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnkgPSB0aGlzLl9zY2FsZSAqIHBhcmVudC5fcmVuZGVyZXIuc2NhbGUueTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZmxhZ1RleHR1cmUpIHtcclxuXHJcbiAgICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLnJlY3QpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVjdCA9IHt9O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9wYWNpdHkgPSB0aGlzLl9vcGFjaXR5ICogcGFyZW50Ll9yZW5kZXJlci5vcGFjaXR5O1xyXG5cclxuICAgICAgICAgIHdlYmdsLnRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMsIHRoaXMuX3JlbmRlcmVyLnJlY3QpO1xyXG5cclxuICAgICAgICAgIHdlYmdsLnVwZGF0ZVRleHR1cmUuY2FsbCh3ZWJnbCwgZ2wsIHRoaXMpO1xyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFdlIHN0aWxsIG5lZWQgdG8gdXBkYXRlIGNoaWxkIFR3byBlbGVtZW50cyBvbiB0aGUgZmlsbCBhbmRcclxuICAgICAgICAgIC8vIHN0cm9rZSBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgaWYgKHRoaXMuX2ZpbGwgJiYgdGhpcy5fZmlsbC5fdXBkYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpbGwuX3VwZGF0ZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHRoaXMuX3N0cm9rZSAmJiB0aGlzLl9zdHJva2UuX3VwZGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdHJva2UuX3VwZGF0ZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGlmICh0aGlzLl9tYXNrKSB7XHJcbiAgICAgICAgLy8gICB3ZWJnbFt0aGlzLl9tYXNrLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChtYXNrLCBnbCwgcHJvZ3JhbSwgdGhpcyk7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fY2xpcCAmJiAhZm9yY2VkUGFyZW50KSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEcmF3IFRleHR1cmVcclxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl9yZW5kZXJlci50ZXh0dXJlKTtcclxuXHJcbiAgICAgICAgLy8gRHJhdyBSZWN0XHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLl9yZW5kZXJlci5yZWN0O1xyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYocHJvZ3JhbS5tYXRyaXgsIGZhbHNlLCB0aGlzLl9yZW5kZXJlci5tYXRyaXgpO1xyXG4gICAgICAgIGdsLnVuaWZvcm00Zihwcm9ncmFtLnJlY3QsIHJlY3QubGVmdCwgcmVjdC50b3AsIHJlY3QucmlnaHQsIHJlY3QuYm90dG9tKTtcclxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgNik7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xyXG5cclxuICAgICAgfVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgJ2xpbmVhci1ncmFkaWVudCc6IHtcclxuXHJcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4LCBlbGVtKSB7XHJcblxyXG4gICAgICAgIGlmICghY3R4LmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlci5lZmZlY3QgfHwgdGhpcy5fZmxhZ0VuZFBvaW50cyB8fCB0aGlzLl9mbGFnU3RvcHMpIHtcclxuXHJcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lZmZlY3QgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoXHJcbiAgICAgICAgICAgIHRoaXMubGVmdC5feCwgdGhpcy5sZWZ0Ll95LFxyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0Ll94LCB0aGlzLnJpZ2h0Ll95XHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdG9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc3RvcCA9IHRoaXMuc3RvcHNbaV07XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVmZmVjdC5hZGRDb2xvclN0b3Aoc3RvcC5fb2Zmc2V0LCBzdG9wLl9jb2xvcik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAncmFkaWFsLWdyYWRpZW50Jzoge1xyXG5cclxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihjdHgsIGVsZW0pIHtcclxuXHJcbiAgICAgICAgaWYgKCFjdHguY2FudmFzLmdldENvbnRleHQoJzJkJykpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLmVmZmVjdCB8fCB0aGlzLl9mbGFnQ2VudGVyIHx8IHRoaXMuX2ZsYWdGb2NhbFxyXG4gICAgICAgICAgICB8fCB0aGlzLl9mbGFnUmFkaXVzIHx8IHRoaXMuX2ZsYWdTdG9wcykge1xyXG5cclxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVmZmVjdCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChcclxuICAgICAgICAgICAgdGhpcy5jZW50ZXIuX3gsIHRoaXMuY2VudGVyLl95LCAwLFxyXG4gICAgICAgICAgICB0aGlzLmZvY2FsLl94LCB0aGlzLmZvY2FsLl95LCB0aGlzLl9yYWRpdXNcclxuICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0b3BzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzdG9wID0gdGhpcy5zdG9wc1tpXTtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWZmZWN0LmFkZENvbG9yU3RvcChzdG9wLl9vZmZzZXQsIHN0b3AuX2NvbG9yKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5mbGFnUmVzZXQoKTtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHRleHR1cmU6IHtcclxuXHJcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4LCBlbGVtKSB7XHJcblxyXG4gICAgICAgIGlmICghY3R4LmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcclxuXHJcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTtcclxuICAgICAgICB2YXIgcmVwZWF0O1xyXG5cclxuICAgICAgICBpZiAoKCh0aGlzLl9mbGFnTG9hZGVkIHx8IHRoaXMuX2ZsYWdJbWFnZSB8fCB0aGlzLl9mbGFnVmlkZW8gfHwgdGhpcy5fZmxhZ1JlcGVhdCkgJiYgdGhpcy5sb2FkZWQpKSB7XHJcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lZmZlY3QgPSBjdHguY3JlYXRlUGF0dGVybihpbWFnZSwgdGhpcy5fcmVwZWF0KTtcclxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9yZW5kZXJlci5lZmZlY3QpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdPZmZzZXQgfHwgdGhpcy5fZmxhZ0xvYWRlZCB8fCB0aGlzLl9mbGFnU2NhbGUpIHtcclxuXHJcbiAgICAgICAgICBpZiAoISh0aGlzLl9yZW5kZXJlci5vZmZzZXQgaW5zdGFuY2VvZiBUd28uVmVjdG9yKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5vZmZzZXQgPSBuZXcgVHdvLlZlY3RvcigpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC54ID0gLSB0aGlzLl9vZmZzZXQueDtcclxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC55ID0gLSB0aGlzLl9vZmZzZXQueTtcclxuXHJcbiAgICAgICAgICBpZiAoaW1hZ2UpIHtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC54ICs9IGltYWdlLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0LnkgKz0gaW1hZ2UuaGVpZ2h0IC8gMjtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2FsZSBpbnN0YW5jZW9mIFR3by5WZWN0b3IpIHtcclxuICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5vZmZzZXQueCAqPSB0aGlzLl9zY2FsZS54O1xyXG4gICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC55ICo9IHRoaXMuX3NjYWxlLnk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0LnggKj0gdGhpcy5fc2NhbGU7XHJcbiAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0LnkgKj0gdGhpcy5fc2NhbGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fZmxhZ1NjYWxlIHx8IHRoaXMuX2ZsYWdMb2FkZWQpIHtcclxuXHJcbiAgICAgICAgICBpZiAoISh0aGlzLl9yZW5kZXJlci5zY2FsZSBpbnN0YW5jZW9mIFR3by5WZWN0b3IpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlID0gbmV3IFR3by5WZWN0b3IoKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5fc2NhbGUgaW5zdGFuY2VvZiBUd28uVmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLmNvcHkodGhpcy5fc2NhbGUpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUuc2V0KHRoaXMuX3NjYWxlLCB0aGlzLl9zY2FsZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICB1cGRhdGVUZXh0dXJlOiBmdW5jdGlvbihnbCwgZWxlbSkge1xyXG5cclxuICAgICAgdGhpc1tlbGVtLl9yZW5kZXJlci50eXBlXS51cGRhdGVDYW52YXMuY2FsbCh3ZWJnbCwgZWxlbSk7XHJcblxyXG4gICAgICBpZiAoIWVsZW0uX3JlbmRlcmVyLnRleHR1cmUpIHtcclxuICAgICAgICBlbGVtLl9yZW5kZXJlci50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBlbGVtLl9yZW5kZXJlci50ZXh0dXJlKTtcclxuXHJcbiAgICAgIC8vIFNldCB0aGUgcGFyYW1ldGVycyBzbyB3ZSBjYW4gcmVuZGVyIGFueSBzaXplIGltYWdlLlxyXG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xyXG4gICAgICAvLyBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcclxuICAgICAgLy8gZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xyXG4gICAgICAvLyBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5jYW52YXMud2lkdGggPD0gMCB8fCB0aGlzLmNhbnZhcy5oZWlnaHQgPD0gMCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXBsb2FkIHRoZSBpbWFnZSBpbnRvIHRoZSB0ZXh0dXJlLlxyXG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMuY2FudmFzKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHByb2dyYW06IHtcclxuXHJcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24oZ2wsIHNoYWRlcnMpIHtcclxuICAgICAgICB2YXIgcHJvZ3JhbSwgbGlua2VkLCBlcnJvcjtcclxuICAgICAgICBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICAgIF8uZWFjaChzaGFkZXJzLCBmdW5jdGlvbihzKSB7XHJcbiAgICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgcyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIGxpbmtlZCA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpO1xyXG4gICAgICAgIGlmICghbGlua2VkKSB7XHJcbiAgICAgICAgICBlcnJvciA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xyXG4gICAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICAgIHRocm93IG5ldyBUd28uVXRpbHMuRXJyb3IoJ3VuYWJsZSB0byBsaW5rIHByb2dyYW06ICcgKyBlcnJvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIHNoYWRlcnM6IHtcclxuXHJcbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24oZ2wsIHNvdXJjZSwgdHlwZSkge1xyXG4gICAgICAgIHZhciBzaGFkZXIsIGNvbXBpbGVkLCBlcnJvcjtcclxuICAgICAgICBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2xbdHlwZV0pO1xyXG4gICAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XHJcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG5cclxuICAgICAgICBjb21waWxlZCA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKTtcclxuICAgICAgICBpZiAoIWNvbXBpbGVkKSB7XHJcbiAgICAgICAgICBlcnJvciA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcclxuICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR3by5VdGlscy5FcnJvcigndW5hYmxlIHRvIGNvbXBpbGUgc2hhZGVyICcgKyBzaGFkZXIgKyAnOiAnICsgZXJyb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcclxuXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICB0eXBlczoge1xyXG4gICAgICAgIHZlcnRleDogJ1ZFUlRFWF9TSEFERVInLFxyXG4gICAgICAgIGZyYWdtZW50OiAnRlJBR01FTlRfU0hBREVSJ1xyXG4gICAgICB9LFxyXG5cclxuICAgICAgdmVydGV4OiBbXHJcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXHJcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyxcclxuICAgICAgICAnJyxcclxuICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXHJcbiAgICAgICAgJ3VuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247JyxcclxuICAgICAgICAndW5pZm9ybSB2ZWM0IHVfcmVjdDsnLFxyXG4gICAgICAgICcnLFxyXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmRzOycsXHJcbiAgICAgICAgJycsXHJcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxyXG4gICAgICAgICcgICB2ZWMyIHJlY3RDb29yZHMgPSAoYV9wb3NpdGlvbiAqICh1X3JlY3QuencgLSB1X3JlY3QueHkpKSArIHVfcmVjdC54eTsnLFxyXG4gICAgICAgICcgICB2ZWMyIHByb2plY3RlZCA9ICh1X21hdHJpeCAqIHZlYzMocmVjdENvb3JkcywgMS4wKSkueHk7JyxcclxuICAgICAgICAnICAgdmVjMiBub3JtYWwgPSBwcm9qZWN0ZWQgLyB1X3Jlc29sdXRpb247JyxcclxuICAgICAgICAnICAgdmVjMiBjbGlwc3BhY2UgPSAobm9ybWFsICogMi4wKSAtIDEuMDsnLFxyXG4gICAgICAgICcnLFxyXG4gICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcHNwYWNlICogdmVjMigxLjAsIC0xLjApLCAwLjAsIDEuMCk7JyxcclxuICAgICAgICAnICAgdl90ZXh0dXJlQ29vcmRzID0gYV9wb3NpdGlvbjsnLFxyXG4gICAgICAgICd9J1xyXG4gICAgICBdLmpvaW4oJ1xcbicpLFxyXG5cclxuICAgICAgZnJhZ21lbnQ6IFtcclxuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcclxuICAgICAgICAnJyxcclxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTsnLFxyXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmRzOycsXHJcbiAgICAgICAgJycsXHJcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxyXG4gICAgICAgICcgIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXh0dXJlQ29vcmRzKTsnLFxyXG4gICAgICAgICcgIGlmICh0ZXhlbC5hID09IDAuMCkgeycsXHJcbiAgICAgICAgJyAgICBkaXNjYXJkOycsXHJcbiAgICAgICAgJyAgfScsXHJcbiAgICAgICAgJyAgZ2xfRnJhZ0NvbG9yID0gdGV4ZWw7JyxcclxuICAgICAgICAnfSdcclxuICAgICAgXS5qb2luKCdcXG4nKVxyXG5cclxuICAgIH0sXHJcblxyXG4gICAgVGV4dHVyZVJlZ2lzdHJ5OiBuZXcgVHdvLlJlZ2lzdHJ5KClcclxuXHJcbiAgfTtcclxuXHJcbiAgd2ViZ2wuY3R4ID0gd2ViZ2wuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuYW1lIFR3by5XZWJHTFJlbmRlcmVyXHJcbiAgICogQGNsYXNzXHJcbiAgICogQGV4dGVuZHMgVHdvLlV0aWxzLkV2ZW50c1xyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1ldGVyc10gLSBUaGlzIG9iamVjdCBpcyBpbmhlcml0ZWQgd2hlbiBjb25zdHJ1Y3RpbmcgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3b30uXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBbcGFyYW1ldGVycy5kb21FbGVtZW50XSAtIFRoZSBgPGNhbnZhcyAvPmAgdG8gZHJhdyB0by4gSWYgbm9uZSBnaXZlbiBhIG5ldyBvbmUgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cclxuICAgKiBAcGFyYW0ge0NhbnZhc0VsZW1lbnR9IFtwYXJhbWV0ZXJzLm9mZnNjcmVlbkVsZW1lbnRdIC0gVGhlIG9mZnNjcmVlbiB0d28gZGltZW5zaW9uYWwgYDxjYW52YXMgLz5gIHRvIHJlbmRlciBlYWNoIGVsZW1lbnQgb24gV2ViR0wgdGV4dHVyZSB1cGRhdGVzLlxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtZXRlcnMuYW50aWFsaWFzXSAtIERldGVybWluZXMgd2hldGhlciB0aGUgY2FudmFzIHNob3VsZCBjbGVhciByZW5kZXIgd2l0aCBhbnRpYWxpYXMgb24uXHJcbiAgICogQGRlc2NyaXB0aW9uIFRoaXMgY2xhc3MgaXMgdXNlZCBieSB7QGxpbmsgVHdvfSB3aGVuIGNvbnN0cnVjdGluZyB3aXRoIGB0eXBlYCBvZiBgVHdvLlR5cGVzLndlYmdsYC4gSXQgdGFrZXMgVHdvLmpzJyBzY2VuZWdyYXBoIGFuZCByZW5kZXJzIGl0IHRvIGEgYDxjYW52YXMgLz5gIHRocm91Z2ggdGhlIFdlYkdMIGFwaS5cclxuICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9zcGVjcy9sYXRlc3QvMS4wL31cclxuICAgKi9cclxuICB2YXIgUmVuZGVyZXIgPSBUd29bVHdvLlR5cGVzLndlYmdsXSA9IGZ1bmN0aW9uKHBhcmFtcykge1xyXG5cclxuICAgIHZhciBnbCwgdnMsIGZzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLldlYkdMUmVuZGVyZXIjZG9tRWxlbWVudFxyXG4gICAgICogQHByb3BlcnR5IHtFbGVtZW50fSAtIFRoZSBgPGNhbnZhcyAvPmAgYXNzb2NpYXRlZCB3aXRoIHRoZSBUd28uanMgc2NlbmUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZG9tRWxlbWVudCA9IHBhcmFtcy5kb21FbGVtZW50IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG5cclxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJhbXMub2Zmc2NyZWVuRWxlbWVudCkpIHtcclxuICAgICAgd2ViZ2wuY2FudmFzID0gcGFyYW1zLm9mZnNjcmVlbkVsZW1lbnQ7XHJcbiAgICAgIHdlYmdsLmN0eCA9IHdlYmdsLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLldlYkdMUmVuZGVyZXIjc2NlbmVcclxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLkdyb3VwfSAtIFRoZSByb290IGdyb3VwIG9mIHRoZSBzY2VuZWdyYXBoLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNjZW5lID0gbmV3IFR3by5Hcm91cCgpO1xyXG4gICAgdGhpcy5zY2VuZS5wYXJlbnQgPSB0aGlzO1xyXG5cclxuICAgIHRoaXMuX3JlbmRlcmVyID0ge1xyXG4gICAgICB0eXBlOiAncmVuZGVyZXInLFxyXG4gICAgICBtYXRyaXg6IG5ldyBUd28uQXJyYXkoaWRlbnRpdHkpLFxyXG4gICAgICBzY2FsZTogMSxcclxuICAgICAgb3BhY2l0eTogMVxyXG4gICAgfTtcclxuICAgIHRoaXMuX2ZsYWdNYXRyaXggPSB0cnVlO1xyXG5cclxuICAgIC8vIGh0dHA6Ly9nYW1lcy5ncmVnZ21hbi5jb20vZ2FtZS93ZWJnbC1hbmQtYWxwaGEvXHJcbiAgICAvLyBodHRwOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL3NwZWNzL2xhdGVzdC8jNS4yXHJcbiAgICBwYXJhbXMgPSBfLmRlZmF1bHRzKHBhcmFtcyB8fCB7fSwge1xyXG4gICAgICBhbnRpYWxpYXM6IGZhbHNlLFxyXG4gICAgICBhbHBoYTogdHJ1ZSxcclxuICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlLFxyXG4gICAgICBzdGVuY2lsOiB0cnVlLFxyXG4gICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWUsXHJcbiAgICAgIG92ZXJkcmF3OiBmYWxzZVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uV2ViR0xSZW5kZXJlciNvdmVyZHJhd1xyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUgY2FudmFzIGNsZWFycyB0aGUgYmFja2dyb3VuZCBlYWNoIGRyYXcgY2FsbC5cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqL1xyXG4gICAgdGhpcy5vdmVyZHJhdyA9IHBhcmFtcy5vdmVyZHJhdztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5XZWJHTFJlbmRlcmVyI2N0eFxyXG4gICAgICogQHByb3BlcnR5IHtXZWJHTENvbnRleHR9IC0gQXNzb2NpYXRlZCB0d28gZGltZW5zaW9uYWwgY29udGV4dCB0byByZW5kZXIgb24gdGhlIGA8Y2FudmFzIC8+YC5cclxuICAgICAqL1xyXG4gICAgZ2wgPSB0aGlzLmN0eCA9IHRoaXMuZG9tRWxlbWVudC5nZXRDb250ZXh0KCd3ZWJnbCcsIHBhcmFtcykgfHxcclxuICAgICAgdGhpcy5kb21FbGVtZW50LmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIHBhcmFtcyk7XHJcblxyXG4gICAgaWYgKCF0aGlzLmN0eCkge1xyXG4gICAgICB0aHJvdyBuZXcgVHdvLlV0aWxzLkVycm9yKFxyXG4gICAgICAgICd1bmFibGUgdG8gY3JlYXRlIGEgd2ViZ2wgY29udGV4dC4gVHJ5IHVzaW5nIGFub3RoZXIgcmVuZGVyZXIuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29tcGlsZSBCYXNlIFNoYWRlcnMgdG8gZHJhdyBpbiBwaXhlbCBzcGFjZS5cclxuICAgIHZzID0gd2ViZ2wuc2hhZGVycy5jcmVhdGUoXHJcbiAgICAgIGdsLCB3ZWJnbC5zaGFkZXJzLnZlcnRleCwgd2ViZ2wuc2hhZGVycy50eXBlcy52ZXJ0ZXgpO1xyXG4gICAgZnMgPSB3ZWJnbC5zaGFkZXJzLmNyZWF0ZShcclxuICAgICAgZ2wsIHdlYmdsLnNoYWRlcnMuZnJhZ21lbnQsIHdlYmdsLnNoYWRlcnMudHlwZXMuZnJhZ21lbnQpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLldlYkdMUmVuZGVyZXIjcHJvZ3JhbVxyXG4gICAgICogQHByb3BlcnR5IHtXZWJHTFByb2dyYW19IC0gQXNzb2NpYXRlZCBXZWJHTCBwcm9ncmFtIHRvIHJlbmRlciBhbGwgZWxlbWVudHMgZnJvbSB0aGUgc2NlbmVncmFwaC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5wcm9ncmFtID0gd2ViZ2wucHJvZ3JhbS5jcmVhdGUoZ2wsIFt2cywgZnNdKTtcclxuICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgYW5kIGJpbmQgdGhlIGRyYXdpbmcgYnVmZmVyXHJcblxyXG4gICAgLy8gbG9vayB1cCB3aGVyZSB0aGUgdmVydGV4IGRhdGEgbmVlZHMgdG8gZ28uXHJcbiAgICB0aGlzLnByb2dyYW0ucG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sICdhX3Bvc2l0aW9uJyk7XHJcbiAgICB0aGlzLnByb2dyYW0ubWF0cml4ID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ3VfbWF0cml4Jyk7XHJcbiAgICB0aGlzLnByb2dyYW0ucmVjdCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sICd1X3JlY3QnKTtcclxuXHJcbiAgICAvLyBCaW5kIHRoZSB2ZXJ0ZXggYnVmZmVyXHJcbiAgICB2YXIgcG9zaXRpb25CdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbkJ1ZmZlcik7XHJcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMucHJvZ3JhbS5wb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMucHJvZ3JhbS5wb3NpdGlvbik7XHJcbiAgICBnbC5idWZmZXJEYXRhKFxyXG4gICAgICBnbC5BUlJBWV9CVUZGRVIsXHJcbiAgICAgIG5ldyBUd28uQXJyYXkoW1xyXG4gICAgICAgIDAsIDAsXHJcbiAgICAgICAgMSwgMCxcclxuICAgICAgICAwLCAxLFxyXG4gICAgICAgIDAsIDEsXHJcbiAgICAgICAgMSwgMCxcclxuICAgICAgICAxLCAxXHJcbiAgICAgIF0pLFxyXG4gICAgICBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgLy8gU2V0dXAgc29tZSBpbml0aWFsIHN0YXRlbWVudHMgb2YgdGhlIGdsIGNvbnRleHRcclxuICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XHJcblxyXG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0cnVlKTtcclxuXHJcbiAgICBnbC5ibGVuZEVxdWF0aW9uKGdsLkZVTkNfQUREKTtcclxuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG4gIH07XHJcblxyXG4gIF8uZXh0ZW5kKFJlbmRlcmVyLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uV2ViR0xSZW5kZXJlci5VdGlsc1xyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IC0gQSBtYXNzaXZlIG9iamVjdCBmaWxsZWQgd2l0aCB1dGlsaXR5IGZ1bmN0aW9ucyBhbmQgcHJvcGVydGllcyB0byByZW5kZXIgVHdvLmpzIG9iamVjdHMgdG8gYSBgPGNhbnZhcyAvPmAgdGhyb3VnaCB0aGUgV2ViR0wgQVBJLlxyXG4gICAgICovXHJcbiAgICBVdGlsczogd2ViZ2xcclxuXHJcbiAgfSk7XHJcblxyXG4gIF8uZXh0ZW5kKFJlbmRlcmVyLnByb3RvdHlwZSwgVHdvLlV0aWxzLkV2ZW50cywge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBSZW5kZXJlcixcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5XZWJHTFJlbmRlcmVyI3NldFNpemVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIG5ldyB3aWR0aCBvZiB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHJlbmRlcmVyLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYXRpb10gLSBUaGUgbmV3IHBpeGVsIHJhdGlvIChwaXhlbCBkZW5zaXR5KSBvZiB0aGUgcmVuZGVyZXIuIERlZmF1bHRzIHRvIGNhbGN1bGF0ZSB0aGUgcGl4ZWwgZGVuc2l0eSBvZiB0aGUgdXNlcidzIHNjcmVlbi5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDaGFuZ2UgdGhlIHNpemUgb2YgdGhlIHJlbmRlcmVyLlxyXG4gICAgICogQG5vdGEtYmVuZSBUcmlnZ2VycyBhIGBUd28uRXZlbnRzLnJlc2l6ZWAuXHJcbiAgICAgKi9cclxuICAgIHNldFNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHJhdGlvKSB7XHJcblxyXG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuICAgICAgdGhpcy5yYXRpbyA9IF8uaXNVbmRlZmluZWQocmF0aW8pID8gZ2V0UmF0aW8odGhpcy5jdHgpIDogcmF0aW87XHJcblxyXG4gICAgICB0aGlzLmRvbUVsZW1lbnQud2lkdGggPSB3aWR0aCAqIHRoaXMucmF0aW87XHJcbiAgICAgIHRoaXMuZG9tRWxlbWVudC5oZWlnaHQgPSBoZWlnaHQgKiB0aGlzLnJhdGlvO1xyXG5cclxuICAgICAgaWYgKF8uaXNPYmplY3QodGhpcy5kb21FbGVtZW50LnN0eWxlKSkge1xyXG4gICAgICAgIF8uZXh0ZW5kKHRoaXMuZG9tRWxlbWVudC5zdHlsZSwge1xyXG4gICAgICAgICAgd2lkdGg6IHdpZHRoICsgJ3B4JyxcclxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICsgJ3B4J1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTZXQgZm9yIHRoaXMuc3RhZ2UgcGFyZW50IHNjYWxpbmcgdG8gYWNjb3VudCBmb3IgSERQSVxyXG4gICAgICB0aGlzLl9yZW5kZXJlci5tYXRyaXhbMF0gPSB0aGlzLl9yZW5kZXJlci5tYXRyaXhbNF0gPSB0aGlzLl9yZW5kZXJlci5zY2FsZSA9IHRoaXMucmF0aW87XHJcblxyXG4gICAgICB0aGlzLl9mbGFnTWF0cml4ID0gdHJ1ZTtcclxuXHJcbiAgICAgIHRoaXMuY3R4LnZpZXdwb3J0KDAsIDAsIHdpZHRoICogdGhpcy5yYXRpbywgaGVpZ2h0ICogdGhpcy5yYXRpbyk7XHJcblxyXG4gICAgICB2YXIgcmVzb2x1dGlvbkxvY2F0aW9uID0gdGhpcy5jdHguZ2V0VW5pZm9ybUxvY2F0aW9uKFxyXG4gICAgICAgIHRoaXMucHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpO1xyXG4gICAgICB0aGlzLmN0eC51bmlmb3JtMmYocmVzb2x1dGlvbkxvY2F0aW9uLCB3aWR0aCAqIHRoaXMucmF0aW8sIGhlaWdodCAqIHRoaXMucmF0aW8pO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLnJlc2l6ZSwgd2lkdGgsIGhlaWdodCwgcmF0aW8pO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uV2ViR0xSZW5kZXJlciNyZW5kZXJcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIFJlbmRlciB0aGUgY3VycmVudCBzY2VuZSB0byB0aGUgYDxjYW52YXMgLz5gLlxyXG4gICAgICovXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdmFyIGdsID0gdGhpcy5jdHg7XHJcblxyXG4gICAgICBpZiAoIXRoaXMub3ZlcmRyYXcpIHtcclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgd2ViZ2wuZ3JvdXAucmVuZGVyLmNhbGwodGhpcy5zY2VuZSwgZ2wsIHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgIHRoaXMuX2ZsYWdNYXRyaXggPSBmYWxzZTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG59KSgodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiAodGhpcyB8fCBzZWxmIHx8IHdpbmRvdykpLlR3byk7XHJcblxuKGZ1bmN0aW9uKFR3bykge1xyXG5cclxuICB2YXIgXyA9IFR3by5VdGlscztcclxuXHJcbiAgLyoqXHJcbiAgICogQG5hbWUgVHdvLlNoYXBlXHJcbiAgICogQGNsYXNzXHJcbiAgICogQGV4dGVuZHMgVHdvLlV0aWxzLkV2ZW50c1xyXG4gICAqIEBkZXNjcmlwdGlvbiBUaGUgZm91bmRhdGlvbmFsIHRyYW5zZm9ybWF0aW9uIG9iamVjdCBmb3IgdGhlIFR3by5qcyBzY2VuZWdyYXBoLlxyXG4gICAqL1xyXG4gIHZhciBTaGFwZSA9IFR3by5TaGFwZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI19yZW5kZXJlclxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGRlc2NyaXB0aW9uIEEgcHJpdmF0ZSBvYmplY3QgdG8gc3RvcmUgcmVsZXZhbnQgcmVuZGVyZXIgc3BlY2lmaWMgdmFyaWFibGVzLlxyXG4gICAgICogQG5vdGEtYmVuZSBXaXRoIHRoZSB7QGxpbmsgVHdvLlN2Z1JlbmRlcmVyfSB5b3UgY2FuIGFjY2VzcyB0aGUgdW5kZXJseWluZyBTVkcgZWxlbWVudCBjcmVhdGVkIHZpYSBgc2hhcGUuX3JlbmRlcmVyLmVsZW1gLlxyXG4gICAgICovXHJcbiAgICB0aGlzLl9yZW5kZXJlciA9IHt9O1xyXG4gICAgdGhpcy5fcmVuZGVyZXIuZmxhZ01hdHJpeCA9IF8uYmluZChTaGFwZS5GbGFnTWF0cml4LCB0aGlzKTtcclxuICAgIHRoaXMuaXNTaGFwZSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjaWRcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIFNlc3Npb24gc3BlY2lmaWMgdW5pcXVlIGlkZW50aWZpZXIuXHJcbiAgICAgKiBAbm90YS1iZW5lIEluIHRoZSB7QGxpbmsgVHdvLlN2Z1JlbmRlcmVyfSBjaGFuZ2UgdGhpcyB0byBjaGFuZ2UgdGhlIHVuZGVybHlpbmcgU1ZHIGVsZW1lbnQncyBpZCB0b28uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaWQgPSBUd28uSWRlbnRpZmllciArIFR3by51bmlxdWVJZCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI2NsYXNzTGlzdFxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBBIGxpc3Qgb2YgY2xhc3Mgc3RyaW5ncyBzdG9yZWQgaWYgaW1wb3J0ZWQgLyBpbnRlcnByZXRlZCAgZnJvbSBhbiBTVkcgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5jbGFzc0xpc3QgPSBbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TaGFwZSNtYXRyaXhcclxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLk1hdHJpeH1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9mIHRoZSBzaGFwZS5cclxuICAgICAqIEBub3RhLWJlbmUge0BsaW5rIFR3by5TaGFwZSN0cmFuc2xhdGlvbn0sIHtAbGluayBUd28uU2hhcGUjcm90YXRpb259LCBhbmQge0BsaW5rIFR3by5TaGFwZSNzY2FsZX0gYXBwbHkgdGhlaXIgdmFsdWVzIHRvIHRoZSBtYXRyaXggd2hlbiBjaGFuZ2VkLiBUaGUgbWF0cml4IGlzIHdoYXQgaXMgc2VudCB0byB0aGUgcmVuZGVyZXIgdG8gYmUgZHJhd24uXHJcbiAgICAgKi9cclxuICAgIHRoaXMubWF0cml4ID0gbmV3IFR3by5NYXRyaXgoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TaGFwZSN0cmFuc2xhdGlvblxyXG4gICAgICogQHByb3BlcnR5IHtUd28uVmVjdG9yfSAtIFRoZSB4IGFuZCB5IHZhbHVlIGZvciB3aGVyZSB0aGUgc2hhcGUgaXMgcGxhY2VkIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMudHJhbnNsYXRpb24gPSBuZXcgVHdvLlZlY3RvcigpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI3JvdGF0aW9uXHJcbiAgICAgKiBAcHJvcGVydHkge1JhZGlhbnN9IC0gVGhlIHZhbHVlIGluIHJhZGlhbnMgZm9yIGhvdyBtdWNoIHRoZSBzaGFwZSBpcyByb3RhdGVkIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucm90YXRpb24gPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI3NjYWxlXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgdmFsdWUgZm9yIGhvdyBtdWNoIHRoZSBzaGFwZSBpcyBzY2FsZWQgcmVsYXRpdmUgdG8gaXRzIHBhcmVudC5cclxuICAgICAqIEBub3RhLWJlbmUgVGhpcyB2YWx1ZSBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIHtAbGluayBUd28uVmVjdG9yfSB0byBkbyBub24tdW5pZm9ybSBzY2FsaW5nLiBlLmc6IGBzaGFwZS5zY2FsZSA9IG5ldyBUd28uVmVjdG9yKDIsIDEpO2BcclxuICAgICAqL1xyXG4gICAgdGhpcy5zY2FsZSA9IDE7XHJcblxyXG4gIH07XHJcblxyXG4gIF8uZXh0ZW5kKFNoYXBlLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUuRmxhZ01hdHJpeFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gVXRpbGl0eSBmdW5jdGlvbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgaGFuZGxlcnMgdG8gdXBkYXRlIHRoZSBmbGFnTWF0cml4IG9mIGEgc2hhcGUuXHJcbiAgICAgKi9cclxuICAgIEZsYWdNYXRyaXg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLl9mbGFnTWF0cml4ID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUuTWFrZU9ic2VydmFibGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5TaGFwZX0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uU2hhcGV9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxyXG4gICAgICovXHJcbiAgICBNYWtlT2JzZXJ2YWJsZTogZnVuY3Rpb24ob2JqZWN0KSB7XHJcblxyXG4gICAgICB2YXIgdHJhbnNsYXRpb24gPSB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2xhdGlvbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgaWYgKHRoaXMuX3RyYW5zbGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uLnVuYmluZChUd28uRXZlbnRzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ01hdHJpeCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvbiA9IHY7XHJcbiAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvbi5iaW5kKFR3by5FdmVudHMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnTWF0cml4KTtcclxuICAgICAgICAgIFNoYXBlLkZsYWdNYXRyaXguY2FsbCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAndHJhbnNsYXRpb24nLCB0cmFuc2xhdGlvbik7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdwb3NpdGlvbicsIHRyYW5zbGF0aW9uKTtcclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdyb3RhdGlvbicsIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRpb247XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgIHRoaXMuX3JvdGF0aW9uID0gdjtcclxuICAgICAgICAgIHRoaXMuX2ZsYWdNYXRyaXggPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnc2NhbGUnLCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMuX3NjYWxlIGluc3RhbmNlb2YgVHdvLlZlY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9zY2FsZS51bmJpbmQoVHdvLkV2ZW50cy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdNYXRyaXgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuX3NjYWxlID0gdjtcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5fc2NhbGUgaW5zdGFuY2VvZiBUd28uVmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NjYWxlLmJpbmQoVHdvLkV2ZW50cy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdNYXRyaXgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuX2ZsYWdNYXRyaXggPSB0cnVlO1xyXG4gICAgICAgICAgdGhpcy5fZmxhZ1NjYWxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdtYXRyaXgnLCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX21hdHJpeDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgdGhpcy5fbWF0cml4ID0gdjtcclxuICAgICAgICAgIHRoaXMuX2ZsYWdNYXRyaXggPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnY2xhc3NOYW1lJywge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzTmFtZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuXHJcbiAgICAgICAgICB0aGlzLl9mbGFnQ2xhc3NOYW1lICA9IHRoaXMuX2NsYXNzTmFtZSAhPT0gdjtcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5fZmxhZ0NsYXNzTmFtZSkge1xyXG5cclxuICAgICAgICAgICAgdmFyIHByZXYgPSB0aGlzLl9jbGFzc05hbWUuc3BsaXQoL1xccys/Lyk7XHJcbiAgICAgICAgICAgIHZhciBkZXN0ID0gdi5zcGxpdCgvXFxzKz8vKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBwcmV2W2ldO1xyXG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IF8uaW5kZXhPZih0aGlzLmNsYXNzTGlzdCwgY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0ID0gdGhpcy5jbGFzc0xpc3QuY29uY2F0KGRlc3QpO1xyXG5cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLl9jbGFzc05hbWUgPSB2O1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gIH0pO1xyXG5cclxuICBfLmV4dGVuZChTaGFwZS5wcm90b3R5cGUsIFR3by5VdGlscy5FdmVudHMsIHtcclxuXHJcbiAgICAvLyBGbGFnc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI19mbGFnTWF0cml4XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUgbWF0cml4IG5lZWRzIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ01hdHJpeDogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TaGFwZSNfZmxhZ1NjYWxlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUgc2NhbGUgbmVlZHMgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnU2NhbGU6IGZhbHNlLFxyXG5cclxuICAgIC8vIF9mbGFnTWFzazogZmFsc2UsXHJcbiAgICAvLyBfZmxhZ0NsaXA6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI19mbGFnQ2xhc3NOYW1lXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Hcm91cCNjbGFzc05hbWV9IG5lZWQgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnQ2xhc3NOYW1lOiBmYWxzZSxcclxuXHJcbiAgICAvLyBVbmRlcmx5aW5nIFByb3BlcnRpZXNcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TaGFwZSNfdHJhbnNsYXRpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge1R3by5WZWN0b3J9IC0gVGhlIHRyYW5zbGF0aW9uIHZhbHVlcyBhcyBhIHtAbGluayBUd28uVmVjdG9yfS5cclxuICAgICAqL1xyXG4gICAgX3RyYW5zbGF0aW9uOiBudWxsLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI19yb3RhdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7UmFkaWFuc30gLSBUaGUgcm90YXRpb24gdmFsdWUgaW4gcmFkaWFucy5cclxuICAgICAqL1xyXG4gICAgX3JvdGF0aW9uOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI190cmFuc2xhdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLlZlY3Rvcn0gLSBUaGUgdHJhbnNsYXRpb24gdmFsdWVzIGFzIGEge0BsaW5rIFR3by5WZWN0b3J9LlxyXG4gICAgICovXHJcbiAgICBfc2NhbGU6IDEsXHJcblxyXG4gICAgLy8gX21hc2s6IG51bGwsXHJcbiAgICAvLyBfY2xpcDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjY2xhc3NOYW1lXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBBIGNsYXNzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQgdG8gYmUgY29tcGF0aWJsZSB3aXRoIENTUyBzdHlsaW5nLlxyXG4gICAgICogQG5vdGEtYmVuZSBPbmx5IGF2YWlsYWJsZSBmb3IgdGhlIFNWRyByZW5kZXJlci5cclxuICAgICAqL1xyXG4gICAgX2NsYXNzTmFtZTogJycsXHJcblxyXG4gICAgY29uc3RydWN0b3I6IFNoYXBlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI2FkZFRvXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7VHdvLkdyb3VwfSBncm91cCAtIFRoZSBwYXJlbnQgdGhlIHNoYXBlIGFkZHMgaXRzZWxmIHRvLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIG1ldGhvZCB0byBhZGQgaXRzZWxmIHRvIHRoZSBzY2VuZWdyYXBoLlxyXG4gICAgICovXHJcbiAgICBhZGRUbzogZnVuY3Rpb24oZ3JvdXApIHtcclxuICAgICAgZ3JvdXAuYWRkKHRoaXMpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjY2xvbmVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IFtwYXJlbnRdIC0gT3B0aW9uYWwgYXJndW1lbnQgdG8gYXV0b21hdGljYWxseSBhZGQgdGhlIHNoYXBlIHRvIGEgc2NlbmVncmFwaC5cclxuICAgICAqIEByZXR1cm5zIHtUd28uU2hhcGV9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IHtAbGluayBUd28uU2hhcGV9IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoZSBjdXJyZW50IHNoYXBlLlxyXG4gICAgICovXHJcbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XHJcblxyXG4gICAgICB2YXIgY2xvbmUgPSBuZXcgU2hhcGUoKTtcclxuXHJcbiAgICAgIGNsb25lLnRyYW5zbGF0aW9uLmNvcHkodGhpcy50cmFuc2xhdGlvbik7XHJcbiAgICAgIGNsb25lLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcclxuICAgICAgY2xvbmUuc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG5cclxuICAgICAgaWYgKHRoaXMubWF0cml4Lm1hbnVhbCkge1xyXG4gICAgICAgIGNsb25lLm1hdHJpeC5jb3B5KHRoaXMubWF0cml4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgIHBhcmVudC5hZGQoY2xvbmUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gY2xvbmUuX3VwZGF0ZSgpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjX3VwZGF0ZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSByZW5kZXJpbmcgaGFwcGVucyBieSB0aGUgcmVuZGVyZXIuIFRoaXMgYXBwbGllcyBhbGwgY2hhbmdlcyBuZWNlc3Nhcnkgc28gdGhhdCByZW5kZXJpbmcgaXMgdXAtdG8tZGF0ZSBidXQgbm90IHVwZGF0ZWQgbW9yZSB0aGFuIGl0IG5lZWRzIHRvIGJlLlxyXG4gICAgICogQG5vdGEtYmVuZSBUcnkgbm90IHRvIGNhbGwgdGhpcyBtZXRob2QgbW9yZSB0aGFuIG9uY2UgYSBmcmFtZS5cclxuICAgICAqL1xyXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oYnViYmxlcykge1xyXG5cclxuICAgICAgaWYgKCF0aGlzLl9tYXRyaXgubWFudWFsICYmIHRoaXMuX2ZsYWdNYXRyaXgpIHtcclxuXHJcbiAgICAgICAgdGhpcy5fbWF0cml4XHJcbiAgICAgICAgICAuaWRlbnRpdHkoKVxyXG4gICAgICAgICAgLnRyYW5zbGF0ZSh0aGlzLnRyYW5zbGF0aW9uLngsIHRoaXMudHJhbnNsYXRpb24ueSk7XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMuX3NjYWxlIGluc3RhbmNlb2YgVHdvLlZlY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXRyaXguc2NhbGUodGhpcy5fc2NhbGUueCwgdGhpcy5fc2NhbGUueSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXRyaXguc2NhbGUodGhpcy5fc2NhbGUpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuX21hdHJpeC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYnViYmxlcykge1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5fdXBkYXRlKSB7XHJcbiAgICAgICAgICB0aGlzLnBhcmVudC5fdXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI2ZsYWdSZXNldFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKi9cclxuICAgIGZsYWdSZXNldDogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB0aGlzLl9mbGFnTWF0cml4ID0gdGhpcy5fZmxhZ1NjYWxlID0gdGhpcy5fZmxhZ0NsYXNzTmFtZSA9IGZhbHNlO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbiAgU2hhcGUuTWFrZU9ic2VydmFibGUoU2hhcGUucHJvdG90eXBlKTtcclxuXHJcbn0pKCh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6ICh0aGlzIHx8IHNlbGYgfHwgd2luZG93KSkuVHdvKTtcclxuXG4oZnVuY3Rpb24oVHdvKSB7XHJcblxyXG4gIC8vIENvbnN0YW50c1xyXG5cclxuICB2YXIgbWluID0gTWF0aC5taW4sIG1heCA9IE1hdGgubWF4LCByb3VuZCA9IE1hdGgucm91bmQsXHJcbiAgICBjZWlsID0gTWF0aC5jZWlsLCBmbG9vciA9IE1hdGguZmxvb3IsXHJcbiAgICBnZXRDb21wdXRlZE1hdHJpeCA9IFR3by5VdGlscy5nZXRDb21wdXRlZE1hdHJpeDtcclxuXHJcbiAgdmFyIGNvbW1hbmRzID0ge307XHJcbiAgdmFyIF8gPSBUd28uVXRpbHM7XHJcblxyXG4gIF8uZWFjaChUd28uQ29tbWFuZHMsIGZ1bmN0aW9uKHYsIGspIHtcclxuICAgIGNvbW1hbmRzW2tdID0gbmV3IFJlZ0V4cCh2KTtcclxuICB9KTtcclxuXHJcbiAgLyoqXHJcbiAgICogQG5hbWUgVHdvLlBhdGhcclxuICAgKiBAY2xhc3NcclxuICAgKiBAZXh0ZW5kcyBUd28uU2hhcGVcclxuICAgKiBAcGFyYW0ge1R3by5BbmNob3JbXX0gW3ZlcnRpY2VzXSAtIEEgbGlzdCBvZiB7QGxpbmsgVHdvLkFuY2hvcn1zIHRoYXQgcmVwcmVzZW50IHRoZSBvcmRlciBhbmQgY29vcmRpbmF0ZXMgdG8gY29uc3RydWN0IHRoZSByZW5kZXJlZCBzaGFwZS5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjbG9zZWQ9ZmFsc2VdIC0gRGVzY3JpYmVzIHdoZXRoZXIgdGhlIHNoYXBlIGlzIGNsb3NlZCBvciBvcGVuLlxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2N1cnZlZD1mYWxzZV0gLSBEZXNjcmliZXMgd2hldGhlciB0aGUgc2hhcGUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVzIGJlemllciBoYW5kbGVzIGZvciBlYWNoIHZlcnRleC5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYW51YWw9ZmFsc2VdIC0gRGVzY3JpYmVzIHdoZXRoZXIgdGhlIGRldmVsb3BlciBjb250cm9scyBob3cgdmVydGljZXMgYXJlIHBsb3R0ZWQgb3IgaWYgVHdvLmpzIGF1dG9tYXRpY2FsbHkgcGxvdHMgY29vcmRpbmF0ZXMgYmFzZWQgb24gY2xvc2VkIGFuZCBjdXJ2ZWQgYm9vbGVhbnMuXHJcbiAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgdGhlIHByaW1hcnkgcHJpbWl0aXZlIGNsYXNzIGZvciBjcmVhdGluZyBhbGwgZHJhd2FibGUgc2hhcGVzIGluIFR3by5qcy4gVW5sZXNzIHNwZWNpZmllZCBtZXRob2RzIHJldHVybiB0aGVpciBpbnN0YW5jZSBvZiBgVHdvLlBhdGhgIGZvciB0aGUgcHVycG9zZSBvZiBjaGFpbmluZy5cclxuICAgKi9cclxuICB2YXIgUGF0aCA9IFR3by5QYXRoID0gZnVuY3Rpb24odmVydGljZXMsIGNsb3NlZCwgY3VydmVkLCBtYW51YWwpIHtcclxuXHJcbiAgICBUd28uU2hhcGUuY2FsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLl9yZW5kZXJlci50eXBlID0gJ3BhdGgnO1xyXG4gICAgdGhpcy5fcmVuZGVyZXIuZmxhZ1ZlcnRpY2VzID0gXy5iaW5kKFBhdGguRmxhZ1ZlcnRpY2VzLCB0aGlzKTtcclxuICAgIHRoaXMuX3JlbmRlcmVyLmJpbmRWZXJ0aWNlcyA9IF8uYmluZChQYXRoLkJpbmRWZXJ0aWNlcywgdGhpcyk7XHJcbiAgICB0aGlzLl9yZW5kZXJlci51bmJpbmRWZXJ0aWNlcyA9IF8uYmluZChQYXRoLlVuYmluZFZlcnRpY2VzLCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLl9yZW5kZXJlci5mbGFnRmlsbCA9IF8uYmluZChQYXRoLkZsYWdGaWxsLCB0aGlzKTtcclxuICAgIHRoaXMuX3JlbmRlcmVyLmZsYWdTdHJva2UgPSBfLmJpbmQoUGF0aC5GbGFnU3Ryb2tlLCB0aGlzKTtcclxuICAgIHRoaXMuX3JlbmRlcmVyLnZlcnRpY2VzID0gW107XHJcbiAgICB0aGlzLl9yZW5kZXJlci5jb2xsZWN0aW9uID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNjbG9zZWRcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgYSBmaW5hbCBsaW5lIGlzIGRyYXduIGJldHdlZW4gdGhlIGZpbmFsIHBvaW50IGluIHRoZSBgdmVydGljZXNgIGFycmF5IGFuZCB0aGUgZmlyc3QgcG9pbnQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2Nsb3NlZCA9ICEhY2xvc2VkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjY3VydmVkXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gV2hlbiB0aGUgcGF0aCBpcyBgYXV0b21hdGljID0gdHJ1ZWAgdGhpcyBib29sZWFuIGRldGVybWluZXMgd2hldGhlciB0aGUgbGluZXMgYmV0d2VlbiB0aGUgcG9pbnRzIGFyZSBjdXJ2ZWQgb3Igbm90LlxyXG4gICAgICovXHJcbiAgICB0aGlzLl9jdXJ2ZWQgPSAhIWN1cnZlZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI2JlZ2lubmluZ1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gTnVtYmVyIGJldHdlZW4gemVybyBhbmQgb25lIHRvIHN0YXRlIHRoZSBiZWdpbm5pbmcgb2Ygd2hlcmUgdGhlIHBhdGggaXMgcmVuZGVyZWQuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24ge0BsaW5rIFR3by5QYXRoI2JlZ2lubmluZ30gaXMgYSBwZXJjZW50YWdlIHZhbHVlIHRoYXQgcmVwcmVzZW50cyBhdCB3aGF0IHBlcmNlbnRhZ2UgaW50byB0aGUgcGF0aCBzaG91bGQgdGhlIHJlbmRlcmVyIHN0YXJ0IGRyYXdpbmcuXHJcbiAgICAgKiBAbm90YS1iZW5lIFRoaXMgaXMgZ3JlYXQgZm9yIGFuaW1hdGluZyBpbiBhbmQgb3V0IHN0cm9rZWQgcGF0aHMgaW4gY29uanVuY3Rpb24gd2l0aCB7QGxpbmsgVHdvLlBhdGgjZW5kaW5nfS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5iZWdpbm5pbmcgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjZW5kaW5nXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBOdW1iZXIgYmV0d2VlbiB6ZXJvIGFuZCBvbmUgdG8gc3RhdGUgdGhlIGVuZGluZyBvZiB3aGVyZSB0aGUgcGF0aCBpcyByZW5kZXJlZC5cclxuICAgICAqIEBkZXNjcmlwdGlvbiB7QGxpbmsgVHdvLlBhdGgjZW5kaW5nfSBpcyBhIHBlcmNlbnRhZ2UgdmFsdWUgdGhhdCByZXByZXNlbnRzIGF0IHdoYXQgcGVyY2VudGFnZSBpbnRvIHRoZSBwYXRoIHNob3VsZCB0aGUgcmVuZGVyZXIgc3RhcnQgZHJhd2luZy5cclxuICAgICAqIEBub3RhLWJlbmUgVGhpcyBpcyBncmVhdCBmb3IgYW5pbWF0aW5nIGluIGFuZCBvdXQgc3Ryb2tlZCBwYXRocyBpbiBjb25qdW5jdGlvbiB3aXRoIHtAbGluayBUd28uUGF0aCNiZWdpbm5pbmd9LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmVuZGluZyA9IDE7XHJcblxyXG4gICAgLy8gU3R5bGUgcHJvcGVydGllc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjZmlsbFxyXG4gICAgICogQHByb3BlcnR5IHsoQ3NzQ29sb3J8VHdvLkdyYWRpZW50fFR3by5UZXh0dXJlKX0gLSBUaGUgdmFsdWUgb2Ygd2hhdCB0aGUgcGF0aCBzaG91bGQgYmUgZmlsbGVkIGluIHdpdGguXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY29sb3JfdmFsdWV9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENTUyBDb2xvcnMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZmlsbCA9ICcjZmZmJztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI3N0cm9rZVxyXG4gICAgICogQHByb3BlcnR5IHsoQ3NzQ29sb3J8VHdvLkdyYWRpZW50fFR3by5UZXh0dXJlKX0gLSBUaGUgdmFsdWUgb2Ygd2hhdCB0aGUgcGF0aCBzaG91bGQgYmUgb3V0bGluZWQgaW4gd2l0aC5cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9jb2xvcl92YWx1ZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ1NTIENvbG9ycy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdHJva2UgPSAnIzAwMCc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNsaW5ld2lkdGhcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSB0aGlja25lc3MgaW4gcGl4ZWxzIG9mIHRoZSBzdHJva2UuXHJcbiAgICAgKi9cclxuICAgIHRoaXMubGluZXdpZHRoID0gMS4wO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjb3BhY2l0eVxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIG9wYXF1ZW5lc3Mgb2YgdGhlIHBhdGguXHJcbiAgICAgKiBAbm90YS1iZW5lIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggQ1NTIENvbG9ycyB0aGF0IGhhdmUgYW4gYWxwaGEgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub3BhY2l0eSA9IDEuMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI2NsYXNzTmFtZVxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IC0gQSBjbGFzcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50IHRvIGJlIGNvbXBhdGlibGUgd2l0aCBDU1Mgc3R5bGluZy5cclxuICAgICAqIEBub3RhLWJlbmUgT25seSBhdmFpbGFibGUgZm9yIHRoZSBTVkcgcmVuZGVyZXIuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2xhc3NOYW1lID0gJyc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCN2aXNpYmxlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGlzcGxheSB0aGUgcGF0aCBvciBub3QuXHJcbiAgICAgKiBAbm90YS1iZW5lIEZvciB7QGxpbmsgVHdvLkNhbnZhc1JlbmRlcmVyfSBhbmQge0BsaW5rIFR3by5XZWJHTFJlbmRlcmVyfSB3aGVuIHNldCB0byBmYWxzZSBhbGwgdXBkYXRpbmcgaXMgZGlzYWJsZWQgaW1wcm92aW5nIHBlcmZvcm1hbmNlIGRyYW1hdGljYWxseSB3aXRoIG1hbnkgb2JqZWN0cyBpbiB0aGUgc2NlbmUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNjYXBcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzExL3BhaW50aW5nLmh0bWwjU3Ryb2tlTGluZWNhcFByb3BlcnR5fVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNhcCA9ICdidXR0JzsgICAgICAvLyBEZWZhdWx0IG9mIEFkb2JlIElsbHVzdHJhdG9yXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNqb2luXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ31cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9wYWludGluZy5odG1sI1N0cm9rZUxpbmVqb2luUHJvcGVydHl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuam9pbiA9ICdtaXRlcic7ICAgIC8vIERlZmF1bHQgb2YgQWRvYmUgSWxsdXN0cmF0b3JcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI21pdGVyXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ31cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9wYWludGluZy5odG1sI1N0cm9rZU1pdGVybGltaXRQcm9wZXJ0eX1cclxuICAgICAqL1xyXG4gICAgdGhpcy5taXRlciA9IDQ7ICAgICAgICAgLy8gRGVmYXVsdCBvZiBBZG9iZSBJbGx1c3RyYXRvclxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjdmVydGljZXNcclxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLkFuY2hvcltdfSAtIEFuIG9yZGVyZWQgbGlzdCBvZiBhbmNob3IgcG9pbnRzIGZvciByZW5kZXJpbmcgdGhlIHBhdGguXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQSBsaXN0IG9mIHtAbGluayBUd28uQW5jaG9yfSBvYmplY3RzIHRoYXQgY29uc2lzdCBvZiB3aGF0IGZvcm0gdGhlIHBhdGggdGFrZXMuXHJcbiAgICAgKiBAbm90YS1iZW5lIFRoZSBhcnJheSB3aGVuIG1hbmlwdWxhdGluZyBpcyBhY3R1YWxseSBhIHtAbGluayBUd28uVXRpbHMuQ29sbGVjdGlvbn0uXHJcbiAgICAgKi9cclxuICAgIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlcztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI2F1dG9tYXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciBvciBub3QgVHdvLmpzIHNob3VsZCBjYWxjdWxhdGUgY3VydmVzLCBsaW5lcywgYW5kIGNvbW1hbmRzIGF1dG9tYXRpY2FsbHkgZm9yIHlvdSBvciB0byBsZXQgdGhlIGRldmVsb3BlciBtYW5pcHVsYXRlIHRoZW0gZm9yIHRoZW1zZWx2ZXMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXV0b21hdGljID0gIW1hbnVhbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI2Rhc2hlc1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJbXX0gLSBBcnJheSBvZiBudW1iZXJzLiBPZGQgaW5kaWNlcyByZXByZXNlbnQgZGFzaCBsZW5ndGguIEV2ZW4gaW5kaWNlcyByZXByZXNlbnQgZGFzaCBzcGFjZS5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBBIGxpc3Qgb2YgbnVtYmVycyB0aGF0IHJlcHJlc2VudCB0aGUgcmVwZWF0ZWQgZGFzaCBsZW5ndGggYW5kIGRhc2ggc3BhY2UgYXBwbGllZCB0byB0aGUgc3Ryb2tlIG9mIHRoZSB0ZXh0LlxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5fSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgU1ZHIHN0cm9rZS1kYXNoYXJyYXkgYXR0cmlidXRlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmRhc2hlcyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjZGFzaGVzI29mZnNldFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gQSBudW1iZXIgaW4gcGl4ZWxzIHRvIG9mZnNldCB7QGxpbmsgVHdvLlBhdGgjZGFzaGVzfSBkaXNwbGF5LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmRhc2hlcy5vZmZzZXQgPSAwO1xyXG5cclxuICB9O1xyXG5cclxuICBfLmV4dGVuZChQYXRoLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aC5Qcm9wZXJ0aWVzXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uUGF0aH0uXHJcbiAgICAgKi9cclxuICAgIFByb3BlcnRpZXM6IFtcclxuICAgICAgJ2ZpbGwnLFxyXG4gICAgICAnc3Ryb2tlJyxcclxuICAgICAgJ2xpbmV3aWR0aCcsXHJcbiAgICAgICdvcGFjaXR5JyxcclxuICAgICAgJ3Zpc2libGUnLFxyXG4gICAgICAnY2FwJyxcclxuICAgICAgJ2pvaW4nLFxyXG4gICAgICAnbWl0ZXInLFxyXG5cclxuICAgICAgJ2Nsb3NlZCcsXHJcbiAgICAgICdjdXJ2ZWQnLFxyXG4gICAgICAnYXV0b21hdGljJyxcclxuICAgICAgJ2JlZ2lubmluZycsXHJcbiAgICAgICdlbmRpbmcnXHJcbiAgICBdLFxyXG5cclxuICAgIFV0aWxzOiB7XHJcbiAgICAgIGdldEN1cnZlTGVuZ3RoOiBnZXRDdXJ2ZUxlbmd0aFxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoLkZsYWdWZXJ0aWNlc1xyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQgcmVuZGVyZXJzIGtub3cgdmVydGljZXMgaGF2ZSBiZWVuIHVwZGF0ZWQgb24gYSB7QGxpbmsgVHdvLlBhdGh9LlxyXG4gICAgICovXHJcbiAgICBGbGFnVmVydGljZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLl9mbGFnVmVydGljZXMgPSB0cnVlO1xyXG4gICAgICB0aGlzLl9mbGFnTGVuZ3RoID0gdHJ1ZTtcclxuICAgICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQuX2ZsYWdMZW5ndGggPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGguQmluZFZlcnRpY2VzXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCB7QGxpbmsgVHdvLlBhdGh9IGtub3cgdmVydGljZXMgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgQmluZFZlcnRpY2VzOiBmdW5jdGlvbihpdGVtcykge1xyXG5cclxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYSBsb3RcclxuICAgICAgLy8gd2hlbiBpbXBvcnRpbmcgYSBsYXJnZSBTVkdcclxuICAgICAgdmFyIGkgPSBpdGVtcy5sZW5ndGg7XHJcbiAgICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICBpdGVtc1tpXS5iaW5kKFR3by5FdmVudHMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnVmVydGljZXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9yZW5kZXJlci5mbGFnVmVydGljZXMoKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGguVW5iaW5kVmVydGljZXNcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHtAbGluayBUd28uUGF0aH0ga25vdyB2ZXJ0aWNlcyBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgVW5iaW5kVmVydGljZXM6IGZ1bmN0aW9uKGl0ZW1zKSB7XHJcblxyXG4gICAgICB2YXIgaSA9IGl0ZW1zLmxlbmd0aDtcclxuICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGl0ZW1zW2ldLnVuYmluZChUd28uRXZlbnRzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1ZlcnRpY2VzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fcmVuZGVyZXIuZmxhZ1ZlcnRpY2VzKCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoLkZsYWdGaWxsXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCB7QGxpbmsgVHdvLlBhdGh9IGtub3cgdGhlIGZpbGwgaGFzIGNoYW5nZWQuXHJcbiAgICAgKi9cclxuICAgIEZsYWdGaWxsOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5fZmxhZ0ZpbGwgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoLkZsYWdGaWxsXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCB7QGxpbmsgVHdvLlBhdGh9IGtub3cgdGhlIHN0cm9rZSBoYXMgY2hhbmdlZC5cclxuICAgICAqL1xyXG4gICAgRmxhZ1N0cm9rZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMuX2ZsYWdTdHJva2UgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoLk1ha2VPYnNlcnZhYmxlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uUGF0aH0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uUGF0aH0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXHJcbiAgICAgKi9cclxuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmplY3QpIHtcclxuXHJcbiAgICAgIFR3by5TaGFwZS5NYWtlT2JzZXJ2YWJsZShvYmplY3QpO1xyXG5cclxuICAgICAgLy8gT25seSB0aGUgNyBkZWZpbmVkIHByb3BlcnRpZXMgYXJlIGZsYWdnZWQgbGlrZSB0aGlzLiBUaGUgc3Vic2VxdWVudFxyXG4gICAgICAvLyBwcm9wZXJ0aWVzIGJlaGF2ZSBkaWZmZXJlbnRseSBhbmQgbmVlZCB0byBiZSBoYW5kIHdyaXR0ZW4uXHJcbiAgICAgIF8uZWFjaChQYXRoLlByb3BlcnRpZXMuc2xpY2UoMiwgOCksIFR3by5VdGlscy5kZWZpbmVQcm9wZXJ0eSwgb2JqZWN0KTtcclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdmaWxsJywge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9maWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbihmKSB7XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBUd28uR3JhZGllbnRcclxuICAgICAgICAgICAgfHwgdGhpcy5fZmlsbCBpbnN0YW5jZW9mIFR3by5MaW5lYXJHcmFkaWVudFxyXG4gICAgICAgICAgICB8fCB0aGlzLl9maWxsIGluc3RhbmNlb2YgVHdvLlJhZGlhbEdyYWRpZW50XHJcbiAgICAgICAgICAgIHx8IHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBUd28uVGV4dHVyZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9maWxsLnVuYmluZChUd28uRXZlbnRzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ0ZpbGwpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuX2ZpbGwgPSBmO1xyXG4gICAgICAgICAgdGhpcy5fZmxhZ0ZpbGwgPSB0cnVlO1xyXG5cclxuICAgICAgICAgIGlmICh0aGlzLl9maWxsIGluc3RhbmNlb2YgVHdvLkdyYWRpZW50XHJcbiAgICAgICAgICAgIHx8IHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBUd28uTGluZWFyR3JhZGllbnRcclxuICAgICAgICAgICAgfHwgdGhpcy5fZmlsbCBpbnN0YW5jZW9mIFR3by5SYWRpYWxHcmFkaWVudFxyXG4gICAgICAgICAgICB8fCB0aGlzLl9maWxsIGluc3RhbmNlb2YgVHdvLlRleHR1cmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlsbC5iaW5kKFR3by5FdmVudHMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnRmlsbCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnc3Ryb2tlJywge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9zdHJva2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGYpIHtcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgVHdvLkdyYWRpZW50XHJcbiAgICAgICAgICAgIHx8IHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIFR3by5MaW5lYXJHcmFkaWVudFxyXG4gICAgICAgICAgICB8fCB0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBUd28uUmFkaWFsR3JhZGllbnRcclxuICAgICAgICAgICAgfHwgdGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgVHdvLlRleHR1cmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlLnVuYmluZChUd28uRXZlbnRzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1N0cm9rZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhpcy5fc3Ryb2tlID0gZjtcclxuICAgICAgICAgIHRoaXMuX2ZsYWdTdHJva2UgPSB0cnVlO1xyXG5cclxuICAgICAgICAgIGlmICh0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBUd28uR3JhZGllbnRcclxuICAgICAgICAgICAgfHwgdGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgVHdvLkxpbmVhckdyYWRpZW50XHJcbiAgICAgICAgICAgIHx8IHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIFR3by5SYWRpYWxHcmFkaWVudFxyXG4gICAgICAgICAgICB8fCB0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBUd28uVGV4dHVyZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdHJva2UuYmluZChUd28uRXZlbnRzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1N0cm9rZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG5hbWUgVHdvLlBhdGgjbGVuZ3RoXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBzdW0gb2YgZGlzdGFuY2VzIGJldHdlZW4gYWxsIHtAbGluayBUd28uUGF0aCN2ZXJ0aWNlc30uXHJcbiAgICAgICAqL1xyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnbGVuZ3RoJywge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5fZmxhZ0xlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMZW5ndGgoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdjbG9zZWQnLCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgdGhpcy5fY2xvc2VkID0gISF2O1xyXG4gICAgICAgICAgdGhpcy5fZmxhZ1ZlcnRpY2VzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ2N1cnZlZCcsIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY3VydmVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICB0aGlzLl9jdXJ2ZWQgPSAhIXY7XHJcbiAgICAgICAgICB0aGlzLl9mbGFnVmVydGljZXMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnYXV0b21hdGljJywge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9hdXRvbWF0aWM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgIGlmICh2ID09PSB0aGlzLl9hdXRvbWF0aWMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5fYXV0b21hdGljID0gISF2O1xyXG4gICAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMuX2F1dG9tYXRpYyA/ICdpZ25vcmUnIDogJ2xpc3Rlbic7XHJcbiAgICAgICAgICBfLmVhY2godGhpcy52ZXJ0aWNlcywgZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgICB2W21ldGhvZF0oKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnYmVnaW5uaW5nJywge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9iZWdpbm5pbmc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgIHRoaXMuX2JlZ2lubmluZyA9IHY7XHJcbiAgICAgICAgICB0aGlzLl9mbGFnVmVydGljZXMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnZW5kaW5nJywge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9lbmRpbmc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgIHRoaXMuX2VuZGluZyA9IHY7XHJcbiAgICAgICAgICB0aGlzLl9mbGFnVmVydGljZXMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAndmVydGljZXMnLCB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbjtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XHJcblxyXG4gICAgICAgICAgdmFyIHVwZGF0ZVZlcnRpY2VzID0gdGhpcy5fcmVuZGVyZXIuZmxhZ1ZlcnRpY2VzO1xyXG4gICAgICAgICAgdmFyIGJpbmRWZXJ0aWNlcyA9IHRoaXMuX3JlbmRlcmVyLmJpbmRWZXJ0aWNlcztcclxuICAgICAgICAgIHZhciB1bmJpbmRWZXJ0aWNlcyA9IHRoaXMuX3JlbmRlcmVyLnVuYmluZFZlcnRpY2VzO1xyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBsaXN0ZW5lcnNcclxuICAgICAgICAgIGlmICh0aGlzLl9jb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25cclxuICAgICAgICAgICAgICAudW5iaW5kKFR3by5FdmVudHMuaW5zZXJ0LCBiaW5kVmVydGljZXMpXHJcbiAgICAgICAgICAgICAgLnVuYmluZChUd28uRXZlbnRzLnJlbW92ZSwgdW5iaW5kVmVydGljZXMpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENyZWF0ZSBuZXcgQ29sbGVjdGlvbiB3aXRoIGNvcHkgb2YgdmVydGljZXNcclxuICAgICAgICAgIGlmICh2ZXJ0aWNlcyBpbnN0YW5jZW9mIFR3by5VdGlscy5Db2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSB2ZXJ0aWNlcztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSBuZXcgVHdvLlV0aWxzLkNvbGxlY3Rpb24odmVydGljZXMgfHwgW10pO1xyXG4gICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAvLyBMaXN0ZW4gZm9yIENvbGxlY3Rpb24gY2hhbmdlcyBhbmQgYmluZCAvIHVuYmluZFxyXG4gICAgICAgICAgdGhpcy5fY29sbGVjdGlvblxyXG4gICAgICAgICAgICAuYmluZChUd28uRXZlbnRzLmluc2VydCwgYmluZFZlcnRpY2VzKVxyXG4gICAgICAgICAgICAuYmluZChUd28uRXZlbnRzLnJlbW92ZSwgdW5iaW5kVmVydGljZXMpO1xyXG5cclxuICAgICAgICAgIC8vIEJpbmQgSW5pdGlhbCBWZXJ0aWNlc1xyXG4gICAgICAgICAgYmluZFZlcnRpY2VzKHRoaXMuX2NvbGxlY3Rpb24pO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbmFtZSBUd28uUGF0aCNjbGlwXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7VHdvLlNoYXBlfSAtIE9iamVjdCB0byBkZWZpbmUgY2xpcHBpbmcgYXJlYS5cclxuICAgICAgICogQG5vdGEtYmVuZSBUaGlzIHByb3BlcnR5IGlzIGN1cnJlbnRseSBub3Qgd29ya2luZyBiZWN1YXNlIG9mIFNWRyBzcGVjIGlzc3VlcyBmb3VuZCBoZXJlIHtAbGluayBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzcwOTUxfS5cclxuICAgICAgICovXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdjbGlwJywge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9jbGlwO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICB0aGlzLl9jbGlwID0gdjtcclxuICAgICAgICAgIHRoaXMuX2ZsYWdDbGlwID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ2Rhc2hlcycsIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGFzaGVzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICBpZiAoIV8uaXNOdW1iZXIodi5vZmZzZXQpKSB7XHJcbiAgICAgICAgICAgIHYub2Zmc2V0ID0gdGhpcy5fZGFzaGVzLm9mZnNldCB8fCAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5fZGFzaGVzID0gdjtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIF8uZXh0ZW5kKFBhdGgucHJvdG90eXBlLCBUd28uU2hhcGUucHJvdG90eXBlLCB7XHJcblxyXG4gICAgLy8gRmxhZ3NcclxuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmxhZ1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2ZsYWdWZXJ0aWNlc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUGF0aCN2ZXJ0aWNlc30gbmVlZCB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdWZXJ0aWNlczogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI19mbGFnTGVuZ3RoXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5QYXRoI2xlbmd0aH0gbmVlZHMgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnTGVuZ3RoOiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2ZsYWdGaWxsXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5QYXRoI2ZpbGx9IG5lZWRzIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ0ZpbGw6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZmxhZ1N0cm9rZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUGF0aCNzdHJva2V9IG5lZWRzIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ1N0cm9rZTogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI19mbGFnTGluZXdpZHRoXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5QYXRoI2xpbmV3aWR0aH0gbmVlZHMgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnTGluZXdpZHRoOiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2ZsYWdPcGFjaXR5XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5QYXRoI29wYWNpdHl9IG5lZWRzIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ09wYWNpdHk6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZmxhZ1Zpc2libGVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlBhdGgjdmlzaWJsZX0gbmVlZHMgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnVmlzaWJsZTogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI19mbGFnQ2FwXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5QYXRoI2NhcH0gbmVlZHMgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnQ2FwOiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2ZsYWdKb2luXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5QYXRoI2pvaW59IG5lZWRzIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ0pvaW46IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZmxhZ01pdGVyXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5QYXRoI21pdGVyfSBuZWVkcyB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdNaXRlcjogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI19mbGFnQ2xpcFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUGF0aCNjbGlwfSBuZWVkcyB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdDbGlwOiBmYWxzZSxcclxuXHJcbiAgICAvLyBVbmRlcmx5aW5nIFByb3BlcnRpZXNcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI19sZW5ndGhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUGF0aCNsZW5ndGh9XHJcbiAgICAgKi9cclxuICAgIF9sZW5ndGg6IDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZmlsbFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI2ZpbGx9XHJcbiAgICAgKi9cclxuICAgIF9maWxsOiAnI2ZmZicsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfc3Ryb2tlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBhdGgjc3Ryb2tlfVxyXG4gICAgICovXHJcbiAgICBfc3Ryb2tlOiAnIzAwMCcsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfbGluZXdpZHRoXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBhdGgjbGluZXdpZHRofVxyXG4gICAgICovXHJcbiAgICBfbGluZXdpZHRoOiAxLjAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfb3BhY2l0eVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI29wYWNpdHl9XHJcbiAgICAgKi9cclxuICAgIF9vcGFjaXR5OiAxLjAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfdmlzaWJsZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI3Zpc2libGV9XHJcbiAgICAgKi9cclxuICAgIF92aXNpYmxlOiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2NhcFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI2NhcH1cclxuICAgICAqL1xyXG4gICAgX2NhcDogJ3JvdW5kJyxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI19qb2luXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBhdGgjam9pbn1cclxuICAgICAqL1xyXG4gICAgX2pvaW46ICdyb3VuZCcsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfbWl0ZXJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUGF0aCNtaXRlcn1cclxuICAgICAqL1xyXG4gICAgX21pdGVyOiA0LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2Nsb3NlZFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI2Nsb3NlZH1cclxuICAgICAqL1xyXG4gICAgX2Nsb3NlZDogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI19jdXJ2ZWRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUGF0aCNjdXJ2ZWR9XHJcbiAgICAgKi9cclxuICAgIF9jdXJ2ZWQ6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2F1dG9tYXRpY1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI2F1dG9tYXRpY31cclxuICAgICAqL1xyXG4gICAgX2F1dG9tYXRpYzogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI19iZWdpbm5pbmdcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUGF0aCNiZWdpbm5pbmd9XHJcbiAgICAgKi9cclxuICAgIF9iZWdpbm5pbmc6IDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZW5kaW5nXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBhdGgjZW5kaW5nfVxyXG4gICAgICovXHJcbiAgICBfZW5kaW5nOiAxLjAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfY2xpcFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI2NsaXB9XHJcbiAgICAgKi9cclxuICAgIF9jbGlwOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI19kYXNoZXNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUGF0aCNkYXNoZXN9XHJcbiAgICAgKi9cclxuICAgIF9kYXNoZXM6IFtdLFxyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBQYXRoLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjY2xvbmVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IFtwYXJlbnRdIC0gVGhlIHBhcmVudCBncm91cCBvciBzY2VuZSB0byBhZGQgdGhlIGNsb25lIHRvLlxyXG4gICAgICogQHJldHVybnMge1R3by5QYXRofVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLlBhdGh9IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBwYXRoLlxyXG4gICAgICovXHJcbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XHJcblxyXG4gICAgICB2YXIgY2xvbmUgPSBuZXcgUGF0aCgpO1xyXG5cclxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgY2xvbmUudmVydGljZXMucHVzaCh0aGlzLnZlcnRpY2VzW2pdLmNsb25lKCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFBhdGguUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBrID0gUGF0aC5Qcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgIGNsb25lW2tdID0gdGhpc1trXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY2xvbmUuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XHJcblxyXG4gICAgICBjbG9uZS50cmFuc2xhdGlvbi5jb3B5KHRoaXMudHJhbnNsYXRpb24pO1xyXG4gICAgICBjbG9uZS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XHJcbiAgICAgIGNsb25lLnNjYWxlID0gdGhpcy5zY2FsZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm1hdHJpeC5tYW51YWwpIHtcclxuICAgICAgICBjbG9uZS5tYXRyaXguY29weSh0aGlzLm1hdHJpeCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNsb25lLl91cGRhdGUoKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjdG9PYmplY3RcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGF0aC5cclxuICAgICAqL1xyXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdmFyIHJlc3VsdCA9IHtcclxuICAgICAgICB2ZXJ0aWNlczogXy5tYXAodGhpcy52ZXJ0aWNlcywgZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgcmV0dXJuIHYudG9PYmplY3QoKTtcclxuICAgICAgICB9KVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgXy5lYWNoKFR3by5TaGFwZS5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihrKSB7XHJcbiAgICAgICAgcmVzdWx0W2tdID0gdGhpc1trXTtcclxuICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICByZXN1bHQuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XHJcblxyXG4gICAgICByZXN1bHQudHJhbnNsYXRpb24gPSB0aGlzLnRyYW5zbGF0aW9uLnRvT2JqZWN0KCk7XHJcbiAgICAgIHJlc3VsdC5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XHJcbiAgICAgIHJlc3VsdC5zY2FsZSA9IHRoaXMuc2NhbGUgaW5zdGFuY2VvZiBUd28uVmVjdG9yID8gdGhpcy5zY2FsZS50b09iamVjdCgpIDogdGhpcy5zY2FsZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm1hdHJpeC5tYW51YWwpIHtcclxuICAgICAgICByZXN1bHQubWF0cml4ID0gdGhpcy5tYXRyaXgudG9PYmplY3QoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjbm9GaWxsXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBkZXNjcmlwdGlvbiBTaG9ydCBoYW5kIG1ldGhvZCB0byBzZXQgZmlsbCB0byBgdHJhbnNwYXJlbnRgLlxyXG4gICAgICovXHJcbiAgICBub0ZpbGw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLmZpbGwgPSAndHJhbnNwYXJlbnQnO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNub1N0cm9rZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gU2hvcnQgaGFuZCBtZXRob2QgdG8gc2V0IHN0cm9rZSB0byBgdHJhbnNwYXJlbnRgLlxyXG4gICAgICovXHJcbiAgICBub1N0cm9rZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMuc3Ryb2tlID0gdW5kZWZpbmVkO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNjb3JuZXJcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIE9yaWVudCB0aGUgdmVydGljZXMgb2YgdGhlIHNoYXBlIHRvIHRoZSB1cHBlciBsZWZ0LWhhbmQgY29ybmVyIG9mIHRoZSBwYXRoLlxyXG4gICAgICovXHJcbiAgICBjb3JuZXI6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCh0cnVlKTtcclxuXHJcbiAgICAgIHJlY3QuY2VudHJvaWQgPSB7XHJcbiAgICAgICAgeDogcmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAvIDIsXHJcbiAgICAgICAgeTogcmVjdC50b3AgKyByZWN0LmhlaWdodCAvIDJcclxuICAgICAgfTtcclxuXHJcbiAgICAgIF8uZWFjaCh0aGlzLnZlcnRpY2VzLCBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgdi5zdWJTZWxmKHJlY3QuY2VudHJvaWQpO1xyXG4gICAgICAgIHYueCArPSByZWN0LndpZHRoIC8gMjtcclxuICAgICAgICB2LnkgKz0gcmVjdC5oZWlnaHQgLyAyO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNjZW50ZXJcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIE9yaWVudCB0aGUgdmVydGljZXMgb2YgdGhlIHNoYXBlIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHBhdGguXHJcbiAgICAgKi9cclxuICAgIGNlbnRlcjogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRydWUpO1xyXG5cclxuICAgICAgcmVjdC5jZW50cm9pZCA9IHtcclxuICAgICAgICB4OiByZWN0LmxlZnQgKyByZWN0LndpZHRoIC8gMiAtIHRoaXMudHJhbnNsYXRpb24ueCxcclxuICAgICAgICB5OiByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC8gMiAtIHRoaXMudHJhbnNsYXRpb24ueVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgXy5lYWNoKHRoaXMudmVydGljZXMsIGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICB2LnN1YlNlbGYocmVjdC5jZW50cm9pZCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI3JlbW92ZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlIHNlbGYgZnJvbSB0aGUgc2NlbmUgLyBwYXJlbnQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICBpZiAoIXRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucGFyZW50LnJlbW92ZSh0aGlzKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNnZXRCb3VuZGluZ0NsaWVudFJlY3RcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2hhbGxvdz1mYWxzZV0gLSBEZXNjcmliZXMgd2hldGhlciB0byBjYWxjdWxhdGUgb2ZmIGxvY2FsIG1hdHJpeCBvciB3b3JsZCBtYXRyaXguXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIFJldHVybnMgb2JqZWN0IHdpdGggdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCB3aWR0aCwgaGVpZ2h0IGF0dHJpYnV0ZXMuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgd2lkdGgsIGFuZCBoZWlnaHQgcGFyYW1ldGVycyBvZiB0aGUgcGF0aC5cclxuICAgICAqL1xyXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBmdW5jdGlvbihzaGFsbG93KSB7XHJcbiAgICAgIHZhciBtYXRyaXgsIGJvcmRlciwgbCwgeCwgeSwgaSwgdjAsIGMwLCBjMSwgdjE7XHJcblxyXG4gICAgICB2YXIgbGVmdCA9IEluZmluaXR5LCByaWdodCA9IC1JbmZpbml0eSxcclxuICAgICAgICAgIHRvcCA9IEluZmluaXR5LCBib3R0b20gPSAtSW5maW5pdHk7XHJcblxyXG4gICAgICAvLyBUT0RPOiBVcGRhdGUgdGhpcyB0byBub3QgX19hbHdheXNfXyB1cGRhdGUuIEp1c3Qgd2hlbiBpdCBuZWVkcyB0by5cclxuICAgICAgdGhpcy5fdXBkYXRlKHRydWUpO1xyXG5cclxuICAgICAgbWF0cml4ID0gc2hhbGxvdyA/IHRoaXMuX21hdHJpeCA6IGdldENvbXB1dGVkTWF0cml4KHRoaXMpO1xyXG5cclxuICAgICAgYm9yZGVyID0gdGhpcy5saW5ld2lkdGggLyAyO1xyXG4gICAgICBsID0gdGhpcy5fcmVuZGVyZXIudmVydGljZXMubGVuZ3RoO1xyXG5cclxuICAgICAgaWYgKGwgPD0gMCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICAgIGhlaWdodDogMFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuXHJcbiAgICAgICAgdjEgPSB0aGlzLl9yZW5kZXJlci52ZXJ0aWNlc1tpXTtcclxuICAgICAgICAvLyBJZiBpID0gMCwgdGhlbiB0aGlzIFwid3JhcHMgYXJvdW5kXCIgdG8gdGhlIGxhc3QgdmVydGV4LiBPdGhlcndpc2UsIGl0J3MgdGhlIHByZXZpb3VzIHZlcnRleC5cclxuICAgICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBmb3IgaGFuZGxpbmcgY3ljbGljIHBhdGhzLlxyXG4gICAgICAgIHYwID0gdGhpcy5fcmVuZGVyZXIudmVydGljZXNbKGkgKyBsIC0gMSkgJSBsXTtcclxuXHJcbiAgICAgICAgaWYgKHYwLmNvbnRyb2xzICYmIHYxLmNvbnRyb2xzKSB7XHJcblxyXG4gICAgICAgICAgaWYgKHYwLnJlbGF0aXZlKSB7XHJcbiAgICAgICAgICAgIGMwID0gbWF0cml4Lm11bHRpcGx5KFxyXG4gICAgICAgICAgICAgIHYwLmNvbnRyb2xzLnJpZ2h0LnggKyB2MC54LCB2MC5jb250cm9scy5yaWdodC55ICsgdjAueSwgMSk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjMCA9IG1hdHJpeC5tdWx0aXBseShcclxuICAgICAgICAgICAgICB2MC5jb250cm9scy5yaWdodC54LCB2MC5jb250cm9scy5yaWdodC55LCAxKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHYwID0gbWF0cml4Lm11bHRpcGx5KHYwLngsIHYwLnksIDEpO1xyXG5cclxuICAgICAgICAgIGlmICh2MS5yZWxhdGl2ZSkge1xyXG4gICAgICAgICAgICBjMSA9IG1hdHJpeC5tdWx0aXBseShcclxuICAgICAgICAgICAgICB2MS5jb250cm9scy5sZWZ0LnggKyB2MS54LCB2MS5jb250cm9scy5sZWZ0LnkgKyB2MS55LCAxKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGMxID0gbWF0cml4Lm11bHRpcGx5KFxyXG4gICAgICAgICAgICAgIHYxLmNvbnRyb2xzLmxlZnQueCwgdjEuY29udHJvbHMubGVmdC55LCAxKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHYxID0gbWF0cml4Lm11bHRpcGx5KHYxLngsIHYxLnksIDEpO1xyXG5cclxuICAgICAgICAgIHZhciBiYiA9IFR3by5VdGlscy5nZXRDdXJ2ZUJvdW5kaW5nQm94KFxyXG4gICAgICAgICAgICB2MC54LCB2MC55LCBjMC54LCBjMC55LCBjMS54LCBjMS55LCB2MS54LCB2MS55KTtcclxuXHJcbiAgICAgICAgICB0b3AgPSBtaW4oYmIubWluLnkgLSBib3JkZXIsIHRvcCk7XHJcbiAgICAgICAgICBsZWZ0ID0gbWluKGJiLm1pbi54IC0gYm9yZGVyLCBsZWZ0KTtcclxuICAgICAgICAgIHJpZ2h0ID0gbWF4KGJiLm1heC54ICsgYm9yZGVyLCByaWdodCk7XHJcbiAgICAgICAgICBib3R0b20gPSBtYXgoYmIubWF4LnkgKyBib3JkZXIsIGJvdHRvbSk7XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgaWYgKGkgPD0gMSkge1xyXG5cclxuICAgICAgICAgICAgdjAgPSBtYXRyaXgubXVsdGlwbHkodjAueCwgdjAueSwgMSk7XHJcblxyXG4gICAgICAgICAgICB0b3AgPSBtaW4odjAueSAtIGJvcmRlciwgdG9wKTtcclxuICAgICAgICAgICAgbGVmdCA9IG1pbih2MC54IC0gYm9yZGVyLCBsZWZ0KTtcclxuICAgICAgICAgICAgcmlnaHQgPSBtYXgodjAueCArIGJvcmRlciwgcmlnaHQpO1xyXG4gICAgICAgICAgICBib3R0b20gPSBtYXgodjAueSArIGJvcmRlciwgYm90dG9tKTtcclxuXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdjEgPSBtYXRyaXgubXVsdGlwbHkodjEueCwgdjEueSwgMSk7XHJcblxyXG4gICAgICAgICAgdG9wID0gbWluKHYxLnkgLSBib3JkZXIsIHRvcCk7XHJcbiAgICAgICAgICBsZWZ0ID0gbWluKHYxLnggLSBib3JkZXIsIGxlZnQpO1xyXG4gICAgICAgICAgcmlnaHQgPSBtYXgodjEueCArIGJvcmRlciwgcmlnaHQpO1xyXG4gICAgICAgICAgYm90dG9tID0gbWF4KHYxLnkgKyBib3JkZXIsIGJvdHRvbSk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICByaWdodDogcmlnaHQsXHJcbiAgICAgICAgYm90dG9tOiBib3R0b20sXHJcbiAgICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcclxuICAgICAgICBoZWlnaHQ6IGJvdHRvbSAtIHRvcFxyXG4gICAgICB9O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNnZXRQb2ludEF0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gdCAtIFBlcmNlbnRhZ2UgdmFsdWUgZGVzY3JpYmluZyB3aGVyZSBvbiB0aGUgVHdvLlBhdGggdG8gZXN0aW1hdGUgYW5kIGFzc2lnbiBjb29yZGluYXRlIHZhbHVlcy5cclxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gW29iaj11bmRlZmluZWRdIC0gT2JqZWN0IHRvIGFwcGx5IGNhbGN1bGF0ZWQgeCwgeSB0by4gSWYgbm9uZSBhdmFpbGFibGUgcmV0dXJucyBuZXcgT2JqZWN0LlxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBHaXZlbiBhIGZsb2F0IGB0YCBmcm9tIDAgdG8gMSwgcmV0dXJuIGEgcG9pbnQgb3IgYXNzaWduIGEgcGFzc2VkIGBvYmpgJ3MgY29vcmRpbmF0ZXMgdG8gdGhhdCBwZXJjZW50YWdlIG9uIHRoaXMgVHdvLlBhdGgncyBjdXJ2ZS5cclxuICAgICAqL1xyXG4gICAgZ2V0UG9pbnRBdDogZnVuY3Rpb24odCwgb2JqKSB7XHJcblxyXG4gICAgICB2YXIgaWEsIGliLCByZXN1bHQ7XHJcbiAgICAgIHZhciB4LCB4MSwgeDIsIHgzLCB4NCwgeSwgeTEsIHkyLCB5MywgeTQsIGxlZnQsIHJpZ2h0O1xyXG4gICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5sZW5ndGggKiBNYXRoLm1pbihNYXRoLm1heCh0LCAwKSwgMSk7XHJcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcclxuICAgICAgdmFyIGxhc3QgPSBsZW5ndGggLSAxO1xyXG5cclxuICAgICAgdmFyIGEgPSBudWxsO1xyXG4gICAgICB2YXIgYiA9IG51bGw7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2xlbmd0aHMubGVuZ3RoLCBzdW0gPSAwOyBpIDwgbDsgaSsrKSB7XHJcblxyXG4gICAgICAgIGlmIChzdW0gKyB0aGlzLl9sZW5ndGhzW2ldID49IHRhcmdldCkge1xyXG5cclxuICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcclxuICAgICAgICAgICAgaWEgPSBUd28uVXRpbHMubW9kKGksIGxlbmd0aCk7XHJcbiAgICAgICAgICAgIGliID0gVHdvLlV0aWxzLm1vZChpIC0gMSwgbGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgICAgICBpYSA9IGliO1xyXG4gICAgICAgICAgICAgIGliID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWEgPSBpO1xyXG4gICAgICAgICAgICBpYiA9IE1hdGgubWluKE1hdGgubWF4KGkgLSAxLCAwKSwgbGFzdCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYSA9IHRoaXMudmVydGljZXNbaWFdO1xyXG4gICAgICAgICAgYiA9IHRoaXMudmVydGljZXNbaWJdO1xyXG4gICAgICAgICAgdGFyZ2V0IC09IHN1bTtcclxuICAgICAgICAgIGlmICh0aGlzLl9sZW5ndGhzW2ldICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHQgPSB0YXJnZXQgLyB0aGlzLl9sZW5ndGhzW2ldO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdCA9IDA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3VtICs9IHRoaXMuX2xlbmd0aHNbaV07XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoXy5pc051bGwoYSkgfHwgXy5pc051bGwoYikpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCFhKSB7XHJcbiAgICAgICAgcmV0dXJuIGI7XHJcbiAgICAgIH0gZWxzZSBpZiAoIWIpIHtcclxuICAgICAgICByZXR1cm4gYTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmlnaHQgPSBiLmNvbnRyb2xzICYmIGIuY29udHJvbHMucmlnaHQ7XHJcbiAgICAgIGxlZnQgPSBhLmNvbnRyb2xzICYmIGEuY29udHJvbHMubGVmdDtcclxuXHJcbiAgICAgIHgxID0gYi54O1xyXG4gICAgICB5MSA9IGIueTtcclxuICAgICAgeDIgPSAocmlnaHQgfHwgYikueDtcclxuICAgICAgeTIgPSAocmlnaHQgfHwgYikueTtcclxuICAgICAgeDMgPSAobGVmdCB8fCBhKS54O1xyXG4gICAgICB5MyA9IChsZWZ0IHx8IGEpLnk7XHJcbiAgICAgIHg0ID0gYS54O1xyXG4gICAgICB5NCA9IGEueTtcclxuXHJcbiAgICAgIGlmIChyaWdodCAmJiBiLnJlbGF0aXZlKSB7XHJcbiAgICAgICAgeDIgKz0gYi54O1xyXG4gICAgICAgIHkyICs9IGIueTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGxlZnQgJiYgYS5yZWxhdGl2ZSkge1xyXG4gICAgICAgIHgzICs9IGEueDtcclxuICAgICAgICB5MyArPSBhLnk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHggPSBUd28uVXRpbHMuZ2V0Q29tcG9uZW50T25DdWJpY0Jlemllcih0LCB4MSwgeDIsIHgzLCB4NCk7XHJcbiAgICAgIHkgPSBUd28uVXRpbHMuZ2V0Q29tcG9uZW50T25DdWJpY0Jlemllcih0LCB5MSwgeTIsIHkzLCB5NCk7XHJcblxyXG4gICAgICAvLyBIaWdoZXIgb3JkZXIgcG9pbnRzIGZvciBjb250cm9sIGNhbGN1bGF0aW9uLlxyXG4gICAgICB2YXIgdDF4ID0gVHdvLlV0aWxzLmxlcnAoeDEsIHgyLCB0KTtcclxuICAgICAgdmFyIHQxeSA9IFR3by5VdGlscy5sZXJwKHkxLCB5MiwgdCk7XHJcbiAgICAgIHZhciB0MnggPSBUd28uVXRpbHMubGVycCh4MiwgeDMsIHQpO1xyXG4gICAgICB2YXIgdDJ5ID0gVHdvLlV0aWxzLmxlcnAoeTIsIHkzLCB0KTtcclxuICAgICAgdmFyIHQzeCA9IFR3by5VdGlscy5sZXJwKHgzLCB4NCwgdCk7XHJcbiAgICAgIHZhciB0M3kgPSBUd28uVXRpbHMubGVycCh5MywgeTQsIHQpO1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSByZXR1cm5lZCBwb2ludHMgY29udHJvbCBwb2ludHMuXHJcbiAgICAgIHZhciBicnggPSBUd28uVXRpbHMubGVycCh0MXgsIHQyeCwgdCk7XHJcbiAgICAgIHZhciBicnkgPSBUd28uVXRpbHMubGVycCh0MXksIHQyeSwgdCk7XHJcbiAgICAgIHZhciBhbHggPSBUd28uVXRpbHMubGVycCh0MngsIHQzeCwgdCk7XHJcbiAgICAgIHZhciBhbHkgPSBUd28uVXRpbHMubGVycCh0MnksIHQzeSwgdCk7XHJcblxyXG4gICAgICBpZiAoXy5pc09iamVjdChvYmopKSB7XHJcblxyXG4gICAgICAgIG9iai54ID0geDtcclxuICAgICAgICBvYmoueSA9IHk7XHJcblxyXG4gICAgICAgIGlmICghXy5pc09iamVjdChvYmouY29udHJvbHMpKSB7XHJcbiAgICAgICAgICBUd28uQW5jaG9yLkFwcGVuZEN1cnZlUHJvcGVydGllcyhvYmopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb2JqLmNvbnRyb2xzLmxlZnQueCA9IGJyeDtcclxuICAgICAgICBvYmouY29udHJvbHMubGVmdC55ID0gYnJ5O1xyXG4gICAgICAgIG9iai5jb250cm9scy5yaWdodC54ID0gYWx4O1xyXG4gICAgICAgIG9iai5jb250cm9scy5yaWdodC55ID0gYWx5O1xyXG5cclxuICAgICAgICBpZiAoIV8uaXNCb29sZWFuKG9iai5yZWxhdGl2ZSkgfHwgb2JqLnJlbGF0aXZlKSB7XHJcbiAgICAgICAgICBvYmouY29udHJvbHMubGVmdC54IC09IHg7XHJcbiAgICAgICAgICBvYmouY29udHJvbHMubGVmdC55IC09IHk7XHJcbiAgICAgICAgICBvYmouY29udHJvbHMucmlnaHQueCAtPSB4O1xyXG4gICAgICAgICAgb2JqLmNvbnRyb2xzLnJpZ2h0LnkgLT0geTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9iai50ID0gdDtcclxuXHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlc3VsdCA9IG5ldyBUd28uQW5jaG9yKFxyXG4gICAgICAgIHgsIHksIGJyeCAtIHgsIGJyeSAtIHksIGFseCAtIHgsIGFseSAtIHksXHJcbiAgICAgICAgdGhpcy5fY3VydmVkID8gVHdvLkNvbW1hbmRzLmN1cnZlIDogVHdvLkNvbW1hbmRzLmxpbmVcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHJlc3VsdC50ID0gdDtcclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI3Bsb3RcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIEJhc2VkIG9uIGNsb3NlZCAvIGN1cnZlZCBhbmQgc29ydGluZyBvZiB2ZXJ0aWNlcyBwbG90IHdoZXJlIGFsbCBwb2ludHMgc2hvdWxkIGJlIGFuZCB3aGVyZSB0aGUgcmVzcGVjdGl2ZSBoYW5kbGVzIHNob3VsZCBiZSB0b28uXHJcbiAgICAgKiBAbm90YS1iZW5lIFdoaWxlIHRoaXMgbWV0aG9kIGlzIHB1YmxpYyBpdCBpcyBpbnRlcm5hbGx5IGNhbGxlZCBieSB7QGxpbmsgVHdvLlBhdGgjX3VwZGF0ZX0gd2hlbiBgYXV0b21hdGljID0gdHJ1ZWAuXHJcbiAgICAgKi9cclxuICAgIHBsb3Q6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgaWYgKHRoaXMuY3VydmVkKSB7XHJcbiAgICAgICAgVHdvLlV0aWxzLmdldEN1cnZlRnJvbVBvaW50cyh0aGlzLl9jb2xsZWN0aW9uLCB0aGlzLmNsb3NlZCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY29sbGVjdGlvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRoaXMuX2NvbGxlY3Rpb25baV0uY29tbWFuZCA9IGkgPT09IDAgPyBUd28uQ29tbWFuZHMubW92ZSA6IFR3by5Db21tYW5kcy5saW5lO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjc3ViZGl2aWRlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gbGltaXQgLSBIb3cgbWFueSB0aW1lcyB0byByZWN1cnNlIHN1YmRpdmlzaW9ucy5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBJbnNlcnQgYSB7QGxpbmsgVHdvLkFuY2hvcn0gYXQgdGhlIG1pZHBvaW50IGJldHdlZW4gZXZlcnkgaXRlbSBpbiB7QGxpbmsgVHdvLlBhdGgjdmVydGljZXN9LlxyXG4gICAgICovXHJcbiAgICBzdWJkaXZpZGU6IGZ1bmN0aW9uKGxpbWl0KSB7XHJcbiAgICAgIC8vVE9ETzogRFJZbmVzcyAoZnVuY3Rpb24gYmVsb3cpXHJcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuICAgICAgdmFyIGxhc3QgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDE7XHJcbiAgICAgIHZhciBiID0gdGhpcy52ZXJ0aWNlc1tsYXN0XTtcclxuICAgICAgdmFyIGNsb3NlZCA9IHRoaXMuX2Nsb3NlZCB8fCB0aGlzLnZlcnRpY2VzW2xhc3RdLl9jb21tYW5kID09PSBUd28uQ29tbWFuZHMuY2xvc2U7XHJcbiAgICAgIHZhciBwb2ludHMgPSBbXTtcclxuICAgICAgXy5lYWNoKHRoaXMudmVydGljZXMsIGZ1bmN0aW9uKGEsIGkpIHtcclxuXHJcbiAgICAgICAgaWYgKGkgPD0gMCAmJiAhY2xvc2VkKSB7XHJcbiAgICAgICAgICBiID0gYTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhLmNvbW1hbmQgPT09IFR3by5Db21tYW5kcy5tb3ZlKSB7XHJcbiAgICAgICAgICBwb2ludHMucHVzaChuZXcgVHdvLkFuY2hvcihiLngsIGIueSkpO1xyXG4gICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0uY29tbWFuZCA9IFR3by5Db21tYW5kcy5saW5lO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYiA9IGE7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgdmVydHMgPSBnZXRTdWJkaXZpc2lvbnMoYSwgYiwgbGltaXQpO1xyXG4gICAgICAgIHBvaW50cyA9IHBvaW50cy5jb25jYXQodmVydHMpO1xyXG5cclxuICAgICAgICAvLyBBc3NpZ24gY29tbWFuZHMgdG8gYWxsIHRoZSB2ZXJ0c1xyXG4gICAgICAgIF8uZWFjaCh2ZXJ0cywgZnVuY3Rpb24odiwgaSkge1xyXG4gICAgICAgICAgaWYgKGkgPD0gMCAmJiBiLmNvbW1hbmQgPT09IFR3by5Db21tYW5kcy5tb3ZlKSB7XHJcbiAgICAgICAgICAgIHYuY29tbWFuZCA9IFR3by5Db21tYW5kcy5tb3ZlO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdi5jb21tYW5kID0gVHdvLkNvbW1hbmRzLmxpbmU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChpID49IGxhc3QpIHtcclxuXHJcbiAgICAgICAgICAvLyBUT0RPOiBBZGQgY2hlY2sgaWYgdGhlIHR3byB2ZWN0b3JzIGluIHF1ZXN0aW9uIGFyZSB0aGUgc2FtZSB2YWx1ZXMuXHJcbiAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkICYmIHRoaXMuX2F1dG9tYXRpYykge1xyXG5cclxuICAgICAgICAgICAgYiA9IGE7XHJcblxyXG4gICAgICAgICAgICB2ZXJ0cyA9IGdldFN1YmRpdmlzaW9ucyhhLCBiLCBsaW1pdCk7XHJcbiAgICAgICAgICAgIHBvaW50cyA9IHBvaW50cy5jb25jYXQodmVydHMpO1xyXG5cclxuICAgICAgICAgICAgLy8gQXNzaWduIGNvbW1hbmRzIHRvIGFsbCB0aGUgdmVydHNcclxuICAgICAgICAgICAgXy5lYWNoKHZlcnRzLCBmdW5jdGlvbih2LCBpKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGkgPD0gMCAmJiBiLmNvbW1hbmQgPT09IFR3by5Db21tYW5kcy5tb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICB2LmNvbW1hbmQgPSBUd28uQ29tbWFuZHMubW92ZTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdi5jb21tYW5kID0gVHdvLkNvbW1hbmRzLmxpbmU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsb3NlZCkge1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaChuZXcgVHdvLkFuY2hvcihhLngsIGEueSkpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0uY29tbWFuZCA9IGNsb3NlZFxyXG4gICAgICAgICAgICA/IFR3by5Db21tYW5kcy5jbG9zZSA6IFR3by5Db21tYW5kcy5saW5lO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGIgPSBhO1xyXG5cclxuICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICB0aGlzLl9hdXRvbWF0aWMgPSBmYWxzZTtcclxuICAgICAgdGhpcy5fY3VydmVkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMudmVydGljZXMgPSBwb2ludHM7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX3VwZGF0ZUxlbmd0aFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBbbGltaXQ9XSAtXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIC0gSWYgc2V0IHRvIGB0cnVlYCB0aGVuIHRoZSBwYXRoIGlzbid0IHVwZGF0ZWQgYmVmb3JlIGNhbGN1bGF0aW9uLiBVc2VmdWwgZm9yIGludGVybmFsIHVzZS5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBSZWNhbGN1bGF0ZSB0aGUge0BsaW5rIFR3by5QYXRoI2xlbmd0aH0gdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIF91cGRhdGVMZW5ndGg6IGZ1bmN0aW9uKGxpbWl0LCBzaWxlbnQpIHtcclxuICAgICAgLy9UT0RPOiBEUlluZXNzIChmdW5jdGlvbiBhYm92ZSlcclxuICAgICAgaWYgKCFzaWxlbnQpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xyXG4gICAgICB2YXIgbGFzdCA9IGxlbmd0aCAtIDE7XHJcbiAgICAgIHZhciBiID0gdGhpcy52ZXJ0aWNlc1tsYXN0XTtcclxuICAgICAgdmFyIGNsb3NlZCA9IGZhbHNlOy8vdGhpcy5fY2xvc2VkIHx8IHRoaXMudmVydGljZXNbbGFzdF0uX2NvbW1hbmQgPT09IFR3by5Db21tYW5kcy5jbG9zZTtcclxuICAgICAgdmFyIHN1bSA9IDA7XHJcblxyXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh0aGlzLl9sZW5ndGhzKSkge1xyXG4gICAgICAgIHRoaXMuX2xlbmd0aHMgPSBbXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgXy5lYWNoKHRoaXMudmVydGljZXMsIGZ1bmN0aW9uKGEsIGkpIHtcclxuXHJcbiAgICAgICAgaWYgKChpIDw9IDAgJiYgIWNsb3NlZCkgfHwgYS5jb21tYW5kID09PSBUd28uQ29tbWFuZHMubW92ZSkge1xyXG4gICAgICAgICAgYiA9IGE7XHJcbiAgICAgICAgICB0aGlzLl9sZW5ndGhzW2ldID0gMDtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2xlbmd0aHNbaV0gPSBnZXRDdXJ2ZUxlbmd0aChhLCBiLCBsaW1pdCk7XHJcbiAgICAgICAgc3VtICs9IHRoaXMuX2xlbmd0aHNbaV07XHJcblxyXG4gICAgICAgIGlmIChpID49IGxhc3QgJiYgY2xvc2VkKSB7XHJcblxyXG4gICAgICAgICAgYiA9IHRoaXMudmVydGljZXNbKGkgKyAxKSAlIGxlbmd0aF07XHJcblxyXG4gICAgICAgICAgdGhpcy5fbGVuZ3Roc1tpICsgMV0gPSBnZXRDdXJ2ZUxlbmd0aChhLCBiLCBsaW1pdCk7XHJcbiAgICAgICAgICBzdW0gKz0gdGhpcy5fbGVuZ3Roc1tpICsgMV07XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYiA9IGE7XHJcblxyXG4gICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgIHRoaXMuX2xlbmd0aCA9IHN1bTtcclxuICAgICAgdGhpcy5fZmxhZ0xlbmd0aCA9IGZhbHNlO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5QYXRoI191cGRhdGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cclxuICAgICAqIEBub3RhLWJlbmUgVHJ5IG5vdCB0byBjYWxsIHRoaXMgbWV0aG9kIG1vcmUgdGhhbiBvbmNlIGEgZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2ZsYWdWZXJ0aWNlcykge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fYXV0b21hdGljKSB7XHJcbiAgICAgICAgICB0aGlzLnBsb3QoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9mbGFnTGVuZ3RoKSB7XHJcbiAgICAgICAgICB0aGlzLl91cGRhdGVMZW5ndGgodW5kZWZpbmVkLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBsID0gdGhpcy5fY29sbGVjdGlvbi5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGxhc3QgPSBsIC0gMTtcclxuICAgICAgICB2YXIgY2xvc2VkID0gdGhpcy5fY2xvc2VkO1xyXG5cclxuICAgICAgICB2YXIgYmVnaW5uaW5nID0gTWF0aC5taW4odGhpcy5fYmVnaW5uaW5nLCB0aGlzLl9lbmRpbmcpO1xyXG4gICAgICAgIHZhciBlbmRpbmcgPSBNYXRoLm1heCh0aGlzLl9iZWdpbm5pbmcsIHRoaXMuX2VuZGluZyk7XHJcblxyXG4gICAgICAgIHZhciBiaWQgPSBnZXRJZEJ5TGVuZ3RoKHRoaXMsIGJlZ2lubmluZyAqIHRoaXMuX2xlbmd0aCk7XHJcbiAgICAgICAgdmFyIGVpZCA9IGdldElkQnlMZW5ndGgodGhpcywgZW5kaW5nICogdGhpcy5fbGVuZ3RoKTtcclxuXHJcbiAgICAgICAgdmFyIGxvdyA9IGNlaWwoYmlkKTtcclxuICAgICAgICB2YXIgaGlnaCA9IGZsb29yKGVpZCk7XHJcblxyXG4gICAgICAgIHZhciBsZWZ0LCByaWdodCwgcHJldiwgbmV4dCwgdjtcclxuXHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIudmVydGljZXMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5fcmVuZGVyZXIuY29sbGVjdGlvbi5sZW5ndGggPD0gaSkge1xyXG4gICAgICAgICAgICAvLyBFeHBlY3RlZCB0byBiZSBgcmVsYXRpdmVgIGFuY2hvciBwb2ludHMuXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmNvbGxlY3Rpb24ucHVzaChuZXcgVHdvLkFuY2hvcigpKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoaSA+IGhpZ2ggJiYgIXJpZ2h0KSB7XHJcblxyXG4gICAgICAgICAgICB2ID0gdGhpcy5fcmVuZGVyZXIuY29sbGVjdGlvbltpXTtcclxuICAgICAgICAgICAgdi5jb3B5KHRoaXMuX2NvbGxlY3Rpb25baV0pO1xyXG4gICAgICAgICAgICB0aGlzLmdldFBvaW50QXQoZW5kaW5nLCB2KTtcclxuICAgICAgICAgICAgdi5jb21tYW5kID0gdGhpcy5fcmVuZGVyZXIuY29sbGVjdGlvbltpXS5jb21tYW5kO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci52ZXJ0aWNlcy5wdXNoKHYpO1xyXG5cclxuICAgICAgICAgICAgcmlnaHQgPSB2O1xyXG4gICAgICAgICAgICBwcmV2ID0gdGhpcy5fY29sbGVjdGlvbltpIC0gMV07XHJcblxyXG4gICAgICAgICAgICAvLyBQcm9qZWN0IGNvbnRyb2wgb3ZlciB0aGUgcGVyY2VudGFnZSBgdGBcclxuICAgICAgICAgICAgLy8gb2YgdGhlIGluLWJldHdlZW4gcG9pbnRcclxuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldi5jb250cm9scykge1xyXG5cclxuICAgICAgICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LmNsZWFyKCk7XHJcblxyXG4gICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmNvbGxlY3Rpb25baSAtIDFdLmNvbnRyb2xzLnJpZ2h0XHJcbiAgICAgICAgICAgICAgICAuY2xlYXIoKVxyXG4gICAgICAgICAgICAgICAgLmxlcnAocHJldi5jb250cm9scy5yaWdodCwgdi50KTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPj0gbG93ICYmIGkgPD0gaGlnaCkge1xyXG5cclxuICAgICAgICAgICAgdiA9IHRoaXMuX3JlbmRlcmVyLmNvbGxlY3Rpb25baV1cclxuICAgICAgICAgICAgICAuY29weSh0aGlzLl9jb2xsZWN0aW9uW2ldKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIudmVydGljZXMucHVzaCh2KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpID09PSBoaWdoICYmIGNvbnRhaW5zKHRoaXMsIGVuZGluZykpIHtcclxuICAgICAgICAgICAgICByaWdodCA9IHY7XHJcbiAgICAgICAgICAgICAgaWYgKCFjbG9zZWQgJiYgcmlnaHQuY29udHJvbHMpIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0LmNvbnRyb2xzLnJpZ2h0LmNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IGxvdyAmJiBjb250YWlucyh0aGlzLCBiZWdpbm5pbmcpKSB7XHJcbiAgICAgICAgICAgICAgbGVmdCA9IHY7XHJcbiAgICAgICAgICAgICAgbGVmdC5jb21tYW5kID0gVHdvLkNvbW1hbmRzLm1vdmU7XHJcbiAgICAgICAgICAgICAgaWYgKCFjbG9zZWQgJiYgbGVmdC5jb250cm9scykge1xyXG4gICAgICAgICAgICAgICAgbGVmdC5jb250cm9scy5sZWZ0LmNsZWFyKCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByZXBlbmQgdGhlIHRyaW1tZWQgcG9pbnQgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgIGlmIChsb3cgPiAwICYmICFsZWZ0KSB7XHJcblxyXG4gICAgICAgICAgaSA9IGxvdyAtIDE7XHJcblxyXG4gICAgICAgICAgdiA9IHRoaXMuX3JlbmRlcmVyLmNvbGxlY3Rpb25baV07XHJcbiAgICAgICAgICB2LmNvcHkodGhpcy5fY29sbGVjdGlvbltpXSk7XHJcbiAgICAgICAgICB0aGlzLmdldFBvaW50QXQoYmVnaW5uaW5nLCB2KTtcclxuICAgICAgICAgIHYuY29tbWFuZCA9IFR3by5Db21tYW5kcy5tb3ZlO1xyXG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIudmVydGljZXMudW5zaGlmdCh2KTtcclxuXHJcbiAgICAgICAgICBsZWZ0ID0gdjtcclxuICAgICAgICAgIG5leHQgPSB0aGlzLl9jb2xsZWN0aW9uW2kgKyAxXTtcclxuXHJcbiAgICAgICAgICAvLyBQcm9qZWN0IGNvbnRyb2wgb3ZlciB0aGUgcGVyY2VudGFnZSBgdGBcclxuICAgICAgICAgIC8vIG9mIHRoZSBpbi1iZXR3ZWVuIHBvaW50XHJcbiAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0LmNvbnRyb2xzKSB7XHJcblxyXG4gICAgICAgICAgICB2LmNvbnRyb2xzLmxlZnQuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmNvbGxlY3Rpb25baSArIDFdLmNvbnRyb2xzLmxlZnRcclxuICAgICAgICAgICAgICAuY29weShuZXh0LmNvbnRyb2xzLmxlZnQpXHJcbiAgICAgICAgICAgICAgLmxlcnAoVHdvLlZlY3Rvci56ZXJvLCB2LnQpO1xyXG5cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgVHdvLlNoYXBlLnByb3RvdHlwZS5fdXBkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBhdGgjZmxhZ1Jlc2V0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIGludGVybmFsbHkgdG8gcmVzZXQgYWxsIGZsYWdzLiBFbnN1cmVzIHRoYXQgb25seSBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIGFyZSB1cGRhdGVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSByZW5kZXJlci5cclxuICAgICAqL1xyXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHRoaXMuX2ZsYWdWZXJ0aWNlcyA9ICB0aGlzLl9mbGFnRmlsbCA9ICB0aGlzLl9mbGFnU3Ryb2tlID1cclxuICAgICAgICAgdGhpcy5fZmxhZ0xpbmV3aWR0aCA9IHRoaXMuX2ZsYWdPcGFjaXR5ID0gdGhpcy5fZmxhZ1Zpc2libGUgPVxyXG4gICAgICAgICB0aGlzLl9mbGFnQ2FwID0gdGhpcy5fZmxhZ0pvaW4gPSB0aGlzLl9mbGFnTWl0ZXIgPVxyXG4gICAgICAgICB0aGlzLl9mbGFnQ2xpcCA9IGZhbHNlO1xyXG5cclxuICAgICAgVHdvLlNoYXBlLnByb3RvdHlwZS5mbGFnUmVzZXQuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIFBhdGguTWFrZU9ic2VydmFibGUoUGF0aC5wcm90b3R5cGUpO1xyXG5cclxuICAgLy8gVXRpbGl0eSBmdW5jdGlvbnNcclxuXHJcbiAgZnVuY3Rpb24gY29udGFpbnMocGF0aCwgdCkge1xyXG5cclxuICAgIGlmICh0ID09PSAwIHx8IHQgPT09IDEpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxlbmd0aCA9IHBhdGguX2xlbmd0aDtcclxuICAgIHZhciB0YXJnZXQgPSBsZW5ndGggKiB0O1xyXG4gICAgdmFyIGVsYXBzZWQgPSAwO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5fbGVuZ3Rocy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgZGlzdCA9IHBhdGguX2xlbmd0aHNbaV07XHJcbiAgICAgIGlmIChlbGFwc2VkID49IHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQgLSBlbGFwc2VkID49IDA7XHJcbiAgICAgIH1cclxuICAgICAgZWxhcHNlZCArPSBkaXN0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICogQHBhcmFtIHtUd28uUGF0aH0gcGF0aCAtIFRoZSBwYXRoIHRvIGFuYWx5emUgYWdhaW5zdC5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGFyZ2V0IC0gVGhlIHRhcmdldCBsZW5ndGggYXQgd2hpY2ggdG8gZmluZCBhbiBhbmNob3IuXHJcbiAgICogQHJldHVybnMge0ludGVnZXJ9XHJcbiAgICogQGRlc2NyaXB0aW9uIFJldHVybiB0aGUgaWQgb2YgYW4gYW5jaG9yIGJhc2VkIG9uIGEgdGFyZ2V0IGxlbmd0aC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBnZXRJZEJ5TGVuZ3RoKHBhdGgsIHRhcmdldCkge1xyXG5cclxuICAgIHZhciB0b3RhbCA9IHBhdGguX2xlbmd0aDtcclxuXHJcbiAgICBpZiAodGFyZ2V0IDw9IDApIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9IGVsc2UgaWYgKHRhcmdldCA+PSB0b3RhbCkge1xyXG4gICAgICByZXR1cm4gcGF0aC5fbGVuZ3Rocy5sZW5ndGggLSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIGkgPSAwLCBzdW0gPSAwOyBpIDwgcGF0aC5fbGVuZ3Rocy5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgaWYgKHN1bSArIHBhdGguX2xlbmd0aHNbaV0gPj0gdGFyZ2V0KSB7XHJcbiAgICAgICAgdGFyZ2V0IC09IHN1bTtcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoaSAtIDEsIDApICsgdGFyZ2V0IC8gcGF0aC5fbGVuZ3Roc1tpXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3VtICs9IHBhdGguX2xlbmd0aHNbaV07XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAtIDE7XHJcblxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0Q3VydmVMZW5ndGgoYSwgYiwgbGltaXQpIHtcclxuICAgIC8vIFRPRE86IERSWW5lc3NcclxuICAgIHZhciB4MSwgeDIsIHgzLCB4NCwgeTEsIHkyLCB5MywgeTQ7XHJcblxyXG4gICAgdmFyIHJpZ2h0ID0gYi5jb250cm9scyAmJiBiLmNvbnRyb2xzLnJpZ2h0O1xyXG4gICAgdmFyIGxlZnQgPSBhLmNvbnRyb2xzICYmIGEuY29udHJvbHMubGVmdDtcclxuXHJcbiAgICB4MSA9IGIueDtcclxuICAgIHkxID0gYi55O1xyXG4gICAgeDIgPSAocmlnaHQgfHwgYikueDtcclxuICAgIHkyID0gKHJpZ2h0IHx8IGIpLnk7XHJcbiAgICB4MyA9IChsZWZ0IHx8IGEpLng7XHJcbiAgICB5MyA9IChsZWZ0IHx8IGEpLnk7XHJcbiAgICB4NCA9IGEueDtcclxuICAgIHk0ID0gYS55O1xyXG5cclxuICAgIGlmIChyaWdodCAmJiBiLl9yZWxhdGl2ZSkge1xyXG4gICAgICB4MiArPSBiLng7XHJcbiAgICAgIHkyICs9IGIueTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobGVmdCAmJiBhLl9yZWxhdGl2ZSkge1xyXG4gICAgICB4MyArPSBhLng7XHJcbiAgICAgIHkzICs9IGEueTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gVHdvLlV0aWxzLmdldEN1cnZlTGVuZ3RoKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgbGltaXQpO1xyXG5cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFN1YmRpdmlzaW9ucyhhLCBiLCBsaW1pdCkge1xyXG4gICAgLy8gVE9ETzogRFJZbmVzc1xyXG4gICAgdmFyIHgxLCB4MiwgeDMsIHg0LCB5MSwgeTIsIHkzLCB5NDtcclxuXHJcbiAgICB2YXIgcmlnaHQgPSBiLmNvbnRyb2xzICYmIGIuY29udHJvbHMucmlnaHQ7XHJcbiAgICB2YXIgbGVmdCA9IGEuY29udHJvbHMgJiYgYS5jb250cm9scy5sZWZ0O1xyXG5cclxuICAgIHgxID0gYi54O1xyXG4gICAgeTEgPSBiLnk7XHJcbiAgICB4MiA9IChyaWdodCB8fCBiKS54O1xyXG4gICAgeTIgPSAocmlnaHQgfHwgYikueTtcclxuICAgIHgzID0gKGxlZnQgfHwgYSkueDtcclxuICAgIHkzID0gKGxlZnQgfHwgYSkueTtcclxuICAgIHg0ID0gYS54O1xyXG4gICAgeTQgPSBhLnk7XHJcblxyXG4gICAgaWYgKHJpZ2h0ICYmIGIuX3JlbGF0aXZlKSB7XHJcbiAgICAgIHgyICs9IGIueDtcclxuICAgICAgeTIgKz0gYi55O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChsZWZ0ICYmIGEuX3JlbGF0aXZlKSB7XHJcbiAgICAgIHgzICs9IGEueDtcclxuICAgICAgeTMgKz0gYS55O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBUd28uVXRpbHMuc3ViZGl2aWRlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgbGltaXQpO1xyXG5cclxuICB9XHJcblxyXG59KSgodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiAodGhpcyB8fCBzZWxmIHx8IHdpbmRvdykpLlR3byk7XHJcblxuKGZ1bmN0aW9uKFR3bykge1xyXG5cclxuICB2YXIgUGF0aCA9IFR3by5QYXRoO1xyXG4gIHZhciBfID0gVHdvLlV0aWxzO1xyXG5cclxuICAvKipcclxuICAgKiBAbmFtZSBUd28uTGluZVxyXG4gICAqIEBjbGFzc1xyXG4gICAqIEBleHRlbmRzIFR3by5QYXRoXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4MT0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBmaXJzdCB2ZXJ0ZXggb24gdGhlIGxpbmUuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5MT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBmaXJzdCB2ZXJ0ZXggb24gdGhlIGxpbmUuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4Mj0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgdmVydGV4IG9uIHRoZSBsaW5lLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeTI9MF0gLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHZlcnRleCBvbiB0aGUgbGluZS5cclxuICAgKi9cclxuICB2YXIgTGluZSA9IFR3by5MaW5lID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcclxuXHJcbiAgICB2YXIgd2lkdGggPSB4MiAtIHgxO1xyXG4gICAgdmFyIGhlaWdodCA9IHkyIC0geTE7XHJcblxyXG4gICAgdmFyIHcyID0gd2lkdGggLyAyO1xyXG4gICAgdmFyIGgyID0gaGVpZ2h0IC8gMjtcclxuXHJcbiAgICBQYXRoLmNhbGwodGhpcywgW1xyXG4gICAgICAgIG5ldyBUd28uQW5jaG9yKHgxLCB5MSksXHJcbiAgICAgICAgbmV3IFR3by5BbmNob3IoeDIsIHkyKVxyXG4gICAgXSk7XHJcblxyXG4gICAgdGhpcy52ZXJ0aWNlc1swXS5jb21tYW5kID0gVHdvLkNvbW1hbmRzLm1vdmU7XHJcbiAgICB0aGlzLnZlcnRpY2VzWzFdLmNvbW1hbmQgPSBUd28uQ29tbWFuZHMubGluZTtcclxuXHJcbiAgICB0aGlzLmF1dG9tYXRpYyA9IGZhbHNlO1xyXG5cclxuICB9O1xyXG5cclxuICBfLmV4dGVuZChMaW5lLnByb3RvdHlwZSwgUGF0aC5wcm90b3R5cGUpO1xyXG4gIExpbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZTtcclxuXHJcbiAgUGF0aC5NYWtlT2JzZXJ2YWJsZShMaW5lLnByb3RvdHlwZSk7XHJcblxyXG59KSgodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiAodGhpcyB8fCBzZWxmIHx8IHdpbmRvdykpLlR3byk7XHJcblxuKGZ1bmN0aW9uKFR3bykge1xyXG5cclxuICB2YXIgUGF0aCA9IFR3by5QYXRoO1xyXG4gIHZhciBfID0gVHdvLlV0aWxzO1xyXG5cclxuICAvKipcclxuICAgKiBAbmFtZSBUd28uUmVjdGFuZ2xlXHJcbiAgICogQGNsYXNzXHJcbiAgICogQGV4dGVuZHMgVHdvLlBhdGhcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgcmVjdGFuZ2xlLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSByZWN0YW5nbGUuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIHZhbHVlIG9mIHRoZSByZWN0YW5nbGUuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSB3aWR0aCB2YWx1ZSBvZiB0aGUgcmVjdGFuZ2xlLlxyXG4gICAqL1xyXG4gIHZhciBSZWN0YW5nbGUgPSBUd28uUmVjdGFuZ2xlID0gZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG5cclxuICAgIFBhdGguY2FsbCh0aGlzLCBbXHJcbiAgICAgIG5ldyBUd28uQW5jaG9yKCksXHJcbiAgICAgIG5ldyBUd28uQW5jaG9yKCksXHJcbiAgICAgIG5ldyBUd28uQW5jaG9yKCksXHJcbiAgICAgIG5ldyBUd28uQW5jaG9yKClcclxuICAgICAgLy8gbmV3IFR3by5BbmNob3IoKSAvLyBUT0RPOiBGaWd1cmUgb3V0IGhvdyB0byBoYW5kbGUgdGhpcyBmb3IgYGJlZ2lubmluZ2AgLyBgZW5kaW5nYCBhbmltYXRpb25zXHJcbiAgICBdLCB0cnVlLCBmYWxzZSwgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUmVjdGFuZ2xlI3dpZHRoXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgc2l6ZSBvZiB0aGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUmVjdGFuZ2xlI2hlaWdodFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHNpemUgb2YgdGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5SZWN0YW5nbGUjb3JpZ2luXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBBIHR3by1jb21wb25lbnQgdmVjdG9yIGRlc2NyaWJpbmcgdGhlIG9yaWdpbiBvZmZzZXQgdG8gZHJhdyB0aGUgcmVjdGFuZ2xlLiBEZWZhdWx0IGlzIGAwLCAwYC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vcmlnaW4gPSBuZXcgVHdvLlZlY3RvcigpO1xyXG4gICAgdGhpcy50cmFuc2xhdGlvbi5zZXQoeCwgeSk7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcblxyXG4gIH07XHJcblxyXG4gIF8uZXh0ZW5kKFJlY3RhbmdsZSwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlJlY3RhbmdsZS5Qcm9wZXJ0aWVzXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uUmVjdGFuZ2xlfS5cclxuICAgICAqL1xyXG4gICAgUHJvcGVydGllczogWyd3aWR0aCcsICdoZWlnaHQnXSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5SZWN0YW5nbGUuTWFrZU9ic2VydmFibGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5SZWN0YW5nbGV9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIHRoZSB7QGxpbmsgVHdvLlJlY3RhbmdsZX0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXHJcbiAgICAgKi9cclxuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmplY3QpIHtcclxuXHJcbiAgICAgIFBhdGguTWFrZU9ic2VydmFibGUob2JqZWN0KTtcclxuICAgICAgXy5lYWNoKFJlY3RhbmdsZS5Qcm9wZXJ0aWVzLCBUd28uVXRpbHMuZGVmaW5lUHJvcGVydHksIG9iamVjdCk7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnb3JpZ2luJywge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW47XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgIGlmICh0aGlzLl9vcmlnaW4pIHtcclxuICAgICAgICAgICAgdGhpcy5fb3JpZ2luLnVuYmluZChUd28uRXZlbnRzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1ZlcnRpY2VzKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuX29yaWdpbiA9IHY7XHJcbiAgICAgICAgICB0aGlzLl9vcmlnaW4uYmluZChUd28uRXZlbnRzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1ZlcnRpY2VzKTtcclxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmZsYWdWZXJ0aWNlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbiAgXy5leHRlbmQoUmVjdGFuZ2xlLnByb3RvdHlwZSwgUGF0aC5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5SZWN0YW5nbGUjX2ZsYWdXaWR0aFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUmVjdGFuZ2xlI3dpZHRofSBuZWVkcyB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdXaWR0aDogMCxcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlJlY3RhbmdsZSNfZmxhZ0hlaWdodFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUmVjdGFuZ2xlI2hlaWdodH0gbmVlZHMgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnSGVpZ2h0OiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlJlY3RhbmdsZSNfd2lkdGhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUmVjdGFuZ2xlI3dpZHRofVxyXG4gICAgICovXHJcbiAgICBfd2lkdGg6IDAsXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5SZWN0YW5nbGUjX2hlaWdodFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5SZWN0YW5nbGUjaGVpZ2h0fVxyXG4gICAgICovXHJcbiAgICBfaGVpZ2h0OiAwLFxyXG5cclxuICAgIF9vcmlnaW46IG51bGwsXHJcblxyXG4gICAgY29uc3RydWN0b3I6IFJlY3RhbmdsZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5SZWN0YW5nbGUjX3VwZGF0ZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSByZW5kZXJpbmcgaGFwcGVucyBieSB0aGUgcmVuZGVyZXIuIFRoaXMgYXBwbGllcyBhbGwgY2hhbmdlcyBuZWNlc3Nhcnkgc28gdGhhdCByZW5kZXJpbmcgaXMgdXAtdG8tZGF0ZSBidXQgbm90IHVwZGF0ZWQgbW9yZSB0aGFuIGl0IG5lZWRzIHRvIGJlLlxyXG4gICAgICogQG5vdGEtYmVuZSBUcnkgbm90IHRvIGNhbGwgdGhpcyBtZXRob2QgbW9yZSB0aGFuIG9uY2UgYSBmcmFtZS5cclxuICAgICAqL1xyXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICBpZiAodGhpcy5fZmxhZ1dpZHRoIHx8IHRoaXMuX2ZsYWdIZWlnaHQpIHtcclxuXHJcbiAgICAgICAgdmFyIHhyID0gdGhpcy5fd2lkdGggLyAyO1xyXG4gICAgICAgIHZhciB5ciA9IHRoaXMuX2hlaWdodCAvIDI7XHJcblxyXG4gICAgICAgIHRoaXMudmVydGljZXNbMF0uc2V0KC14ciwgLXlyKS5hZGQodGhpcy5fb3JpZ2luKS5jb21tYW5kID0gVHdvLkNvbW1hbmRzLm1vdmU7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlc1sxXS5zZXQoeHIsIC15cikuYWRkKHRoaXMuX29yaWdpbikuY29tbWFuZCA9IFR3by5Db21tYW5kcy5saW5lO1xyXG4gICAgICAgIHRoaXMudmVydGljZXNbMl0uc2V0KHhyLCB5cikuYWRkKHRoaXMuX29yaWdpbikuY29tbWFuZCA9IFR3by5Db21tYW5kcy5saW5lO1xyXG4gICAgICAgIHRoaXMudmVydGljZXNbM10uc2V0KC14ciwgeXIpLmFkZCh0aGlzLl9vcmlnaW4pLmNvbW1hbmQgPSBUd28uQ29tbWFuZHMubGluZTtcclxuICAgICAgICAvLyBGWUk6IFR3by5TcHJpdGUgYW5kIFR3by5JbWFnZVNlcXVlbmNlIGhhdmUgNCB2ZXJ0c1xyXG4gICAgICAgIGlmICh0aGlzLnZlcnRpY2VzWzRdKSB7XHJcbiAgICAgICAgICB0aGlzLnZlcnRpY2VzWzRdLnNldCgteHIsIC15cikuYWRkKHRoaXMuX29yaWdpbikuY29tbWFuZCA9IFR3by5Db21tYW5kcy5saW5lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFBhdGgucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUmVjdGFuZ2xlI2ZsYWdSZXNldFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKi9cclxuICAgIGZsYWdSZXNldDogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB0aGlzLl9mbGFnV2lkdGggPSB0aGlzLl9mbGFnSGVpZ2h0ID0gZmFsc2U7XHJcbiAgICAgIFBhdGgucHJvdG90eXBlLmZsYWdSZXNldC5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5SZWN0YW5nbGUjY2xvbmVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IFtwYXJlbnRdIC0gVGhlIHBhcmVudCBncm91cCBvciBzY2VuZSB0byBhZGQgdGhlIGNsb25lIHRvLlxyXG4gICAgICogQHJldHVybnMge1R3by5SZWN0YW5nbGV9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd28uUmVjdGFuZ2xlfSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgcGF0aC5cclxuICAgICAqL1xyXG4gICAgY2xvbmU6IGZ1bmN0aW9uKHBhcmVudCkge1xyXG5cclxuICAgICAgdmFyIGNsb25lID0gbmV3IFJlY3RhbmdsZSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcblxyXG4gICAgICBjbG9uZS50cmFuc2xhdGlvbi5jb3B5KHRoaXMudHJhbnNsYXRpb24pO1xyXG4gICAgICBjbG9uZS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XHJcbiAgICAgIGNsb25lLnNjYWxlID0gdGhpcy5zY2FsZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm1hdHJpeC5tYW51YWwpIHtcclxuICAgICAgICBjbG9uZS5tYXRyaXguY29weSh0aGlzLm1hdHJpeCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF8uZWFjaChUd28uUGF0aC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihrKSB7XHJcbiAgICAgICAgY2xvbmVba10gPSB0aGlzW2tdO1xyXG4gICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNsb25lO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUmVjdGFuZ2xlI3RvT2JqZWN0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhdGguXHJcbiAgICAgKi9cclxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHZhciBvYmplY3QgPSBQYXRoLnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xyXG4gICAgICBvYmplY3Qud2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgICBvYmplY3QuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgIG9iamVjdC5vcmlnaW4gPSB0aGlzLm9yaWdpbi50b09iamVjdCgpO1xyXG4gICAgICByZXR1cm4gb2JqZWN0O1xyXG5cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIFJlY3RhbmdsZS5NYWtlT2JzZXJ2YWJsZShSZWN0YW5nbGUucHJvdG90eXBlKTtcclxuXHJcbn0pKCh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6ICh0aGlzIHx8IHNlbGYgfHwgd2luZG93KSkuVHdvKTtcclxuXG4oZnVuY3Rpb24oVHdvKSB7XHJcblxyXG4gIHZhciBQYXRoID0gVHdvLlBhdGgsIFRXT19QSSA9IE1hdGguUEkgKiAyLCBIQUxGX1BJID0gTWF0aC5QSSAvIDI7XHJcbiAgdmFyIGNvcyA9IE1hdGguY29zLCBzaW4gPSBNYXRoLnNpbjtcclxuICB2YXIgXyA9IFR3by5VdGlscztcclxuXHJcbiAgLyoqXHJcbiAgICogQG5hbWUgVHdvLkVsbGlwc2VcclxuICAgKiBAY2xhc3NcclxuICAgKiBAZXh0ZW5kcyBUd28uUGF0aFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBlbGxpcHNlLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBlbGxpcHNlLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByeCAtIFRoZSByYWRpdXMgdmFsdWUgb2YgdGhlIGVsbGlwc2UgaW4gdGhlIHggZGlyZWN0aW9uLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByeSAtIFRoZSByYWRpdXMgdmFsdWUgb2YgdGhlIGVsbGlwc2UgaW4gdGhlIHkgZGlyZWN0aW9uLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcmVzb2x1dGlvbj00XSAtIFRoZSBudW1iZXIgb2YgdmVydGljZXMgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIGVsbGlwc2UuXHJcbiAgICovXHJcbiAgdmFyIEVsbGlwc2UgPSBUd28uRWxsaXBzZSA9IGZ1bmN0aW9uKG94LCBveSwgcngsIHJ5LCByZXNvbHV0aW9uKSB7XHJcblxyXG4gICAgaWYgKCFfLmlzTnVtYmVyKHJ5KSkge1xyXG4gICAgICByeSA9IHJ4O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEF0IGxlYXN0IDIgdmVydGljZXMgYXJlIHJlcXVpcmVkIGZvciBwcm9wZXIgY2lyY2xhZ2VcclxuICAgIHZhciBhbW91bnQgPSByZXNvbHV0aW9uID8gTWF0aC5tYXgocmVzb2x1dGlvbiwgMikgOiA0O1xyXG5cclxuICAgIHZhciBwb2ludHMgPSBfLm1hcChfLnJhbmdlKGFtb3VudCksIGZ1bmN0aW9uKGkpIHtcclxuICAgICAgcmV0dXJuIG5ldyBUd28uQW5jaG9yKCk7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICBQYXRoLmNhbGwodGhpcywgcG9pbnRzLCB0cnVlLCB0cnVlLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5FbGxpcHNlI3dpZHRoXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgd2lkdGggb2YgdGhlIGVsbGlwc2UuXHJcbiAgICAgKi9cclxuICAgIHRoaXMud2lkdGggPSByeCAqIDI7XHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5FbGxpcHNlI2hlaWdodFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGhlaWdodCBvZiB0aGUgZWxsaXBzZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5oZWlnaHQgPSByeSAqIDI7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICB0aGlzLnRyYW5zbGF0aW9uLnNldChveCwgb3kpO1xyXG5cclxuICB9O1xyXG5cclxuICBfLmV4dGVuZChFbGxpcHNlLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uRWxsaXBzZS5Qcm9wZXJ0aWVzXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uRWxsaXBzZX0uXHJcbiAgICAgKi9cclxuICAgIFByb3BlcnRpZXM6IFsnd2lkdGgnLCAnaGVpZ2h0J10sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uRWxsaXBzZS5NYWtlT2JzZXJ2YWJsZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYXBwbHkgb2JzZXJ2YWJsZSBxdWFsaXRpZXMgb2YgYSB7QGxpbmsgVHdvLkVsbGlwc2V9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIHRoZSB7QGxpbmsgVHdvLkVsbGlwc2V9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxyXG4gICAgICovXHJcbiAgICBNYWtlT2JzZXJ2YWJsZTogZnVuY3Rpb24ob2JqKSB7XHJcblxyXG4gICAgICBQYXRoLk1ha2VPYnNlcnZhYmxlKG9iaik7XHJcbiAgICAgIF8uZWFjaChFbGxpcHNlLlByb3BlcnRpZXMsIFR3by5VdGlscy5kZWZpbmVQcm9wZXJ0eSwgb2JqKTtcclxuXHJcbiAgICB9XHJcblxyXG4gIH0pO1xyXG5cclxuICBfLmV4dGVuZChFbGxpcHNlLnByb3RvdHlwZSwgUGF0aC5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5FbGxpcHNlI19mbGFnV2lkdGhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkVsbGlwc2Ujd2lkdGh9IG5lZWRzIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ1dpZHRoOiBmYWxzZSxcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkVsbGlwc2UjX2ZsYWdIZWlnaHRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkVsbGlwc2UjaGVpZ2h0fSBuZWVkcyB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdIZWlnaHQ6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jX3dpZHRoXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLkVsbGlwc2Ujd2lkdGh9XHJcbiAgICAgKi9cclxuICAgIF93aWR0aDogMCxcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jX2hlaWdodFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5FbGxpcHNlI2hlaWdodH1cclxuICAgICAqL1xyXG4gICAgX2hlaWdodDogMCxcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogRWxsaXBzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5FbGxpcHNlI191cGRhdGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cclxuICAgICAqIEBub3RhLWJlbmUgVHJ5IG5vdCB0byBjYWxsIHRoaXMgbWV0aG9kIG1vcmUgdGhhbiBvbmNlIGEgZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2ZsYWdXaWR0aCB8fCB0aGlzLl9mbGFnSGVpZ2h0KSB7XHJcbiAgICAgICAgLy8gQ29lZmZpY2llbnQgZm9yIGFwcHJveGltYXRpbmcgY2lyY3VsYXIgYXJjcyB3aXRoIEJlemllciBjdXJ2ZXNcclxuICAgICAgICB2YXIgYyA9ICg0IC8gMykgKiBNYXRoLnRhbihNYXRoLlBJIC8gKHRoaXMudmVydGljZXMubGVuZ3RoICogMikpO1xyXG4gICAgICAgIHZhciByYWRpdXNYID0gdGhpcy5fd2lkdGggLyAyO1xyXG4gICAgICAgIHZhciByYWRpdXNZID0gdGhpcy5faGVpZ2h0IC8gMjtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG51bVZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBudW1WZXJ0aWNlczsgaSsrKSB7XHJcbiAgICAgICAgICB2YXIgcGN0ID0gaSAvIG51bVZlcnRpY2VzO1xyXG4gICAgICAgICAgdmFyIHRoZXRhID0gcGN0ICogVFdPX1BJO1xyXG5cclxuICAgICAgICAgIHZhciB4ID0gcmFkaXVzWCAqIGNvcyh0aGV0YSk7XHJcbiAgICAgICAgICB2YXIgeSA9IHJhZGl1c1kgKiBzaW4odGhldGEpO1xyXG5cclxuICAgICAgICAgIHZhciBseCA9IHJhZGl1c1ggKiBjICogY29zKHRoZXRhIC0gSEFMRl9QSSk7XHJcbiAgICAgICAgICB2YXIgbHkgPSByYWRpdXNZICogYyAqIHNpbih0aGV0YSAtIEhBTEZfUEkpO1xyXG5cclxuICAgICAgICAgIHZhciByeCA9IHJhZGl1c1ggKiBjICogY29zKHRoZXRhICsgSEFMRl9QSSk7XHJcbiAgICAgICAgICB2YXIgcnkgPSByYWRpdXNZICogYyAqIHNpbih0aGV0YSArIEhBTEZfUEkpO1xyXG5cclxuICAgICAgICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlc1tpXTtcclxuXHJcbiAgICAgICAgICB2LmNvbW1hbmQgPSBUd28uQ29tbWFuZHMuY3VydmU7XHJcbiAgICAgICAgICB2LnNldCh4LCB5KTtcclxuICAgICAgICAgIHYuY29udHJvbHMubGVmdC5zZXQobHgsIGx5KTtcclxuICAgICAgICAgIHYuY29udHJvbHMucmlnaHQuc2V0KHJ4LCByeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBQYXRoLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uRWxsaXBzZSNmbGFnUmVzZXRcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxyXG4gICAgICovXHJcbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdGhpcy5fZmxhZ1dpZHRoID0gdGhpcy5fZmxhZ0hlaWdodCA9IGZhbHNlO1xyXG5cclxuICAgICAgUGF0aC5wcm90b3R5cGUuZmxhZ1Jlc2V0LmNhbGwodGhpcyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uRWxsaXBzZSNjbG9uZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLlBvbHlnb259XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd28uUG9seWdvbn0gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHBhdGguXHJcbiAgICAgKi9cclxuICAgIGNsb25lOiBmdW5jdGlvbihwYXJlbnQpIHtcclxuXHJcbiAgICAgIHZhciByeCA9IHRoaXMud2lkdGggLyAyO1xyXG4gICAgICB2YXIgcnkgPSB0aGlzLmhlaWdodCAvIDI7XHJcbiAgICAgIHZhciByZXNvbHV0aW9uID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHJcbiAgICAgIHZhciBjbG9uZSA9IG5ldyBFbGxpcHNlKDAsIDAsIHJ4LCByeSwgcmVzb2x1dGlvbik7XHJcblxyXG4gICAgICBjbG9uZS50cmFuc2xhdGlvbi5jb3B5KHRoaXMudHJhbnNsYXRpb24pO1xyXG4gICAgICBjbG9uZS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XHJcbiAgICAgIGNsb25lLnNjYWxlID0gdGhpcy5zY2FsZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm1hdHJpeC5tYW51YWwpIHtcclxuICAgICAgICBjbG9uZS5tYXRyaXguY29weSh0aGlzLm1hdHJpeCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF8uZWFjaChUd28uUGF0aC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihrKSB7XHJcbiAgICAgICAgY2xvbmVba10gPSB0aGlzW2tdO1xyXG4gICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNsb25lO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uRWxsaXBzZSN0b09iamVjdFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoLlxyXG4gICAgICovXHJcbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB2YXIgb2JqZWN0ID0gUGF0aC5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgIF8uZWFjaChFbGxpcHNlLlByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BlcnR5KSB7XHJcbiAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IHRoaXNbcHJvcGVydHldO1xyXG4gICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgIHJldHVybiBvYmplY3Q7XHJcblxyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbiAgRWxsaXBzZS5NYWtlT2JzZXJ2YWJsZShFbGxpcHNlLnByb3RvdHlwZSk7XHJcblxyXG59KSgodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiAodGhpcyB8fCBzZWxmIHx8IHdpbmRvdykpLlR3byk7XHJcblxuKGZ1bmN0aW9uKFR3bykge1xyXG5cclxuICB2YXIgUGF0aCA9IFR3by5QYXRoLCBUV09fUEkgPSBNYXRoLlBJICogMiwgSEFMRl9QSSA9IE1hdGguUEkgLyAyO1xyXG4gIHZhciBjb3MgPSBNYXRoLmNvcywgc2luID0gTWF0aC5zaW47XHJcbiAgdmFyIF8gPSBUd28uVXRpbHM7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuYW1lIFR3by5DaXJjbGVcclxuICAgKiBAY2xhc3NcclxuICAgKiBAZXh0ZW5kcyBUd28uUGF0aFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBjaXJjbGUuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIGNpcmNsZS5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyB2YWx1ZSBvZiB0aGUgY2lyY2xlLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcmVzb2x1dGlvbj00XSAtIFRoZSBudW1iZXIgb2YgdmVydGljZXMgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIGNpcmNsZS5cclxuICAgKi9cclxuICB2YXIgQ2lyY2xlID0gVHdvLkNpcmNsZSA9IGZ1bmN0aW9uKG94LCBveSwgciwgcmVzb2x1dGlvbikge1xyXG5cclxuICAgIC8vIEF0IGxlYXN0IDIgdmVydGljZXMgYXJlIHJlcXVpcmVkIGZvciBwcm9wZXIgY2lyY2xhZ2VcclxuICAgIHZhciBhbW91bnQgPSByZXNvbHV0aW9uID8gTWF0aC5tYXgocmVzb2x1dGlvbiwgMikgOiA0O1xyXG5cclxuICAgIHZhciBwb2ludHMgPSBfLm1hcChfLnJhbmdlKGFtb3VudCksIGZ1bmN0aW9uKGkpIHtcclxuICAgICAgcmV0dXJuIG5ldyBUd28uQW5jaG9yKCk7XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICBQYXRoLmNhbGwodGhpcywgcG9pbnRzLCB0cnVlLCB0cnVlLCB0cnVlKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5DaXJjbGUjcmFkaXVzXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgc2l6ZSBvZiB0aGUgcmFkaXVzIG9mIHRoZSBjaXJjbGUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmFkaXVzID0gcjtcclxuXHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuXHJcbiAgICBpZiAoXy5pc051bWJlcihveCkpIHtcclxuICAgICAgdGhpcy50cmFuc2xhdGlvbi54ID0gb3g7XHJcbiAgICB9XHJcbiAgICBpZiAoXy5pc051bWJlcihveSkpIHtcclxuICAgICAgdGhpcy50cmFuc2xhdGlvbi55ID0gb3k7XHJcbiAgICB9XHJcblxyXG4gIH07XHJcblxyXG4gIF8uZXh0ZW5kKENpcmNsZSwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkNpcmNsZS5Qcm9wZXJ0aWVzXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uQ2lyY2xlfS5cclxuICAgICAqL1xyXG4gICAgUHJvcGVydGllczogWydyYWRpdXMnXSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5DaXJjbGUuTWFrZU9ic2VydmFibGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5DaXJjbGV9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIHRoZSB7QGxpbmsgVHdvLkNpcmNsZX0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXHJcbiAgICAgKi9cclxuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmopIHtcclxuXHJcbiAgICAgIFBhdGguTWFrZU9ic2VydmFibGUob2JqKTtcclxuICAgICAgXy5lYWNoKENpcmNsZS5Qcm9wZXJ0aWVzLCBUd28uVXRpbHMuZGVmaW5lUHJvcGVydHksIG9iaik7XHJcblxyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbiAgXy5leHRlbmQoQ2lyY2xlLnByb3RvdHlwZSwgUGF0aC5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5DaXJjbGUjX2ZsYWdSYWRpdXNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkNpcmNsZSNyYWRpdXN9IG5lZWRzIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ1JhZGl1czogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uQ2lyY2xlI19yYWRpdXNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAc2VlIHtAbGluayBUd28uQ2lyY2xlI3JhZGl1c31cclxuICAgICAqL1xyXG4gICAgX3JhZGl1czogMCxcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogQ2lyY2xlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkNpcmNsZSNfdXBkYXRlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVzPWZhbHNlXSAtIEZvcmNlIHRoZSBwYXJlbnQgdG8gYF91cGRhdGVgIGFzIHdlbGwuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHJlbmRlcmluZyBoYXBwZW5zIGJ5IHRoZSByZW5kZXJlci4gVGhpcyBhcHBsaWVzIGFsbCBjaGFuZ2VzIG5lY2Vzc2FyeSBzbyB0aGF0IHJlbmRlcmluZyBpcyB1cC10by1kYXRlIGJ1dCBub3QgdXBkYXRlZCBtb3JlIHRoYW4gaXQgbmVlZHMgdG8gYmUuXHJcbiAgICAgKiBAbm90YS1iZW5lIFRyeSBub3QgdG8gY2FsbCB0aGlzIG1ldGhvZCBtb3JlIHRoYW4gb25jZSBhIGZyYW1lLlxyXG4gICAgICovXHJcbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9mbGFnUmFkaXVzKSB7XHJcbiAgICAgICAgLy8gQ29lZmZpY2llbnQgZm9yIGFwcHJveGltYXRpbmcgY2lyY3VsYXIgYXJjcyB3aXRoIEJlemllciBjdXJ2ZXNcclxuICAgICAgICB2YXIgYyA9ICg0IC8gMykgKiBNYXRoLnRhbihNYXRoLlBJIC8gKHRoaXMudmVydGljZXMubGVuZ3RoICogMikpO1xyXG5cclxuICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIHZhciByYyA9IHJhZGl1cyAqIGM7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBudW1WZXJ0aWNlcyA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgbnVtVmVydGljZXM7IGkrKykge1xyXG4gICAgICAgICAgdmFyIHBjdCA9IGkgLyBudW1WZXJ0aWNlcztcclxuICAgICAgICAgIHZhciB0aGV0YSA9IHBjdCAqIFRXT19QSTtcclxuXHJcbiAgICAgICAgICB2YXIgeCA9IHJhZGl1cyAqIGNvcyh0aGV0YSk7XHJcbiAgICAgICAgICB2YXIgeSA9IHJhZGl1cyAqIHNpbih0aGV0YSk7XHJcblxyXG4gICAgICAgICAgdmFyIGx4ID0gcmMgKiBjb3ModGhldGEgLSBIQUxGX1BJKTtcclxuICAgICAgICAgIHZhciBseSA9IHJjICogc2luKHRoZXRhIC0gSEFMRl9QSSk7XHJcblxyXG4gICAgICAgICAgdmFyIHJ4ID0gcmMgKiBjb3ModGhldGEgKyBIQUxGX1BJKTtcclxuICAgICAgICAgIHZhciByeSA9IHJjICogc2luKHRoZXRhICsgSEFMRl9QSSk7XHJcblxyXG4gICAgICAgICAgdmFyIHYgPSB0aGlzLnZlcnRpY2VzW2ldO1xyXG5cclxuICAgICAgICAgIHYuY29tbWFuZCA9IFR3by5Db21tYW5kcy5jdXJ2ZTtcclxuICAgICAgICAgIHYuc2V0KHgsIHkpO1xyXG4gICAgICAgICAgdi5jb250cm9scy5sZWZ0LnNldChseCwgbHkpO1xyXG4gICAgICAgICAgdi5jb250cm9scy5yaWdodC5zZXQocngsIHJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFBhdGgucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5DaXJjbGUjZmxhZ1Jlc2V0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIGludGVybmFsbHkgdG8gcmVzZXQgYWxsIGZsYWdzLiBFbnN1cmVzIHRoYXQgb25seSBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIGFyZSB1cGRhdGVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSByZW5kZXJlci5cclxuICAgICAqL1xyXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHRoaXMuX2ZsYWdSYWRpdXMgPSBmYWxzZTtcclxuXHJcbiAgICAgIFBhdGgucHJvdG90eXBlLmZsYWdSZXNldC5jYWxsKHRoaXMpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkNpcmNsZSNjbG9uZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLkNpcmNsZX1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3by5DaXJjbGV9IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBwYXRoLlxyXG4gICAgICovXHJcbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XHJcblxyXG4gICAgICB2YXIgY2xvbmUgPSBuZXcgQ2lyY2xlKDAsIDAsIHRoaXMucmFkaXVzLCB0aGlzLnZlcnRpY2VzLmxlbmd0aCk7XHJcblxyXG4gICAgICBjbG9uZS50cmFuc2xhdGlvbi5jb3B5KHRoaXMudHJhbnNsYXRpb24pO1xyXG4gICAgICBjbG9uZS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XHJcbiAgICAgIGNsb25lLnNjYWxlID0gdGhpcy5zY2FsZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm1hdHJpeC5tYW51YWwpIHtcclxuICAgICAgICBjbG9uZS5tYXRyaXguY29weSh0aGlzLm1hdHJpeCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF8uZWFjaChUd28uUGF0aC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihrKSB7XHJcbiAgICAgICAgY2xvbmVba10gPSB0aGlzW2tdO1xyXG4gICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNsb25lO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uQ2lyY2xlI3RvT2JqZWN0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhdGguXHJcbiAgICAgKi9cclxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHZhciBvYmplY3QgPSBQYXRoLnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgXy5lYWNoKENpcmNsZS5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xyXG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSB0aGlzW3Byb3BlcnR5XTtcclxuICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICByZXR1cm4gb2JqZWN0O1xyXG5cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIENpcmNsZS5NYWtlT2JzZXJ2YWJsZShDaXJjbGUucHJvdG90eXBlKTtcclxuXHJcbn0pKCh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6ICh0aGlzIHx8IHNlbGYgfHwgd2luZG93KSkuVHdvKTtcclxuXG4oZnVuY3Rpb24oVHdvKSB7XHJcblxyXG4gIHZhciBQYXRoID0gVHdvLlBhdGgsIFRXT19QSSA9IE1hdGguUEkgKiAyLCBjb3MgPSBNYXRoLmNvcywgc2luID0gTWF0aC5zaW47XHJcbiAgdmFyIF8gPSBUd28uVXRpbHM7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuYW1lIFR3by5Qb2x5Z29uXHJcbiAgICogQGNsYXNzXHJcbiAgICogQGV4dGVuZHMgVHdvLlBhdGhcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgcG9seWdvbi5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgcG9seWdvbi5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyB2YWx1ZSBvZiB0aGUgcG9seWdvbi5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3NpZGVzPTEyXSAtIFRoZSBudW1iZXIgb2YgdmVydGljZXMgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHBvbHlnb24uXHJcbiAgICovXHJcbiAgdmFyIFBvbHlnb24gPSBUd28uUG9seWdvbiA9IGZ1bmN0aW9uKG94LCBveSwgciwgc2lkZXMpIHtcclxuXHJcbiAgICBzaWRlcyA9IE1hdGgubWF4KHNpZGVzIHx8IDAsIDMpO1xyXG5cclxuICAgIFBhdGguY2FsbCh0aGlzKTtcclxuXHJcbiAgICB0aGlzLmNsb3NlZCA9IHRydWU7XHJcbiAgICB0aGlzLmF1dG9tYXRpYyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jd2lkdGhcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBzaXplIG9mIHRoZSB3aWR0aCBvZiB0aGUgcG9seWdvbi5cclxuICAgICAqL1xyXG4gICAgdGhpcy53aWR0aCA9IHIgKiAyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUG9seWdvbiNoZWlnaHRcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBzaXplIG9mIHRoZSBoZWlnaHQgb2YgdGhlIHBvbHlnb24uXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGVpZ2h0ID0gciAqIDI7XHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Qb2x5Z29uI3NpZGVzXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgYW1vdW50IG9mIHNpZGVzIHRoZSBwb2x5b2duIGhhcy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zaWRlcyA9IHNpZGVzO1xyXG5cclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gICAgdGhpcy50cmFuc2xhdGlvbi5zZXQob3gsIG95KTtcclxuXHJcbiAgfTtcclxuXHJcbiAgXy5leHRlbmQoUG9seWdvbiwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24uUHJvcGVydGllc1xyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLlBvbHlnb259LlxyXG4gICAgICovXHJcbiAgICBQcm9wZXJ0aWVzOiBbJ3dpZHRoJywgJ2hlaWdodCcsICdzaWRlcyddLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24uTWFrZU9ic2VydmFibGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5Qb2x5Z29ufSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCB0aGUge0BsaW5rIFR3by5Qb2x5Z29ufSBjbGFzcyBvbiBhIGN1c3RvbSBjbGFzcy5cclxuICAgICAqL1xyXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iaikge1xyXG5cclxuICAgICAgUGF0aC5NYWtlT2JzZXJ2YWJsZShvYmopO1xyXG4gICAgICBfLmVhY2goUG9seWdvbi5Qcm9wZXJ0aWVzLCBUd28uVXRpbHMuZGVmaW5lUHJvcGVydHksIG9iaik7XHJcblxyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbiAgXy5leHRlbmQoUG9seWdvbi5wcm90b3R5cGUsIFBhdGgucHJvdG90eXBlLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUG9seWdvbiNfZmxhZ1dpZHRoXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Qb2x5Z29uI3dpZHRofSBuZWVkcyB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdXaWR0aDogZmFsc2UsXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Qb2x5Z29uI19mbGFnSGVpZ2h0XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Qb2x5Z29uI2hlaWdodH0gbmVlZHMgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnSGVpZ2h0OiBmYWxzZSxcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jX2ZsYWdTaWRlc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUG9seWdvbiNzaWRlc30gbmVlZHMgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnU2lkZXM6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jX3dpZHRoXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBvbHlnb24jd2lkdGh9XHJcbiAgICAgKi9cclxuICAgIF93aWR0aDogMCxcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jX2hlaWdodFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5Qb2x5Z29uI2hlaWdodH1cclxuICAgICAqL1xyXG4gICAgX2hlaWdodDogMCxcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jX3NpZGVzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBvbHlnb24jc2lkZXN9XHJcbiAgICAgKi9cclxuICAgIF9zaWRlczogMCxcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogUG9seWdvbixcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Qb2x5Z29uI191cGRhdGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cclxuICAgICAqIEBub3RhLWJlbmUgVHJ5IG5vdCB0byBjYWxsIHRoaXMgbWV0aG9kIG1vcmUgdGhhbiBvbmNlIGEgZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2ZsYWdXaWR0aCB8fCB0aGlzLl9mbGFnSGVpZ2h0IHx8IHRoaXMuX2ZsYWdTaWRlcykge1xyXG5cclxuICAgICAgICB2YXIgc2lkZXMgPSB0aGlzLl9zaWRlcztcclxuICAgICAgICB2YXIgYW1vdW50ID0gc2lkZXMgKyAxO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKGxlbmd0aCA+IHNpZGVzKSB7XHJcbiAgICAgICAgICB0aGlzLnZlcnRpY2VzLnNwbGljZShzaWRlcyAtIDEsIGxlbmd0aCAtIHNpZGVzKTtcclxuICAgICAgICAgIGxlbmd0aCA9IHNpZGVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xyXG5cclxuICAgICAgICAgIHZhciBwY3QgPSAoaSArIDAuNSkgLyBzaWRlcztcclxuICAgICAgICAgIHZhciB0aGV0YSA9IFRXT19QSSAqIHBjdCArIE1hdGguUEkgLyAyO1xyXG4gICAgICAgICAgdmFyIHggPSB0aGlzLl93aWR0aCAqIGNvcyh0aGV0YSkgLyAyO1xyXG4gICAgICAgICAgdmFyIHkgPSB0aGlzLl9oZWlnaHQgKiBzaW4odGhldGEpIC8gMjtcclxuXHJcbiAgICAgICAgICBpZiAoaSA+PSBsZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyBUd28uQW5jaG9yKHgsIHkpKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbaV0uc2V0KHgsIHkpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMudmVydGljZXNbaV0uY29tbWFuZCA9IGkgPT09IDBcclxuICAgICAgICAgICAgPyBUd28uQ29tbWFuZHMubW92ZSA6IFR3by5Db21tYW5kcy5saW5lO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgICBQYXRoLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUG9seWdvbiNmbGFnUmVzZXRcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxyXG4gICAgICovXHJcbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdGhpcy5fZmxhZ1dpZHRoID0gdGhpcy5fZmxhZ0hlaWdodCA9IHRoaXMuX2ZsYWdTaWRlcyA9IGZhbHNlO1xyXG4gICAgICBQYXRoLnByb3RvdHlwZS5mbGFnUmVzZXQuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUG9seWdvbiNjbG9uZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLlBvbHlnb259XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd28uUG9seWdvbn0gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHBhdGguXHJcbiAgICAgKi9cclxuICAgIGNsb25lOiBmdW5jdGlvbihwYXJlbnQpIHtcclxuXHJcbiAgICAgIHZhciBjbG9uZSA9IG5ldyBQb2x5Z29uKDAsIDAsIHRoaXMucmFkaXVzLCB0aGlzLnNpZGVzKTtcclxuXHJcbiAgICAgIGNsb25lLnRyYW5zbGF0aW9uLmNvcHkodGhpcy50cmFuc2xhdGlvbik7XHJcbiAgICAgIGNsb25lLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcclxuICAgICAgY2xvbmUuc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG5cclxuICAgICAgaWYgKHRoaXMubWF0cml4Lm1hbnVhbCkge1xyXG4gICAgICAgIGNsb25lLm1hdHJpeC5jb3B5KHRoaXMubWF0cml4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgXy5lYWNoKFR3by5QYXRoLlByb3BlcnRpZXMsIGZ1bmN0aW9uKGspIHtcclxuICAgICAgICBjbG9uZVtrXSA9IHRoaXNba107XHJcbiAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgIHBhcmVudC5hZGQoY2xvbmUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gY2xvbmU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Qb2x5Z29uI3RvT2JqZWN0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhdGguXHJcbiAgICAgKi9cclxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHZhciBvYmplY3QgPSBQYXRoLnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgXy5lYWNoKFBvbHlnb24uUHJvcGVydGllcywgZnVuY3Rpb24ocHJvcGVydHkpIHtcclxuICAgICAgICBvYmplY3RbcHJvcGVydHldID0gdGhpc1twcm9wZXJ0eV07XHJcbiAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgcmV0dXJuIG9iamVjdDtcclxuXHJcbiAgICB9XHJcblxyXG4gIH0pO1xyXG5cclxuICBQb2x5Z29uLk1ha2VPYnNlcnZhYmxlKFBvbHlnb24ucHJvdG90eXBlKTtcclxuXHJcbn0pKCh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6ICh0aGlzIHx8IHNlbGYgfHwgd2luZG93KSkuVHdvKTtcclxuXG4oZnVuY3Rpb24oVHdvKSB7XHJcblxyXG4gIHZhciBQYXRoID0gVHdvLlBhdGgsIFBJID0gTWF0aC5QSSwgVFdPX1BJID0gTWF0aC5QSSAqIDIsIEhBTEZfUEkgPSBNYXRoLlBJIC8gMixcclxuICAgIGNvcyA9IE1hdGguY29zLCBzaW4gPSBNYXRoLnNpbiwgYWJzID0gTWF0aC5hYnMsIF8gPSBUd28uVXRpbHMsXHJcbiAgICBtb2QgPSBUd28uVXRpbHMubW9kO1xyXG5cclxuICAvKipcclxuICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudFxyXG4gICAqIEBjbGFzc1xyXG4gICAqIEBleHRlbmRzIFR3by5QYXRoXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIGFyYyBzZWdtZW50LlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBhcmMgc2VnbWVudC5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5uZXJSYWRpdXMgLSBUaGUgaW5uZXIgcmFkaXVzIHZhbHVlIG9mIHRoZSBhcmMgc2VnbWVudC5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gb3V0ZXJSYWRpdXMgLSBUaGUgb3V0ZXIgcmFkaXVzIHZhbHVlIG9mIHRoZSBhcmMgc2VnbWVudC5cclxuICAgKiBAcGFyYW0ge1JhZGlhbnN9IHN0YXJ0QW5nbGUgLSBUaGUgc3RhcnQgYW5nbGUgb2YgdGhlIGFyYyBzZWdtZW50IGluIHJhZGlhbnMuXHJcbiAgICogQHBhcmFtIHtSYWRpYW5zfSBlbmRBbmdsZSAtIFRoZSBlbmQgYW5nbGUgb2YgdGhlIGFyYyBzZWdtZW50IGluIHJhZGlhbnMuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyZXNvbHV0aW9uPTI0XSAtIFRoZSBudW1iZXIgb2YgdmVydGljZXMgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIGFyYyBzZWdtZW50LlxyXG4gICAqL1xyXG4gIHZhciBBcmNTZWdtZW50ID0gVHdvLkFyY1NlZ21lbnQgPSBmdW5jdGlvbihveCwgb3ksIGlyLCBvciwgc2EsIGVhLCByZXMpIHtcclxuXHJcbiAgICB2YXIgYW1vdW50ID0gcmVzIHx8IChUd28uUmVzb2x1dGlvbiAqIDMpO1xyXG4gICAgdmFyIHBvaW50cyA9IF8ubWFwKF8ucmFuZ2UoYW1vdW50KSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBuZXcgVHdvLkFuY2hvcigpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgUGF0aC5jYWxsKHRoaXMsIHBvaW50cywgdHJ1ZSwgZmFsc2UsIHRydWUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQjaW5uZXJSYWRpdXNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBzaXplIG9mIHRoZSBpbm5lciByYWRpdXMgb2YgdGhlIGFyYyBzZWdtZW50LlxyXG4gICAgICovXHJcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gaXI7XHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50I291dGVyUmFkaXVzXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgc2l6ZSBvZiB0aGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBhcmMgc2VnbWVudC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG9yO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQjc3RhcnRSYWRpdXNcclxuICAgICAqIEBwcm9wZXJ0eSB7UmFkaWFuc30gLSBUaGUgYW5nbGUgb2Ygb25lIHNpZGUgZm9yIHRoZSBhcmMgc2VnbWVudC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdGFydEFuZ2xlID0gc2E7XHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50I2VuZEFuZ2xlXHJcbiAgICAgKiBAcHJvcGVydHkge1JhZGlhbnN9IC0gVGhlIGFuZ2xlIG9mIHRoZSBvdGhlciBzaWRlIGZvciB0aGUgYXJjIHNlZ21lbnQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZW5kQW5nbGUgPSBlYTtcclxuXHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuXHJcbiAgICBpZiAoXy5pc051bWJlcihveCkpIHtcclxuICAgICAgdGhpcy50cmFuc2xhdGlvbi54ID0gb3g7XHJcbiAgICB9XHJcbiAgICBpZiAoXy5pc051bWJlcihveSkpIHtcclxuICAgICAgdGhpcy50cmFuc2xhdGlvbi55ID0gb3k7XHJcbiAgICB9XHJcblxyXG4gIH07XHJcblxyXG4gIF8uZXh0ZW5kKEFyY1NlZ21lbnQsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50LlByb3BlcnRpZXNcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IC0gQSBsaXN0IG9mIHByb3BlcnRpZXMgdGhhdCBhcmUgb24gZXZlcnkge0BsaW5rIFR3by5BcmNTZWdtZW50fS5cclxuICAgICAqL1xyXG4gICAgUHJvcGVydGllczogWydzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJ10sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudC5NYWtlT2JzZXJ2YWJsZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYXBwbHkgb2JzZXJ2YWJsZSBxdWFsaXRpZXMgb2YgYSB7QGxpbmsgVHdvLkFyY1NlZ21lbnR9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIHRoZSB7QGxpbmsgVHdvLkFyY1NlZ21lbnR9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxyXG4gICAgICovXHJcbiAgICBNYWtlT2JzZXJ2YWJsZTogZnVuY3Rpb24ob2JqKSB7XHJcblxyXG4gICAgICBQYXRoLk1ha2VPYnNlcnZhYmxlKG9iaik7XHJcbiAgICAgIF8uZWFjaChBcmNTZWdtZW50LlByb3BlcnRpZXMsIFR3by5VdGlscy5kZWZpbmVQcm9wZXJ0eSwgb2JqKTtcclxuXHJcbiAgICB9XHJcblxyXG4gIH0pO1xyXG5cclxuICBfLmV4dGVuZChBcmNTZWdtZW50LnByb3RvdHlwZSwgUGF0aC5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50I19mbGFnU3RhcnRBbmdsZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uQXJjU2VnbWVudCNzdGFydEFuZ2xlfSBuZWVkcyB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdTdGFydEFuZ2xlOiBmYWxzZSxcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQjX2ZsYWdFbmRBbmdsZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uQXJjU2VnbWVudCNlbmRBbmdsZX0gbmVlZHMgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnRW5kQW5nbGU6IGZhbHNlLFxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudCNfZmxhZ0lubmVyUmFkaXVzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5BcmNTZWdtZW50I2lubmVyUmFkaXVzfSBuZWVkcyB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdJbm5lclJhZGl1czogZmFsc2UsXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50I19mbGFnT3V0ZXJSYWRpdXNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkFyY1NlZ21lbnQjb3V0ZXJSYWRpdXN9IG5lZWRzIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ091dGVyUmFkaXVzOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50I19zdGFydEFuZ2xlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLkFyY1NlZ21lbnQjc3RhcnRBbmdsZX1cclxuICAgICAqL1xyXG4gICAgX3N0YXJ0QW5nbGU6IDAsXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50I19lbmRBbmdsZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5BcmNTZWdtZW50I2VuZEFuZ2xlfVxyXG4gICAgICovXHJcbiAgICBfZW5kQW5nbGU6IFRXT19QSSxcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQjX2lubmVyUmFkaXVzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLkFyY1NlZ21lbnQjaW5uZXJSYWRpdXN9XHJcbiAgICAgKi9cclxuICAgIF9pbm5lclJhZGl1czogMCxcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQjX291dGVyUmFkaXVzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLkFyY1NlZ21lbnQjb3V0ZXJSYWRpdXN9XHJcbiAgICAgKi9cclxuICAgIF9vdXRlclJhZGl1czogMCxcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogQXJjU2VnbWVudCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50I191cGRhdGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cclxuICAgICAqIEBub3RhLWJlbmUgVHJ5IG5vdCB0byBjYWxsIHRoaXMgbWV0aG9kIG1vcmUgdGhhbiBvbmNlIGEgZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2ZsYWdTdGFydEFuZ2xlIHx8IHRoaXMuX2ZsYWdFbmRBbmdsZSB8fCB0aGlzLl9mbGFnSW5uZXJSYWRpdXNcclxuICAgICAgICB8fCB0aGlzLl9mbGFnT3V0ZXJSYWRpdXMpIHtcclxuXHJcbiAgICAgICAgdmFyIHNhID0gdGhpcy5fc3RhcnRBbmdsZTtcclxuICAgICAgICB2YXIgZWEgPSB0aGlzLl9lbmRBbmdsZTtcclxuXHJcbiAgICAgICAgdmFyIGlyID0gdGhpcy5faW5uZXJSYWRpdXM7XHJcbiAgICAgICAgdmFyIG9yID0gdGhpcy5fb3V0ZXJSYWRpdXM7XHJcblxyXG4gICAgICAgIHZhciBjb25uZWN0ZWQgPSBtb2Qoc2EsIFRXT19QSSkgPT09IG1vZChlYSwgVFdPX1BJKTtcclxuICAgICAgICB2YXIgcHVuY3R1cmVkID0gaXIgPiAwO1xyXG5cclxuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSAocHVuY3R1cmVkID8gdmVydGljZXMubGVuZ3RoIC8gMiA6IHZlcnRpY2VzLmxlbmd0aCk7XHJcbiAgICAgICAgdmFyIGNvbW1hbmQsIGlkID0gMDtcclxuXHJcbiAgICAgICAgaWYgKGNvbm5lY3RlZCkge1xyXG4gICAgICAgICAgbGVuZ3RoLS07XHJcbiAgICAgICAgfSBlbHNlIGlmICghcHVuY3R1cmVkKSB7XHJcbiAgICAgICAgICBsZW5ndGggLT0gMjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE91dGVyIENpcmNsZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsYXN0ID0gbGVuZ3RoIC0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgdmFyIHBjdCA9IGkgLyBsYXN0O1xyXG4gICAgICAgICAgdmFyIHYgPSB2ZXJ0aWNlc1tpZF07XHJcbiAgICAgICAgICB2YXIgdGhldGEgPSBwY3QgKiAoZWEgLSBzYSkgKyBzYTtcclxuICAgICAgICAgIHZhciBzdGVwID0gKGVhIC0gc2EpIC8gbGVuZ3RoO1xyXG5cclxuICAgICAgICAgIHZhciB4ID0gb3IgKiBNYXRoLmNvcyh0aGV0YSk7XHJcbiAgICAgICAgICB2YXIgeSA9IG9yICogTWF0aC5zaW4odGhldGEpO1xyXG5cclxuICAgICAgICAgIHN3aXRjaCAoaSkge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgY29tbWFuZCA9IFR3by5Db21tYW5kcy5tb3ZlO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIGNvbW1hbmQgPSBUd28uQ29tbWFuZHMuY3VydmU7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdi5jb21tYW5kID0gY29tbWFuZDtcclxuICAgICAgICAgIHYueCA9IHg7XHJcbiAgICAgICAgICB2LnkgPSB5O1xyXG4gICAgICAgICAgdi5jb250cm9scy5sZWZ0LmNsZWFyKCk7XHJcbiAgICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LmNsZWFyKCk7XHJcblxyXG4gICAgICAgICAgaWYgKHYuY29tbWFuZCA9PT0gVHdvLkNvbW1hbmRzLmN1cnZlKSB7XHJcbiAgICAgICAgICAgIHZhciBhbXAgPSBvciAqIHN0ZXAgLyBNYXRoLlBJO1xyXG4gICAgICAgICAgICB2LmNvbnRyb2xzLmxlZnQueCA9IGFtcCAqIE1hdGguY29zKHRoZXRhIC0gSEFMRl9QSSk7XHJcbiAgICAgICAgICAgIHYuY29udHJvbHMubGVmdC55ID0gYW1wICogTWF0aC5zaW4odGhldGEgLSBIQUxGX1BJKTtcclxuICAgICAgICAgICAgdi5jb250cm9scy5yaWdodC54ID0gYW1wICogTWF0aC5jb3ModGhldGEgKyBIQUxGX1BJKTtcclxuICAgICAgICAgICAgdi5jb250cm9scy5yaWdodC55ID0gYW1wICogTWF0aC5zaW4odGhldGEgKyBIQUxGX1BJKTtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDEpIHtcclxuICAgICAgICAgICAgICB2LmNvbnRyb2xzLmxlZnQubXVsdGlwbHlTY2FsYXIoMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGkgPT09IGxhc3QpIHtcclxuICAgICAgICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0Lm11bHRpcGx5U2NhbGFyKDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWQrKztcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocHVuY3R1cmVkKSB7XHJcblxyXG4gICAgICAgICAgaWYgKGNvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICB2ZXJ0aWNlc1tpZF0uY29tbWFuZCA9IFR3by5Db21tYW5kcy5jbG9zZTtcclxuICAgICAgICAgICAgaWQrKztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxlbmd0aC0tO1xyXG4gICAgICAgICAgICBsYXN0ID0gbGVuZ3RoIC0gMTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvKipcclxuICAgICAgICAgICAqIElubmVyIENpcmNsZVxyXG4gICAgICAgICAgICovXHJcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIHBjdCA9IGkgLyBsYXN0O1xyXG4gICAgICAgICAgICB2ID0gdmVydGljZXNbaWRdO1xyXG4gICAgICAgICAgICB0aGV0YSA9ICgxIC0gcGN0KSAqIChlYSAtIHNhKSArIHNhO1xyXG4gICAgICAgICAgICBzdGVwID0gKGVhIC0gc2EpIC8gbGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgeCA9IGlyICogTWF0aC5jb3ModGhldGEpO1xyXG4gICAgICAgICAgICB5ID0gaXIgKiBNYXRoLnNpbih0aGV0YSk7XHJcbiAgICAgICAgICAgIGNvbW1hbmQgPSBUd28uQ29tbWFuZHMuY3VydmU7XHJcbiAgICAgICAgICAgIGlmIChpIDw9IDApIHtcclxuICAgICAgICAgICAgICBjb21tYW5kID0gY29ubmVjdGVkID8gVHdvLkNvbW1hbmRzLm1vdmUgOiBUd28uQ29tbWFuZHMubGluZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdi5jb21tYW5kID0gY29tbWFuZDtcclxuICAgICAgICAgICAgdi54ID0geDtcclxuICAgICAgICAgICAgdi55ID0geTtcclxuICAgICAgICAgICAgdi5jb250cm9scy5sZWZ0LmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHYuY29udHJvbHMucmlnaHQuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh2LmNvbW1hbmQgPT09IFR3by5Db21tYW5kcy5jdXJ2ZSkge1xyXG4gICAgICAgICAgICAgIGFtcCA9IGlyICogc3RlcCAvIE1hdGguUEk7XHJcbiAgICAgICAgICAgICAgdi5jb250cm9scy5sZWZ0LnggPSBhbXAgKiBNYXRoLmNvcyh0aGV0YSArIEhBTEZfUEkpO1xyXG4gICAgICAgICAgICAgIHYuY29udHJvbHMubGVmdC55ID0gYW1wICogTWF0aC5zaW4odGhldGEgKyBIQUxGX1BJKTtcclxuICAgICAgICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LnggPSBhbXAgKiBNYXRoLmNvcyh0aGV0YSAtIEhBTEZfUEkpO1xyXG4gICAgICAgICAgICAgIHYuY29udHJvbHMucmlnaHQueSA9IGFtcCAqIE1hdGguc2luKHRoZXRhIC0gSEFMRl9QSSk7XHJcbiAgICAgICAgICAgICAgaWYgKGkgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHYuY29udHJvbHMubGVmdC5tdWx0aXBseVNjYWxhcigyKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgaWYgKGkgPT09IGxhc3QpIHtcclxuICAgICAgICAgICAgICAgIHYuY29udHJvbHMucmlnaHQubXVsdGlwbHlTY2FsYXIoMik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZCsrO1xyXG5cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBGaW5hbCBQb2ludFxyXG4gICAgICAgICAgdmVydGljZXNbaWRdLmNvcHkodmVydGljZXNbMF0pO1xyXG4gICAgICAgICAgdmVydGljZXNbaWRdLmNvbW1hbmQgPSBUd28uQ29tbWFuZHMubGluZTtcclxuXHJcbiAgICAgICAgfSBlbHNlIGlmICghY29ubmVjdGVkKSB7XHJcblxyXG4gICAgICAgICAgdmVydGljZXNbaWRdLmNvbW1hbmQgPSBUd28uQ29tbWFuZHMubGluZTtcclxuICAgICAgICAgIHZlcnRpY2VzW2lkXS54ID0gMDtcclxuICAgICAgICAgIHZlcnRpY2VzW2lkXS55ID0gMDtcclxuICAgICAgICAgIGlkKys7XHJcblxyXG4gICAgICAgICAgLy8gRmluYWwgUG9pbnRcclxuICAgICAgICAgIHZlcnRpY2VzW2lkXS5jb3B5KHZlcnRpY2VzWzBdKTtcclxuICAgICAgICAgIHZlcnRpY2VzW2lkXS5jb21tYW5kID0gVHdvLkNvbW1hbmRzLmxpbmU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFBhdGgucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudCNmbGFnUmVzZXRcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxyXG4gICAgICovXHJcbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgUGF0aC5wcm90b3R5cGUuZmxhZ1Jlc2V0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgICB0aGlzLl9mbGFnU3RhcnRBbmdsZSA9IHRoaXMuX2ZsYWdFbmRBbmdsZVxyXG4gICAgICAgID0gdGhpcy5fZmxhZ0lubmVyUmFkaXVzID0gdGhpcy5fZmxhZ091dGVyUmFkaXVzID0gZmFsc2U7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQjY2xvbmVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IFtwYXJlbnRdIC0gVGhlIHBhcmVudCBncm91cCBvciBzY2VuZSB0byBhZGQgdGhlIGNsb25lIHRvLlxyXG4gICAgICogQHJldHVybnMge1R3by5BcmNTZWdtZW50fVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLkFyY1NlZ21lbnR9IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBwYXRoLlxyXG4gICAgICovXHJcbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XHJcblxyXG4gICAgICB2YXIgaXIgPSB0aGlzLmlubmVyUmFkaXVzO1xyXG4gICAgICB2YXIgb3IgPSB0aGlzLm91dGVycmFkaXVzO1xyXG4gICAgICB2YXIgc2EgPSB0aGlzLnN0YXJ0QW5nbGU7XHJcbiAgICAgIHZhciBlYSA9IHRoaXMuZW5kQW5nbGU7XHJcbiAgICAgIHZhciByZXNvbHV0aW9uID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG4gICAgICB2YXIgY2xvbmUgPSBuZXcgQXJjU2VnbWVudCgwLCAwLCBpciwgb3IsIHNhLCBlYSwgcmVzb2x1dGlvbik7XHJcblxyXG4gICAgICBjbG9uZS50cmFuc2xhdGlvbi5jb3B5KHRoaXMudHJhbnNsYXRpb24pO1xyXG4gICAgICBjbG9uZS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XHJcbiAgICAgIGNsb25lLnNjYWxlID0gdGhpcy5zY2FsZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm1hdHJpeC5tYW51YWwpIHtcclxuICAgICAgICBjbG9uZS5tYXRyaXguY29weSh0aGlzLm1hdHJpeCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF8uZWFjaChUd28uUGF0aC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihrKSB7XHJcbiAgICAgICAgY2xvbmVba10gPSB0aGlzW2tdO1xyXG4gICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNsb25lO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudCN0b09iamVjdFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoLlxyXG4gICAgICovXHJcbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB2YXIgb2JqZWN0ID0gUGF0aC5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgIF8uZWFjaChBcmNTZWdtZW50LlByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BlcnR5KSB7XHJcbiAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IHRoaXNbcHJvcGVydHldO1xyXG4gICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgIHJldHVybiBvYmplY3Q7XHJcblxyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbiAgQXJjU2VnbWVudC5NYWtlT2JzZXJ2YWJsZShBcmNTZWdtZW50LnByb3RvdHlwZSk7XHJcblxyXG59KSgodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiAodGhpcyB8fCBzZWxmIHx8IHdpbmRvdykpLlR3byk7XHJcblxuKGZ1bmN0aW9uKFR3bykge1xyXG5cclxuICB2YXIgUGF0aCA9IFR3by5QYXRoLCBUV09fUEkgPSBNYXRoLlBJICogMiwgY29zID0gTWF0aC5jb3MsIHNpbiA9IE1hdGguc2luO1xyXG4gIHZhciBfID0gVHdvLlV0aWxzO1xyXG5cclxuICAvKipcclxuICAgKiBAbmFtZSBUd28uU3RhclxyXG4gICAqIEBjbGFzc1xyXG4gICAqIEBleHRlbmRzIFR3by5QYXRoXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHN0YXIuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHN0YXIuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGlubmVyUmFkaXVzIC0gVGhlIGlubmVyIHJhZGl1cyB2YWx1ZSBvZiB0aGUgc3Rhci5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gb3V0ZXJSYWRpdXMgLSBUaGUgb3V0ZXIgcmFkaXVzIHZhbHVlIG9mIHRoZSBzdGFyLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc2lkZXM9NV0gLSBUaGUgbnVtYmVyIG9mIHNpZGVzIHVzZWQgdG8gY29uc3RydWN0IHRoZSBzdGFyLlxyXG4gICAqL1xyXG4gIHZhciBTdGFyID0gVHdvLlN0YXIgPSBmdW5jdGlvbihveCwgb3ksIGlyLCBvciwgc2lkZXMpIHtcclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAzKSB7XHJcbiAgICAgIG9yID0gaXI7XHJcbiAgICAgIGlyID0gb3IgLyAyO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghXy5pc051bWJlcihzaWRlcykgfHwgc2lkZXMgPD0gMCkge1xyXG4gICAgICBzaWRlcyA9IDU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGxlbmd0aCA9IHNpZGVzICogMjtcclxuXHJcbiAgICBQYXRoLmNhbGwodGhpcyk7XHJcbiAgICB0aGlzLmNsb3NlZCA9IHRydWU7XHJcbiAgICB0aGlzLmF1dG9tYXRpYyA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlN0YXIjaW5uZXJSYWRpdXNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBzaXplIG9mIHRoZSBpbm5lciByYWRpdXMgb2YgdGhlIHN0YXIuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSBpcjtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlN0YXIjb3V0ZXJSYWRpdXNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBzaXplIG9mIHRoZSBvdXRlciByYWRpdXMgb2YgdGhlIHN0YXIuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvcjtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlN0YXIjc2lkZXNcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBhbW91bnQgb2Ygc2lkZXMgdGhlIHN0YXIgaGFzLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnNpZGVzID0gc2lkZXM7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICB0aGlzLnRyYW5zbGF0aW9uLnNldChveCwgb3kpO1xyXG5cclxuICB9O1xyXG5cclxuICBfLmV4dGVuZChTdGFyLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3Rhci5Qcm9wZXJ0aWVzXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uU3Rhcn0uXHJcbiAgICAgKi9cclxuICAgIFByb3BlcnRpZXM6IFsnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAnc2lkZXMnXSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TdGFyLk1ha2VPYnNlcnZhYmxlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uU3Rhcn0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uU3Rhcn0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXHJcbiAgICAgKi9cclxuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmopIHtcclxuXHJcbiAgICAgIFBhdGguTWFrZU9ic2VydmFibGUob2JqKTtcclxuICAgICAgXy5lYWNoKFN0YXIuUHJvcGVydGllcywgVHdvLlV0aWxzLmRlZmluZVByb3BlcnR5LCBvYmopO1xyXG5cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIF8uZXh0ZW5kKFN0YXIucHJvdG90eXBlLCBQYXRoLnByb3RvdHlwZSwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlN0YXIjX2ZsYWdJbm5lclJhZGl1c1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uU3RhciNpbm5lclJhZGl1c30gbmVlZHMgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnSW5uZXJSYWRpdXM6IGZhbHNlLFxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3RhciNfZmxhZ091dGVyUmFkaXVzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5TdGFyI291dGVyUmFkaXVzfSBuZWVkcyB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdPdXRlclJhZGl1czogZmFsc2UsXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TdGFyI19mbGFnU2lkZXNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlN0YXIjc2lkZXN9IG5lZWRzIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ1NpZGVzOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TdGFyI19pbm5lclJhZGl1c1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5TdGFyI2lubmVyUmFkaXVzfVxyXG4gICAgICovXHJcbiAgICBfaW5uZXJSYWRpdXM6IDAsXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TdGFyI19vdXRlclJhZGl1c1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5TdGFyI291dGVyUmFkaXVzfVxyXG4gICAgICovXHJcbiAgICBfb3V0ZXJSYWRpdXM6IDAsXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TdGFyI19zaWRlc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5TdGFyI3NpZGVzfVxyXG4gICAgICovXHJcbiAgICBfc2lkZXM6IDAsXHJcblxyXG4gICAgY29uc3RydWN0b3I6IFN0YXIsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3RhciNfdXBkYXRlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVzPWZhbHNlXSAtIEZvcmNlIHRoZSBwYXJlbnQgdG8gYF91cGRhdGVgIGFzIHdlbGwuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHJlbmRlcmluZyBoYXBwZW5zIGJ5IHRoZSByZW5kZXJlci4gVGhpcyBhcHBsaWVzIGFsbCBjaGFuZ2VzIG5lY2Vzc2FyeSBzbyB0aGF0IHJlbmRlcmluZyBpcyB1cC10by1kYXRlIGJ1dCBub3QgdXBkYXRlZCBtb3JlIHRoYW4gaXQgbmVlZHMgdG8gYmUuXHJcbiAgICAgKiBAbm90YS1iZW5lIFRyeSBub3QgdG8gY2FsbCB0aGlzIG1ldGhvZCBtb3JlIHRoYW4gb25jZSBhIGZyYW1lLlxyXG4gICAgICovXHJcbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9mbGFnSW5uZXJSYWRpdXMgfHwgdGhpcy5fZmxhZ091dGVyUmFkaXVzIHx8IHRoaXMuX2ZsYWdTaWRlcykge1xyXG5cclxuICAgICAgICB2YXIgc2lkZXMgPSB0aGlzLl9zaWRlcyAqIDI7XHJcbiAgICAgICAgdmFyIGFtb3VudCA9IHNpZGVzICsgMTtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChsZW5ndGggPiBzaWRlcykge1xyXG4gICAgICAgICAgdGhpcy52ZXJ0aWNlcy5zcGxpY2Uoc2lkZXMgLSAxLCBsZW5ndGggLSBzaWRlcyk7XHJcbiAgICAgICAgICBsZW5ndGggPSBzaWRlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcclxuXHJcbiAgICAgICAgICB2YXIgcGN0ID0gKGkgKyAwLjUpIC8gc2lkZXM7XHJcbiAgICAgICAgICB2YXIgdGhldGEgPSBUV09fUEkgKiBwY3Q7XHJcbiAgICAgICAgICB2YXIgciA9ICghKGkgJSAyKSA/IHRoaXMuX2lubmVyUmFkaXVzIDogdGhpcy5fb3V0ZXJSYWRpdXMpIC8gMjtcclxuICAgICAgICAgIHZhciB4ID0gciAqIGNvcyh0aGV0YSk7XHJcbiAgICAgICAgICB2YXIgeSA9IHIgKiBzaW4odGhldGEpO1xyXG5cclxuICAgICAgICAgIGlmIChpID49IGxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2gobmV3IFR3by5BbmNob3IoeCwgeSkpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlc1tpXS5zZXQoeCwgeSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhpcy52ZXJ0aWNlc1tpXS5jb21tYW5kID0gaSA9PT0gMFxyXG4gICAgICAgICAgICA/IFR3by5Db21tYW5kcy5tb3ZlIDogVHdvLkNvbW1hbmRzLmxpbmU7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIFBhdGgucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3RhciNmbGFnUmVzZXRcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxyXG4gICAgICovXHJcbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdGhpcy5fZmxhZ0lubmVyUmFkaXVzID0gdGhpcy5fZmxhZ091dGVyUmFkaXVzID0gdGhpcy5fZmxhZ1NpZGVzID0gZmFsc2U7XHJcbiAgICAgIFBhdGgucHJvdG90eXBlLmZsYWdSZXNldC5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TdGFyI2Nsb25lXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7VHdvLkdyb3VwfSBbcGFyZW50XSAtIFRoZSBwYXJlbnQgZ3JvdXAgb3Igc2NlbmUgdG8gYWRkIHRoZSBjbG9uZSB0by5cclxuICAgICAqIEByZXR1cm5zIHtUd28uU3Rhcn1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3by5TdGFyfSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgcGF0aC5cclxuICAgICAqL1xyXG4gICAgY2xvbmU6IGZ1bmN0aW9uKHBhcmVudCkge1xyXG5cclxuICAgICAgdmFyIGlyID0gdGhpcy5pbm5lclJhZGl1cztcclxuICAgICAgdmFyIG9yID0gdGhpcy5vdXRlclJhZGl1cztcclxuICAgICAgdmFyIHNpZGVzID0gdGhpcy5zaWRlcztcclxuXHJcbiAgICAgIHZhciBjbG9uZSA9IG5ldyBTdGFyKDAsIDAsIGlyLCBvciwgc2lkZXMpO1xyXG5cclxuICAgICAgY2xvbmUudHJhbnNsYXRpb24uY29weSh0aGlzLnRyYW5zbGF0aW9uKTtcclxuICAgICAgY2xvbmUucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xyXG4gICAgICBjbG9uZS5zY2FsZSA9IHRoaXMuc2NhbGU7XHJcblxyXG4gICAgICBpZiAodGhpcy5tYXRyaXgubWFudWFsKSB7XHJcbiAgICAgICAgY2xvbmUubWF0cml4LmNvcHkodGhpcy5tYXRyaXgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBfLmVhY2goVHdvLlBhdGguUHJvcGVydGllcywgZnVuY3Rpb24oaykge1xyXG4gICAgICAgIGNsb25lW2tdID0gdGhpc1trXTtcclxuICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgcGFyZW50LmFkZChjbG9uZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBjbG9uZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlN0YXIjdG9PYmplY3RcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGF0aC5cclxuICAgICAqL1xyXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdmFyIG9iamVjdCA9IFBhdGgucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgICBfLmVhY2goU3Rhci5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xyXG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSB0aGlzW3Byb3BlcnR5XTtcclxuICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICByZXR1cm4gb2JqZWN0O1xyXG5cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIFN0YXIuTWFrZU9ic2VydmFibGUoU3Rhci5wcm90b3R5cGUpO1xyXG5cclxufSkoKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogKHRoaXMgfHwgc2VsZiB8fCB3aW5kb3cpKS5Ud28pO1xyXG5cbihmdW5jdGlvbihUd28pIHtcclxuXHJcbiAgdmFyIFBhdGggPSBUd28uUGF0aDtcclxuICB2YXIgXyA9IFR3by5VdGlscztcclxuXHJcbiAgLyoqXHJcbiAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGVcclxuICAgKiBAY2xhc3NcclxuICAgKiBAZXh0ZW5kcyBUd28uUGF0aFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSByb3VuZGVkIHJlY3RhbmdsZS5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGUuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIHZhbHVlIG9mIHRoZSByb3VuZGVkIHJlY3RhbmdsZS5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIHdpZHRoIHZhbHVlIG9mIHRoZSByb3VuZGVkIHJlY3RhbmdsZS5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyB2YWx1ZSBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGUuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyZXNvbHV0aW9uPTEyXSAtIFRoZSBudW1iZXIgb2YgdmVydGljZXMgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlLlxyXG4gICAqL1xyXG4gIHZhciBSb3VuZGVkUmVjdGFuZ2xlID0gVHdvLlJvdW5kZWRSZWN0YW5nbGUgPSBmdW5jdGlvbihveCwgb3ksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xyXG5cclxuICAgIGlmIChfLmlzVW5kZWZpbmVkKHJhZGl1cykpIHtcclxuICAgICAgcmFkaXVzID0gTWF0aC5mbG9vcihNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDEyKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYW1vdW50ID0gMTA7XHJcblxyXG4gICAgdmFyIHBvaW50cyA9IF8ubWFwKF8ucmFuZ2UoYW1vdW50KSwgZnVuY3Rpb24oaSkge1xyXG4gICAgICByZXR1cm4gbmV3IFR3by5BbmNob3IoMCwgMCwgMCwgMCwgMCwgMCxcclxuICAgICAgICBpID09PSAwID8gVHdvLkNvbW1hbmRzLm1vdmUgOiBUd28uQ29tbWFuZHMuY3VydmUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXS5jb21tYW5kID0gVHdvLkNvbW1hbmRzLmNsb3NlO1xyXG5cclxuICAgIFBhdGguY2FsbCh0aGlzLCBwb2ludHMpO1xyXG5cclxuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcclxuICAgIHRoaXMuYXV0b21hdGljID0gZmFsc2U7XHJcblxyXG4gICAgdGhpcy5fcmVuZGVyZXIuZmxhZ1JhZGl1cyA9IF8uYmluZChSb3VuZGVkUmVjdGFuZ2xlLkZsYWdSYWRpdXMsIHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUjd2lkdGhcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSB3aWR0aCBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUjaGVpZ2h0XHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgaGVpZ2h0IG9mIHRoZSByb3VuZGVkIHJlY3RhbmdsZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI3JhZGl1c1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHNpemUgb2YgdGhlIHJhZGl1cyBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xyXG5cclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gICAgdGhpcy50cmFuc2xhdGlvbi5zZXQob3gsIG95KTtcclxuXHJcbiAgfTtcclxuXHJcbiAgXy5leHRlbmQoUm91bmRlZFJlY3RhbmdsZSwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUuUHJvcGVydGllc1xyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLlJvdW5kZWRSZWN0YW5nbGV9LlxyXG4gICAgICovXHJcbiAgICBQcm9wZXJ0aWVzOiBbJ3dpZHRoJywgJ2hlaWdodCddLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUuRmxhZ1JhZGl1c1xyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gLSBBIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHRyaWdnZXIgdGhlIGZsYWcgZm9yIHJhZGl1cyBjaGFuZ2luZy5cclxuICAgICAqL1xyXG4gICAgRmxhZ1JhZGl1czogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMuX2ZsYWdSYWRpdXMgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Sb3VuZGVkUmVjdGFuZ2xlLk1ha2VPYnNlcnZhYmxlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uUm91bmRlZFJlY3RhbmdsZX0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uUm91bmRlZFJlY3RhbmdsZX0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXHJcbiAgICAgKi9cclxuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmplY3QpIHtcclxuXHJcbiAgICAgIFBhdGguTWFrZU9ic2VydmFibGUob2JqZWN0KTtcclxuICAgICAgXy5lYWNoKFJvdW5kZWRSZWN0YW5nbGUuUHJvcGVydGllcywgVHdvLlV0aWxzLmRlZmluZVByb3BlcnR5LCBvYmplY3QpO1xyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3JhZGl1cycsIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMuX3JhZGl1cyBpbnN0YW5jZW9mIFR3by5WZWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmFkaXVzLnVuYmluZChUd28uRXZlbnRzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1JhZGl1cyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhpcy5fcmFkaXVzID0gdjtcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5fcmFkaXVzIGluc3RhbmNlb2YgVHdvLlZlY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9yYWRpdXMuYmluZChUd28uRXZlbnRzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1JhZGl1cyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhpcy5fZmxhZ1JhZGl1cyA9IHRydWU7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbiAgXy5leHRlbmQoUm91bmRlZFJlY3RhbmdsZS5wcm90b3R5cGUsIFBhdGgucHJvdG90eXBlLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUm91bmRlZFJlY3RhbmdsZSNfZmxhZ1dpZHRoXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI3dpZHRofSBuZWVkcyB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdXaWR0aDogZmFsc2UsXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI19mbGFnSGVpZ2h0XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI2hlaWdodH0gbmVlZHMgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnSGVpZ2h0OiBmYWxzZSxcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUjX2ZsYWdSYWRpdXNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlJvdW5kZWRSZWN0YW5nbGUjcmFkaXVzfSBuZWVkcyB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdSYWRpdXM6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUjX3dpZHRoXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlJvdW5kZWRSZWN0YW5nbGUjd2lkdGh9XHJcbiAgICAgKi9cclxuICAgIF93aWR0aDogMCxcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUjX2hlaWdodFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI2hlaWdodH1cclxuICAgICAqL1xyXG4gICAgX2hlaWdodDogMCxcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUjX3JhZGl1c1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI3JhZGl1c31cclxuICAgICAqL1xyXG4gICAgX3JhZGl1czogMCxcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogUm91bmRlZFJlY3RhbmdsZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI191cGRhdGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cclxuICAgICAqIEBub3RhLWJlbmUgVHJ5IG5vdCB0byBjYWxsIHRoaXMgbWV0aG9kIG1vcmUgdGhhbiBvbmNlIGEgZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2ZsYWdXaWR0aCB8fCB0aGlzLl9mbGFnSGVpZ2h0IHx8IHRoaXMuX2ZsYWdSYWRpdXMpIHtcclxuXHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5fd2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcclxuXHJcbiAgICAgICAgdmFyIHJ4LCByeTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX3JhZGl1cyBpbnN0YW5jZW9mIFR3by5WZWN0b3IpIHtcclxuICAgICAgICAgIHJ4ID0gdGhpcy5fcmFkaXVzLng7XHJcbiAgICAgICAgICByeSA9IHRoaXMuX3JhZGl1cy55O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByeCA9IHRoaXMuX3JhZGl1cztcclxuICAgICAgICAgIHJ5ID0gdGhpcy5fcmFkaXVzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHY7XHJcbiAgICAgICAgdmFyIHcgPSB3aWR0aCAvIDI7XHJcbiAgICAgICAgdmFyIGggPSBoZWlnaHQgLyAyO1xyXG5cclxuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlc1swXTtcclxuICAgICAgICB2LnggPSAtICh3IC0gcngpO1xyXG4gICAgICAgIHYueSA9IC0gaDtcclxuXHJcbiAgICAgICAgLy8gVXBwZXIgUmlnaHQgQ29ybmVyXHJcblxyXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzWzFdO1xyXG4gICAgICAgIHYueCA9ICh3IC0gcngpO1xyXG4gICAgICAgIHYueSA9IC0gaDtcclxuICAgICAgICB2LmNvbnRyb2xzLmxlZnQuY2xlYXIoKTtcclxuICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LnggPSByeDtcclxuICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LnkgPSAwO1xyXG5cclxuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlc1syXTtcclxuICAgICAgICB2LnggPSB3O1xyXG4gICAgICAgIHYueSA9IC0gKGggLSByeSk7XHJcbiAgICAgICAgdi5jb250cm9scy5yaWdodC5jbGVhcigpO1xyXG4gICAgICAgIHYuY29udHJvbHMubGVmdC5jbGVhcigpO1xyXG5cclxuICAgICAgICAvLyBCb3R0b20gUmlnaHQgQ29ybmVyXHJcblxyXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzWzNdO1xyXG4gICAgICAgIHYueCA9IHc7XHJcbiAgICAgICAgdi55ID0gKGggLSByeSk7XHJcbiAgICAgICAgdi5jb250cm9scy5sZWZ0LmNsZWFyKCk7XHJcbiAgICAgICAgdi5jb250cm9scy5yaWdodC54ID0gMDtcclxuICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LnkgPSByeTtcclxuXHJcbiAgICAgICAgdiA9IHRoaXMudmVydGljZXNbNF07XHJcbiAgICAgICAgdi54ID0gKHcgLSByeCk7XHJcbiAgICAgICAgdi55ID0gaDtcclxuICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LmNsZWFyKCk7XHJcbiAgICAgICAgdi5jb250cm9scy5sZWZ0LmNsZWFyKCk7XHJcblxyXG4gICAgICAgIC8vIEJvdHRvbSBMZWZ0IENvcm5lclxyXG5cclxuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlc1s1XTtcclxuICAgICAgICB2LnggPSAtICh3IC0gcngpO1xyXG4gICAgICAgIHYueSA9IGg7XHJcbiAgICAgICAgdi5jb250cm9scy5sZWZ0LmNsZWFyKCk7XHJcbiAgICAgICAgdi5jb250cm9scy5yaWdodC54ID0gLSByeDtcclxuICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LnkgPSAwO1xyXG5cclxuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlc1s2XTtcclxuICAgICAgICB2LnggPSAtIHc7XHJcbiAgICAgICAgdi55ID0gKGggLSByeSk7XHJcbiAgICAgICAgdi5jb250cm9scy5sZWZ0LmNsZWFyKCk7XHJcbiAgICAgICAgdi5jb250cm9scy5yaWdodC5jbGVhcigpO1xyXG5cclxuICAgICAgICAvLyBVcHBlciBMZWZ0IENvcm5lclxyXG5cclxuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlc1s3XTtcclxuICAgICAgICB2LnggPSAtIHc7XHJcbiAgICAgICAgdi55ID0gLSAoaCAtIHJ5KTtcclxuICAgICAgICB2LmNvbnRyb2xzLmxlZnQuY2xlYXIoKTtcclxuICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LnggPSAwO1xyXG4gICAgICAgIHYuY29udHJvbHMucmlnaHQueSA9IC0gcnk7XHJcblxyXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzWzhdO1xyXG4gICAgICAgIHYueCA9IC0gKHcgLSByeCk7XHJcbiAgICAgICAgdi55ID0gLSBoO1xyXG4gICAgICAgIHYuY29udHJvbHMubGVmdC5jbGVhcigpO1xyXG4gICAgICAgIHYuY29udHJvbHMucmlnaHQuY2xlYXIoKTtcclxuXHJcbiAgICAgICAgdiA9IHRoaXMudmVydGljZXNbOV07XHJcbiAgICAgICAgdi5jb3B5KHRoaXMudmVydGljZXNbOF0pO1xyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgUGF0aC5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI2ZsYWdSZXNldFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKi9cclxuICAgIGZsYWdSZXNldDogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB0aGlzLl9mbGFnV2lkdGggPSB0aGlzLl9mbGFnSGVpZ2h0ID0gdGhpcy5fZmxhZ1JhZGl1cyA9IGZhbHNlO1xyXG4gICAgICBQYXRoLnByb3RvdHlwZS5mbGFnUmVzZXQuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUm91bmRlZFJlY3RhbmdsZSNjbG9uZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLlJvdW5kZWRSZWN0YW5nbGV9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd28uUm91bmRlZFJlY3RhbmdsZX0gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHBhdGguXHJcbiAgICAgKi9cclxuICAgIGNsb25lOiBmdW5jdGlvbihwYXJlbnQpIHtcclxuXHJcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgICAgdmFyIHJhZGl1cyA9IHRoaXMucmFkaXVzO1xyXG5cclxuICAgICAgdmFyIGNsb25lID0gbmV3IFJvdW5kZWRSZWN0YW5nbGUoMCwgMCwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKTtcclxuXHJcbiAgICAgIGNsb25lLnRyYW5zbGF0aW9uLmNvcHkodGhpcy50cmFuc2xhdGlvbik7XHJcbiAgICAgIGNsb25lLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcclxuICAgICAgY2xvbmUuc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG5cclxuICAgICAgaWYgKHRoaXMubWF0cml4Lm1hbnVhbCkge1xyXG4gICAgICAgIGNsb25lLm1hdHJpeC5jb3B5KHRoaXMubWF0cml4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgXy5lYWNoKFR3by5QYXRoLlByb3BlcnRpZXMsIGZ1bmN0aW9uKGspIHtcclxuICAgICAgICBjbG9uZVtrXSA9IHRoaXNba107XHJcbiAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgIHBhcmVudC5hZGQoY2xvbmUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gY2xvbmU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI3RvT2JqZWN0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhdGguXHJcbiAgICAgKi9cclxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHZhciBvYmplY3QgPSBQYXRoLnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgXy5lYWNoKFJvdW5kZWRSZWN0YW5nbGUuUHJvcGVydGllcywgZnVuY3Rpb24ocHJvcGVydHkpIHtcclxuICAgICAgICBvYmplY3RbcHJvcGVydHldID0gdGhpc1twcm9wZXJ0eV07XHJcbiAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgb2JqZWN0LnJhZGl1cyA9IF8uaXNOdW1iZXIodGhpcy5yYWRpdXMpXHJcbiAgICAgICAgPyB0aGlzLnJhZGl1cyA6IHRoaXMucmFkaXVzLnRvT2JqZWN0KCk7XHJcblxyXG4gICAgICByZXR1cm4gb2JqZWN0O1xyXG5cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIFJvdW5kZWRSZWN0YW5nbGUuTWFrZU9ic2VydmFibGUoUm91bmRlZFJlY3RhbmdsZS5wcm90b3R5cGUpO1xyXG5cclxufSkoKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogKHRoaXMgfHwgc2VsZiB8fCB3aW5kb3cpKS5Ud28pO1xyXG5cbihmdW5jdGlvbihUd28pIHtcclxuXHJcbiAgdmFyIHJvb3QgPSBUd28ucm9vdDtcclxuICB2YXIgZ2V0Q29tcHV0ZWRNYXRyaXggPSBUd28uVXRpbHMuZ2V0Q29tcHV0ZWRNYXRyaXg7XHJcbiAgdmFyIF8gPSBUd28uVXRpbHM7XHJcblxyXG4gIC8vIFVzZWQgd2l0aCBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgd2FzIGNhbGN1bGF0ZWQgdGhyb3VnaCB0aGUgY3R4LmdldFRleHRXaWR0aFxyXG4gIC8vIHZhciBjYW52YXMgPSBnZXRDYW52YXMoKTtcclxuICAvLyB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuYW1lIFR3by5UZXh0XHJcbiAgICogQGNsYXNzXHJcbiAgICogQGV4dGVuZHMgVHdvLlNoYXBlXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgLSBUaGUgU3RyaW5nIHRvIGJlIHJlbmRlcmVkIHRvIHRoZSBzY2VuZS5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gLSBUaGUgcG9zaXRpb24gaW4gdGhlIHggZGlyZWN0aW9uIGZvciB0aGUgb2JqZWN0LlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSAtIFRoZSBwb3NpdGlvbiBpbiB0aGUgeSBkaXJlY3Rpb24gZm9yIHRoZSBvYmplY3QuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZXNdIC0gQW4gb2JqZWN0IHdoZXJlIHN0eWxlcyBhcmUgYXBwbGllZC4gQXR0cmlidXRlIG11c3QgZXhpc3QgaW4gVHdvLlRleHQuUHJvcGVydGllcy5cclxuICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBhIHByaW1pdGl2ZSBjbGFzcyBmb3IgY3JlYXRpbmcgZHJhd2FibGUgdGV4dCB0aGF0IGNhbiBiZSBhZGRlZCB0byB0aGUgc2NlbmVncmFwaC5cclxuICAgKi9cclxuICB2YXIgVGV4dCA9IFR3by5UZXh0ID0gZnVuY3Rpb24obWVzc2FnZSwgeCwgeSwgc3R5bGVzKSB7XHJcblxyXG4gICAgVHdvLlNoYXBlLmNhbGwodGhpcyk7XHJcblxyXG4gICAgdGhpcy5fcmVuZGVyZXIudHlwZSA9ICd0ZXh0JztcclxuICAgIHRoaXMuX3JlbmRlcmVyLmZsYWdGaWxsID0gXy5iaW5kKFR3by5UZXh0LkZsYWdGaWxsLCB0aGlzKTtcclxuICAgIHRoaXMuX3JlbmRlcmVyLmZsYWdTdHJva2UgPSBfLmJpbmQoVHdvLlRleHQuRmxhZ1N0cm9rZSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy52YWx1ZSA9IG1lc3NhZ2U7XHJcblxyXG4gICAgaWYgKF8uaXNOdW1iZXIoeCkpIHtcclxuICAgICAgICB0aGlzLnRyYW5zbGF0aW9uLnggPSB4O1xyXG4gICAgfVxyXG4gICAgaWYgKF8uaXNOdW1iZXIoeSkpIHtcclxuICAgICAgICB0aGlzLnRyYW5zbGF0aW9uLnkgPSB5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHQjZGFzaGVzXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcltdfSAtIEFycmF5IG9mIG51bWJlcnMuIE9kZCBpbmRpY2VzIHJlcHJlc2VudCBkYXNoIGxlbmd0aC4gRXZlbiBpbmRpY2VzIHJlcHJlc2VudCBkYXNoIHNwYWNlLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIEEgbGlzdCBvZiBudW1iZXJzIHRoYXQgcmVwcmVzZW50IHRoZSByZXBlYXRlZCBkYXNoIGxlbmd0aCBhbmQgZGFzaCBzcGFjZSBhcHBsaWVkIHRvIHRoZSBzdHJva2Ugb2YgdGhlIHRleHQuXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNoYXJyYXl9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZSBTVkcgc3Ryb2tlLWRhc2hhcnJheSBhdHRyaWJ1dGUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGFzaGVzID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNkYXNoZXMjb2Zmc2V0XHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBBIG51bWJlciBpbiBwaXhlbHMgdG8gb2Zmc2V0IHtAbGluayBUd28uVGV4dCNkYXNoZXN9IGRpc3BsYXkuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGFzaGVzLm9mZnNldCA9IDA7XHJcblxyXG4gICAgaWYgKCFfLmlzT2JqZWN0KHN0eWxlcykpIHtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgXy5lYWNoKFR3by5UZXh0LlByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BlcnR5KSB7XHJcblxyXG4gICAgICBpZiAocHJvcGVydHkgaW4gc3R5bGVzKSB7XHJcbiAgICAgICAgdGhpc1twcm9wZXJ0eV0gPSBzdHlsZXNbcHJvcGVydHldO1xyXG4gICAgICB9XHJcblxyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gIH07XHJcblxyXG4gIF8uZXh0ZW5kKFR3by5UZXh0LCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dC5SYXRpb1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gQXBwcm94aW1hdGUgYXNwZWN0IHJhdGlvIG9mIGEgdHlwZWZhY2UncyBjaGFyYWN0ZXIgd2lkdGggdG8gaGVpZ2h0LlxyXG4gICAgICovXHJcbiAgICBSYXRpbzogMC42LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHQuUHJvcGVydGllc1xyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLlRleHR9LlxyXG4gICAgICovXHJcbiAgICBQcm9wZXJ0aWVzOiBbXHJcbiAgICAgICd2YWx1ZScsICdmYW1pbHknLCAnc2l6ZScsICdsZWFkaW5nJywgJ2FsaWdubWVudCcsICdsaW5ld2lkdGgnLCAnc3R5bGUnLFxyXG4gICAgICAnY2xhc3NOYW1lJywgJ3dlaWdodCcsICdkZWNvcmF0aW9uJywgJ2Jhc2VsaW5lJywgJ29wYWNpdHknLCAndmlzaWJsZScsXHJcbiAgICAgICdmaWxsJywgJ3N0cm9rZScsXHJcbiAgICBdLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHQuRmxhZ0ZpbGxcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHJlbmRlcmVycyBrbm93IHRoZSBmaWxsIHByb3BlcnR5IGhhdmUgYmVlbiB1cGRhdGVkIG9uIGEge0BsaW5rIFR3by5UZXh0fS5cclxuICAgICAqL1xyXG4gICAgRmxhZ0ZpbGw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLl9mbGFnRmlsbCA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHQuRmxhZ1N0cm9rZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQgcmVuZGVyZXJzIGtub3cgdGhlIHN0cm9rZSBwcm9wZXJ0eSBoYXZlIGJlZW4gdXBkYXRlZCBvbiBhIHtAbGluayBUd28uVGV4dH0uXHJcbiAgICAgKi9cclxuICAgIEZsYWdTdHJva2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLl9mbGFnU3Ryb2tlID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iamVjdCkge1xyXG5cclxuICAgICAgVHdvLlNoYXBlLk1ha2VPYnNlcnZhYmxlKG9iamVjdCk7XHJcblxyXG4gICAgICBfLmVhY2goVHdvLlRleHQuUHJvcGVydGllcy5zbGljZSgwLCAxMyksIFR3by5VdGlscy5kZWZpbmVQcm9wZXJ0eSwgb2JqZWN0KTtcclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdmaWxsJywge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9maWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbihmKSB7XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBUd28uR3JhZGllbnRcclxuICAgICAgICAgICAgfHwgdGhpcy5fZmlsbCBpbnN0YW5jZW9mIFR3by5MaW5lYXJHcmFkaWVudFxyXG4gICAgICAgICAgICB8fCB0aGlzLl9maWxsIGluc3RhbmNlb2YgVHdvLlJhZGlhbEdyYWRpZW50XHJcbiAgICAgICAgICAgIHx8IHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBUd28uVGV4dHVyZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9maWxsLnVuYmluZChUd28uRXZlbnRzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ0ZpbGwpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuX2ZpbGwgPSBmO1xyXG4gICAgICAgICAgdGhpcy5fZmxhZ0ZpbGwgPSB0cnVlO1xyXG5cclxuICAgICAgICAgIGlmICh0aGlzLl9maWxsIGluc3RhbmNlb2YgVHdvLkdyYWRpZW50XHJcbiAgICAgICAgICAgIHx8IHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBUd28uTGluZWFyR3JhZGllbnRcclxuICAgICAgICAgICAgfHwgdGhpcy5fZmlsbCBpbnN0YW5jZW9mIFR3by5SYWRpYWxHcmFkaWVudFxyXG4gICAgICAgICAgICB8fCB0aGlzLl9maWxsIGluc3RhbmNlb2YgVHdvLlRleHR1cmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlsbC5iaW5kKFR3by5FdmVudHMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnRmlsbCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnc3Ryb2tlJywge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9zdHJva2U7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGYpIHtcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgVHdvLkdyYWRpZW50XHJcbiAgICAgICAgICAgIHx8IHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIFR3by5MaW5lYXJHcmFkaWVudFxyXG4gICAgICAgICAgICB8fCB0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBUd28uUmFkaWFsR3JhZGllbnRcclxuICAgICAgICAgICAgfHwgdGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgVHdvLlRleHR1cmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlLnVuYmluZChUd28uRXZlbnRzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1N0cm9rZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhpcy5fc3Ryb2tlID0gZjtcclxuICAgICAgICAgIHRoaXMuX2ZsYWdTdHJva2UgPSB0cnVlO1xyXG5cclxuICAgICAgICAgIGlmICh0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBUd28uR3JhZGllbnRcclxuICAgICAgICAgICAgfHwgdGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgVHdvLkxpbmVhckdyYWRpZW50XHJcbiAgICAgICAgICAgIHx8IHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIFR3by5SYWRpYWxHcmFkaWVudFxyXG4gICAgICAgICAgICB8fCB0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBUd28uVGV4dHVyZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdHJva2UuYmluZChUd28uRXZlbnRzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1N0cm9rZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnY2xpcCcsIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2xpcDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgdGhpcy5fY2xpcCA9IHY7XHJcbiAgICAgICAgICB0aGlzLl9mbGFnQ2xpcCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdkYXNoZXMnLCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2Rhc2hlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgaWYgKCFfLmlzTnVtYmVyKHYub2Zmc2V0KSkge1xyXG4gICAgICAgICAgICB2Lm9mZnNldCA9IHRoaXMuX2Rhc2hlcy5vZmZzZXQgfHwgMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRoaXMuX2Rhc2hlcyA9IHY7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gIH0pO1xyXG5cclxuICBfLmV4dGVuZChUd28uVGV4dC5wcm90b3R5cGUsIFR3by5TaGFwZS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAvLyBGbGFnc1xyXG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbGFnXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZmxhZ1ZhbHVlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5UZXh0I3ZhbHVlfSBuZWVkIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ1ZhbHVlOiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHQjX2ZsYWdGYW1pbHlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjZmFtaWx5fSBuZWVkIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ0ZhbWlseTogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0I19mbGFnU2l6ZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCNzaXplfSBuZWVkIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ1NpemU6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZmxhZ0xlYWRpbmdcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjbGVhZGluZ30gbmVlZCB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdMZWFkaW5nOiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHQjX2ZsYWdBbGlnbm1lbnRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjYWxpZ25tZW50fSBuZWVkIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ0FsaWdubWVudDogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0I19mbGFnQmFzZWxpbmVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjYmFzZWxpbmV9IG5lZWQgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnQmFzZWxpbmU6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZmxhZ1N0eWxlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5UZXh0I3N0eWxlfSBuZWVkIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ1N0eWxlOiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHQjX2ZsYWdXZWlnaHRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjd2VpZ2h0fSBuZWVkIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ1dlaWdodDogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0I19mbGFnRGVjb3JhdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCNkZWNvcmF0aW9ufSBuZWVkIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ0RlY29yYXRpb246IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZmxhZ0ZpbGxcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjZmlsbH0gbmVlZCB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdGaWxsOiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHQjX2ZsYWdTdHJva2VcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjc3Ryb2tlfSBuZWVkIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ1N0cm9rZTogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0I19mbGFnTGluZXdpZHRoXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5UZXh0I2xpbmV3aWR0aH0gbmVlZCB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdMaW5ld2lkdGg6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZmxhZ09wYWNpdHlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjb3BhY2l0eX0gbmVlZCB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdPcGFjaXR5OiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHQjX2ZsYWdDbGFzc05hbWVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjY2xhc3NOYW1lfSBuZWVkIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ0NsYXNzTmFtZTogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0I19mbGFnVmlzaWJsZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCN2aXNpYmxlfSBuZWVkIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ1Zpc2libGU6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZmxhZ0NsaXBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjY2xpcH0gbmVlZCB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdDbGlwOiBmYWxzZSxcclxuXHJcbiAgICAvLyBVbmRlcmx5aW5nIFByb3BlcnRpZXNcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0I3ZhbHVlXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBUaGUgY2hhcmFjdGVycyB0byBiZSByZW5kZXJlZCB0byB0aGUgdGhlIHNjcmVlbi4gUmVmZXJyZWQgdG8gaW4gdGhlIGRvY3VtZW50YXRpb24gc29tZXRpbWVzIGFzIHRoZSBgbWVzc2FnZWAuXHJcbiAgICAgKi9cclxuICAgIF92YWx1ZTogJycsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNmYW1pbHlcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIFRoZSBmb250IGZhbWlseSBUd28uanMgc2hvdWxkIGF0dGVtcHQgdG8gcmVnc2l0ZXIgZm9yIHJlbmRlcmluZy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYCdzYW5zLXNlcmlmJ2AuIENvbW1hIHNlcGFyYXRlZCBmb250IG5hbWVzIGNhbiBiZSBzdXBwbGllZCBhcyBhIFwic3RhY2tcIiwgc2ltaWxhciB0byB0aGUgQ1NTIGltcGxlbWVudGF0aW9uIG9mIGBmb250LWZhbWlseWAuXHJcbiAgICAgKi9cclxuICAgIF9mYW1pbHk6ICdzYW5zLXNlcmlmJyxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0I3NpemVcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBmb250IHNpemUgaW4gVHdvLmpzIHBvaW50IHNwYWNlLiBEZWZhdWx0cyB0byBgMTNgLlxyXG4gICAgICovXHJcbiAgICBfc2l6ZTogMTMsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNsZWFkaW5nXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgaGVpZ2h0IGJldHdlZW4gbGluZXMgbWVhc3VyZWQgZnJvbSBiYXNlIHRvIGJhc2UgaW4gVHdvLmpzIHBvaW50IHNwYWNlLiBEZWZhdWx0cyB0byBgMTdgLlxyXG4gICAgICovXHJcbiAgICBfbGVhZGluZzogMTcsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNhbGlnbm1lbnRcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIEFsaWdubWVudCBvZiB0ZXh0IGluIHJlbGF0aW9uIHRvIHtAbGluayBUd28uVGV4dCN0cmFuc2xhdGlvbn0ncyBjb29yZGluYXRlcy4gUG9zc2libGUgdmFsdWVzIGluY2x1ZGUgYCdsZWZ0J2AsIGAnY2VudGVyJ2AsIGAncmlnaHQnYC4gRGVmYXVsdHMgdG8gYCdjZW50ZXInYC5cclxuICAgICAqL1xyXG4gICAgX2FsaWdubWVudDogJ2NlbnRlcicsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNiYXNlbGluZVxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IC0gVGhlIHZlcnRpY2FsIGFsaWdtZW50IG9mIHRoZSB0ZXh0IGluIHJlbGF0aW9uIHRvIHtAbGluayBUd28uVGV4dCN0cmFuc2xhdGlvbn0ncyBjb29yZGluYXRlcy4gUG9zc2libGUgdmFsdWVzIGluY2x1ZGUgYCd0b3AnYCwgYCdtaWRkbGUnYCwgYCdib3R0b20nYCwgYW5kIGAnYmFzZWxpbmUnYC4gRGVmYXVsdHMgdG8gYCdiYXNlbGluZSdgLlxyXG4gICAgICovXHJcbiAgICBfYmFzZWxpbmU6ICdtaWRkbGUnLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHQjc3R5bGVcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIFRoZSBmb250J3Mgc3R5bGUuIFBvc3NpYmxlIHZhbHVlcyBpbmNsdWRlICdgbm9ybWFsYCcsIGAnaXRhbGljJ2AuIERlZmF1bHRzIHRvIGAnbm9ybWFsJ2AuXHJcbiAgICAgKi9cclxuICAgIF9zdHlsZTogJ25vcm1hbCcsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCN3ZWlnaHRcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIEEgbnVtYmVyIGF0IGludGVydmFscyBvZiAxMDAgdG8gZGVzY3JpYmUgdGhlIGZvbnQncyB3ZWlnaHQuIFRoaXMgY29tcGF0aWJpbGl0eSB2YXJpZXMgd2l0aCB0aGUgdHlwZWZhY2UncyB2YXJpYW50IHdlaWdodHMuIExhcmdlciB2YWx1ZXMgYXJlIGJvbGRlci4gU21hbGxlciB2YWx1ZXMgYXJlIHRoaW5uZXIuIERlZmF1bHRzIHRvIGAnNTAwJ2AuXHJcbiAgICAgKi9cclxuICAgIF93ZWlnaHQ6IDUwMCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0I2RlY29yYXRpb25cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIFN0cmluZyB0byBkZWxpbmVhdGUgd2hldGhlciB0ZXh0IHNob3VsZCBiZSBkZWNvcmF0ZWQgd2l0aCBmb3IgaW5zdGFuY2UgYW4gYCd1bmRlcmxpbmUnYC4gRGVmYXVsdHMgdG8gYCdub25lJ2AuXHJcbiAgICAgKi9cclxuICAgIF9kZWNvcmF0aW9uOiAnbm9uZScsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNmaWxsXHJcbiAgICAgKiBAcHJvcGVydHkgeyhDc3NDb2xvcnxUd28uR3JhZGllbnR8VHdvLlRleHR1cmUpfSAtIFRoZSB2YWx1ZSBvZiB3aGF0IHRoZSB0ZXh0IG9iamVjdCBzaG91bGQgYmUgZmlsbGVkIGluIHdpdGguXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY29sb3JfdmFsdWV9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENTUyBDb2xvcnMuXHJcbiAgICAgKi9cclxuICAgIF9maWxsOiAnIzAwMCcsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNzdHJva2VcclxuICAgICAqIEBwcm9wZXJ0eSB7KENzc0NvbG9yfFR3by5HcmFkaWVudHxUd28uVGV4dHVyZSl9IC0gVGhlIHZhbHVlIG9mIHdoYXQgdGhlIHRleHQgb2JqZWN0IHNob3VsZCBiZSBmaWxsZWQgaW4gd2l0aC5cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9jb2xvcl92YWx1ZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ1NTIENvbG9ycy5cclxuICAgICAqL1xyXG4gICAgX3N0cm9rZTogJ3RyYW5zcGFyZW50JyxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0I2xpbmV3aWR0aFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHRoaWNrbmVzcyBpbiBwaXhlbHMgb2YgdGhlIHN0cm9rZS5cclxuICAgICAqL1xyXG4gICAgX2xpbmV3aWR0aDogMSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0I29wYWNpdHlcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBvcGFxdWVuZXNzIG9mIHRoZSB0ZXh0IG9iamVjdC5cclxuICAgICAqIEBub3RhLWJlbmUgQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBDU1MgQ29sb3JzIHRoYXQgaGF2ZSBhbiBhbHBoYSB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgX29wYWNpdHk6IDEsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNjbGFzc05hbWVcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIEEgY2xhc3MgdG8gYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudCB0byBiZSBjb21wYXRpYmxlIHdpdGggQ1NTIHN0eWxpbmcuIE9ubHkgYXZhaWxhYmxlIGZvciB0aGUge0BsaW5rIFR3by5TdmdSZW5kZXJlcn0uXHJcbiAgICAgKi9cclxuICAgIF9jbGFzc05hbWU6ICcnLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHQjdmlzaWJsZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERpc3BsYXkgdGhlIHRleHQgb2JqZWN0IG9yIG5vdC5cclxuICAgICAqIEBub3RhLWJlbmUgRm9yIHtAbGluayBUd28uQ2FudmFzUmVuZGVyZXJ9IGFuZCB7QGxpbmsgVHdvLldlYkdMUmVuZGVyZXJ9IHdoZW4gc2V0IHRvIGZhbHNlIGFsbCB1cGRhdGluZyBpcyBkaXNhYmxlZCBpbXByb3ZpbmcgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5IHdpdGggbWFueSBvYmplY3RzIGluIHRoZSBzY2VuZS5cclxuICAgICAqL1xyXG4gICAgX3Zpc2libGU6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNjbGlwXHJcbiAgICAgKiBAcHJvcGVydHkge1R3by5TaGFwZX0gLSBPYmplY3QgdG8gZGVmaW5lIGNsaXBwaW5nIGFyZWEuXHJcbiAgICAgKiBAbm90YS1iZW5lIFRoaXMgcHJvcGVydHkgaXMgY3VycmVudGx5IG5vdCB3b3JraW5nIGJlY3Vhc2Ugb2YgU1ZHIHNwZWMgaXNzdWVzIGZvdW5kIGhlcmUge0BsaW5rIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzA5NTF9LlxyXG4gICAgICovXHJcbiAgICBfY2xpcDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZGFzaGVzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlRleHQjZGFzaGVzfVxyXG4gICAgICovXHJcbiAgICBfZGFzaGVzOiBbXSxcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVHdvLlRleHQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNyZW1vdmVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIFJlbW92ZSBzZWxmIGZyb20gdGhlIHNjZW5lIC8gcGFyZW50LlxyXG4gICAgICovXHJcbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnBhcmVudC5yZW1vdmUodGhpcyk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHQjY2xvbmVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IFtwYXJlbnRdIC0gVGhlIHBhcmVudCBncm91cCBvciBzY2VuZSB0byBhZGQgdGhlIGNsb25lIHRvLlxyXG4gICAgICogQHJldHVybnMge1R3by5UZXh0fVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLlRleHR9IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0ZXh0IG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgY2xvbmU6IGZ1bmN0aW9uKHBhcmVudCkge1xyXG5cclxuICAgICAgdmFyIGNsb25lID0gbmV3IFR3by5UZXh0KHRoaXMudmFsdWUpO1xyXG4gICAgICBjbG9uZS50cmFuc2xhdGlvbi5jb3B5KHRoaXMudHJhbnNsYXRpb24pO1xyXG4gICAgICBjbG9uZS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XHJcbiAgICAgIGNsb25lLnNjYWxlID0gdGhpcy5zY2FsZTtcclxuXHJcbiAgICAgIF8uZWFjaChUd28uVGV4dC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xyXG4gICAgICAgIGNsb25lW3Byb3BlcnR5XSA9IHRoaXNbcHJvcGVydHldO1xyXG4gICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm1hdHJpeC5tYW51YWwpIHtcclxuICAgICAgICBjbG9uZS5tYXRyaXguY29weSh0aGlzLm1hdHJpeCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNsb25lLl91cGRhdGUoKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHQjdG9PYmplY3RcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgdGV4dCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgdHJhbnNsYXRpb246IHRoaXMudHJhbnNsYXRpb24udG9PYmplY3QoKSxcclxuICAgICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcclxuICAgICAgICBzY2FsZTogdGhpcy5zY2FsZVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgaWYgKHRoaXMubWF0cml4Lm1hbnVhbCkge1xyXG4gICAgICAgIHJlc3VsdC5tYXRyaXggPSB0aGlzLm1hdHJpeC50b09iamVjdCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBfLmVhY2goVHdvLlRleHQuUHJvcGVydGllcywgZnVuY3Rpb24ocHJvcGVydHkpIHtcclxuICAgICAgICByZXN1bHRbcHJvcGVydHldID0gdGhpc1twcm9wZXJ0eV07XHJcbiAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHQjbm9GaWxsXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBkZXNjcmlwdGlvbiBTaG9ydCBoYW5kIG1ldGhvZCB0byBzZXQgZmlsbCB0byBgdHJhbnNwYXJlbnRgLlxyXG4gICAgICovXHJcbiAgICBub0ZpbGw6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLmZpbGwgPSAndHJhbnNwYXJlbnQnO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNub1N0cm9rZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gU2hvcnQgaGFuZCBtZXRob2QgdG8gc2V0IHN0cm9rZSB0byBgdHJhbnNwYXJlbnRgLlxyXG4gICAgICovXHJcbiAgICBub1N0cm9rZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMuc3Ryb2tlID0gdW5kZWZpbmVkO1xyXG4gICAgICB0aGlzLmxpbmV3aWR0aCA9IHVuZGVmaW5lZDtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEEgc2hpbSB0byBub3QgYnJlYWsgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgY2FsbHMuXHJcbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQgYSB3YXkgdG8gY2FsY3VsYXRlIHByb3BlciBib3VuZGluZ1xyXG4gICAgLy8gYm94ZXMgb2YgYFR3by5UZXh0YC5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0I2dldEJvdW5kaW5nQ2xpZW50UmVjdFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaGFsbG93PWZhbHNlXSAtIERlc2NyaWJlcyB3aGV0aGVyIHRvIGNhbGN1bGF0ZSBvZmYgbG9jYWwgbWF0cml4IG9yIHdvcmxkIG1hdHJpeC5cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IC0gUmV0dXJucyBvYmplY3Qgd2l0aCB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHdpZHRoLCBoZWlnaHQgYXR0cmlidXRlcy5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCB3aWR0aCwgYW5kIGhlaWdodCBwYXJhbWV0ZXJzIG9mIHRoZSB0ZXh0IG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBmdW5jdGlvbihzaGFsbG93KSB7XHJcblxyXG4gICAgICB2YXIgbWF0cml4LCBib3JkZXIsIGwsIHgsIHksIGksIHY7XHJcbiAgICAgIHZhciBsZWZ0LCByaWdodCwgdG9wLCBib3R0b207XHJcblxyXG4gICAgICAvLyBUT0RPOiBVcGRhdGUgdGhpcyB0byBub3QgX19hbHdheXNfXyB1cGRhdGUuIEp1c3Qgd2hlbiBpdCBuZWVkcyB0by5cclxuICAgICAgdGhpcy5fdXBkYXRlKHRydWUpO1xyXG5cclxuICAgICAgbWF0cml4ID0gc2hhbGxvdyA/IHRoaXMuX21hdHJpeCA6IGdldENvbXB1dGVkTWF0cml4KHRoaXMpO1xyXG5cclxuICAgICAgdmFyIGhlaWdodCA9IHRoaXMubGVhZGluZztcclxuICAgICAgdmFyIHdpZHRoID0gdGhpcy52YWx1ZS5sZW5ndGggKiB0aGlzLnNpemUgKiBUZXh0LlJhdGlvO1xyXG5cclxuICAgICAgc3dpdGNoICh0aGlzLmFsaWdubWVudCkge1xyXG4gICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgbGVmdCA9IDA7XHJcbiAgICAgICAgICByaWdodCA9IHdpZHRoO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgbGVmdCA9IC0gd2lkdGg7XHJcbiAgICAgICAgICByaWdodCA9IDA7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgbGVmdCA9IC0gd2lkdGggLyAyO1xyXG4gICAgICAgICAgcmlnaHQgPSB3aWR0aCAvIDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN3aXRjaCAodGhpcy5iYXNlbGluZSkge1xyXG4gICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICB0b3AgPSAwO1xyXG4gICAgICAgICAgYm90dG9tID0gaGVpZ2h0O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcclxuICAgICAgICAgIHRvcCA9IC0gaGVpZ2h0O1xyXG4gICAgICAgICAgYm90dG9tID0gMDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICB0b3AgPSAtIGhlaWdodCAvIDI7XHJcbiAgICAgICAgICBib3R0b20gPSBoZWlnaHQgLyAyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2ID0gbWF0cml4Lm11bHRpcGx5KGxlZnQsIHRvcCwgMSk7XHJcblxyXG4gICAgICB0b3AgPSB2Lnk7XHJcbiAgICAgIGxlZnQgPSB2Lng7XHJcblxyXG4gICAgICB2ID0gbWF0cml4Lm11bHRpcGx5KHJpZ2h0LCBib3R0b20sIDEpO1xyXG5cclxuICAgICAgcmlnaHQgPSB2Lng7XHJcbiAgICAgIGJvdHRvbSA9IHYueTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICByaWdodDogcmlnaHQsXHJcbiAgICAgICAgYm90dG9tOiBib3R0b20sXHJcbiAgICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcclxuICAgICAgICBoZWlnaHQ6IGJvdHRvbSAtIHRvcFxyXG4gICAgICB9O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNmbGFnUmVzZXRcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxyXG4gICAgICovXHJcbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdGhpcy5fZmxhZ1ZhbHVlID0gdGhpcy5fZmxhZ0ZhbWlseSA9IHRoaXMuX2ZsYWdTaXplID1cclxuICAgICAgICB0aGlzLl9mbGFnTGVhZGluZyA9IHRoaXMuX2ZsYWdBbGlnbm1lbnQgPSB0aGlzLl9mbGFnRmlsbCA9XHJcbiAgICAgICAgdGhpcy5fZmxhZ1N0cm9rZSA9IHRoaXMuX2ZsYWdMaW5ld2lkdGggPSB0aGlzLl9mbGFnT3BhY2l0eSA9XHJcbiAgICAgICAgdGhpcy5fZmxhZ1Zpc2libGUgPSB0aGlzLl9mbGFnQ2xpcCA9IHRoaXMuX2ZsYWdEZWNvcmF0aW9uID1cclxuICAgICAgICB0aGlzLl9mbGFnQ2xhc3NOYW1lID0gdGhpcy5fZmxhZ0Jhc2VsaW5lID0gZmFsc2U7XHJcblxyXG4gICAgICBUd28uU2hhcGUucHJvdG90eXBlLmZsYWdSZXNldC5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbiAgVHdvLlRleHQuTWFrZU9ic2VydmFibGUoVHdvLlRleHQucHJvdG90eXBlKTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0Q2FudmFzKCkge1xyXG4gICAgaWYgKHJvb3QuZG9jdW1lbnQpIHtcclxuICAgICAgcmV0dXJuIHJvb3QuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ1R3by5qczogVW5hYmxlIHRvIGNyZWF0ZSBjYW52YXMgZm9yIFR3by5UZXh0IG1lYXN1cmVtZW50cy4nKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBnZXRDb250ZXh0OiBfLmlkZW50aXR5XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSkoKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogKHRoaXMgfHwgc2VsZiB8fCB3aW5kb3cpKS5Ud28pO1xyXG5cbihmdW5jdGlvbihUd28pIHtcclxuXHJcbiAgdmFyIF8gPSBUd28uVXRpbHM7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuYW1lIFR3by5TdG9wXHJcbiAgICogQGNsYXNzXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRdIC0gVGhlIG9mZnNldCBwZXJjZW50YWdlIG9mIHRoZSBzdG9wIHJlcHJlc2VudGVkIGFzIGEgemVyby10by1vbmUgdmFsdWUuIERlZmF1bHQgdmFsdWUgZmxpcCBmbG9wcyBmcm9tIHplcm8tdG8tb25lIGFzIG5ldyBzdG9wcyBhcmUgY3JlYXRlZC5cclxuICAgKiBAcGFyYW0ge0Nzc0NvbG9yfSBbY29sb3JdIC0gVGhlIGNvbG9yIG9mIHRoZSBzdG9wLiBEZWZhdWx0IHZhbHVlIGZsaXAgZmxvcHMgZnJvbSB3aGl0ZSB0byBibGFjayBhcyBuZXcgc3RvcHMgYXJlIGNyZWF0ZWQuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcGFjaXR5XSAtIFRoZSBvcGFjaXR5IHZhbHVlLiBEZWZhdWx0IHZhbHVlIGlzIDEsIGNhbm5vdCBiZSBsb3dlciB0aGFuIDAuXHJcbiAgICogQG5vdGEtYmVuZSBVc2VkIHNwZWNpZmljYWxseSBpbiBjb25qdW5jdGlvbiB3aXRoIHtAbGluayBUd28uR3JhZGllbnR9cyB0byBjb250cm9sIGNvbG9yIGdyYWR1YXRpb24uXHJcbiAgICovXHJcbiAgdmFyIFN0b3AgPSBUd28uU3RvcCA9IGZ1bmN0aW9uKG9mZnNldCwgY29sb3IsIG9wYWNpdHkpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TdG9wI19yZW5kZXJlclxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGRlc2NyaXB0aW9uIEEgcHJpdmF0ZSBvYmplY3QgdG8gc3RvcmUgcmVsZXZhbnQgcmVuZGVyZXIgc3BlY2lmaWMgdmFyaWFibGVzLlxyXG4gICAgICogQG5vdGEtYmVuZSBXaXRoIHRoZSB7QGxpbmsgVHdvLlN2Z1JlbmRlcmVyfSB5b3UgY2FuIGFjY2VzcyB0aGUgdW5kZXJseWluZyBTVkcgZWxlbWVudCBjcmVhdGVkIHZpYSBgc3RvcC5fcmVuZGVyZXIuZWxlbWAuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3JlbmRlcmVyID0ge307XHJcbiAgICB0aGlzLl9yZW5kZXJlci50eXBlID0gJ3N0b3AnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlN0b3Ajb2Zmc2V0XHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgb2Zmc2V0IHBlcmNlbnRhZ2Ugb2YgdGhlIHN0b3AgcmVwcmVzZW50ZWQgYXMgYSB6ZXJvLXRvLW9uZSB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vZmZzZXQgPSBfLmlzTnVtYmVyKG9mZnNldCkgPyBvZmZzZXRcclxuICAgICAgOiBTdG9wLkluZGV4IDw9IDAgPyAwIDogMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TdG9wI29wYWNpdHlcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBhbHBoYSBwZXJjZW50YWdlIG9mIHRoZSBzdG9wIHJlcHJlc2VudGVkIGFzIGEgemVyby10by1vbmUgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIHRoaXMub3BhY2l0eSA9IF8uaXNOdW1iZXIob3BhY2l0eSkgPyBvcGFjaXR5IDogMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TdG9wI2NvbG9yXHJcbiAgICAgKiBAcHJvcGVydHkge0Nzc0NvbG9yfSAtIFRoZSBjb2xvciBvZiB0aGUgc3RvcC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5jb2xvciA9IF8uaXNTdHJpbmcoY29sb3IpID8gY29sb3JcclxuICAgICAgOiBTdG9wLkluZGV4IDw9IDAgPyAnI2ZmZicgOiAnIzAwMCc7XHJcblxyXG4gICAgU3RvcC5JbmRleCA9IChTdG9wLkluZGV4ICsgMSkgJSAyO1xyXG5cclxuICB9O1xyXG5cclxuICBfLmV4dGVuZChTdG9wLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3RvcC5JbmRleFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGN1cnJlbnQgaW5kZXggYmVpbmcgcmVmZXJlbmNlZCBmb3IgY2FsY3VsYXRpbmcgYSBzdG9wJ3MgZGVmYXVsdCBvZmZzZXQgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIEluZGV4OiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlN0b3AuUHJvcGVydGllc1xyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLlN0b3B9LlxyXG4gICAgICovXHJcbiAgICBQcm9wZXJ0aWVzOiBbXHJcbiAgICAgICdvZmZzZXQnLFxyXG4gICAgICAnb3BhY2l0eScsXHJcbiAgICAgICdjb2xvcidcclxuICAgIF0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3RvcC5NYWtlT2JzZXJ2YWJsZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYXBwbHkgb2JzZXJ2YWJsZSBxdWFsaXRpZXMgb2YgYSB7QGxpbmsgVHdvLlN0b3B9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIHRoZSB7QGxpbmsgVHdvLlN0b3B9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxyXG4gICAgICovXHJcbiAgICBNYWtlT2JzZXJ2YWJsZTogZnVuY3Rpb24ob2JqZWN0KSB7XHJcblxyXG4gICAgICBfLmVhY2goU3RvcC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xyXG5cclxuICAgICAgICB2YXIgb2JqZWN0ID0gdGhpcztcclxuICAgICAgICB2YXIgc2VjcmV0ID0gJ18nICsgcHJvcGVydHk7XHJcbiAgICAgICAgdmFyIGZsYWcgPSAnX2ZsYWcnICsgcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcclxuXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHtcclxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1tzZWNyZXRdO1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHNldDogZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgICB0aGlzW3NlY3JldF0gPSB2O1xyXG4gICAgICAgICAgICB0aGlzW2ZsYWddID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuX2ZsYWdTdG9wcyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgIH0sIG9iamVjdCk7XHJcblxyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbiAgXy5leHRlbmQoU3RvcC5wcm90b3R5cGUsIFR3by5VdGlscy5FdmVudHMsIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogU3RvcCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TdG9wI2Nsb25lXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7VHdvLkdyb3VwfSBbcGFyZW50XSAtIFRoZSBwYXJlbnQgZ3JvdXAgb3Igc2NlbmUgdG8gYWRkIHRoZSBjbG9uZSB0by5cclxuICAgICAqIEByZXR1cm5zIHtUd28uU3RvcH1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3by5TdG9wfSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgcGF0aC5cclxuICAgICAqL1xyXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdmFyIGNsb25lID0gbmV3IFN0b3AoKTtcclxuXHJcbiAgICAgIF8uZWFjaChTdG9wLlByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BlcnR5KSB7XHJcbiAgICAgICAgY2xvbmVbcHJvcGVydHldID0gdGhpc1twcm9wZXJ0eV07XHJcbiAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgcmV0dXJuIGNsb25lO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3RvcCN0b09iamVjdFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoLlxyXG4gICAgICovXHJcbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB2YXIgcmVzdWx0ID0ge307XHJcblxyXG4gICAgICBfLmVhY2goU3RvcC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihrKSB7XHJcbiAgICAgICAgcmVzdWx0W2tdID0gdGhpc1trXTtcclxuICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3RvcCNmbGFnUmVzZXRcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxyXG4gICAgICovXHJcbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdGhpcy5fZmxhZ09mZnNldCA9IHRoaXMuX2ZsYWdDb2xvciA9IHRoaXMuX2ZsYWdPcGFjaXR5ID0gZmFsc2U7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9XHJcblxyXG4gIH0pO1xyXG5cclxuICBTdG9wLk1ha2VPYnNlcnZhYmxlKFN0b3AucHJvdG90eXBlKTtcclxuICBTdG9wLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0b3A7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuYW1lIFR3by5HcmFkaWVudFxyXG4gICAqIEBjbGFzc1xyXG4gICAqIEBwYXJhbSB7VHdvLlN0b3BbXX0gW3N0b3BzXSAtIEEgbGlzdCBvZiB7QGxpbmsgVHdvLlN0b3B9cyB0aGF0IGNvbnRhaW4gdGhlIGdyYWRpZW50IGZpbGwgcGF0dGVybiBmb3IgdGhlIGdyYWRpZW50LlxyXG4gICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBjb25zdHJ1Y3RpbmcgZGlmZmVyZW50IHR5cGVzIG9mIGdyYWRpZW50cyB3aXRoIFR3by5qcy4gVGhlIHR3byBjb21tb24gZ3JhZGllbnRzIGFyZSB7QGxpbmsgVHdvLkxpbmVhckdyYWRpZW50fSBhbmQge0BsaW5rIFR3by5SYWRpYWxHcmFkaWVudH0uXHJcbiAgICovXHJcbiAgdmFyIEdyYWRpZW50ID0gVHdvLkdyYWRpZW50ID0gZnVuY3Rpb24oc3RvcHMpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudCNfcmVuZGVyZXJcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBkZXNjcmlwdGlvbiBBIHByaXZhdGUgb2JqZWN0IHRvIHN0b3JlIHJlbGV2YW50IHJlbmRlcmVyIHNwZWNpZmljIHZhcmlhYmxlcy5cclxuICAgICAqIEBub3RhLWJlbmUgV2l0aCB0aGUge0BsaW5rIFR3by5TdmdSZW5kZXJlcn0geW91IGNhbiBhY2Nlc3MgdGhlIHVuZGVybHlpbmcgU1ZHIGVsZW1lbnQgY3JlYXRlZCB2aWEgYGdyYWRpZW50Ll9yZW5kZXJlci5lbGVtYC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5fcmVuZGVyZXIgPSB7fTtcclxuICAgIHRoaXMuX3JlbmRlcmVyLnR5cGUgPSAnZ3JhZGllbnQnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50I2lkXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBTZXNzaW9uIHNwZWNpZmljIHVuaXF1ZSBpZGVudGlmaWVyLlxyXG4gICAgICogQG5vdGEtYmVuZSBJbiB0aGUge0BsaW5rIFR3by5TdmdSZW5kZXJlcn0gY2hhbmdlIHRoaXMgdG8gY2hhbmdlIHRoZSB1bmRlcmx5aW5nIFNWRyBlbGVtZW50J3MgaWQgdG9vLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmlkID0gVHdvLklkZW50aWZpZXIgKyBUd28udW5pcXVlSWQoKTtcclxuICAgIHRoaXMuY2xhc3NMaXN0ID0gW107XHJcblxyXG4gICAgdGhpcy5fcmVuZGVyZXIuZmxhZ1N0b3BzID0gXy5iaW5kKEdyYWRpZW50LkZsYWdTdG9wcywgdGhpcyk7XHJcbiAgICB0aGlzLl9yZW5kZXJlci5iaW5kU3RvcHMgPSBfLmJpbmQoR3JhZGllbnQuQmluZFN0b3BzLCB0aGlzKTtcclxuICAgIHRoaXMuX3JlbmRlcmVyLnVuYmluZFN0b3BzID0gXy5iaW5kKEdyYWRpZW50LlVuYmluZFN0b3BzLCB0aGlzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudCNzcHJlYWRcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIEluZGljYXRlcyB3aGF0IGhhcHBlbnMgaWYgdGhlIGdyYWRpZW50IHN0YXJ0cyBvciBlbmRzIGluc2lkZSB0aGUgYm91bmRzIG9mIHRoZSB0YXJnZXQgcmVjdGFuZ2xlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGAncGFkJ2AsIGAncmVmbGVjdCdgLCBhbmQgYCdyZXBlYXQnYC5cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9wc2VydmVycy5odG1sI0xpbmVhckdyYWRpZW50RWxlbWVudFNwcmVhZE1ldGhvZEF0dHJpYnV0ZX0gZm9yIG1vcmUgaW5mb3JtYXRpb25cclxuICAgICAqL1xyXG4gICAgdGhpcy5zcHJlYWQgPSAncGFkJztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudCNzdG9wc1xyXG4gICAgICogQHByb3BlcnR5IHtUd28uU3RvcFtdfSAtIEFuIG9yZGVyZWQgbGlzdCBvZiB7QGxpbmsgVHdvLlN0b3B9cyBmb3IgcmVuZGVyaW5nIHRoZSBncmFkaWVudC5cclxuICAgICAqL1xyXG4gICAgdGhpcy5zdG9wcyA9IHN0b3BzO1xyXG5cclxuICB9O1xyXG5cclxuICBfLmV4dGVuZChHcmFkaWVudCwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50I1N0b3BcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5TdG9wfVxyXG4gICAgICovXHJcbiAgICBTdG9wOiBTdG9wLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50LlByb3BlcnRpZXNcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IC0gQSBsaXN0IG9mIHByb3BlcnRpZXMgdGhhdCBhcmUgb24gZXZlcnkge0BsaW5rIFR3by5HcmFkaWVudH0uXHJcbiAgICAgKi9cclxuICAgIFByb3BlcnRpZXM6IFtcclxuICAgICAgJ3NwcmVhZCdcclxuICAgIF0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JhZGllbnQuTWFrZU9ic2VydmFibGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5HcmFkaWVudH0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uR3JhZGllbnR9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxyXG4gICAgICovXHJcbiAgICBNYWtlT2JzZXJ2YWJsZTogZnVuY3Rpb24ob2JqZWN0KSB7XHJcblxyXG4gICAgICBfLmVhY2goR3JhZGllbnQuUHJvcGVydGllcywgVHdvLlV0aWxzLmRlZmluZVByb3BlcnR5LCBvYmplY3QpO1xyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3N0b3BzJywge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24oc3RvcHMpIHtcclxuXHJcbiAgICAgICAgICB2YXIgdXBkYXRlU3RvcHMgPSB0aGlzLl9yZW5kZXJlci5mbGFnU3RvcHM7XHJcbiAgICAgICAgICB2YXIgYmluZFN0b3BzID0gdGhpcy5fcmVuZGVyZXIuYmluZFN0b3BzO1xyXG4gICAgICAgICAgdmFyIHVuYmluZFN0b3BzID0gdGhpcy5fcmVuZGVyZXIudW5iaW5kU3RvcHM7XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGxpc3RlbmVyc1xyXG4gICAgICAgICAgaWYgKHRoaXMuX3N0b3BzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BzXHJcbiAgICAgICAgICAgICAgLnVuYmluZChUd28uRXZlbnRzLmluc2VydCwgYmluZFN0b3BzKVxyXG4gICAgICAgICAgICAgIC51bmJpbmQoVHdvLkV2ZW50cy5yZW1vdmUsIHVuYmluZFN0b3BzKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDcmVhdGUgbmV3IENvbGxlY3Rpb24gd2l0aCBjb3B5IG9mIFN0b3BzXHJcbiAgICAgICAgICB0aGlzLl9zdG9wcyA9IG5ldyBUd28uVXRpbHMuQ29sbGVjdGlvbigoc3RvcHMgfHwgW10pLnNsaWNlKDApKTtcclxuXHJcbiAgICAgICAgICAvLyBMaXN0ZW4gZm9yIENvbGxlY3Rpb24gY2hhbmdlcyBhbmQgYmluZCAvIHVuYmluZFxyXG4gICAgICAgICAgdGhpcy5fc3RvcHNcclxuICAgICAgICAgICAgLmJpbmQoVHdvLkV2ZW50cy5pbnNlcnQsIGJpbmRTdG9wcylcclxuICAgICAgICAgICAgLmJpbmQoVHdvLkV2ZW50cy5yZW1vdmUsIHVuYmluZFN0b3BzKTtcclxuXHJcbiAgICAgICAgICAvLyBCaW5kIEluaXRpYWwgU3RvcHNcclxuICAgICAgICAgIGJpbmRTdG9wcyh0aGlzLl9zdG9wcyk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JhZGllbnQuRmxhZ1N0b3BzXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCByZW5kZXJlcnMga25vdyBzdG9wcyBoYXZlIGJlZW4gdXBkYXRlZCBvbiBhIHtAbGluayBUd28uR3JhZGllbnR9LlxyXG4gICAgICovXHJcbiAgICBGbGFnU3RvcHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLl9mbGFnU3RvcHMgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudC5CaW5kVmVydGljZXNcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHtAbGluayBUd28uR3JhZGllbnR9IGtub3cgdmVydGljZXMgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgQmluZFN0b3BzOiBmdW5jdGlvbihpdGVtcykge1xyXG5cclxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYSBsb3RcclxuICAgICAgLy8gd2hlbiBpbXBvcnRpbmcgYSBsYXJnZSBTVkdcclxuICAgICAgdmFyIGkgPSBpdGVtcy5sZW5ndGg7XHJcbiAgICAgIHdoaWxlKGktLSkge1xyXG4gICAgICAgIGl0ZW1zW2ldLmJpbmQoVHdvLkV2ZW50cy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdTdG9wcyk7XHJcbiAgICAgICAgaXRlbXNbaV0ucGFyZW50ID0gdGhpcztcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fcmVuZGVyZXIuZmxhZ1N0b3BzKCk7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudC5VbmJpbmRTdG9wc1xyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQge0BsaW5rIFR3by5HcmFkaWVudH0ga25vdyB2ZXJ0aWNlcyBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgVW5iaW5kU3RvcHM6IGZ1bmN0aW9uKGl0ZW1zKSB7XHJcblxyXG4gICAgICB2YXIgaSA9IGl0ZW1zLmxlbmd0aDtcclxuICAgICAgd2hpbGUoaS0tKSB7XHJcbiAgICAgICAgaXRlbXNbaV0udW5iaW5kKFR3by5FdmVudHMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnU3RvcHMpO1xyXG4gICAgICAgIGRlbGV0ZSBpdGVtc1tpXS5wYXJlbnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX3JlbmRlcmVyLmZsYWdTdG9wcygpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIF8uZXh0ZW5kKEdyYWRpZW50LnByb3RvdHlwZSwgVHdvLlV0aWxzLkV2ZW50cywge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50I19mbGFnU3RvcHNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkdyYWRpZW50I3N0b3BzfSBuZWVkIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ1N0b3BzOiBmYWxzZSxcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50I19mbGFnU3ByZWFkXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5HcmFkaWVudCNzcHJlYWR9IG5lZWQgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnU3ByZWFkOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudCNjbG9uZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLkdyYWRpZW50fVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLkdyYWRpZW50fSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgcGF0aC5cclxuICAgICAqL1xyXG4gICAgY2xvbmU6IGZ1bmN0aW9uKHBhcmVudCkge1xyXG5cclxuICAgICAgdmFyIHN0b3BzID0gXy5tYXAodGhpcy5zdG9wcywgZnVuY3Rpb24ocykge1xyXG4gICAgICAgIHJldHVybiBzLmNsb25lKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdmFyIGNsb25lID0gbmV3IEdyYWRpZW50KHN0b3BzKTtcclxuXHJcbiAgICAgIF8uZWFjaChUd28uR3JhZGllbnQuUHJvcGVydGllcywgZnVuY3Rpb24oaykge1xyXG4gICAgICAgIGNsb25lW2tdID0gdGhpc1trXTtcclxuICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgcGFyZW50LmFkZChjbG9uZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBjbG9uZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50I3RvT2JqZWN0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhdGguXHJcbiAgICAgKi9cclxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgc3RvcHM6IF8ubWFwKHRoaXMuc3RvcHMsIGZ1bmN0aW9uKHMpIHtcclxuICAgICAgICAgIHJldHVybiBzLnRvT2JqZWN0KCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgfTtcclxuXHJcbiAgICAgIF8uZWFjaChHcmFkaWVudC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihrKSB7XHJcbiAgICAgICAgcmVzdWx0W2tdID0gdGhpc1trXTtcclxuICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JhZGllbnQjX3VwZGF0ZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSByZW5kZXJpbmcgaGFwcGVucyBieSB0aGUgcmVuZGVyZXIuIFRoaXMgYXBwbGllcyBhbGwgY2hhbmdlcyBuZWNlc3Nhcnkgc28gdGhhdCByZW5kZXJpbmcgaXMgdXAtdG8tZGF0ZSBidXQgbm90IHVwZGF0ZWQgbW9yZSB0aGFuIGl0IG5lZWRzIHRvIGJlLlxyXG4gICAgICogQG5vdGEtYmVuZSBUcnkgbm90IHRvIGNhbGwgdGhpcyBtZXRob2QgbW9yZSB0aGFuIG9uY2UgYSBmcmFtZS5cclxuICAgICAqL1xyXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICBpZiAodGhpcy5fZmxhZ1NwcmVhZCB8fCB0aGlzLl9mbGFnU3RvcHMpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoVHdvLkV2ZW50cy5jaGFuZ2UpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50I2ZsYWdSZXNldFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKi9cclxuICAgIGZsYWdSZXNldDogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB0aGlzLl9mbGFnU3ByZWFkID0gdGhpcy5fZmxhZ1N0b3BzID0gZmFsc2U7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9XHJcblxyXG4gIH0pO1xyXG5cclxuICBHcmFkaWVudC5NYWtlT2JzZXJ2YWJsZShHcmFkaWVudC5wcm90b3R5cGUpO1xyXG5cclxufSkoKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogKHRoaXMgfHwgc2VsZiB8fCB3aW5kb3cpKS5Ud28pO1xyXG5cbihmdW5jdGlvbihUd28pIHtcclxuXHJcbiAgdmFyIF8gPSBUd28uVXRpbHM7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuYW1lIFR3by5MaW5lYXJHcmFkaWVudFxyXG4gICAqIEBjbGFzc1xyXG4gICAqIEBleHRlbmRzIFR3by5HcmFkaWVudFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeDE9MF0gLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgZW5kIHBvaW50IG9mIHRoZSBsaW5lYXIgZ3JhZGllbnQuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5MT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBlbmQgcG9pbnQgb2YgdGhlIGxpbmVhciBncmFkaWVudC5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3gyPTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHNlY29uZCBlbmQgcG9pbnQgb2YgdGhlIGxpbmVhciBncmFkaWVudC5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3kyPTBdIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBlbmQgcG9pbnQgb2YgdGhlIGxpbmVhciBncmFkaWVudC5cclxuICAgKiBAcGFyYW0ge1R3by5TdG9wW119IFtzdG9wc10gLSBBIGxpc3Qgb2Yge0BsaW5rIFR3by5TdG9wfXMgdGhhdCBjb250YWluIHRoZSBncmFkaWVudCBmaWxsIHBhdHRlcm4gZm9yIHRoZSBncmFkaWVudC5cclxuICAgKiBAbm90YS1iZW5lIFRoZSBsaW5lYXIgZ3JhZGllbnQgbGl2ZXMgd2l0aGluIHRoZSBzcGFjZSBvZiB0aGUgcGFyZW50IG9iamVjdCdzIG1hdHJpeCBzcGFjZS5cclxuICAgKi9cclxuICB2YXIgTGluZWFyR3JhZGllbnQgPSBUd28uTGluZWFyR3JhZGllbnQgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Miwgc3RvcHMpIHtcclxuXHJcbiAgICBUd28uR3JhZGllbnQuY2FsbCh0aGlzLCBzdG9wcyk7XHJcblxyXG4gICAgdGhpcy5fcmVuZGVyZXIudHlwZSA9ICdsaW5lYXItZ3JhZGllbnQnO1xyXG5cclxuICAgIHZhciBmbGFnRW5kUG9pbnRzID0gXy5iaW5kKExpbmVhckdyYWRpZW50LkZsYWdFbmRQb2ludHMsIHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkxpbmVhckdyYWRpZW50I2xlZnRcclxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLlZlY3Rvcn0gLSBUaGUgeCBhbmQgeSB2YWx1ZSBmb3Igd2hlcmUgdGhlIGZpcnN0IGVuZCBwb2ludCBpcyBwbGFjZWQgb24gdGhlIGNhbnZhcy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5sZWZ0ID0gbmV3IFR3by5WZWN0b3IoKS5iaW5kKFR3by5FdmVudHMuY2hhbmdlLCBmbGFnRW5kUG9pbnRzKTtcclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkxpbmVhckdyYWRpZW50I3JpZ2h0XHJcbiAgICAgKiBAcHJvcGVydHkge1R3by5WZWN0b3J9IC0gVGhlIHggYW5kIHkgdmFsdWUgZm9yIHdoZXJlIHRoZSBzZWNvbmQgZW5kIHBvaW50IGlzIHBsYWNlZCBvbiB0aGUgY2FudmFzLlxyXG4gICAgICovXHJcbiAgICB0aGlzLnJpZ2h0ID0gbmV3IFR3by5WZWN0b3IoKS5iaW5kKFR3by5FdmVudHMuY2hhbmdlLCBmbGFnRW5kUG9pbnRzKTtcclxuXHJcbiAgICBpZiAoXy5pc051bWJlcih4MSkpIHtcclxuICAgICAgdGhpcy5sZWZ0LnggPSB4MTtcclxuICAgIH1cclxuICAgIGlmIChfLmlzTnVtYmVyKHkxKSkge1xyXG4gICAgICB0aGlzLmxlZnQueSA9IHkxO1xyXG4gICAgfVxyXG4gICAgaWYgKF8uaXNOdW1iZXIoeDIpKSB7XHJcbiAgICAgIHRoaXMucmlnaHQueCA9IHgyO1xyXG4gICAgfVxyXG4gICAgaWYgKF8uaXNOdW1iZXIoeTIpKSB7XHJcbiAgICAgIHRoaXMucmlnaHQueSA9IHkyO1xyXG4gICAgfVxyXG5cclxuICB9O1xyXG5cclxuICBfLmV4dGVuZChMaW5lYXJHcmFkaWVudCwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkxpbmVhckdyYWRpZW50I1N0b3BcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5TdG9wfVxyXG4gICAgICovXHJcbiAgICBTdG9wOiBUd28uR3JhZGllbnQuU3RvcCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5MaW5lYXJHcmFkaWVudC5NYWtlT2JzZXJ2YWJsZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYXBwbHkgb2JzZXJ2YWJsZSBxdWFsaXRpZXMgb2YgYSB7QGxpbmsgVHdvLkxpbmVhckdyYWRpZW50fSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCB0aGUge0BsaW5rIFR3by5MaW5lYXJHcmFkaWVudH0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXHJcbiAgICAgKi9cclxuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmplY3QpIHtcclxuICAgICAgVHdvLkdyYWRpZW50Lk1ha2VPYnNlcnZhYmxlKG9iamVjdCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkxpbmVhckdyYWRpZW50LkZsYWdFbmRQb2ludHNcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHJlbmRlcmVycyBrbm93IGVuZCBwb2ludHMgaGF2ZSBiZWVuIHVwZGF0ZWQgb24gYSB7QGxpbmsgVHdvLkxpbmVhckdyYWRpZW50fS5cclxuICAgICAqL1xyXG4gICAgRmxhZ0VuZFBvaW50czogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMuX2ZsYWdFbmRQb2ludHMgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbiAgXy5leHRlbmQoTGluZWFyR3JhZGllbnQucHJvdG90eXBlLCBUd28uR3JhZGllbnQucHJvdG90eXBlLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uTGluZWFyR3JhZGllbnQjX2ZsYWdFbmRQb2ludHNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkxpbmVhckdyYWRpZW50I2xlZnR9IG9yIHtAbGluayBUd28uTGluZWFyR3JhZGllbnQjcmlnaHR9IGNoYW5nZWQgYW5kIG5lZWRzIHRvIHVwZGF0ZS5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdFbmRQb2ludHM6IGZhbHNlLFxyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBMaW5lYXJHcmFkaWVudCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5MaW5lYXJHcmFkaWVudCNjbG9uZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLkdyYWRpZW50fVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLkxpbmVhckdyYWRpZW50fSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgcGF0aC5cclxuICAgICAqL1xyXG4gICAgY2xvbmU6IGZ1bmN0aW9uKHBhcmVudCkge1xyXG5cclxuICAgICAgdmFyIHN0b3BzID0gXy5tYXAodGhpcy5zdG9wcywgZnVuY3Rpb24oc3RvcCkge1xyXG4gICAgICAgIHJldHVybiBzdG9wLmNsb25lKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgdmFyIGNsb25lID0gbmV3IExpbmVhckdyYWRpZW50KHRoaXMubGVmdC5feCwgdGhpcy5sZWZ0Ll95LFxyXG4gICAgICAgIHRoaXMucmlnaHQuX3gsIHRoaXMucmlnaHQuX3ksIHN0b3BzKTtcclxuXHJcbiAgICAgIF8uZWFjaChUd28uR3JhZGllbnQuUHJvcGVydGllcywgZnVuY3Rpb24oaykge1xyXG4gICAgICAgIGNsb25lW2tdID0gdGhpc1trXTtcclxuICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgcGFyZW50LmFkZChjbG9uZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBjbG9uZTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkxpbmVhckdyYWRpZW50I3RvT2JqZWN0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhdGguXHJcbiAgICAgKi9cclxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHZhciByZXN1bHQgPSBUd28uR3JhZGllbnQucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgICByZXN1bHQubGVmdCA9IHRoaXMubGVmdC50b09iamVjdCgpO1xyXG4gICAgICByZXN1bHQucmlnaHQgPSB0aGlzLnJpZ2h0LnRvT2JqZWN0KCk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uTGluZWFyR3JhZGllbnQjX3VwZGF0ZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSByZW5kZXJpbmcgaGFwcGVucyBieSB0aGUgcmVuZGVyZXIuIFRoaXMgYXBwbGllcyBhbGwgY2hhbmdlcyBuZWNlc3Nhcnkgc28gdGhhdCByZW5kZXJpbmcgaXMgdXAtdG8tZGF0ZSBidXQgbm90IHVwZGF0ZWQgbW9yZSB0aGFuIGl0IG5lZWRzIHRvIGJlLlxyXG4gICAgICogQG5vdGEtYmVuZSBUcnkgbm90IHRvIGNhbGwgdGhpcyBtZXRob2QgbW9yZSB0aGFuIG9uY2UgYSBmcmFtZS5cclxuICAgICAqL1xyXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICBpZiAodGhpcy5fZmxhZ0VuZFBvaW50cyB8fCB0aGlzLl9mbGFnU3ByZWFkIHx8IHRoaXMuX2ZsYWdTdG9wcykge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLmNoYW5nZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uTGluZWFyR3JhZGllbnQjZmxhZ1Jlc2V0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIGludGVybmFsbHkgdG8gcmVzZXQgYWxsIGZsYWdzLiBFbnN1cmVzIHRoYXQgb25seSBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIGFyZSB1cGRhdGVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSByZW5kZXJlci5cclxuICAgICAqL1xyXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHRoaXMuX2ZsYWdFbmRQb2ludHMgPSBmYWxzZTtcclxuXHJcbiAgICAgIFR3by5HcmFkaWVudC5wcm90b3R5cGUuZmxhZ1Jlc2V0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9XHJcblxyXG4gIH0pO1xyXG5cclxuICBMaW5lYXJHcmFkaWVudC5NYWtlT2JzZXJ2YWJsZShMaW5lYXJHcmFkaWVudC5wcm90b3R5cGUpO1xyXG5cclxufSkoKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogKHRoaXMgfHwgc2VsZiB8fCB3aW5kb3cpKS5Ud28pO1xyXG5cbihmdW5jdGlvbihUd28pIHtcclxuXHJcbiAgdmFyIF8gPSBUd28uVXRpbHM7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBuYW1lIFR3by5SYWRpYWxHcmFkaWVudFxyXG4gICAqIEBjbGFzc1xyXG4gICAqIEBleHRlbmRzIFR3by5HcmFkaWVudFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBvcmlnaW4gb2YgdGhlIHJhZGlhbCBncmFkaWVudC5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgb3JpZ2luIG9mIHRoZSByYWRpYWwgZ3JhZGllbnQuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYWRpdXM9MF0gLSBUaGUgcmFkaXVzIG9mIHRoZSByYWRpYWwgZ3JhZGllbnQuXHJcbiAgICogQHBhcmFtIHtUd28uU3RvcFtdfSBbc3RvcHNdIC0gQSBsaXN0IG9mIHtAbGluayBUd28uU3RvcH1zIHRoYXQgY29udGFpbiB0aGUgZ3JhZGllbnQgZmlsbCBwYXR0ZXJuIGZvciB0aGUgZ3JhZGllbnQuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmb2NhbFg9MF0gLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgZm9jYWwgcG9pbnQgb24gdGhlIHJhZGlhbCBncmFkaWVudC5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW2ZvY2FsWT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBmb2NhbCBwb2ludCBvbiB0aGUgcmFkaWFsIGdyYWRpZW50LlxyXG4gICAqIEBub3RhLWJlbmUgVGhlIHJhZGlhbCBncmFkaWVudCBsaXZlcyB3aXRoaW4gdGhlIHNwYWNlIG9mIHRoZSBwYXJlbnQgb2JqZWN0J3MgbWF0cml4IHNwYWNlLlxyXG4gICAqL1xyXG4gIHZhciBSYWRpYWxHcmFkaWVudCA9IFR3by5SYWRpYWxHcmFkaWVudCA9IGZ1bmN0aW9uKGN4LCBjeSwgciwgc3RvcHMsIGZ4LCBmeSkge1xyXG5cclxuICAgIFR3by5HcmFkaWVudC5jYWxsKHRoaXMsIHN0b3BzKTtcclxuXHJcbiAgICB0aGlzLl9yZW5kZXJlci50eXBlID0gJ3JhZGlhbC1ncmFkaWVudCc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUmFkaWFsR3JhZGllbnQjY2VudGVyXHJcbiAgICAgKiBAcHJvcGVydHkge1R3by5WZWN0b3J9IC0gVGhlIHggYW5kIHkgdmFsdWUgZm9yIHdoZXJlIHRoZSBvcmlnaW4gb2YgdGhlIHJhZGlhbCBncmFkaWVudCBpcy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5jZW50ZXIgPSBuZXcgVHdvLlZlY3RvcigpXHJcbiAgICAgIC5iaW5kKFR3by5FdmVudHMuY2hhbmdlLCBfLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fZmxhZ0NlbnRlciA9IHRydWU7XHJcbiAgICAgIH0sIHRoaXMpKTtcclxuXHJcbiAgICB0aGlzLnJhZGl1cyA9IF8uaXNOdW1iZXIocikgPyByIDogMjA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUmFkaWFsR3JhZGllbnQjZm9jYWxcclxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLlZlY3Rvcn0gLSBUaGUgeCBhbmQgeSB2YWx1ZSBmb3Igd2hlcmUgdGhlIGZvY2FsIHBvaW50IG9mIHRoZSByYWRpYWwgZ3JhZGllbnQgaXMuXHJcbiAgICAgKiBAbm90YS1iZW5lIFRoaXMgZWZmZWN0cyB0aGUgc3ByYXkgb3Igc3ByZWFkIG9mIHRoZSByYWRpYWwgZ3JhZGllbnQuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZm9jYWwgPSBuZXcgVHdvLlZlY3RvcigpXHJcbiAgICAgIC5iaW5kKFR3by5FdmVudHMuY2hhbmdlLCBfLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fZmxhZ0ZvY2FsID0gdHJ1ZTtcclxuICAgICAgfSwgdGhpcykpO1xyXG5cclxuICAgIGlmIChfLmlzTnVtYmVyKGN4KSkge1xyXG4gICAgICB0aGlzLmNlbnRlci54ID0gY3g7XHJcbiAgICB9XHJcbiAgICBpZiAoXy5pc051bWJlcihjeSkpIHtcclxuICAgICAgdGhpcy5jZW50ZXIueSA9IGN5O1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZm9jYWwuY29weSh0aGlzLmNlbnRlcik7XHJcblxyXG4gICAgaWYgKF8uaXNOdW1iZXIoZngpKSB7XHJcbiAgICAgIHRoaXMuZm9jYWwueCA9IGZ4O1xyXG4gICAgfVxyXG4gICAgaWYgKF8uaXNOdW1iZXIoZnkpKSB7XHJcbiAgICAgIHRoaXMuZm9jYWwueSA9IGZ5O1xyXG4gICAgfVxyXG5cclxuICB9O1xyXG5cclxuICBfLmV4dGVuZChSYWRpYWxHcmFkaWVudCwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlJhZGlhbEdyYWRpZW50I1N0b3BcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5TdG9wfVxyXG4gICAgICovXHJcbiAgICBTdG9wOiBUd28uR3JhZGllbnQuU3RvcCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5SYWRpYWxHcmFkaWVudC5Qcm9wZXJ0aWVzXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uUmFkaWFsR3JhZGllbnR9LlxyXG4gICAgICovXHJcbiAgICBQcm9wZXJ0aWVzOiBbXHJcbiAgICAgICdyYWRpdXMnXHJcbiAgICBdLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlJhZGlhbEdyYWRpZW50Lk1ha2VPYnNlcnZhYmxlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uUmFkaWFsR3JhZGllbnR9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIHRoZSB7QGxpbmsgVHdvLlJhZGlhbEdyYWRpZW50fSBjbGFzcyBvbiBhIGN1c3RvbSBjbGFzcy5cclxuICAgICAqL1xyXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iamVjdCkge1xyXG5cclxuICAgICAgVHdvLkdyYWRpZW50Lk1ha2VPYnNlcnZhYmxlKG9iamVjdCk7XHJcblxyXG4gICAgICBfLmVhY2goUmFkaWFsR3JhZGllbnQuUHJvcGVydGllcywgVHdvLlV0aWxzLmRlZmluZVByb3BlcnR5LCBvYmplY3QpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIF8uZXh0ZW5kKFJhZGlhbEdyYWRpZW50LnByb3RvdHlwZSwgVHdvLkdyYWRpZW50LnByb3RvdHlwZSwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlJhZGlhbEdyYWRpZW50I19mbGFnUmFkaXVzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5SYWRpYWxHcmFkaWVudCNyYWRpdXN9IGNoYW5nZWQgYW5kIG5lZWRzIHRvIHVwZGF0ZS5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdSYWRpdXM6IGZhbHNlLFxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUmFkaWFsR3JhZGllbnQjX2ZsYWdDZW50ZXJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlJhZGlhbEdyYWRpZW50I2NlbnRlcn0gY2hhbmdlZCBhbmQgbmVlZHMgdG8gdXBkYXRlLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ0NlbnRlcjogZmFsc2UsXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5SYWRpYWxHcmFkaWVudCNfZmxhZ0ZvY2FsXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5SYWRpYWxHcmFkaWVudCNmb2NhbH0gY2hhbmdlZCBhbmQgbmVlZHMgdG8gdXBkYXRlLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ0ZvY2FsOiBmYWxzZSxcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogUmFkaWFsR3JhZGllbnQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUmFkaWFsR3JhZGllbnQjY2xvbmVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IFtwYXJlbnRdIC0gVGhlIHBhcmVudCBncm91cCBvciBzY2VuZSB0byBhZGQgdGhlIGNsb25lIHRvLlxyXG4gICAgICogQHJldHVybnMge1R3by5HcmFkaWVudH1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3by5SYWRpYWxHcmFkaWVudH0gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHBhdGguXHJcbiAgICAgKi9cclxuICAgIGNsb25lOiBmdW5jdGlvbihwYXJlbnQpIHtcclxuXHJcbiAgICAgIHZhciBzdG9wcyA9IF8ubWFwKHRoaXMuc3RvcHMsIGZ1bmN0aW9uKHN0b3ApIHtcclxuICAgICAgICByZXR1cm4gc3RvcC5jbG9uZSgpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHZhciBjbG9uZSA9IG5ldyBSYWRpYWxHcmFkaWVudCh0aGlzLmNlbnRlci5feCwgdGhpcy5jZW50ZXIuX3ksXHJcbiAgICAgICAgICB0aGlzLl9yYWRpdXMsIHN0b3BzLCB0aGlzLmZvY2FsLl94LCB0aGlzLmZvY2FsLl95KTtcclxuXHJcbiAgICAgIF8uZWFjaChUd28uR3JhZGllbnQuUHJvcGVydGllcy5jb25jYXQoUmFkaWFsR3JhZGllbnQuUHJvcGVydGllcyksIGZ1bmN0aW9uKGspIHtcclxuICAgICAgICBjbG9uZVtrXSA9IHRoaXNba107XHJcbiAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgIHBhcmVudC5hZGQoY2xvbmUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gY2xvbmU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5SYWRpYWxHcmFkaWVudCN0b09iamVjdFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoLlxyXG4gICAgICovXHJcbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB2YXIgcmVzdWx0ID0gVHdvLkdyYWRpZW50LnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgXy5lYWNoKFJhZGlhbEdyYWRpZW50LlByb3BlcnRpZXMsIGZ1bmN0aW9uKGspIHtcclxuICAgICAgICByZXN1bHRba10gPSB0aGlzW2tdO1xyXG4gICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgIHJlc3VsdC5jZW50ZXIgPSB0aGlzLmNlbnRlci50b09iamVjdCgpO1xyXG4gICAgICByZXN1bHQuZm9jYWwgPSB0aGlzLmZvY2FsLnRvT2JqZWN0KCk7XHJcblxyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uUmFkaWFsR3JhZGllbnQjX3VwZGF0ZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSByZW5kZXJpbmcgaGFwcGVucyBieSB0aGUgcmVuZGVyZXIuIFRoaXMgYXBwbGllcyBhbGwgY2hhbmdlcyBuZWNlc3Nhcnkgc28gdGhhdCByZW5kZXJpbmcgaXMgdXAtdG8tZGF0ZSBidXQgbm90IHVwZGF0ZWQgbW9yZSB0aGFuIGl0IG5lZWRzIHRvIGJlLlxyXG4gICAgICogQG5vdGEtYmVuZSBUcnkgbm90IHRvIGNhbGwgdGhpcyBtZXRob2QgbW9yZSB0aGFuIG9uY2UgYSBmcmFtZS5cclxuICAgICAqL1xyXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICBpZiAodGhpcy5fZmxhZ1JhZGl1cyB8fCB0aGlzLl9mbGF0Q2VudGVyIHx8IHRoaXMuX2ZsYWdGb2NhbFxyXG4gICAgICAgIHx8IHRoaXMuX2ZsYWdTcHJlYWQgfHwgdGhpcy5fZmxhZ1N0b3BzKSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKFR3by5FdmVudHMuY2hhbmdlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5SYWRpYWxHcmFkaWVudCNmbGFnUmVzZXRcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxyXG4gICAgICovXHJcbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdGhpcy5fZmxhZ1JhZGl1cyA9IHRoaXMuX2ZsYWdDZW50ZXIgPSB0aGlzLl9mbGFnRm9jYWwgPSBmYWxzZTtcclxuXHJcbiAgICAgIFR3by5HcmFkaWVudC5wcm90b3R5cGUuZmxhZ1Jlc2V0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9XHJcblxyXG4gIH0pO1xyXG5cclxuICBSYWRpYWxHcmFkaWVudC5NYWtlT2JzZXJ2YWJsZShSYWRpYWxHcmFkaWVudC5wcm90b3R5cGUpO1xyXG5cclxufSkoKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogKHRoaXMgfHwgc2VsZiB8fCB3aW5kb3cpKS5Ud28pO1xyXG5cbihmdW5jdGlvbihUd28pIHtcclxuXHJcbiAgdmFyIHJvb3QgPSBUd28ucm9vdDtcclxuICB2YXIgXyA9IFR3by5VdGlscztcclxuICB2YXIgYW5jaG9yO1xyXG4gIHZhciByZWdleCA9IHtcclxuICAgIHZpZGVvOiAvXFwuKG1wNHx3ZWJtfG9nZykkL2ksXHJcbiAgICBpbWFnZTogL1xcLihqcGU/Z3xwbmd8Z2lmfHRpZmZ8d2VicCkkL2ksXHJcbiAgICBlZmZlY3Q6IC90ZXh0dXJlfGdyYWRpZW50L2lcclxuICB9O1xyXG5cclxuICBpZiAocm9vdC5kb2N1bWVudCkge1xyXG4gICAgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQG5hbWUgVHdvLlRleHR1cmVcclxuICAgKiBAY2xhc3NcclxuICAgKiBAZXh0ZW5kcyBUd28uU2hhcGVcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xJbWFnZUVsZW1lbnR9IFtzcmNdIC0gVGhlIFVSTCBwYXRoIHRvIGFuIGltYWdlIGZpbGUgb3IgYW4gYDxpbWcgLz5gIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIG9uY2UgdGhlIGltYWdlIGhhcyBiZWVuIGxvYWRlZC5cclxuICAgKiBAZGVzY3JpcHRpb24gRnVuZGFtZW50YWwgdG8gd29yayB3aXRoIGJpdG1hcCBkYXRhLCBhLmsuYS4gcHJlZ2VuZXJhdGVkIGltYWdlcnksIGluIFR3by5qcy4gU3VwcG9ydGVkIGZvcm1hdHMgaW5jbHVkZSBqcGcsIHBuZywgZ2lmLCBhbmQgdGlmZi4gU2VlIHtAbGluayBUd28uVGV4dHVyZS5SZWd1bGFyRXhwcmVzc2lvbnN9IGZvciBhIGZ1bGwgbGlzdCBvZiBzdXBwb3J0ZWQgZm9ybWF0cy5cclxuICAgKi9cclxuICB2YXIgVGV4dHVyZSA9IFR3by5UZXh0dXJlID0gZnVuY3Rpb24oc3JjLCBjYWxsYmFjaykge1xyXG5cclxuICAgIHRoaXMuX3JlbmRlcmVyID0ge307XHJcbiAgICB0aGlzLl9yZW5kZXJlci50eXBlID0gJ3RleHR1cmUnO1xyXG4gICAgdGhpcy5fcmVuZGVyZXIuZmxhZ09mZnNldCA9IF8uYmluZChUZXh0dXJlLkZsYWdPZmZzZXQsIHRoaXMpO1xyXG4gICAgdGhpcy5fcmVuZGVyZXIuZmxhZ1NjYWxlID0gXy5iaW5kKFRleHR1cmUuRmxhZ1NjYWxlLCB0aGlzKTtcclxuXHJcbiAgICB0aGlzLmlkID0gVHdvLklkZW50aWZpZXIgKyBUd28udW5pcXVlSWQoKTtcclxuICAgIHRoaXMuY2xhc3NMaXN0ID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNsb2FkZWRcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBTaG9ydGhhbmQgdmFsdWUgdG8gZGV0ZXJtaW5lIGlmIGltYWdlIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjcmVwZWF0XHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBDU1Mgc3R5bGUgZGVjbGFyYXRpb24gdG8gdGlsZSB7QGxpbmsgVHdvLlBhdGh9LiBWYWxpZCB2YWx1ZXMgaW5jbHVkZTogYCduby1yZXBlYXQnYCwgYCdyZXBlYXQnYCwgYCdyZXBlYXQteCdgLCBgJ3JlcGVhdC15J2AuXHJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvMmRjb250ZXh0LyNkb20tY29udGV4dC0yZC1jcmVhdGVwYXR0ZXJufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlcGVhdCA9ICduby1yZXBlYXQnO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjb2Zmc2V0XHJcbiAgICAgKiBAcHJvcGVydHkge1R3by5WZWN0b3J9IC0gQSB0d28tY29tcG9uZW50IHZlY3RvciBkZXNjcmliaW5nIGFueSBwaXhlbCBvZmZzZXQgb2YgdGhlIHRleHR1cmUgd2hlbiBhcHBsaWVkIHRvIGEge0BsaW5rIFR3by5QYXRofS5cclxuICAgICAqL1xyXG4gICAgdGhpcy5vZmZzZXQgPSBuZXcgVHdvLlZlY3RvcigpO1xyXG5cclxuICAgIGlmIChfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XHJcbiAgICAgIHZhciBsb2FkZWQgPSBfLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy51bmJpbmQoVHdvLkV2ZW50cy5sb2FkLCBsb2FkZWQpO1xyXG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XHJcbiAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgdGhpcyk7XHJcbiAgICAgIHRoaXMuYmluZChUd28uRXZlbnRzLmxvYWQsIGxvYWRlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNzcmNcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIFRoZSBVUkwgcGF0aCB0byB0aGUgaW1hZ2UgZGF0YS5cclxuICAgICAqIEBub3RhLWJlbmUgVGhpcyBwcm9wZXJ0eSBpcyB1bHRpbWF0ZWx5IHNlcmlhbGl6ZWQgaW4gYSB7QGxpbmsgVHdvLlJlZ2lzdHJ5fSB0byBjYWNoZSByZXRyaWV2YWwuXHJcbiAgICAgKi9cclxuICAgIGlmIChfLmlzU3RyaW5nKHNyYykpIHtcclxuICAgICAgdGhpcy5zcmMgPSBzcmM7XHJcbiAgICB9IGVsc2UgaWYgKF8uaXNFbGVtZW50KHNyYykpIHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI2ltYWdlXHJcbiAgICAgICAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gLSBUaGUgY29ycmVzcG9uZGluZyBET00gRWxlbWVudCBvZiB0aGUgdGV4dHVyZS4gQ2FuIGJlIGEgYDxpbWcgLz5gLCBgPGNhbnZhcyAvPmAsIG9yIGA8dmlkZW8gLz5gIGVsZW1lbnQuIFNlZSB7QGxpbmsgVHdvLlRleHR1cmUuUmVndWxhckV4cHJlc3Npb25zfSBmb3IgYSBmdWxsIGxpc3Qgb2Ygc3VwcG9ydGVkIGVsZW1lbnRzLlxyXG4gICAgICAgKiBAbm90YS1iZW5lIEluIGhlYWRsZXNzIGVudmlyb25tZW50cyB0aGlzIGlzIGEgYENhbnZhcy5JbWFnZWAgb2JqZWN0LiBTZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL25vZGUtY2FudmFzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBoZWFkbGVzcyBpbWFnZSBvYmplY3RzLlxyXG4gICAgICAgKi9cclxuICAgICAgdGhpcy5pbWFnZSA9IHNyYztcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuXHJcbiAgfTtcclxuXHJcbiAgXy5leHRlbmQoVGV4dHVyZSwge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUuUHJvcGVydGllc1xyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLlRleHR1cmV9LlxyXG4gICAgICovXHJcbiAgICBQcm9wZXJ0aWVzOiBbXHJcbiAgICAgICdzcmMnLFxyXG4gICAgICAnbG9hZGVkJyxcclxuICAgICAgJ3JlcGVhdCdcclxuICAgIF0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZS5SZWd1bGFyRXhwcmVzc2lvbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAtIEEgbWFwIG9mIGNvbXBhdGlibGUgRE9NIEVsZW1lbnRzIGNhdGVnb3JpemVkIGJ5IG1lZGlhIGZvcm1hdC5cclxuICAgICAqL1xyXG4gICAgUmVndWxhckV4cHJlc3Npb25zOiByZWdleCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlLkltYWdlUmVnaXN0cnlcclxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLlJlZ2lzdHJ5fSAtIEEgY2Fub25pY2FsIGxpc3Rpbmcgb2YgaW1hZ2UgZGF0YSB1c2VkIGluIGEgc2luZ2xlIHNlc3Npb24gb2YgVHdvLmpzLlxyXG4gICAgICogQG5vdGEtYmVuZSBUaGlzIG9iamVjdCBpcyB1c2VkIHRvIGNhY2hlIGltYWdlIGRhdGEgYmV0d2VlbiBkaWZmZXJlbnQgdGV4dHVyZXMuXHJcbiAgICAgKi9cclxuICAgIEltYWdlUmVnaXN0cnk6IG5ldyBUd28uUmVnaXN0cnkoKSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlLmdldEFic29sdXRlVVJMXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSAtIFNlcmlhbGl6ZXMgYSBVUkwgYXMgYW4gYWJzb2x1dGUgcGF0aCBmb3IgY2Fub25pY2FsIGF0dHJpYnV0aW9uIGluIHtAbGluayBUd28uSW1hZ2VSZWdpc3RyeX0uXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gLSBUaGUgc2VyaWFsaXplZCBhYnNvbHV0ZSBwYXRoLlxyXG4gICAgICovXHJcbiAgICBnZXRBYnNvbHV0ZVVSTDogZnVuY3Rpb24ocGF0aCkge1xyXG4gICAgICBpZiAoIWFuY2hvcikge1xyXG4gICAgICAgIC8vIFRPRE86IEZpeCBmb3IgaGVhZGxlc3MgZW52aXJvbm1lbnRzXHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICAgIH1cclxuICAgICAgYW5jaG9yLmhyZWYgPSBwYXRoO1xyXG4gICAgICByZXR1cm4gYW5jaG9yLmhyZWY7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUubG9hZEhlYWRsZXNzQnVmZmVyXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSAtIExvYWRzIGFuIGltYWdlIGFzIGEgYnVmZmVyIGluIGhlYWRsZXNzIGVudmlyb25tZW50cy5cclxuICAgICAqIEBwYXJhbSB7VHdvLlRleHR1cmV9IHRleHR1cmUgLSBUaGUge0BsaW5rIFR3by5UZXh0dXJlfSB0byBiZSBsb2FkZWQuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsb2FkZWQgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgdHJpZ2dlcmVkIG9uY2UgdGhlIGltYWdlIGlzIGxvYWRlZC5cclxuICAgICAqIEBub3RhLWJlbmUgLSBUaGlzIGZ1bmN0aW9uIHVzZXMgbm9kZSdzIGBmcy5yZWFkRmlsZVN5bmNgIHRvIHNwb29mIHRoZSBgPGltZyAvPmAgbG9hZGluZyBwcm9jZXNzIGluIHRoZSBicm93c2VyLlxyXG4gICAgICovXHJcbiAgICBsb2FkSGVhZGxlc3NCdWZmZXI6IG5ldyBGdW5jdGlvbigndGV4dHVyZScsICdsb2FkZWQnLCBbXHJcbiAgICAgICd2YXIgZnMgPSByZXF1aXJlKFwiZnNcIik7JyxcclxuICAgICAgJ3ZhciBidWZmZXIgPSBmcy5yZWFkRmlsZVN5bmModGV4dHVyZS5zcmMpOycsXHJcblxyXG4gICAgICAndGV4dHVyZS5pbWFnZS5zcmMgPSBidWZmZXI7JyxcclxuICAgICAgJ2xvYWRlZCgpOydcclxuICAgIF0uam9pbignXFxuJykpLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUuZ2V0SW1hZ2VcclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IC0gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gc2V0IHtAbGluayBUd28uVGV4dHVyZSNpbWFnZX0gcHJvcGVydGllcyB3aXRoIGNhbm9uaW5jYWwgdmVyc2lvbnMgc2V0IGluIHtAbGluayBUd28uVGV4dHVyZS5JbWFnZVJlZ2lzdHJ5fS5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgLSBUaGUgVVJMIHBhdGggb2YgdGhlIGltYWdlLlxyXG4gICAgICogQHJldHVybnMge0ltYWdlRWxlbWVudH0gLSBSZXR1cm5zIGVpdGhlciBhIGNhY2hlZCB2ZXJzaW9uIG9mIHRoZSBpbWFnZSBvciBhIG5ldyBvbmUgdGhhdCBpcyByZWdpc3RlcmVkIGluIHtAbGluayBUd28uVGV4dHVyZS5JbWFnZVJlZ2lzdHJ5fS5cclxuICAgICAqL1xyXG4gICAgZ2V0SW1hZ2U6IGZ1bmN0aW9uKHNyYykge1xyXG5cclxuICAgICAgdmFyIGFic29sdXRlU3JjID0gVGV4dHVyZS5nZXRBYnNvbHV0ZVVSTChzcmMpO1xyXG5cclxuICAgICAgaWYgKFRleHR1cmUuSW1hZ2VSZWdpc3RyeS5jb250YWlucyhhYnNvbHV0ZVNyYykpIHtcclxuICAgICAgICByZXR1cm4gVGV4dHVyZS5JbWFnZVJlZ2lzdHJ5LmdldChhYnNvbHV0ZVNyYyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBpbWFnZTtcclxuXHJcbiAgICAgIGlmIChUd28uVXRpbHMuSW1hZ2UpIHtcclxuXHJcbiAgICAgICAgLy8gVE9ETzogRml4IGZvciBoZWFkbGVzcyBlbnZpcm9ubWVudHNcclxuICAgICAgICBpbWFnZSA9IG5ldyBUd28uVXRpbHMuSW1hZ2UoKTtcclxuICAgICAgICBUd28uQ2FudmFzUmVuZGVyZXIuVXRpbHMuc2hpbShpbWFnZSwgJ2ltZycpO1xyXG5cclxuICAgICAgfSBlbHNlIGlmIChyb290LmRvY3VtZW50KSB7XHJcblxyXG4gICAgICAgIGlmIChyZWdleC52aWRlby50ZXN0KGFic29sdXRlU3JjKSkge1xyXG4gICAgICAgICAgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUud2FybignVHdvLmpzOiBubyBwcm90b3R5cGljYWwgaW1hZ2UgZGVmaW5lZCBmb3IgVHdvLlRleHR1cmUnKTtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XHJcblxyXG4gICAgICByZXR1cm4gaW1hZ2U7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5SZWdpc3RlclxyXG4gICAgICogQGludGVyZmFjZVxyXG4gICAgICogQGRlc2NyaXB0aW9uIEEgY29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgdG8gcmVnaXN0ZXIgZGlmZmVyZW50IHR5cGVzIG9mIHRleHR1cmVzLiBVc2VkIGludGVybmFsbHkgYnkgYSB7QGxpbmsgVHdvLlRleHR1cmV9LlxyXG4gICAgICovXHJcbiAgICBSZWdpc3Rlcjoge1xyXG4gICAgICBjYW52YXM6IGZ1bmN0aW9uKHRleHR1cmUsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGV4dHVyZS5fc3JjID0gJyMnICsgdGV4dHVyZS5pZDtcclxuICAgICAgICBUZXh0dXJlLkltYWdlUmVnaXN0cnkuYWRkKHRleHR1cmUuc3JjLCB0ZXh0dXJlLmltYWdlKTtcclxuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIGltZzogZnVuY3Rpb24odGV4dHVyZSwgY2FsbGJhY2spIHtcclxuXHJcbiAgICAgICAgdmFyIGxvYWRlZCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgIGlmIChfLmlzRnVuY3Rpb24odGV4dHVyZS5pbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICB0ZXh0dXJlLmltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsb2FkZWQsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGV4dHVyZS5pbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yLCBmYWxzZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIGVycm9yID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbih0ZXh0dXJlLmltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICAgIHRleHR1cmUuaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRlZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0ZXh0dXJlLmltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IsIGZhbHNlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRocm93IG5ldyBUd28uVXRpbHMuRXJyb3IoJ3VuYWJsZSB0byBsb2FkICcgKyB0ZXh0dXJlLnNyYyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKF8uaXNOdW1iZXIodGV4dHVyZS5pbWFnZS53aWR0aCkgJiYgdGV4dHVyZS5pbWFnZS53aWR0aCA+IDBcclxuICAgICAgICAgICYmIF8uaXNOdW1iZXIodGV4dHVyZS5pbWFnZS5oZWlnaHQpICYmIHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICBsb2FkZWQoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKF8uaXNGdW5jdGlvbih0ZXh0dXJlLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICB0ZXh0dXJlLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsb2FkZWQsIGZhbHNlKTtcclxuICAgICAgICAgIHRleHR1cmUuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvciwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGV4dHVyZS5fc3JjID0gVGV4dHVyZS5nZXRBYnNvbHV0ZVVSTCh0ZXh0dXJlLl9zcmMpO1xyXG5cclxuICAgICAgICBpZiAodGV4dHVyZS5pbWFnZSAmJiB0ZXh0dXJlLmltYWdlLmdldEF0dHJpYnV0ZSgndHdvLXNyYycpKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0ZXh0dXJlLmltYWdlLnNldEF0dHJpYnV0ZSgndHdvLXNyYycsIHRleHR1cmUuc3JjKTtcclxuICAgICAgICBUZXh0dXJlLkltYWdlUmVnaXN0cnkuYWRkKHRleHR1cmUuc3JjLCB0ZXh0dXJlLmltYWdlKTtcclxuXHJcbiAgICAgICAgaWYgKFR3by5VdGlscy5pc0hlYWRsZXNzKSB7XHJcblxyXG4gICAgICAgICAgVGV4dHVyZS5sb2FkSGVhZGxlc3NCdWZmZXIodGV4dHVyZSwgbG9hZGVkKTtcclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICB0ZXh0dXJlLmltYWdlLnNyYyA9IHRleHR1cmUuc3JjO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICB9LFxyXG4gICAgICB2aWRlbzogZnVuY3Rpb24odGV4dHVyZSwgY2FsbGJhY2spIHtcclxuXHJcbiAgICAgICAgdmFyIGxvYWRlZCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgIHRleHR1cmUuaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCBsb2FkZWQsIGZhbHNlKTtcclxuICAgICAgICAgIHRleHR1cmUuaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvciwgZmFsc2UpO1xyXG4gICAgICAgICAgdGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleHR1cmUuaW1hZ2UudmlkZW9XaWR0aDtcclxuICAgICAgICAgIHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gdGV4dHVyZS5pbWFnZS52aWRlb0hlaWdodDtcclxuICAgICAgICAgIHRleHR1cmUuaW1hZ2UucGxheSgpO1xyXG4gICAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBlcnJvciA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgIHRleHR1cmUuaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCBsb2FkZWQsIGZhbHNlKTtcclxuICAgICAgICAgIHRleHR1cmUuaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvciwgZmFsc2UpO1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR3by5VdGlscy5FcnJvcigndW5hYmxlIHRvIGxvYWQgJyArIHRleHR1cmUuc3JjKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0ZXh0dXJlLl9zcmMgPSBUZXh0dXJlLmdldEFic29sdXRlVVJMKHRleHR1cmUuX3NyYyk7XHJcbiAgICAgICAgdGV4dHVyZS5pbWFnZS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIGxvYWRlZCwgZmFsc2UpO1xyXG4gICAgICAgIHRleHR1cmUuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvciwgZmFsc2UpO1xyXG5cclxuICAgICAgICBpZiAodGV4dHVyZS5pbWFnZSAmJiB0ZXh0dXJlLmltYWdlLmdldEF0dHJpYnV0ZSgndHdvLXNyYycpKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoVHdvLlV0aWxzLmlzSGVhZGxlc3MpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUd28uVXRpbHMuRXJyb3IoJ3ZpZGVvIHRleHR1cmVzIGFyZSBub3QgaW1wbGVtZW50ZWQgaW4gaGVhZGxlc3MgZW52aXJvbm1lbnRzLicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGV4dHVyZS5pbWFnZS5zZXRBdHRyaWJ1dGUoJ3R3by1zcmMnLCB0ZXh0dXJlLnNyYyk7XHJcbiAgICAgICAgVGV4dHVyZS5JbWFnZVJlZ2lzdHJ5LmFkZCh0ZXh0dXJlLnNyYywgdGV4dHVyZS5pbWFnZSk7XHJcbiAgICAgICAgdGV4dHVyZS5pbWFnZS5zcmMgPSB0ZXh0dXJlLnNyYztcclxuICAgICAgICB0ZXh0dXJlLmltYWdlLmxvb3AgPSB0cnVlO1xyXG4gICAgICAgIHRleHR1cmUuaW1hZ2UubG9hZCgpO1xyXG5cclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlLmxvYWRcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtUd28uVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSB0ZXh0dXJlIHRvIGxvYWQuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSB0aGUgdGV4dHVyZSBpcyBsb2FkZWQuXHJcbiAgICAgKi9cclxuICAgIGxvYWQ6IGZ1bmN0aW9uKHRleHR1cmUsIGNhbGxiYWNrKSB7XHJcblxyXG4gICAgICB2YXIgc3JjID0gdGV4dHVyZS5zcmM7XHJcbiAgICAgIHZhciBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XHJcbiAgICAgIHZhciB0YWcgPSBpbWFnZSAmJiBpbWFnZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgICAgaWYgKHRleHR1cmUuX2ZsYWdJbWFnZSkge1xyXG4gICAgICAgIGlmICgvY2FudmFzL2kudGVzdCh0YWcpKSB7XHJcbiAgICAgICAgICBUZXh0dXJlLlJlZ2lzdGVyLmNhbnZhcyh0ZXh0dXJlLCBjYWxsYmFjayk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRleHR1cmUuX3NyYyA9IGltYWdlLmdldEF0dHJpYnV0ZSgndHdvLXNyYycpIHx8IGltYWdlLnNyYztcclxuICAgICAgICAgIFRleHR1cmUuUmVnaXN0ZXJbdGFnXSh0ZXh0dXJlLCBjYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGV4dHVyZS5fZmxhZ1NyYykge1xyXG4gICAgICAgIGlmICghaW1hZ2UpIHtcclxuICAgICAgICAgIHRleHR1cmUuaW1hZ2UgPSBUZXh0dXJlLmdldEltYWdlKHRleHR1cmUuc3JjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGFnID0gdGV4dHVyZS5pbWFnZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIFRleHR1cmUuUmVnaXN0ZXJbdGFnXSh0ZXh0dXJlLCBjYWxsYmFjayk7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUuRmxhZ09mZnNldFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQgcmVuZGVyZXJzIGtub3cgYG9mZnNldGAgaGFzIGJlZW4gdXBkYXRlZCBvbiBhIHtAbGluayBUd28uVGV4dHVyZX0uXHJcbiAgICAgKi9cclxuICAgIEZsYWdPZmZzZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLl9mbGFnT2Zmc2V0ID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZS5GbGFnU2NhbGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHJlbmRlcmVycyBrbm93IGBzY2FsZWAgaGFzIGJlZW4gdXBkYXRlZCBvbiBhIHtAbGluayBUd28uVGV4dHVyZX0uXHJcbiAgICAgKi9cclxuICAgIEZsYWdTY2FsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMuX2ZsYWdTY2FsZSA9IHRydWU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUuTWFrZU9ic2VydmFibGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5UZXh0dXJlfSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCBvciBpbmhlcml0IHRoZSB7QGxpbmsgVHdvLlRleHR1cmV9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxyXG4gICAgICovXHJcbiAgICBNYWtlT2JzZXJ2YWJsZTogZnVuY3Rpb24ob2JqZWN0KSB7XHJcblxyXG4gICAgICBfLmVhY2goVGV4dHVyZS5Qcm9wZXJ0aWVzLCBUd28uVXRpbHMuZGVmaW5lUHJvcGVydHksIG9iamVjdCk7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnaW1hZ2UnLCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbihpbWFnZSkge1xyXG5cclxuICAgICAgICAgIHZhciB0YWcgPSBpbWFnZSAmJiBpbWFnZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgdmFyIGluZGV4O1xyXG5cclxuICAgICAgICAgIHN3aXRjaCAodGFnKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NhbnZhcyc6XHJcbiAgICAgICAgICAgICAgaW5kZXggPSAnIycgKyBpbWFnZS5pZDtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICBpbmRleCA9IGltYWdlLnNyYztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoVGV4dHVyZS5JbWFnZVJlZ2lzdHJ5LmNvbnRhaW5zKGluZGV4KSkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbWFnZSA9IFRleHR1cmUuSW1hZ2VSZWdpc3RyeS5nZXQoaW1hZ2Uuc3JjKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlID0gaW1hZ2U7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhpcy5fZmxhZ0ltYWdlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnb2Zmc2V0Jywge1xyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgIGlmICh0aGlzLl9vZmZzZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0LnVuYmluZChUd28uRXZlbnRzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ09mZnNldCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLl9vZmZzZXQgPSB2O1xyXG4gICAgICAgICAgdGhpcy5fb2Zmc2V0LmJpbmQoVHdvLkV2ZW50cy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdPZmZzZXQpO1xyXG4gICAgICAgICAgdGhpcy5fZmxhZ09mZnNldCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdzY2FsZScsIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5fc2NhbGUgaW5zdGFuY2VvZiBUd28uVmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NjYWxlLnVuYmluZChUd28uRXZlbnRzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1NjYWxlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLl9zY2FsZSA9IHY7XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMuX3NjYWxlIGluc3RhbmNlb2YgVHdvLlZlY3Rvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9zY2FsZS5iaW5kKFR3by5FdmVudHMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnU2NhbGUpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuX2ZsYWdTY2FsZSA9IHRydWU7XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbiAgXy5leHRlbmQoVGV4dHVyZS5wcm90b3R5cGUsIFR3by5VdGlscy5FdmVudHMsIFR3by5TaGFwZS5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19mbGFnU3JjXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5UZXh0dXJlI3NyY30gbmVlZHMgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnU3JjOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19mbGFnSW1hZ2VcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHR1cmUjaW1hZ2V9IG5lZWRzIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ0ltYWdlOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19mbGFnVmlkZW9cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHR1cmUjdmlkZW99IG5lZWRzIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ1ZpZGVvOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19mbGFnTG9hZGVkXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5UZXh0dXJlI2xvYWRlZH0gbmVlZHMgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnTG9hZGVkOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19mbGFnUmVwZWF0XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5UZXh0dXJlI3JlcGVhdH0gbmVlZHMgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnUmVwZWF0OiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19mbGFnT2Zmc2V0XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5UZXh0dXJlI29mZnNldH0gbmVlZHMgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnT2Zmc2V0OiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19mbGFnU2NhbGVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHR1cmUjc2NhbGV9IG5lZWRzIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ1NjYWxlOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19zcmNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAc2VlIHtAbGluayBUd28uVGV4dHVyZSNzcmN9XHJcbiAgICAgKi9cclxuICAgIF9zcmM6ICcnLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjX2ltYWdlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlRleHR1cmUjaW1hZ2V9XHJcbiAgICAgKi9cclxuICAgIF9pbWFnZTogbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19sb2FkZWRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAc2VlIHtAbGluayBUd28uVGV4dHVyZSNsb2FkZWR9XHJcbiAgICAgKi9cclxuICAgIF9sb2FkZWQ6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjX3JlcGVhdFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5UZXh0dXJlI3JlcGVhdH1cclxuICAgICAqL1xyXG4gICAgX3JlcGVhdDogJ25vLXJlcGVhdCcsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNfc2NhbGVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAc2VlIHtAbGluayBUd28uVGV4dHVyZSNzY2FsZX1cclxuICAgICAqL1xyXG4gICAgX3NjYWxlOiAxLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjX29mZnNldFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5UZXh0dXJlI29mZnNldH1cclxuICAgICAqL1xyXG4gICAgX29mZnNldDogbnVsbCxcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogVGV4dHVyZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI2Nsb25lXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtUd28uVGV4dHVyZX1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3by5UZXh0dXJlfSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgdGV4dHVyZS5cclxuICAgICAqL1xyXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgY2xvbmUgPSBuZXcgVGV4dHVyZSh0aGlzLnNyYyk7XHJcbiAgICAgIGNsb25lLnJlcGVhdCA9IHRoaXMucmVwZWF0O1xyXG4gICAgICBjbG9uZS5vZmZzZXQuY29weSh0aGlzLm9yaWdpbik7XHJcbiAgICAgIGNsb25lLnNjYWxlID0gdGhpcy5zY2FsZTtcclxuICAgICAgcmV0dXJuIGNsb25lO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI3RvT2JqZWN0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHRleHR1cmUuXHJcbiAgICAgKi9cclxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzcmM6IHRoaXMuc3JjLFxyXG4gICAgICAgIC8vIGltYWdlOiB0aGlzLmltYWdlLFxyXG4gICAgICAgIHJlcGVhdDogdGhpcy5yZXBlYXQsXHJcbiAgICAgICAgb3JpZ2luOiB0aGlzLm9yaWdpbi50b09iamVjdCgpLFxyXG4gICAgICAgIHNjYWxlOiBfLmlzTnVtYmVyKHRoaXMuc2NhbGUpID8gdGhpcy5zY2FsZSA6IHRoaXMuc2NhbGUudG9PYmplY3QoKVxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI191cGRhdGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cclxuICAgICAqIEBub3RhLWJlbmUgVHJ5IG5vdCB0byBjYWxsIHRoaXMgbWV0aG9kIG1vcmUgdGhhbiBvbmNlIGEgZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2ZsYWdTcmMgfHwgdGhpcy5fZmxhZ0ltYWdlKSB7XHJcblxyXG4gICAgICAgIHRoaXMudHJpZ2dlcihUd28uRXZlbnRzLmNoYW5nZSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9mbGFnU3JjIHx8IHRoaXMuX2ZsYWdJbWFnZSkge1xyXG4gICAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcclxuICAgICAgICAgIFRleHR1cmUubG9hZCh0aGlzLCBfLmJpbmQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICAgIC50cmlnZ2VyKFR3by5FdmVudHMuY2hhbmdlKVxyXG4gICAgICAgICAgICAgIC50cmlnZ2VyKFR3by5FdmVudHMubG9hZCk7XHJcbiAgICAgICAgICB9LCB0aGlzKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX2ltYWdlICYmIHRoaXMuX2ltYWdlLnJlYWR5U3RhdGUgPj0gNCkge1xyXG4gICAgICAgIHRoaXMuX2ZsYWdWaWRlbyA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNmbGFnUmVzZXRcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxyXG4gICAgICovXHJcbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdGhpcy5fZmxhZ1NyYyA9IHRoaXMuX2ZsYWdJbWFnZSA9IHRoaXMuX2ZsYWdMb2FkZWRcclxuICAgICAgICA9IHRoaXMuX2ZsYWdWaWRlbyA9IHRoaXMuX2ZsYWdTY2FsZSA9IHRoaXMuX2ZsYWdPZmZzZXQgPSBmYWxzZTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIFRleHR1cmUuTWFrZU9ic2VydmFibGUoVGV4dHVyZS5wcm90b3R5cGUpO1xyXG5cclxufSkoKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogKHRoaXMgfHwgc2VsZiB8fCB3aW5kb3cpKS5Ud28pO1xyXG5cbihmdW5jdGlvbihUd28pIHtcclxuXHJcbiAgdmFyIF8gPSBUd28uVXRpbHM7XHJcbiAgdmFyIFBhdGggPSBUd28uUGF0aDtcclxuICB2YXIgUmVjdGFuZ2xlID0gVHdvLlJlY3RhbmdsZTtcclxuXHJcbiAgLyoqXHJcbiAgICogQG5hbWUgVHdvLlNwcml0ZVxyXG4gICAqIEBjbGFzc1xyXG4gICAqIEBleHRlbmRzIFR3by5SZWN0YW5nbGVcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xUd28uVGV4dHVyZX0gW3BhdGhdIC0gVGhlIFVSTCBwYXRoIG9yIHtAbGluayBUd28uVGV4dHVyZX0gdG8gYmUgdXNlZCBhcyB0aGUgYml0bWFwIGRhdGEgZGlzcGxheWVkIG9uIHRoZSBzcHJpdGUuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtveD0wXSAtIFRoZSBpbml0aWFsIGB4YCBwb3NpdGlvbiBvZiB0aGUgVHdvLlNwcml0ZS5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW295PTBdIC0gVGhlIGluaXRpYWwgYHlgIHBvc2l0aW9uIG9mIHRoZSBUd28uU3ByaXRlLlxyXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gW2NvbHM9MV0gLSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgdGhlIHNwcml0ZSBjb250YWlucy5cclxuICAgKiBAcGFyYW0ge0ludGVnZXJ9IFtyb3dzPTFdIC0gVGhlIG51bWJlciBvZiByb3dzIHRoZSBzcHJpdGUgY29udGFpbnMuXHJcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBbZnJhbWVSYXRlPTBdIC0gVGhlIGZyYW1lIHJhdGUgYXQgd2hpY2ggdGhlIHBhcnRpdGlvbnMgb2YgdGhlIGltYWdlIHNob3VsZCBwbGF5YmFjayBhdC5cclxuICAgKiBAZGVzY3JpcHRpb24gQSBjb252ZW5pZW50IHBhY2thZ2UgdG8gZGlzcGxheSBzdGlsbCBvciBhbmltYXRlZCBpbWFnZXMgdGhyb3VnaCBhIHRpbGVkIGltYWdlIHNvdXJjZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIHByaW5jaXBhbHMgb2YgYW5pbWF0ZWQgaW1hZ2VyeSB0aHJvdWdoIHRpbGluZyBzZWUgW1RleHR1cmUgQXRsYXNde0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RleHR1cmVfYXRsYXN9IG9uIFdpa2lwZWRpYS4uXHJcbiAgICovXHJcbiAgdmFyIFNwcml0ZSA9IFR3by5TcHJpdGUgPSBmdW5jdGlvbihwYXRoLCBveCwgb3ksIGNvbHMsIHJvd3MsIGZyYW1lUmF0ZSkge1xyXG5cclxuICAgIC8vIE5vdCB1c2luZyBkZWZhdWx0IGNvbnN0cnVjdG9yIG9mIFJlY3RhbmdsZSBkdWUgdG8gb2RkIGBiZWdpbm5pbmdgIC8gYGVuZGluZ2AgYmVoYXZpb3IuXHJcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb25vYnIxL3R3by5qcy9pc3N1ZXMvMzgzXHJcbiAgICBQYXRoLmNhbGwodGhpcywgW1xyXG4gICAgICBuZXcgVHdvLkFuY2hvcigpLFxyXG4gICAgICBuZXcgVHdvLkFuY2hvcigpLFxyXG4gICAgICBuZXcgVHdvLkFuY2hvcigpLFxyXG4gICAgICBuZXcgVHdvLkFuY2hvcigpXHJcbiAgICBdLCB0cnVlKTtcclxuXHJcbiAgICB0aGlzLm5vU3Ryb2tlKCk7XHJcbiAgICB0aGlzLm5vRmlsbCgpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSN0ZXh0dXJlXHJcbiAgICAgKiBAcHJvcGVydHkge1R3by5UZXh0dXJlfSAtIFRoZSB0ZXh0dXJlIHRvIGJlIHVzZWQgYXMgYml0bWFwIGRhdGEgdG8gZGlzcGxheSBpbWFnZSBpbiB0aGUgc2NlbmUuXHJcbiAgICAgKi9cclxuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgVHdvLlRleHR1cmUpIHtcclxuICAgICAgdGhpcy50ZXh0dXJlID0gcGF0aDtcclxuICAgIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhwYXRoKSkge1xyXG4gICAgICB0aGlzLnRleHR1cmUgPSBuZXcgVHdvLlRleHR1cmUocGF0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5vcmlnaW4gPSBuZXcgVHdvLlZlY3RvcigpO1xyXG5cclxuICAgIHRoaXMuX3VwZGF0ZSgpO1xyXG4gICAgdGhpcy50cmFuc2xhdGlvbi5zZXQob3ggfHwgMCwgb3kgfHwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI2NvbHVtbnNcclxuICAgICAqIEBwcm9wZXJ0eSB7SW50ZWdlcn0gLSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgdG8gc3BsaXQgdGhlIHRleHR1cmUgaW50by4gRGVmYXVsdHMgdG8gYDFgLlxyXG4gICAgICovXHJcbiAgICBpZiAoXy5pc051bWJlcihjb2xzKSkge1xyXG4gICAgICB0aGlzLmNvbHVtbnMgPSBjb2xzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNyb3dzXHJcbiAgICAgKiBAcHJvcGVydHkge0ludGVnZXJ9IC0gVGhlIG51bWJlciBvZiByb3dzIHRvIHNwbGl0IHRoZSB0ZXh0dXJlIGludG8uIERlZmF1bHRzIHRvIGAxYC5cclxuICAgICAqL1xyXG4gICAgaWYgKF8uaXNOdW1iZXIocm93cykpIHtcclxuICAgICAgdGhpcy5yb3dzID0gcm93cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjZnJhbWVSYXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0ludGVnZXJ9IC0gVGhlIG51bWJlciBvZiBmcmFtZXMgdG8gYW5pbWF0ZSBhZ2FpbnN0IHBlciBzZWNvbmQuIERlZmF1bHRzIHRvIGAwYCBmb3Igbm9uLWFuaW1hdGVkIHNwcml0ZXMuXHJcbiAgICAgKi9cclxuICAgIGlmIChfLmlzTnVtYmVyKGZyYW1lUmF0ZSkpIHtcclxuICAgICAgdGhpcy5mcmFtZVJhdGUgPSBmcmFtZVJhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI2luZGV4XHJcbiAgICAgKiBAcHJvcGVydHkge0ludGVnZXJ9IC0gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IHRpbGUgb2YgdGhlIHNwcml0ZSB0byBkaXNwbGF5LiBEZWZhdWx0cyB0byBgMGAuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaW5kZXggPSAwO1xyXG5cclxuICB9O1xyXG5cclxuICBfLmV4dGVuZChTcHJpdGUsIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUuUHJvcGVydGllc1xyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLlNwcml0ZX0uXHJcbiAgICAgKi9cclxuICAgIFByb3BlcnRpZXM6IFtcclxuICAgICAgJ3RleHR1cmUnLCAnY29sdW1ucycsICdyb3dzJywgJ2ZyYW1lUmF0ZScsICdpbmRleCdcclxuICAgIF0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlLk1ha2VPYnNlcnZhYmxlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uU3ByaXRlfSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCBvciBpbmhlcml0IHRoZSB7QGxpbmsgVHdvLlNwcml0ZX0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXHJcbiAgICAgKi9cclxuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmopIHtcclxuXHJcbiAgICAgIFJlY3RhbmdsZS5NYWtlT2JzZXJ2YWJsZShvYmopO1xyXG4gICAgICBfLmVhY2goU3ByaXRlLlByb3BlcnRpZXMsIFR3by5VdGlscy5kZWZpbmVQcm9wZXJ0eSwgb2JqKTtcclxuXHJcbiAgICB9XHJcblxyXG4gIH0pO1xyXG5cclxuICBfLmV4dGVuZChTcHJpdGUucHJvdG90eXBlLCBSZWN0YW5nbGUucHJvdG90eXBlLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI19mbGFnVGV4dHVyZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uU3ByaXRlI3RleHR1cmV9IG5lZWRzIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ1RleHR1cmU6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfZmxhZ0NvbHVtbnNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlNwcml0ZSNjb2x1bW5zfSBuZWVkIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ0NvbHVtbnM6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfZmxhZ1Jvd3NcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlNwcml0ZSNyb3dzfSBuZWVkIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ1Jvd3M6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfZmxhZ0ZyYW1lUmF0ZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uU3ByaXRlI2ZsYWdGcmFtZVJhdGV9IG5lZWRzIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ0ZyYW1lUmF0ZTogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI19mbGFnSW5kZXhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlNwcml0ZSNpbmRleH0gbmVlZHMgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIGZsYWdJbmRleDogZmFsc2UsXHJcblxyXG4gICAgLy8gUHJpdmF0ZSB2YXJpYWJsZXNcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX2Ftb3VudFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7SW50ZWdlcn0gLSBOdW1iZXIgb2YgZnJhbWVzIGZvciBhIGdpdmVuIHtAbGluayBUd28uU3ByaXRlfS5cclxuICAgICAqL1xyXG4gICAgX2Ftb3VudDogMSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX2R1cmF0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhIHtAbGluayBUd28uU3ByaXRlfS5cclxuICAgICAqL1xyXG4gICAgX2R1cmF0aW9uOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfc3RhcnRUaW1lXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtNaWxsaXNlY29uZHN9IC0gRXBvY2ggdGltZSBpbiBtaWxsaXNlY29uZHMgb2Ygd2hlbiB0aGUge0BsaW5rIFR3by5TcHJpdGV9IHN0YXJ0ZWQuXHJcbiAgICAgKi9cclxuICAgIF9zdGFydFRpbWU6IDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI19wbGF5aW5nXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERpY3RhdGVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uU3ByaXRlfSBpcyBhbmltYXRpbmcgb3Igbm90LlxyXG4gICAgICovXHJcbiAgICBfcGxheWluZzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI19maXJzdEZyYW1lXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtJbnRlZ2VyfSAtIFRoZSBmcmFtZSB0aGUge0BsaW5rIFR3by5TcHJpdGV9IHNob3VsZCBzdGFydCB3aXRoLlxyXG4gICAgICovXHJcbiAgICBfZmlyc3RGcmFtZTogMCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX2xhc3RGcmFtZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7SW50ZWdlcn0gLSBUaGUgZnJhbWUgdGhlIHtAbGluayBUd28uU3ByaXRlfSBzaG91bGQgZW5kIHdpdGguXHJcbiAgICAgKi9cclxuICAgIF9sYXN0RnJhbWU6IDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI19wbGF5aW5nXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERpY3RhdGVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uU3ByaXRlfSBzaG91bGQgbG9vcCBvciBub3QuXHJcbiAgICAgKi9cclxuICAgIF9sb29wOiB0cnVlLFxyXG5cclxuICAgIC8vIEV4cG9zZWQgdGhyb3VnaCBnZXR0ZXItc2V0dGVyXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI190ZXh0dXJlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlNwcml0ZSN0ZXh0dXJlfVxyXG4gICAgICovXHJcbiAgICBfdGV4dHVyZTogbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX2NvbHVtbnNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAc2VlIHtAbGluayBUd28uU3ByaXRlI2NvbHVtbnN9XHJcbiAgICAgKi9cclxuICAgIF9jb2x1bW5zOiAxLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfcm93c1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5TcHJpdGUjcm93c31cclxuICAgICAqL1xyXG4gICAgX3Jvd3M6IDEsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI19mcmFtZVJhdGVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAc2VlIHtAbGluayBUd28uU3ByaXRlI2ZyYW1lUmF0ZX1cclxuICAgICAqL1xyXG4gICAgX2ZyYW1lUmF0ZTogMCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX2luZGV4XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtJbnRlZ2VyfSAtIFRoZSBjdXJyZW50IGZyYW1lIHRoZSB7QGxpbmsgVHdvLlNwcml0ZX0gaXMgY3VycmVudGx5IGRpc3BsYXlpbmcuXHJcbiAgICAgKi9cclxuICAgIF9pbmRleDogMCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX29yaWdpblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5TcHJpdGUjb3JpZ2lufVxyXG4gICAgICovXHJcbiAgICBfb3JpZ2luOiBudWxsLFxyXG5cclxuICAgIGNvbnN0cnVjdG9yOiBTcHJpdGUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI3BsYXlcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBbZmlyc3RGcmFtZT0wXSAtIFRoZSBpbmRleCBvZiB0aGUgZnJhbWUgdG8gc3RhcnQgdGhlIGFuaW1hdGlvbiB3aXRoLlxyXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBbbGFzdEZyYW1lXSAtIFRoZSBpbmRleCBvZiB0aGUgZnJhbWUgdG8gZW5kIHRoZSBhbmltYXRpb24gd2l0aC4gRGVmYXVsdHMgdG8gdGhlIGxhc3QgaXRlbSBpbiB0aGUge0BsaW5rIFR3by5TcHJpdGUjdGV4dHVyZXN9LlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uTGFzdEZyYW1lXSAtIE9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIHRyaWdnZXJlZCBhZnRlciBwbGF5aW5nIHRoZSBsYXN0IGZyYW1lLiBUaGlzIGZpcmVzIG11bHRpcGxlIHRpbWVzIHdoZW4gdGhlIHNwcml0ZSBpcyBsb29wZWQuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gSW5pdGlhdGUgYW5pbWF0aW9uIHBsYXliYWNrIG9mIGEge0BsaW5rIFR3by5TcHJpdGV9LlxyXG4gICAgICovXHJcbiAgICBwbGF5OiBmdW5jdGlvbihmaXJzdEZyYW1lLCBsYXN0RnJhbWUsIG9uTGFzdEZyYW1lKSB7XHJcblxyXG4gICAgICB0aGlzLl9wbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgdGhpcy5fZmlyc3RGcmFtZSA9IDA7XHJcbiAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IHRoaXMuYW1vdW50IC0gMTtcclxuICAgICAgdGhpcy5fc3RhcnRUaW1lID0gXy5wZXJmb3JtYW5jZS5ub3coKTtcclxuXHJcbiAgICAgIGlmIChfLmlzTnVtYmVyKGZpcnN0RnJhbWUpKSB7XHJcbiAgICAgICAgdGhpcy5fZmlyc3RGcmFtZSA9IGZpcnN0RnJhbWU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKF8uaXNOdW1iZXIobGFzdEZyYW1lKSkge1xyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IGxhc3RGcmFtZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9uTGFzdEZyYW1lKSkge1xyXG4gICAgICAgIHRoaXMuX29uTGFzdEZyYW1lID0gb25MYXN0RnJhbWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX29uTGFzdEZyYW1lO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5faW5kZXggIT09IHRoaXMuX2ZpcnN0RnJhbWUpIHtcclxuICAgICAgICB0aGlzLl9zdGFydFRpbWUgLT0gMTAwMCAqIE1hdGguYWJzKHRoaXMuX2luZGV4IC0gdGhpcy5fZmlyc3RGcmFtZSlcclxuICAgICAgICAgIC8gdGhpcy5fZnJhbWVSYXRlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNwYXVzZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gSGFsdCBhbmltYXRpb24gcGxheWJhY2sgb2YgYSB7QGxpbmsgVHdvLlNwcml0ZX0uXHJcbiAgICAgKi9cclxuICAgIHBhdXNlOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjc3RvcFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gSGFsdCBhbmltYXRpb24gcGxheWJhY2sgb2YgYSB7QGxpbmsgVHdvLlNwcml0ZX0gYW5kIHNldCB0aGUgY3VycmVudCBmcmFtZSBiYWNrIHRvIHRoZSBmaXJzdCBmcmFtZS5cclxuICAgICAqL1xyXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2luZGV4ID0gMDtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI2Nsb25lXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7VHdvLkdyb3VwfSBbcGFyZW50XSAtIFRoZSBwYXJlbnQgZ3JvdXAgb3Igc2NlbmUgdG8gYWRkIHRoZSBjbG9uZSB0by5cclxuICAgICAqIEByZXR1cm5zIHtUd28uU3ByaXRlfVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLlNwcml0ZX0gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHNwcml0ZS5cclxuICAgICAqL1xyXG4gICAgY2xvbmU6IGZ1bmN0aW9uKHBhcmVudCkge1xyXG5cclxuICAgICAgdmFyIGNsb25lID0gbmV3IFNwcml0ZShcclxuICAgICAgICB0aGlzLnRleHR1cmUsIHRoaXMudHJhbnNsYXRpb24ueCwgdGhpcy50cmFuc2xhdGlvbi55LFxyXG4gICAgICAgIHRoaXMuY29sdW1ucywgdGhpcy5yb3dzLCB0aGlzLmZyYW1lUmF0ZVxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKHRoaXMucGxheWluZykge1xyXG4gICAgICAgIGNsb25lLnBsYXkodGhpcy5fZmlyc3RGcmFtZSwgdGhpcy5fbGFzdEZyYW1lKTtcclxuICAgICAgICBjbG9uZS5fbG9vcCA9IHRoaXMuX2xvb3A7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNsb25lO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI3RvT2JqZWN0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhdGguXHJcbiAgICAgKi9cclxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIG9iamVjdCA9IFJlY3RhbmdsZS5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzKTtcclxuICAgICAgb2JqZWN0LnRleHR1cmUgPSB0aGlzLnRleHR1cmUudG9PYmplY3QoKTtcclxuICAgICAgb2JqZWN0LmNvbHVtbnMgPSB0aGlzLmNvbHVtbnM7XHJcbiAgICAgIG9iamVjdC5yb3dzID0gdGhpcy5yb3dzO1xyXG4gICAgICBvYmplY3QuZnJhbWVSYXRlID0gdGhpcy5mcmFtZVJhdGU7XHJcbiAgICAgIG9iamVjdC5pbmRleCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgIG9iamVjdC5fZmlyc3RGcmFtZSA9IHRoaXMuX2ZpcnN0RnJhbWU7XHJcbiAgICAgIG9iamVjdC5fbGFzdEZyYW1lID0gdGhpcy5fbGFzdEZyYW1lO1xyXG4gICAgICBvYmplY3QuX2xvb3AgPSB0aGlzLl9sb29wO1xyXG4gICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX3VwZGF0ZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSByZW5kZXJpbmcgaGFwcGVucyBieSB0aGUgcmVuZGVyZXIuIFRoaXMgYXBwbGllcyBhbGwgY2hhbmdlcyBuZWNlc3Nhcnkgc28gdGhhdCByZW5kZXJpbmcgaXMgdXAtdG8tZGF0ZSBidXQgbm90IHVwZGF0ZWQgbW9yZSB0aGFuIGl0IG5lZWRzIHRvIGJlLlxyXG4gICAgICogQG5vdGEtYmVuZSBUcnkgbm90IHRvIGNhbGwgdGhpcyBtZXRob2QgbW9yZSB0aGFuIG9uY2UgYSBmcmFtZS5cclxuICAgICAqL1xyXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB2YXIgZWZmZWN0ID0gdGhpcy5fdGV4dHVyZTtcclxuICAgICAgdmFyIGNvbHMgPSB0aGlzLl9jb2x1bW5zO1xyXG4gICAgICB2YXIgcm93cyA9IHRoaXMuX3Jvd3M7XHJcblxyXG4gICAgICB2YXIgd2lkdGgsIGhlaWdodCwgZWxhcHNlZCwgYW1vdW50LCBkdXJhdGlvbjtcclxuICAgICAgdmFyIGluZGV4LCBpdywgaWgsIGlzUmFuZ2UsIGZyYW1lcztcclxuXHJcbiAgICAgIGlmICh0aGlzLl9mbGFnQ29sdW1ucyB8fCB0aGlzLl9mbGFnUm93cykge1xyXG4gICAgICAgIHRoaXMuX2Ftb3VudCA9IHRoaXMuX2NvbHVtbnMgKiB0aGlzLl9yb3dzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5fZmxhZ0ZyYW1lUmF0ZSkge1xyXG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gMTAwMCAqIHRoaXMuX2Ftb3VudCAvIHRoaXMuX2ZyYW1lUmF0ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX2ZsYWdUZXh0dXJlKSB7XHJcbiAgICAgICAgdGhpcy5maWxsID0gdGhpcy5fdGV4dHVyZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX3RleHR1cmUubG9hZGVkKSB7XHJcblxyXG4gICAgICAgIGl3ID0gZWZmZWN0LmltYWdlLndpZHRoO1xyXG4gICAgICAgIGloID0gZWZmZWN0LmltYWdlLmhlaWdodDtcclxuXHJcbiAgICAgICAgd2lkdGggPSBpdyAvIGNvbHM7XHJcbiAgICAgICAgaGVpZ2h0ID0gaWggLyByb3dzO1xyXG4gICAgICAgIGFtb3VudCA9IHRoaXMuX2Ftb3VudDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMud2lkdGggIT09IHdpZHRoKSB7XHJcbiAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPT0gaGVpZ2h0KSB7XHJcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9wbGF5aW5nICYmIHRoaXMuX2ZyYW1lUmF0ZSA+IDApIHtcclxuXHJcbiAgICAgICAgICBpZiAoXy5pc05hTih0aGlzLl9sYXN0RnJhbWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IGFtb3VudCAtIDE7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gVE9ETzogT2ZmbG9hZCBwZXJmIGxvZ2ljIHRvIGluc3RhbmNlIG9mIGBUd29gLlxyXG4gICAgICAgICAgZWxhcHNlZCA9IF8ucGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLl9zdGFydFRpbWU7XHJcbiAgICAgICAgICBmcmFtZXMgPSB0aGlzLl9sYXN0RnJhbWUgKyAxO1xyXG4gICAgICAgICAgZHVyYXRpb24gPSAxMDAwICogKGZyYW1lcyAtIHRoaXMuX2ZpcnN0RnJhbWUpIC8gdGhpcy5fZnJhbWVSYXRlO1xyXG5cclxuICAgICAgICAgIGlmICh0aGlzLl9sb29wKSB7XHJcbiAgICAgICAgICAgIGVsYXBzZWQgPSBlbGFwc2VkICUgZHVyYXRpb247XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlbGFwc2VkID0gTWF0aC5taW4oZWxhcHNlZCwgZHVyYXRpb24pO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGluZGV4ID0gXy5sZXJwKHRoaXMuX2ZpcnN0RnJhbWUsIGZyYW1lcywgZWxhcHNlZCAvIGR1cmF0aW9uKTtcclxuICAgICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcihpbmRleCk7XHJcblxyXG4gICAgICAgICAgaWYgKGluZGV4ICE9PSB0aGlzLl9pbmRleCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5fbGFzdEZyYW1lIC0gMSAmJiB0aGlzLl9vbkxhc3RGcmFtZSkge1xyXG4gICAgICAgICAgICAgIHRoaXMuX29uTGFzdEZyYW1lKCk7ICAvLyBTaG9ydGN1dCBmb3IgY2hhaW5hYmxlIHNwcml0ZSBhbmltYXRpb25zXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY29sID0gdGhpcy5faW5kZXggJSBjb2xzO1xyXG4gICAgICAgIHZhciByb3cgPSBNYXRoLmZsb29yKHRoaXMuX2luZGV4IC8gY29scyk7XHJcblxyXG4gICAgICAgIHZhciBveCA9IC0gd2lkdGggKiBjb2wgKyAoaXcgLSB3aWR0aCkgLyAyO1xyXG4gICAgICAgIHZhciBveSA9IC0gaGVpZ2h0ICogcm93ICsgKGloIC0gaGVpZ2h0KSAvIDI7XHJcblxyXG4gICAgICAgIC8vIFRPRE86IEltcHJvdmUgcGVyZm9ybWFuY2VcclxuICAgICAgICBpZiAob3ggIT09IGVmZmVjdC5vZmZzZXQueCkge1xyXG4gICAgICAgICAgZWZmZWN0Lm9mZnNldC54ID0gb3g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChveSAhPT0gZWZmZWN0Lm9mZnNldC55KSB7XHJcbiAgICAgICAgICBlZmZlY3Qub2Zmc2V0LnkgPSBveTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgICBSZWN0YW5nbGUucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI2ZsYWdSZXNldFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXHJcbiAgICAgKi9cclxuICAgIGZsYWdSZXNldDogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB0aGlzLl9mbGFnVGV4dHVyZSA9IHRoaXMuX2ZsYWdDb2x1bW5zID0gdGhpcy5fZmxhZ1Jvd3NcclxuICAgICAgICA9IHRoaXMuX2ZsYWdGcmFtZVJhdGUgPSBmYWxzZTtcclxuXHJcbiAgICAgIFJlY3RhbmdsZS5wcm90b3R5cGUuZmxhZ1Jlc2V0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcblxyXG4gIH0pO1xyXG5cclxuICBTcHJpdGUuTWFrZU9ic2VydmFibGUoU3ByaXRlLnByb3RvdHlwZSk7XHJcblxyXG59KSgodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiAodGhpcyB8fCBzZWxmIHx8IHdpbmRvdykpLlR3byk7XHJcblxuKGZ1bmN0aW9uKFR3bykge1xyXG5cclxuICB2YXIgXyA9IFR3by5VdGlscztcclxuICB2YXIgUGF0aCA9IFR3by5QYXRoO1xyXG4gIHZhciBSZWN0YW5nbGUgPSBUd28uUmVjdGFuZ2xlO1xyXG5cclxuICAvKipcclxuICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZVxyXG4gICAqIEBjbGFzc1xyXG4gICAqIEBleHRlbmRzIFR3by5SZWN0YW5nbGVcclxuICAgKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXXxUd28uVGV4dHVyZXxUd28uVGV4dHVyZVtdfSBwYXRocyAtIEEgbGlzdCBvZiBVUkxzIG9yIHtAbGluayBUd28uVGV4dHVyZX1zLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3g9MF0gLSBUaGUgaW5pdGlhbCBgeGAgcG9zaXRpb24gb2YgdGhlIFR3by5JbWFnZVNlcXVlbmNlLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3k9MF0gLSBUaGUgaW5pdGlhbCBgeWAgcG9zaXRpb24gb2YgdGhlIFR3by5JbWFnZVNlcXVlbmNlLlxyXG4gICAqIEBwYXJhbSB7SW50ZWdlcn0gW2ZyYW1lUmF0ZT0zMF0gLSBUaGUgZnJhbWUgcmF0ZSBhdCB3aGljaCB0aGUgaW1hZ2VzIHNob3VsZCBwbGF5YmFjayBhdC5cclxuICAgKiBAZGVzY3JpcHRpb24gQSBjb252ZW5pZW50IHBhY2thZ2UgdG8gZGlzcGxheSBzdGlsbCBvciBhbmltYXRlZCBpbWFnZXMgb3JnYW5pemVkIGFzIGEgc2VyaWVzIG9mIHN0aWxsIGltYWdlcy5cclxuICAgKi9cclxuICB2YXIgSW1hZ2VTZXF1ZW5jZSA9IFR3by5JbWFnZVNlcXVlbmNlID0gZnVuY3Rpb24ocGF0aHMsIG94LCBveSwgZnJhbWVSYXRlKSB7XHJcblxyXG4gICAgLy8gTm90IHVzaW5nIGRlZmF1bHQgY29uc3RydWN0b3Igb2YgUmVjdGFuZ2xlIGR1ZSB0byBvZGQgYGJlZ2lubmluZ2AgLyBgZW5kaW5nYCBiZWhhdmlvci5cclxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pvbm9icjEvdHdvLmpzL2lzc3Vlcy8zODNcclxuICAgIFBhdGguY2FsbCh0aGlzLCBbXHJcbiAgICAgIG5ldyBUd28uQW5jaG9yKCksXHJcbiAgICAgIG5ldyBUd28uQW5jaG9yKCksXHJcbiAgICAgIG5ldyBUd28uQW5jaG9yKCksXHJcbiAgICAgIG5ldyBUd28uQW5jaG9yKClcclxuICAgIF0sIHRydWUpO1xyXG5cclxuICAgIHRoaXMuX3JlbmRlcmVyLmZsYWdUZXh0dXJlcyA9IF8uYmluZChJbWFnZVNlcXVlbmNlLkZsYWdUZXh0dXJlcywgdGhpcyk7XHJcbiAgICB0aGlzLl9yZW5kZXJlci5iaW5kVGV4dHVyZXMgPSBfLmJpbmQoSW1hZ2VTZXF1ZW5jZS5CaW5kVGV4dHVyZXMsIHRoaXMpO1xyXG4gICAgdGhpcy5fcmVuZGVyZXIudW5iaW5kVGV4dHVyZXMgPSBfLmJpbmQoSW1hZ2VTZXF1ZW5jZS5VbmJpbmRUZXh0dXJlcywgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5ub1N0cm9rZSgpO1xyXG4gICAgdGhpcy5ub0ZpbGwoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI3RleHR1cmVzXHJcbiAgICAgKiBAcHJvcGVydHkge1R3by5UZXh0dXJlW119IC0gQSBsaXN0IG9mIHRleHR1cmVzIHRvIGJlIHVzZWQgYXMgZnJhbWVzIGZvciBhbmltYXRpbmcgdGhlIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0uXHJcbiAgICAgKi9cclxuICAgIGlmIChfLmlzT2JqZWN0KHBhdGhzKSkge1xyXG4gICAgICB0aGlzLnRleHR1cmVzID0gXy5tYXAocGF0aHMsIEltYWdlU2VxdWVuY2UuR2VuZXJhdGVUZXh0dXJlLCB0aGlzKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIElmIGp1c3QgYSBzaW5nbGUgcGF0aCBjb252ZXJ0IGludG8gYSBzaW5nbGUgVHdvLlRleHR1cmVcclxuICAgICAgdGhpcy50ZXh0dXJlcyA9IFtJbWFnZVNlcXVlbmNlLkdlbmVyYXRlVGV4dHVyZShwYXRocyldO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMub3JpZ2luID0gbmV3IFR3by5WZWN0b3IoKTtcclxuXHJcbiAgICB0aGlzLl91cGRhdGUoKTtcclxuICAgIHRoaXMudHJhbnNsYXRpb24uc2V0KG94IHx8IDAsIG95IHx8IDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjZnJhbWVSYXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0ludGVnZXJ9IC0gVGhlIG51bWJlciBvZiBmcmFtZXMgdG8gYW5pbWF0ZSBhZ2FpbnN0IHBlciBzZWNvbmQuXHJcbiAgICAgKi9cclxuICAgIGlmIChfLmlzTnVtYmVyKGZyYW1lUmF0ZSkpIHtcclxuICAgICAgdGhpcy5mcmFtZVJhdGUgPSBmcmFtZVJhdGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmZyYW1lUmF0ZSA9IEltYWdlU2VxdWVuY2UuRGVmYXVsdEZyYW1lUmF0ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI2luZGV4XHJcbiAgICAgKiBAcHJvcGVydHkge0ludGVnZXJ9IC0gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IHRpbGUgb2YgdGhlIHNwcml0ZSB0byBkaXNwbGF5LiBEZWZhdWx0cyB0byBgMGAuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaW5kZXggPSAwO1xyXG5cclxuICB9O1xyXG5cclxuICBfLmV4dGVuZChJbWFnZVNlcXVlbmNlLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZS5Qcm9wZXJ0aWVzXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0uXHJcbiAgICAgKi9cclxuICAgIFByb3BlcnRpZXM6IFtcclxuICAgICAgJ2ZyYW1lUmF0ZScsXHJcbiAgICAgICdpbmRleCdcclxuICAgIF0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZS5EZWZhdWx0RnJhbWVSYXRlXHJcbiAgICAgKiBAcHJvcGVydHkgVGhlIGRlZmF1bHQgZnJhbWUgcmF0ZSB0aGF0IHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZSNmcmFtZVJhdGV9IGlzIHNldCB0byB3aGVuIGluc3RhbnRpYXRlZC5cclxuICAgICAqL1xyXG4gICAgRGVmYXVsdEZyYW1lUmF0ZTogMzAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZS5GbGFnVGV4dHVyZXNcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHJlbmRlcmVycyBrbm93IHRleHR1cmVzIGhhdmUgYmVlbiB1cGRhdGVkIG9uIGEge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlfS5cclxuICAgICAqL1xyXG4gICAgRmxhZ1RleHR1cmVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5fZmxhZ1RleHR1cmVzID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZS5CaW5kVGV4dHVyZXNcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0ga25vdyB0ZXh0dXJlcyBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBCaW5kVGV4dHVyZXM6IGZ1bmN0aW9uKGl0ZW1zKSB7XHJcblxyXG4gICAgICB2YXIgaSA9IGl0ZW1zLmxlbmd0aDtcclxuICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGl0ZW1zW2ldLmJpbmQoVHdvLkV2ZW50cy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdUZXh0dXJlcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX3JlbmRlcmVyLmZsYWdUZXh0dXJlcygpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZS5VbmJpbmRWZXJ0aWNlc1xyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlfSBrbm93IHRleHR1cmVzIGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBVbmJpbmRUZXh0dXJlczogZnVuY3Rpb24oaXRlbXMpIHtcclxuXHJcbiAgICAgIHZhciBpID0gaXRlbXMubGVuZ3RoO1xyXG4gICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgaXRlbXNbaV0udW5iaW5kKFR3by5FdmVudHMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnVGV4dHVyZXMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9yZW5kZXJlci5mbGFnVGV4dHVyZXMoKTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UuTWFrZU9ic2VydmFibGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlfSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCBvciBpbmhlcml0IHRoZSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxyXG4gICAgICovXHJcbiAgICBNYWtlT2JzZXJ2YWJsZTogZnVuY3Rpb24ob2JqKSB7XHJcblxyXG4gICAgICBSZWN0YW5nbGUuTWFrZU9ic2VydmFibGUob2JqKTtcclxuICAgICAgXy5lYWNoKEltYWdlU2VxdWVuY2UuUHJvcGVydGllcywgVHdvLlV0aWxzLmRlZmluZVByb3BlcnR5LCBvYmopO1xyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ3RleHR1cmVzJywge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24odGV4dHVyZXMpIHtcclxuXHJcbiAgICAgICAgICB2YXIgdXBkYXRlVGV4dHVyZXMgPSB0aGlzLl9yZW5kZXJlci5mbGFnVGV4dHVyZXM7XHJcbiAgICAgICAgICB2YXIgYmluZFRleHR1cmVzID0gdGhpcy5fcmVuZGVyZXIuYmluZFRleHR1cmVzO1xyXG4gICAgICAgICAgdmFyIHVuYmluZFRleHR1cmVzID0gdGhpcy5fcmVuZGVyZXIudW5iaW5kVGV4dHVyZXM7XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGxpc3RlbmVyc1xyXG4gICAgICAgICAgaWYgKHRoaXMuX3RleHR1cmVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVzXHJcbiAgICAgICAgICAgICAgLnVuYmluZChUd28uRXZlbnRzLmluc2VydCwgYmluZFRleHR1cmVzKVxyXG4gICAgICAgICAgICAgIC51bmJpbmQoVHdvLkV2ZW50cy5yZW1vdmUsIHVuYmluZFRleHR1cmVzKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDcmVhdGUgbmV3IENvbGxlY3Rpb24gd2l0aCBjb3B5IG9mIHZlcnRpY2VzXHJcbiAgICAgICAgICB0aGlzLl90ZXh0dXJlcyA9IG5ldyBUd28uVXRpbHMuQ29sbGVjdGlvbigodGV4dHVyZXMgfHwgW10pLnNsaWNlKDApKTtcclxuXHJcbiAgICAgICAgICAvLyBMaXN0ZW4gZm9yIENvbGxlY3Rpb24gY2hhbmdlcyBhbmQgYmluZCAvIHVuYmluZFxyXG4gICAgICAgICAgdGhpcy5fdGV4dHVyZXNcclxuICAgICAgICAgICAgLmJpbmQoVHdvLkV2ZW50cy5pbnNlcnQsIGJpbmRUZXh0dXJlcylcclxuICAgICAgICAgICAgLmJpbmQoVHdvLkV2ZW50cy5yZW1vdmUsIHVuYmluZFRleHR1cmVzKTtcclxuXHJcbiAgICAgICAgICAvLyBCaW5kIEluaXRpYWwgVGV4dHVyZXNcclxuICAgICAgICAgIGJpbmRUZXh0dXJlcyh0aGlzLl90ZXh0dXJlcyk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZS5HZW5lcmF0ZVRleHR1cmVcclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IC0gU2hvcnRoYW5kIGZ1bmN0aW9uIHRvIHByZXBhcmUgc291cmNlIGltYWdlIG1hdGVyaWFsIGludG8gcmVhZGFibGUgZm9ybWF0IGJ5IHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0uXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xUd28uVGV4dHVyZX0gdGV4dHVyZU9yU3RyaW5nIC0gVGhlIHRleHR1cmUgb3Igc3RyaW5nIHRvIGNyZWF0ZSBhIHtAbGluayBUd28uVGV4dHVyZX0gZnJvbS5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiB1c2VkIGludGVybmFsbHkgYnkge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlfSB0byBwYXJzZSBhcmd1bWVudHMgYW5kIHJldHVybiB7QGxpbmsgVHdvLlRleHR1cmV9cy5cclxuICAgICAqIEByZXR1cm5zIHtUd28uVGV4dHVyZX1cclxuICAgICAqL1xyXG4gICAgR2VuZXJhdGVUZXh0dXJlOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFR3by5UZXh0dXJlKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKG9iaikpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFR3by5UZXh0dXJlKG9iaik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIF8uZXh0ZW5kKEltYWdlU2VxdWVuY2UucHJvdG90eXBlLCBSZWN0YW5nbGUucHJvdG90eXBlLCB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNfZmxhZ1RleHR1cmVzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlI3RleHR1cmVzfSBuZWVkIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ1RleHR1cmVzOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI19mbGFnRnJhbWVSYXRlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlI2ZyYW1lUmF0ZX0gbmVlZHMgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnRnJhbWVSYXRlOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI19mbGFnSW5kZXhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2UjaW5kZXh9IG5lZWRzIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ0luZGV4OiBmYWxzZSxcclxuXHJcbiAgICAvLyBQcml2YXRlIHZhcmlhYmxlc1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjX2Ftb3VudFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7SW50ZWdlcn0gLSBOdW1iZXIgb2YgZnJhbWVzIGZvciBhIGdpdmVuIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0uXHJcbiAgICAgKi9cclxuICAgIF9hbW91bnQ6IDEsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNfZHVyYXRpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGEge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlfS5cclxuICAgICAqL1xyXG4gICAgX2R1cmF0aW9uOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjX2luZGV4XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtJbnRlZ2VyfSAtIFRoZSBjdXJyZW50IGZyYW1lIHRoZSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9IGlzIGN1cnJlbnRseSBkaXNwbGF5aW5nLlxyXG4gICAgICovXHJcbiAgICBfaW5kZXg6IDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNfc3RhcnRUaW1lXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtNaWxsaXNlY29uZHN9IC0gRXBvY2ggdGltZSBpbiBtaWxsaXNlY29uZHMgb2Ygd2hlbiB0aGUge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlfSBzdGFydGVkLlxyXG4gICAgICovXHJcbiAgICBfc3RhcnRUaW1lOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjX3BsYXlpbmdcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGljdGF0ZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlfSBpcyBhbmltYXRpbmcgb3Igbm90LlxyXG4gICAgICovXHJcbiAgICBfcGxheWluZzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNfZmlyc3RGcmFtZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7SW50ZWdlcn0gLSBUaGUgZnJhbWUgdGhlIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0gc2hvdWxkIHN0YXJ0IHdpdGguXHJcbiAgICAgKi9cclxuICAgIF9maXJzdEZyYW1lOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjX2xhc3RGcmFtZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7SW50ZWdlcn0gLSBUaGUgZnJhbWUgdGhlIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0gc2hvdWxkIGVuZCB3aXRoLlxyXG4gICAgICovXHJcbiAgICBfbGFzdEZyYW1lOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjX3BsYXlpbmdcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGljdGF0ZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlfSBzaG91bGQgbG9vcCBvciBub3QuXHJcbiAgICAgKi9cclxuICAgIF9sb29wOiB0cnVlLFxyXG5cclxuICAgIC8vIEV4cG9zZWQgdGhyb3VnaCBnZXR0ZXItc2V0dGVyXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNfdGV4dHVyZXNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAc2VlIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZSN0ZXh0dXJlc31cclxuICAgICAqL1xyXG4gICAgX3RleHR1cmVzOiBudWxsLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjX2ZyYW1lUmF0ZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBzZWUge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlI2ZyYW1lUmF0ZX1cclxuICAgICAqL1xyXG4gICAgX2ZyYW1lUmF0ZTogMCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI19vcmlnaW5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAc2VlIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZSNvcmlnaW59XHJcbiAgICAgKi9cclxuICAgIF9vcmlnaW46IG51bGwsXHJcblxyXG4gICAgY29uc3RydWN0b3I6IEltYWdlU2VxdWVuY2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNwbGF5XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gW2ZpcnN0RnJhbWU9MF0gLSBUaGUgaW5kZXggb2YgdGhlIGZyYW1lIHRvIHN0YXJ0IHRoZSBhbmltYXRpb24gd2l0aC5cclxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gW2xhc3RGcmFtZV0gLSBUaGUgaW5kZXggb2YgdGhlIGZyYW1lIHRvIGVuZCB0aGUgYW5pbWF0aW9uIHdpdGguIERlZmF1bHRzIHRvIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZSN0ZXh0dXJlc30uXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb25MYXN0RnJhbWVdIC0gT3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgdHJpZ2dlcmVkIGFmdGVyIHBsYXlpbmcgdGhlIGxhc3QgZnJhbWUuIFRoaXMgZmlyZXMgbXVsdGlwbGUgdGltZXMgd2hlbiB0aGUgaW1hZ2Ugc2VxdWVuY2UgaXMgbG9vcGVkLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYXRlIGFuaW1hdGlvbiBwbGF5YmFjayBvZiBhIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0uXHJcbiAgICAgKi9cclxuICAgIHBsYXk6IGZ1bmN0aW9uKGZpcnN0RnJhbWUsIGxhc3RGcmFtZSwgb25MYXN0RnJhbWUpIHtcclxuXHJcbiAgICAgIHRoaXMuX3BsYXlpbmcgPSB0cnVlO1xyXG4gICAgICB0aGlzLl9maXJzdEZyYW1lID0gMDtcclxuICAgICAgdGhpcy5fbGFzdEZyYW1lID0gdGhpcy5hbW91bnQgLSAxO1xyXG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSBfLnBlcmZvcm1hbmNlLm5vdygpO1xyXG5cclxuICAgICAgaWYgKF8uaXNOdW1iZXIoZmlyc3RGcmFtZSkpIHtcclxuICAgICAgICB0aGlzLl9maXJzdEZyYW1lID0gZmlyc3RGcmFtZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoXy5pc051bWJlcihsYXN0RnJhbWUpKSB7XHJcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gbGFzdEZyYW1lO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob25MYXN0RnJhbWUpKSB7XHJcbiAgICAgICAgdGhpcy5fb25MYXN0RnJhbWUgPSBvbkxhc3RGcmFtZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkZWxldGUgdGhpcy5fb25MYXN0RnJhbWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLl9pbmRleCAhPT0gdGhpcy5fZmlyc3RGcmFtZSkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSAtPSAxMDAwICogTWF0aC5hYnModGhpcy5faW5kZXggLSB0aGlzLl9maXJzdEZyYW1lKVxyXG4gICAgICAgICAgLyB0aGlzLl9mcmFtZVJhdGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNwYXVzZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gSGFsdCBhbmltYXRpb24gcGxheWJhY2sgb2YgYSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9LlxyXG4gICAgICovXHJcbiAgICBwYXVzZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNzdG9wXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBkZXNjcmlwdGlvbiBIYWx0IGFuaW1hdGlvbiBwbGF5YmFjayBvZiBhIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0gYW5kIHNldCB0aGUgY3VycmVudCBmcmFtZSBiYWNrIHRvIHRoZSBmaXJzdCBmcmFtZS5cclxuICAgICAqL1xyXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2luZGV4ID0gdGhpcy5fZmlyc3RGcmFtZTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNjbG9uZVxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXHJcbiAgICAgKiBAcmV0dXJucyB7VHdvLkltYWdlU2VxdWVuY2V9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IGltYWdlIHNlcXVlbmNlLlxyXG4gICAgICovXHJcbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XHJcblxyXG4gICAgICB2YXIgY2xvbmUgPSBuZXcgSW1hZ2VTZXF1ZW5jZSh0aGlzLnRleHR1cmVzLCB0aGlzLnRyYW5zbGF0aW9uLngsXHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGlvbi55LCB0aGlzLmZyYW1lUmF0ZSk7XHJcblxyXG4gICAgICBjbG9uZS5fbG9vcCA9IHRoaXMuX2xvb3A7XHJcblxyXG4gICAgICBpZiAodGhpcy5fcGxheWluZykge1xyXG4gICAgICAgIGNsb25lLnBsYXkoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgIHBhcmVudC5hZGQoY2xvbmUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gY2xvbmU7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI3RvT2JqZWN0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhdGguXHJcbiAgICAgKi9cclxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIG9iamVjdCA9IFJlY3RhbmdsZS5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzKTtcclxuICAgICAgb2JqZWN0LnRleHR1cmVzID0gXy5tYXAodGhpcy50ZXh0dXJlcywgZnVuY3Rpb24odGV4dHVyZSkge1xyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlLnRvT2JqZWN0KCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBvYmplY3QuZnJhbWVSYXRlID0gdGhpcy5mcmFtZVJhdGU7XHJcbiAgICAgIG9iamVjdC5pbmRleCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgIG9iamVjdC5fZmlyc3RGcmFtZSA9IHRoaXMuX2ZpcnN0RnJhbWU7XHJcbiAgICAgIG9iamVjdC5fbGFzdEZyYW1lID0gdGhpcy5fbGFzdEZyYW1lO1xyXG4gICAgICBvYmplY3QuX2xvb3AgPSB0aGlzLl9sb29wO1xyXG4gICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI191cGRhdGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cclxuICAgICAqIEBub3RhLWJlbmUgVHJ5IG5vdCB0byBjYWxsIHRoaXMgbWV0aG9kIG1vcmUgdGhhbiBvbmNlIGEgZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdmFyIGVmZmVjdHMgPSB0aGlzLl90ZXh0dXJlcztcclxuICAgICAgdmFyIHdpZHRoLCBoZWlnaHQsIGVsYXBzZWQsIGFtb3VudCwgZHVyYXRpb24sIHRleHR1cmU7XHJcbiAgICAgIHZhciBpbmRleCwgZnJhbWVzO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX2ZsYWdUZXh0dXJlcykge1xyXG4gICAgICAgIHRoaXMuX2Ftb3VudCA9IGVmZmVjdHMubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5fZmxhZ0ZyYW1lUmF0ZSkge1xyXG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gMTAwMCAqIHRoaXMuX2Ftb3VudCAvIHRoaXMuX2ZyYW1lUmF0ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRoaXMuX3BsYXlpbmcgJiYgdGhpcy5fZnJhbWVSYXRlID4gMCkge1xyXG5cclxuICAgICAgICBhbW91bnQgPSB0aGlzLl9hbW91bnQ7XHJcblxyXG4gICAgICAgIGlmIChfLmlzTmFOKHRoaXMuX2xhc3RGcmFtZSkpIHtcclxuICAgICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IGFtb3VudCAtIDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUT0RPOiBPZmZsb2FkIHBlcmYgbG9naWMgdG8gaW5zdGFuY2Ugb2YgYFR3b2AuXHJcbiAgICAgICAgZWxhcHNlZCA9IF8ucGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLl9zdGFydFRpbWU7XHJcbiAgICAgICAgZnJhbWVzID0gdGhpcy5fbGFzdEZyYW1lICsgMTtcclxuICAgICAgICBkdXJhdGlvbiA9IDEwMDAgKiAoZnJhbWVzIC0gdGhpcy5fZmlyc3RGcmFtZSkgLyB0aGlzLl9mcmFtZVJhdGU7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9sb29wKSB7XHJcbiAgICAgICAgICBlbGFwc2VkID0gZWxhcHNlZCAlIGR1cmF0aW9uO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlbGFwc2VkID0gTWF0aC5taW4oZWxhcHNlZCwgZHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5kZXggPSBfLmxlcnAodGhpcy5fZmlyc3RGcmFtZSwgZnJhbWVzLCBlbGFwc2VkIC8gZHVyYXRpb24pO1xyXG4gICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcihpbmRleCk7XHJcblxyXG4gICAgICAgIGlmIChpbmRleCAhPT0gdGhpcy5faW5kZXgpIHtcclxuXHJcbiAgICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgdGV4dHVyZSA9IGVmZmVjdHNbdGhpcy5faW5kZXhdO1xyXG5cclxuICAgICAgICAgIGlmICh0ZXh0dXJlLmxvYWRlZCkge1xyXG5cclxuICAgICAgICAgICAgd2lkdGggPSB0ZXh0dXJlLmltYWdlLndpZHRoO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSB0ZXh0dXJlLmltYWdlLmhlaWdodDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLndpZHRoICE9PSB3aWR0aCkge1xyXG4gICAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT09IGhlaWdodCkge1xyXG4gICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLmZpbGwgPSB0ZXh0dXJlO1xyXG5cclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuX2xhc3RGcmFtZSAtIDEgJiYgdGhpcy5fb25MYXN0RnJhbWUpIHtcclxuICAgICAgICAgICAgICB0aGlzLl9vbkxhc3RGcmFtZSgpOyAgLy8gU2hvcnRjdXQgZm9yIGNoYWluYWJsZSBzcHJpdGUgYW5pbWF0aW9uc1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdJbmRleCB8fCAhKHRoaXMuZmlsbCBpbnN0YW5jZW9mIFR3by5UZXh0dXJlKSkge1xyXG5cclxuICAgICAgICB0ZXh0dXJlID0gZWZmZWN0c1t0aGlzLl9pbmRleF07XHJcblxyXG4gICAgICAgIGlmICh0ZXh0dXJlLmxvYWRlZCkge1xyXG5cclxuICAgICAgICAgIHdpZHRoID0gdGV4dHVyZS5pbWFnZS53aWR0aDtcclxuICAgICAgICAgIGhlaWdodCA9IHRleHR1cmUuaW1hZ2UuaGVpZ2h0O1xyXG5cclxuICAgICAgICAgIGlmICh0aGlzLndpZHRoICE9PSB3aWR0aCkge1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT09IGhlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmZpbGwgPSB0ZXh0dXJlO1xyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjZmxhZ1Jlc2V0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIGludGVybmFsbHkgdG8gcmVzZXQgYWxsIGZsYWdzLiBFbnN1cmVzIHRoYXQgb25seSBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIGFyZSB1cGRhdGVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSByZW5kZXJlci5cclxuICAgICAqL1xyXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHRoaXMuX2ZsYWdUZXh0dXJlcyA9IHRoaXMuX2ZsYWdGcmFtZVJhdGUgPSBmYWxzZTtcclxuICAgICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5mbGFnUmVzZXQuY2FsbCh0aGlzKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIEltYWdlU2VxdWVuY2UuTWFrZU9ic2VydmFibGUoSW1hZ2VTZXF1ZW5jZS5wcm90b3R5cGUpO1xyXG5cclxufSkoKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogKHRoaXMgfHwgc2VsZiB8fCB3aW5kb3cpKS5Ud28pO1xyXG5cbihmdW5jdGlvbihUd28pIHtcclxuXHJcbiAgLy8gQ29uc3RhbnRzXHJcblxyXG4gIHZhciBtaW4gPSBNYXRoLm1pbiwgbWF4ID0gTWF0aC5tYXg7XHJcbiAgdmFyIF8gPSBUd28uVXRpbHM7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBjbGFzc1xyXG4gICAqIEBuYW1lIFR3by5Hcm91cC5DaGlsZHJlblxyXG4gICAqIEBleHRlbmRzIFR3by5VdGlscy5Db2xsZWN0aW9uXHJcbiAgICogQGRlc2NyaXB0aW9uIEEgY2hpbGRyZW4gY29sbGVjdGlvbiB3aGljaCBpcyBhY2Nlc2libGUgYm90aCBieSBpbmRleCBhbmQgYnkgb2JqZWN0IGBpZGAuXHJcbiAgICovXHJcbiAgdmFyIENoaWxkcmVuID0gZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgVHdvLlV0aWxzLkNvbGxlY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19ldmVudHMnLCB7XHJcbiAgICAgIHZhbHVlIDoge30sXHJcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXHJcbiAgICB9KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Hcm91cC5DaGlsZHJlbiNpZHNcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAtIE1hcCBvZiBhbGwgZWxlbWVudHMgaW4gdGhlIGxpc3Qga2V5ZWQgYnkgYGlkYHMuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuaWRzID0ge307XHJcblxyXG4gICAgdGhpcy5vbihUd28uRXZlbnRzLmluc2VydCwgdGhpcy5hdHRhY2gpO1xyXG4gICAgdGhpcy5vbihUd28uRXZlbnRzLnJlbW92ZSwgdGhpcy5kZXRhY2gpO1xyXG4gICAgQ2hpbGRyZW4ucHJvdG90eXBlLmF0dGFjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICB9O1xyXG5cclxuICBDaGlsZHJlbi5wcm90b3R5cGUgPSBuZXcgVHdvLlV0aWxzLkNvbGxlY3Rpb24oKTtcclxuXHJcbiAgXy5leHRlbmQoQ2hpbGRyZW4ucHJvdG90eXBlLCB7XHJcblxyXG4gICAgY29uc3RydWN0b3I6IENoaWxkcmVuLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAuQ2hpbGRyZW4jYXR0YWNoXHJcbiAgICAgKiBAcGFyYW0ge1R3by5TaGFwZVtdfVxyXG4gICAgICogQGRlc2NyaXB0aW9uIEFkZHMgZWxlbWVudHMgdG8gdGhlIGBpZHNgIG1hcC5cclxuICAgICAqL1xyXG4gICAgYXR0YWNoOiBmdW5jdGlvbihjaGlsZHJlbikge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5pZHNbY2hpbGRyZW5baV0uaWRdID0gY2hpbGRyZW5baV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAuQ2hpbGRyZW4jZGV0YWNoXHJcbiAgICAgKiBAcGFyYW0ge1R3by5TaGFwZVtdfVxyXG4gICAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgZWxlbWVudHMgdG8gdGhlIGBpZHNgIG1hcC5cclxuICAgICAqL1xyXG4gICAgZGV0YWNoOiBmdW5jdGlvbihjaGlsZHJlbikge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuaWRzW2NoaWxkcmVuW2ldLmlkXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEBjbGFzc1xyXG4gICAqIEBuYW1lIFR3by5Hcm91cFxyXG4gICAqL1xyXG4gIHZhciBHcm91cCA9IFR3by5Hcm91cCA9IGZ1bmN0aW9uKGNoaWxkcmVuKSB7XHJcblxyXG4gICAgVHdvLlNoYXBlLmNhbGwodGhpcywgdHJ1ZSk7XHJcblxyXG4gICAgdGhpcy5fcmVuZGVyZXIudHlwZSA9ICdncm91cCc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjYWRkaXRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge1R3by5TaGFwZVtdfVxyXG4gICAgICogQGRlc2NyaXB0aW9uIEFuIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCBsaXN0IG9mIGNoaWxkcmVuIHRoYXQgbmVlZCB0byBiZSBhcHBlbmRlZCB0byB0aGUgcmVuZGVyZXIncyBzY2VuZWdyYXBoLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmFkZGl0aW9ucyA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI3N1YnRyYWN0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtUd28uU2hhcGVbXX1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBBbiBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgbGlzdCBvZiBjaGlsZHJlbiB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSByZW5kZXJlcidzIHNjZW5lZ3JhcGguXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3VidHJhY3Rpb25zID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjYWRkaXRpb25zXHJcbiAgICAgKiBAcHJvcGVydHkge1R3by5Hcm91cC5DaGlsZHJlbltdfVxyXG4gICAgICogQGRlc2NyaXB0aW9uIEEgbGlzdCBvZiBhbGwgdGhlIGNoaWxkcmVuIGluIHRoZSBzY2VuZWdyYXBoLlxyXG4gICAgICogQG5vdGEtYmVuZSBUaGVyIG9yZGVyIG9mIHRoaXMgbGlzdCBpbmRpY2F0ZXMgdGhlIG9yZGVyIGVhY2ggZWxlbWVudCBpcyByZW5kZXJlZCB0byB0aGUgc2NyZWVuLlxyXG4gICAgICovXHJcbiAgICB0aGlzLmNoaWxkcmVuID0gXy5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuIDogYXJndW1lbnRzO1xyXG5cclxuICB9O1xyXG5cclxuICBfLmV4dGVuZChHcm91cCwge1xyXG5cclxuICAgIENoaWxkcmVuOiBDaGlsZHJlbixcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Hcm91cC5JbnNlcnRDaGlsZHJlblxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQgcmVuZGVyZXJzIGtub3cgY2hpbGRyZW4gaGF2ZSBiZWVuIGFkZGVkIHRvIGEge0BsaW5rIFR3by5Hcm91cH0uXHJcbiAgICAgKi9cclxuICAgIEluc2VydENoaWxkcmVuOiBmdW5jdGlvbihjaGlsZHJlbikge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcmVwbGFjZVBhcmVudC5jYWxsKHRoaXMsIGNoaWxkcmVuW2ldLCB0aGlzKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Hcm91cC5SZW1vdmVDaGlsZHJlblxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQgcmVuZGVyZXJzIGtub3cgY2hpbGRyZW4gaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSBhIHtAbGluayBUd28uR3JvdXB9LlxyXG4gICAgICovXHJcbiAgICBSZW1vdmVDaGlsZHJlbjogZnVuY3Rpb24oY2hpbGRyZW4pIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHJlcGxhY2VQYXJlbnQuY2FsbCh0aGlzLCBjaGlsZHJlbltpXSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAuT3JkZXJDaGlsZHJlblxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQgcmVuZGVyZXJzIGtub3cgb3JkZXIgaGFzIGJlZW4gdXBkYXRlZCBvbiBhIHtAbGluayBUd28uR3JvdXB9LlxyXG4gICAgICovXHJcbiAgICBPcmRlckNoaWxkcmVuOiBmdW5jdGlvbihjaGlsZHJlbikge1xyXG4gICAgICB0aGlzLl9mbGFnT3JkZXIgPSB0cnVlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Hcm91cC5Qcm9wZXJ0aWVzXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uR3JvdXB9LlxyXG4gICAgICovXHJcbiAgICBQcm9wZXJ0aWVzOiBbXHJcbiAgICAgICdmaWxsJyxcclxuICAgICAgJ3N0cm9rZScsXHJcbiAgICAgICdsaW5ld2lkdGgnLFxyXG4gICAgICAndmlzaWJsZScsXHJcbiAgICAgICdjYXAnLFxyXG4gICAgICAnam9pbicsXHJcbiAgICAgICdtaXRlcicsXHJcblxyXG4gICAgICAnY2xvc2VkJyxcclxuICAgICAgJ2N1cnZlZCcsXHJcbiAgICAgICdhdXRvbWF0aWMnXHJcbiAgICBdLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyb3VwLk1ha2VPYnNlcnZhYmxlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uR3JvdXB9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIHRoZSB7QGxpbmsgVHdvLkdyb3VwfSBjbGFzcyBvbiBhIGN1c3RvbSBjbGFzcy5cclxuICAgICAqL1xyXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iamVjdCkge1xyXG5cclxuICAgICAgdmFyIHByb3BlcnRpZXMgPSBUd28uR3JvdXAuUHJvcGVydGllcztcclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdvcGFjaXR5Jywge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29wYWNpdHk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICB0aGlzLl9mbGFnT3BhY2l0eSA9IHRoaXMuX29wYWNpdHkgIT09IHY7XHJcbiAgICAgICAgICB0aGlzLl9vcGFjaXR5ID0gdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdiZWdpbm5pbmcnLCB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5fYmVnaW5uaW5nO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xyXG4gICAgICAgICAgdGhpcy5fZmxhZ0JlZ2lubmluZyA9IHRoaXMuX2JlZ2lubmluZyAhPT0gdjtcclxuICAgICAgICAgIHRoaXMuX2JlZ2lubmluZyA9IHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSk7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnZW5kaW5nJywge1xyXG5cclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2VuZGluZztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgIHRoaXMuX2ZsYWdFbmRpbmcgPSB0aGlzLl9lbmRpbmcgIT09IHY7XHJcbiAgICAgICAgICB0aGlzLl9lbmRpbmcgPSB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ2xlbmd0aCcsIHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGlmICh0aGlzLl9mbGFnTGVuZ3RoIHx8IHRoaXMuX2xlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICB0aGlzLl9sZW5ndGggKz0gY2hpbGQubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgVHdvLlNoYXBlLk1ha2VPYnNlcnZhYmxlKG9iamVjdCk7XHJcbiAgICAgIEdyb3VwLk1ha2VHZXR0ZXJTZXR0ZXJzKG9iamVjdCwgcHJvcGVydGllcyk7XHJcblxyXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnY2hpbGRyZW4nLCB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW47XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbihjaGlsZHJlbikge1xyXG5cclxuICAgICAgICAgIHZhciBpbnNlcnRDaGlsZHJlbiA9IF8uYmluZChHcm91cC5JbnNlcnRDaGlsZHJlbiwgdGhpcyk7XHJcbiAgICAgICAgICB2YXIgcmVtb3ZlQ2hpbGRyZW4gPSBfLmJpbmQoR3JvdXAuUmVtb3ZlQ2hpbGRyZW4sIHRoaXMpO1xyXG4gICAgICAgICAgdmFyIG9yZGVyQ2hpbGRyZW4gPSBfLmJpbmQoR3JvdXAuT3JkZXJDaGlsZHJlbiwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnVuYmluZCgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuX2NoaWxkcmVuID0gbmV3IENoaWxkcmVuKGNoaWxkcmVuKTtcclxuICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLmJpbmQoVHdvLkV2ZW50cy5pbnNlcnQsIGluc2VydENoaWxkcmVuKTtcclxuICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLmJpbmQoVHdvLkV2ZW50cy5yZW1vdmUsIHJlbW92ZUNoaWxkcmVuKTtcclxuICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLmJpbmQoVHdvLkV2ZW50cy5vcmRlciwgb3JkZXJDaGlsZHJlbik7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ21hc2snLCB7XHJcblxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcblxyXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbWFzaztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAgICAgIHRoaXMuX21hc2sgPSB2O1xyXG4gICAgICAgICAgdGhpcy5fZmxhZ01hc2sgPSB0cnVlO1xyXG4gICAgICAgICAgaWYgKCF2LmNsaXApIHtcclxuICAgICAgICAgICAgdi5jbGlwID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICB9KTtcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyb3VwLk1ha2VHZXR0ZXJTZXR0ZXJzXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7VHdvLkdyb3VwfSBncm91cCAtIFRoZSBncm91cCB0byBhcHBseSBnZXR0ZXJzIGFuZCBzZXR0ZXJzLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgLSBBIGtleSAvIHZhbHVlIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgdG8gaW5oZXJpdC5cclxuICAgICAqL1xyXG4gICAgTWFrZUdldHRlclNldHRlcnM6IGZ1bmN0aW9uKGdyb3VwLCBwcm9wZXJ0aWVzKSB7XHJcblxyXG4gICAgICBpZiAoIV8uaXNBcnJheShwcm9wZXJ0aWVzKSkge1xyXG4gICAgICAgIHByb3BlcnRpZXMgPSBbcHJvcGVydGllc107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF8uZWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihrKSB7XHJcbiAgICAgICAgR3JvdXAuTWFrZUdldHRlclNldHRlcihncm91cCwgayk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAuTWFrZUdldHRlclNldHRlclxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gZ3JvdXAgLSBUaGUgZ3JvdXAgdG8gYXBwbHkgZ2V0dGVycyBhbmQgc2V0dGVycy5cclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSBUaGUga2V5IHdoaWNoIHdpbGwgYmVjb21lIGEgcHJvcGVydHkgb24gdGhlIGdyb3VwLlxyXG4gICAgICovXHJcbiAgICBNYWtlR2V0dGVyU2V0dGVyOiBmdW5jdGlvbihncm91cCwga2V5KSB7XHJcblxyXG4gICAgICB2YXIgc2VjcmV0ID0gJ18nICsga2V5O1xyXG5cclxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdyb3VwLCBrZXksIHtcclxuXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzW3NlY3JldF07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XHJcbiAgICAgICAgICB0aGlzW3NlY3JldF0gPSB2O1xyXG4gICAgICAgICAgLy8gVHJpY2tsZSBkb3duIHN0eWxlc1xyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGNoaWxkW2tleV0gPSB2O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIF8uZXh0ZW5kKEdyb3VwLnByb3RvdHlwZSwgVHdvLlNoYXBlLnByb3RvdHlwZSwge1xyXG5cclxuICAgIC8vIEZsYWdzXHJcbiAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZsYWdcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNfZmxhZ0FkZGl0aW9uc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uR3JvdXAjYWRkaXRpb25zfSBuZWVkIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ0FkZGl0aW9uczogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjX2ZsYWdTdWJ0cmFjdGlvbnNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkdyb3VwI3N1YnRyYWN0aW9uc30gbmVlZCB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdTdWJ0cmFjdGlvbnM6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI19mbGFnT3JkZXJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkdyb3VwI29yZGVyfSBuZWVkIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ09yZGVyOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNfZmxhZ09wYWNpdHlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkdyb3VwI29wYWNpdHl9IG5lZWQgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnT3BhY2l0eTogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNfZmxhZ0JlZ2lubmluZ1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uR3JvdXAjYmVnaW5uaW5nfSBuZWVkIHVwZGF0aW5nLlxyXG4gICAgICovXHJcbiAgICBfZmxhZ0JlZ2lubmluZzogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjX2ZsYWdFbmRpbmdcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkdyb3VwI2VuZGluZ30gbmVlZCB1cGRhdGluZy5cclxuICAgICAqL1xyXG4gICAgX2ZsYWdFbmRpbmc6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI19mbGFnTGVuZ3RoXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Hcm91cCNsZW5ndGh9IG5lZWQgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnTGVuZ3RoOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNfZmxhZ01hc2tcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkdyb3VwI21hc2t9IG5lZWQgdXBkYXRpbmcuXHJcbiAgICAgKi9cclxuICAgIF9mbGFnTWFzazogZmFsc2UsXHJcblxyXG4gICAgLy8gVW5kZXJseWluZyBQcm9wZXJ0aWVzXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjZmlsbFxyXG4gICAgICogQHByb3BlcnR5IHsoQ3NzQ29sb3J8VHdvLkdyYWRpZW50fFR3by5UZXh0dXJlKX0gLSBUaGUgdmFsdWUgb2Ygd2hhdCBhbGwgY2hpbGQgc2hhcGVzIHNob3VsZCBiZSBmaWxsZWQgaW4gd2l0aC5cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9jb2xvcl92YWx1ZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ1NTIENvbG9ycy5cclxuICAgICAqL1xyXG4gICAgX2ZpbGw6ICcjZmZmJyxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNzdHJva2VcclxuICAgICAqIEBwcm9wZXJ0eSB7KENzc0NvbG9yfFR3by5HcmFkaWVudHxUd28uVGV4dHVyZSl9IC0gVGhlIHZhbHVlIG9mIHdoYXQgYWxsIGNoaWxkIHNoYXBlcyBzaG91bGQgYmUgb3V0bGluZWQgaW4gd2l0aC5cclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9jb2xvcl92YWx1ZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ1NTIENvbG9ycy5cclxuICAgICAqL1xyXG4gICAgX3N0cm9rZTogJyMwMDAnLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2xpbmV3aWR0aFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHRoaWNrbmVzcyBpbiBwaXhlbHMgb2YgdGhlIHN0cm9rZSBmb3IgYWxsIGNoaWxkIHNoYXBlcy5cclxuICAgICAqL1xyXG4gICAgX2xpbmV3aWR0aDogMS4wLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI29wYWNpdHlcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBvcGFxdWVuZXNzIG9mIGFsbCBjaGlsZCBzaGFwZXMuXHJcbiAgICAgKiBAbm90YS1iZW5lIEJlY29tZXMgbXVsdGlwbGllZCBieSB0aGUgaW5kaXZpZHVhbCBjaGlsZCdzIG9wYWNpdHkgcHJvcGVydHkuXHJcbiAgICAgKi9cclxuICAgIF9vcGFjaXR5OiAxLjAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjdmlzaWJsZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERpc3BsYXkgdGhlIHBhdGggb3Igbm90LlxyXG4gICAgICogQG5vdGEtYmVuZSBGb3Ige0BsaW5rIFR3by5DYW52YXNSZW5kZXJlcn0gYW5kIHtAbGluayBUd28uV2ViR0xSZW5kZXJlcn0gd2hlbiBzZXQgdG8gZmFsc2UgYWxsIHVwZGF0aW5nIGlzIGRpc2FibGVkIGltcHJvdmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgd2l0aCBtYW55IG9iamVjdHMgaW4gdGhlIHNjZW5lLlxyXG4gICAgICovXHJcbiAgICBfdmlzaWJsZTogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNjYXBcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzExL3BhaW50aW5nLmh0bWwjU3Ryb2tlTGluZWNhcFByb3BlcnR5fVxyXG4gICAgICovXHJcbiAgICBfY2FwOiAncm91bmQnLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2pvaW5cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzExL3BhaW50aW5nLmh0bWwjU3Ryb2tlTGluZWpvaW5Qcm9wZXJ0eX1cclxuICAgICAqL1xyXG4gICAgX2pvaW46ICdyb3VuZCcsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjbWl0ZXJcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfVxyXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzExL3BhaW50aW5nLmh0bWwjU3Ryb2tlTWl0ZXJsaW1pdFByb3BlcnR5fVxyXG4gICAgICovXHJcbiAgICBfbWl0ZXI6IDQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjY2xvc2VkXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIGEgZmluYWwgbGluZSBpcyBkcmF3biBiZXR3ZWVuIHRoZSBmaW5hbCBwb2ludCBpbiB0aGUgYHZlcnRpY2VzYCBhcnJheSBhbmQgdGhlIGZpcnN0IHBvaW50IG9mIGFsbCBjaGlsZCBzaGFwZXMuXHJcbiAgICAgKi9cclxuICAgIF9jbG9zZWQ6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjY3VydmVkXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gV2hlbiB0aGUgY2hpbGQncyBwYXRoIGlzIGBhdXRvbWF0aWMgPSB0cnVlYCB0aGlzIGJvb2xlYW4gZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBsaW5lcyBiZXR3ZWVuIHRoZSBwb2ludHMgYXJlIGN1cnZlZCBvciBub3QuXHJcbiAgICAgKi9cclxuICAgIF9jdXJ2ZWQ6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2F1dG9tYXRpY1xyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciBvciBub3QgVHdvLmpzIHNob3VsZCBjYWxjdWxhdGUgY3VydmVzLCBsaW5lcywgYW5kIGNvbW1hbmRzIGF1dG9tYXRpY2FsbHkgZm9yIHlvdSBvciB0byBsZXQgdGhlIGRldmVsb3BlciBtYW5pcHVsYXRlIHRoZW0gZm9yIHRoZW1zZWx2ZXMuXHJcbiAgICAgKi9cclxuICAgIF9hdXRvbWF0aWM6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjYmVnaW5uaW5nXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBOdW1iZXIgYmV0d2VlbiB6ZXJvIGFuZCBvbmUgdG8gc3RhdGUgdGhlIGJlZ2lubmluZyBvZiB3aGVyZSB0aGUgcGF0aCBpcyByZW5kZXJlZC5cclxuICAgICAqIEBkZXNjcmlwdGlvbiB7QGxpbmsgVHdvLkdyb3VwI2JlZ2lubmluZ30gaXMgYSBwZXJjZW50YWdlIHZhbHVlIHRoYXQgcmVwcmVzZW50cyBhdCB3aGF0IHBlcmNlbnRhZ2UgaW50byBhbGwgY2hpbGQgc2hhcGVzIHNob3VsZCB0aGUgcmVuZGVyZXIgc3RhcnQgZHJhd2luZy5cclxuICAgICAqIEBub3RhLWJlbmUgVGhpcyBpcyBncmVhdCBmb3IgYW5pbWF0aW5nIGluIGFuZCBvdXQgc3Ryb2tlZCBwYXRocyBpbiBjb25qdW5jdGlvbiB3aXRoIHtAbGluayBUd28uR3JvdXAjZW5kaW5nfS5cclxuICAgICAqL1xyXG4gICAgX2JlZ2lubmluZzogMCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNlbmRpbmdcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIE51bWJlciBiZXR3ZWVuIHplcm8gYW5kIG9uZSB0byBzdGF0ZSB0aGUgZW5kaW5nIG9mIHdoZXJlIHRoZSBwYXRoIGlzIHJlbmRlcmVkLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIHtAbGluayBUd28uR3JvdXAjZW5kaW5nfSBpcyBhIHBlcmNlbnRhZ2UgdmFsdWUgdGhhdCByZXByZXNlbnRzIGF0IHdoYXQgcGVyY2VudGFnZSBpbnRvIGFsbCBjaGlsZCBzaGFwZXMgc2hvdWxkIHRoZSByZW5kZXJlciBzdGFydCBkcmF3aW5nLlxyXG4gICAgICogQG5vdGEtYmVuZSBUaGlzIGlzIGdyZWF0IGZvciBhbmltYXRpbmcgaW4gYW5kIG91dCBzdHJva2VkIHBhdGhzIGluIGNvbmp1bmN0aW9uIHdpdGgge0BsaW5rIFR3by5Hcm91cCNiZWdpbm5pbmd9LlxyXG4gICAgICovXHJcbiAgICBfZW5kaW5nOiAxLjAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjbGVuZ3RoXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgc3VtIG9mIGRpc3RhbmNlcyBiZXR3ZWVuIGFsbCBjaGlsZCBsZW5ndGhzLlxyXG4gICAgICovXHJcbiAgICBfbGVuZ3RoOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI21hc2tcclxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLlNoYXBlfSAtIFRoZSBUd28uanMgb2JqZWN0IHRvIGNsaXAgZnJvbSBhIGdyb3VwJ3MgcmVuZGVyaW5nLlxyXG4gICAgICovXHJcbiAgICBfbWFzazogbnVsbCxcclxuXHJcbiAgICBjb25zdHJ1Y3RvcjogR3JvdXAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjY2xvbmVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IFtwYXJlbnRdIC0gVGhlIHBhcmVudCBncm91cCBvciBzY2VuZSB0byBhZGQgdGhlIGNsb25lIHRvLlxyXG4gICAgICogQHJldHVybnMge1R3by5Hcm91cH1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3by5Hcm91cH0gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IGdyb3VwLlxyXG4gICAgICovXHJcbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XHJcblxyXG4gICAgICAvLyAvKipcclxuICAgICAgLy8gICogVE9ETzogR3JvdXAgaGFzIGEgZ290Y2hhIGluIHRoYXQgaXQncyBhdCB0aGUgbW9tZW50IHJlcXVpcmVkIHRvIGJlIGJvdW5kIHRvXHJcbiAgICAgIC8vICAqIGFuIGluc3RhbmNlIG9mIHR3byBpbiBvcmRlciB0byBhZGQgZWxlbWVudHMgY29ycmVjdGx5LiBUaGlzIG5lZWRzIHRvXHJcbiAgICAgIC8vICAqIGJlIHJldGhvdWdodCBhbmQgZml4ZWQuXHJcbiAgICAgIC8vICAqL1xyXG5cclxuICAgICAgdmFyIGNsb25lID0gbmV3IEdyb3VwKCk7XHJcbiAgICAgIHZhciBjaGlsZHJlbiA9IF8ubWFwKHRoaXMuY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkLmNsb25lKCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgY2xvbmUuYWRkKGNoaWxkcmVuKTtcclxuXHJcbiAgICAgIGNsb25lLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XHJcblxyXG4gICAgICBpZiAodGhpcy5tYXNrKSB7XHJcbiAgICAgICAgY2xvbmUubWFzayA9IHRoaXMubWFzaztcclxuICAgICAgfVxyXG5cclxuICAgICAgY2xvbmUudHJhbnNsYXRpb24uY29weSh0aGlzLnRyYW5zbGF0aW9uKTtcclxuICAgICAgY2xvbmUucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xyXG4gICAgICBjbG9uZS5zY2FsZSA9IHRoaXMuc2NhbGU7XHJcbiAgICAgIGNsb25lLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xyXG5cclxuICAgICAgaWYgKHRoaXMubWF0cml4Lm1hbnVhbCkge1xyXG4gICAgICAgIGNsb25lLm1hdHJpeC5jb3B5KHRoaXMubWF0cml4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgIHBhcmVudC5hZGQoY2xvbmUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gY2xvbmUuX3VwZGF0ZSgpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjdG9PYmplY3RcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHJldHVybnMge09iamVjdH1cclxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgZ3JvdXAuXHJcbiAgICAgKi9cclxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIHZhciByZXN1bHQgPSB7XHJcbiAgICAgICAgY2hpbGRyZW46IFtdLFxyXG4gICAgICAgIHRyYW5zbGF0aW9uOiB0aGlzLnRyYW5zbGF0aW9uLnRvT2JqZWN0KCksXHJcbiAgICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXHJcbiAgICAgICAgc2NhbGU6IHRoaXMuc2NhbGUgaW5zdGFuY2VvZiBUd28uVmVjdG9yID8gdGhpcy5zY2FsZS50b09iamVjdCgpIDogdGhpcy5zY2FsZSxcclxuICAgICAgICBvcGFjaXR5OiB0aGlzLm9wYWNpdHksXHJcbiAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmNsYXNzTmFtZSxcclxuICAgICAgICBtYXNrOiAodGhpcy5tYXNrID8gdGhpcy5tYXNrLnRvT2JqZWN0KCkgOiBudWxsKVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgaWYgKHRoaXMubWF0cml4Lm1hbnVhbCkge1xyXG4gICAgICAgIHJlc3VsdC5tYXRyaXggPSB0aGlzLm1hdHJpeC50b09iamVjdCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBfLmVhY2godGhpcy5jaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQsIGkpIHtcclxuICAgICAgICByZXN1bHQuY2hpbGRyZW5baV0gPSBjaGlsZC50b09iamVjdCgpO1xyXG4gICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNjb3JuZXJcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIE9yaWVudCB0aGUgY2hpbGRyZW4gb2YgdGhlIGdyb3VwIHRvIHRoZSB1cHBlciBsZWZ0LWhhbmQgY29ybmVyIG9mIHRoYXQgZ3JvdXAuXHJcbiAgICAgKi9cclxuICAgIGNvcm5lcjogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRydWUpO1xyXG4gICAgICB2YXIgY29ybmVyID0geyB4OiByZWN0LmxlZnQsIHk6IHJlY3QudG9wIH07XHJcblxyXG4gICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgICBjaGlsZC50cmFuc2xhdGlvbi5zdWIoY29ybmVyKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2NlbnRlclxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gT3JpZW50IHRoZSBjaGlsZHJlbiBvZiB0aGUgZ3JvdXAgdG8gdGhlIGNlbnRlciBvZiB0aGF0IGdyb3VwLlxyXG4gICAgICovXHJcbiAgICBjZW50ZXI6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCh0cnVlKTtcclxuXHJcbiAgICAgIHJlY3QuY2VudHJvaWQgPSB7XHJcbiAgICAgICAgeDogcmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAvIDIgLSB0aGlzLnRyYW5zbGF0aW9uLngsXHJcbiAgICAgICAgeTogcmVjdC50b3AgKyByZWN0LmhlaWdodCAvIDIgLSB0aGlzLnRyYW5zbGF0aW9uLnlcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICAgIGlmIChjaGlsZC5pc1NoYXBlKSB7XHJcbiAgICAgICAgICBjaGlsZC50cmFuc2xhdGlvbi5zdWIocmVjdC5jZW50cm9pZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjZ2V0QnlJZFxyXG4gICAgICogQGZ1bmN0aW9uXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUmVjdXJzaXZlbHkgc2VhcmNoIGZvciBpZC4gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBmb3VuZC5cclxuICAgICAqIEByZXR1cm5zIHtUd28uU2hhcGV9IC0gT3IgYG51bGxgIGlmIG5vdGhpbmcgaXMgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIGdldEJ5SWQ6IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICB2YXIgZm91bmQgPSBudWxsO1xyXG4gICAgICBmdW5jdGlvbiBzZWFyY2gobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlLmlkID09PSBpZCkge1xyXG4gICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm91bmQgPSBzZWFyY2gobm9kZS5jaGlsZHJlbltpXSwgaWQpO1xyXG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNlYXJjaCh0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjZ2V0QnlDbGFzc05hbWVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIFJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgY2xhc3Nlcy4gUmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGluZyBlbGVtZW50cy5cclxuICAgICAqIEByZXR1cm5zIHtUd28uU2hhcGVbXX0gLSBPciBlbXB0eSBhcnJheSBpZiBub3RoaW5nIGlzIGZvdW5kLlxyXG4gICAgICovXHJcbiAgICBnZXRCeUNsYXNzTmFtZTogZnVuY3Rpb24oY2xhc3NOYW1lKSB7XHJcbiAgICAgIHZhciBmb3VuZCA9IFtdO1xyXG4gICAgICBmdW5jdGlvbiBzZWFyY2gobm9kZSkge1xyXG4gICAgICAgIGlmIChfLmluZGV4T2Yobm9kZS5jbGFzc0xpc3QsIGNsYXNzTmFtZSkgPj0gMCkge1xyXG4gICAgICAgICAgZm91bmQucHVzaChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcclxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBzZWFyY2goY2hpbGQsIGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3VuZDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2VhcmNoKHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNnZXRCeVR5cGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIFJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgY2hpbGRyZW4gb2YgYSBzcGVjaWZpYyB0eXBlLCBlLmcuIHtAbGluayBUd28uUGF0aH0uIFBhc3MgYSByZWZlcmVuY2UgdG8gdGhpcyB0eXBlIGFzIHRoZSBwYXJhbS4gUmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGluZyBlbGVtZW50cy5cclxuICAgICAqIEByZXR1cm5zIHtUd28uU2hhcGVbXX0gLSBFbXB0eSBhcnJheSBpZiBub3RoaW5nIGlzIGZvdW5kLlxyXG4gICAgICovXHJcbiAgICBnZXRCeVR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcclxuICAgICAgdmFyIGZvdW5kID0gW107XHJcbiAgICAgIGZ1bmN0aW9uIHNlYXJjaChub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiB0eXBlKSB7XHJcbiAgICAgICAgICBmb3VuZC5wdXNoKG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIHNlYXJjaChjaGlsZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3VuZDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gc2VhcmNoKHRoaXMsIHR5cGUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNhZGRcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtUd28uU2hhcGVbXX0gb2JqZWN0cyAtIEFuIGFycmF5IG9mIG9iamVjdHMgdG8gYmUgYWRkZWQuIENhbiBiZSBhbHNvIGFkZGVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzLlxyXG4gICAgICogQGRlc2NyaXB0aW9uIEFkZCBvYmplY3RzIHRvIHRoZSBncm91cC5cclxuICAgICAqL1xyXG4gICAgYWRkOiBmdW5jdGlvbihvYmplY3RzKSB7XHJcblxyXG4gICAgICAvLyBBbGxvdyB0byBwYXNzIG11bHRpcGxlIG9iamVjdHMgZWl0aGVyIGFzIGFycmF5IG9yIGFzIG11bHRpcGxlIGFyZ3VtZW50c1xyXG4gICAgICAvLyBJZiBpdCdzIGFuIGFycmF5IGFsc28gY3JlYXRlIGNvcHkgb2YgaXQgaW4gY2FzZSB3ZSdyZSBnZXR0aW5nIHBhc3NlZFxyXG4gICAgICAvLyBhIGNoaWxkcmVucyBhcnJheSBkaXJlY3RseS5cclxuICAgICAgaWYgKCEob2JqZWN0cyBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICAgIG9iamVjdHMgPSBfLnRvQXJyYXkoYXJndW1lbnRzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvYmplY3RzID0gb2JqZWN0cy5zbGljZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBZGQgdGhlIG9iamVjdHNcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkID0gb2JqZWN0c1tpXTtcclxuICAgICAgICBpZiAoIShjaGlsZCAmJiBjaGlsZC5pZCkpIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW5kZXggPSBfLmluZGV4T2YodGhpcy5jaGlsZHJlbiwgY2hpbGQpO1xyXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjYWRkXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwYXJhbSB7VHdvLlNoYXBlW119IG9iamVjdHMgLSBBbiBhcnJheSBvZiBvYmplY3RzIHRvIGJlIHJlbW92ZWQuIENhbiBiZSBhbHNvIHJlbW92ZWQgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlIG9iamVjdHMgZnJvbSB0aGUgZ3JvdXAuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZTogZnVuY3Rpb24ob2JqZWN0cykge1xyXG5cclxuICAgICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoLFxyXG4gICAgICAgIGdyYW5kcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcblxyXG4gICAgICAvLyBBbGxvdyB0byBjYWxsIHJlbW92ZSB3aXRob3V0IGFyZ3VtZW50c1xyXG4gICAgICAvLyBUaGlzIHdpbGwgZGV0YWNoIHRoZSBvYmplY3QgZnJvbSBpdHMgb3duIHBhcmVudC5cclxuICAgICAgaWYgKGwgPD0gMCAmJiBncmFuZHBhcmVudCkge1xyXG4gICAgICAgIGdyYW5kcGFyZW50LnJlbW92ZSh0aGlzKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWxsb3cgdG8gcGFzcyBtdWx0aXBsZSBvYmplY3RzIGVpdGhlciBhcyBhcnJheSBvciBhcyBtdWx0aXBsZSBhcmd1bWVudHNcclxuICAgICAgLy8gSWYgaXQncyBhbiBhcnJheSBhbHNvIGNyZWF0ZSBjb3B5IG9mIGl0IGluIGNhc2Ugd2UncmUgZ2V0dGluZyBwYXNzZWRcclxuICAgICAgLy8gYSBjaGlsZHJlbnMgYXJyYXkgZGlyZWN0bHkuXHJcbiAgICAgIGlmICghKG9iamVjdHMgaW5zdGFuY2VvZiBBcnJheSkpIHtcclxuICAgICAgICBvYmplY3RzID0gXy50b0FycmF5KGFyZ3VtZW50cyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgb2JqZWN0cyA9IG9iamVjdHMuc2xpY2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3RzXHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICghb2JqZWN0c1tpXSB8fCAhKHRoaXMuY2hpbGRyZW4uaWRzW29iamVjdHNbaV0uaWRdKSkgY29udGludWU7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoXy5pbmRleE9mKHRoaXMuY2hpbGRyZW4sIG9iamVjdHNbaV0pLCAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNnZXRCb3VuZGluZ0NsaWVudFJlY3RcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2hhbGxvdz1mYWxzZV0gLSBEZXNjcmliZXMgd2hldGhlciB0byBjYWxjdWxhdGUgb2ZmIGxvY2FsIG1hdHJpeCBvciB3b3JsZCBtYXRyaXguXHJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIFJldHVybnMgb2JqZWN0IHdpdGggdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCB3aWR0aCwgaGVpZ2h0IGF0dHJpYnV0ZXMuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgd2lkdGgsIGFuZCBoZWlnaHQgcGFyYW1ldGVycyBvZiB0aGUgZ3JvdXAuXHJcbiAgICAgKi9cclxuICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogZnVuY3Rpb24oc2hhbGxvdykge1xyXG4gICAgICB2YXIgcmVjdDtcclxuXHJcbiAgICAgIC8vIFRPRE86IFVwZGF0ZSB0aGlzIHRvIG5vdCBfX2Fsd2F5c19fIHVwZGF0ZS4gSnVzdCB3aGVuIGl0IG5lZWRzIHRvLlxyXG4gICAgICB0aGlzLl91cGRhdGUodHJ1ZSk7XHJcblxyXG4gICAgICAvLyBWYXJpYWJsZXMgbmVlZCB0byBiZSBkZWZpbmVkIGhlcmUsIGJlY2F1c2Ugb2YgbmVzdGVkIG5hdHVyZSBvZiBncm91cHMuXHJcbiAgICAgIHZhciBsZWZ0ID0gSW5maW5pdHksIHJpZ2h0ID0gLUluZmluaXR5LFxyXG4gICAgICAgICAgdG9wID0gSW5maW5pdHksIGJvdHRvbSA9IC1JbmZpbml0eTtcclxuXHJcbiAgICAgIHZhciByZWdleCA9IFR3by5UZXh0dXJlLlJlZ3VsYXJFeHByZXNzaW9ucy5lZmZlY3Q7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcclxuXHJcbiAgICAgICAgaWYgKCFjaGlsZC52aXNpYmxlIHx8IHJlZ2V4LnRlc3QoY2hpbGQuX3JlbmRlcmVyLnR5cGUpKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlY3QgPSBjaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3Qoc2hhbGxvdyk7XHJcblxyXG4gICAgICAgIGlmICghXy5pc051bWJlcihyZWN0LnRvcCkgICB8fCAhXy5pc051bWJlcihyZWN0LmxlZnQpICAgfHxcclxuICAgICAgICAgICAgIV8uaXNOdW1iZXIocmVjdC5yaWdodCkgfHwgIV8uaXNOdW1iZXIocmVjdC5ib3R0b20pKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRvcCA9IG1pbihyZWN0LnRvcCwgdG9wKTtcclxuICAgICAgICBsZWZ0ID0gbWluKHJlY3QubGVmdCwgbGVmdCk7XHJcbiAgICAgICAgcmlnaHQgPSBtYXgocmVjdC5yaWdodCwgcmlnaHQpO1xyXG4gICAgICAgIGJvdHRvbSA9IG1heChyZWN0LmJvdHRvbSwgYm90dG9tKTtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICByaWdodDogcmlnaHQsXHJcbiAgICAgICAgYm90dG9tOiBib3R0b20sXHJcbiAgICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcclxuICAgICAgICBoZWlnaHQ6IGJvdHRvbSAtIHRvcFxyXG4gICAgICB9O1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjbm9GaWxsXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBkZXNjcmlwdGlvbiBBcHBseSBgbm9GaWxsYCBtZXRob2QgdG8gYWxsIGNoaWxkIHNoYXBlcy5cclxuICAgICAqL1xyXG4gICAgbm9GaWxsOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgY2hpbGQubm9GaWxsKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjbm9TdHJva2VcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIEFwcGx5IGBub1N0cm9rZWAgbWV0aG9kIHRvIGFsbCBjaGlsZCBzaGFwZXMuXHJcbiAgICAgKi9cclxuICAgIG5vU3Ryb2tlOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgY2hpbGQubm9TdHJva2UoKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNzdWJkaXZpZGVcclxuICAgICAqIEBmdW5jdGlvblxyXG4gICAgICogQGRlc2NyaXB0aW9uIEFwcGx5IGBzdWJkaXZpZGVgIG1ldGhvZCB0byBhbGwgY2hpbGQgc2hhcGVzLlxyXG4gICAgICovXHJcbiAgICBzdWJkaXZpZGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcclxuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XHJcbiAgICAgICAgY2hpbGQuc3ViZGl2aWRlLmFwcGx5KGNoaWxkLCBhcmdzKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNfdXBkYXRlXHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVzPWZhbHNlXSAtIEZvcmNlIHRoZSBwYXJlbnQgdG8gYF91cGRhdGVgIGFzIHdlbGwuXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHJlbmRlcmluZyBoYXBwZW5zIGJ5IHRoZSByZW5kZXJlci4gVGhpcyBhcHBsaWVzIGFsbCBjaGFuZ2VzIG5lY2Vzc2FyeSBzbyB0aGF0IHJlbmRlcmluZyBpcyB1cC10by1kYXRlIGJ1dCBub3QgdXBkYXRlZCBtb3JlIHRoYW4gaXQgbmVlZHMgdG8gYmUuXHJcbiAgICAgKiBAbm90YS1iZW5lIFRyeSBub3QgdG8gY2FsbCB0aGlzIG1ldGhvZCBtb3JlIHRoYW4gb25jZSBhIGZyYW1lLlxyXG4gICAgICovXHJcbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9mbGFnQmVnaW5uaW5nIHx8IHRoaXMuX2ZsYWdFbmRpbmcpIHtcclxuXHJcbiAgICAgICAgdmFyIGJlZ2lubmluZyA9IE1hdGgubWluKHRoaXMuX2JlZ2lubmluZywgdGhpcy5fZW5kaW5nKTtcclxuICAgICAgICB2YXIgZW5kaW5nID0gTWF0aC5tYXgodGhpcy5fYmVnaW5uaW5nLCB0aGlzLl9lbmRpbmcpO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcclxuICAgICAgICB2YXIgc3VtID0gMDtcclxuXHJcbiAgICAgICAgdmFyIGJkID0gYmVnaW5uaW5nICogbGVuZ3RoO1xyXG4gICAgICAgIHZhciBlZCA9IGVuZGluZyAqIGxlbmd0aDtcclxuICAgICAgICB2YXIgZGlzdGFuY2UgPSAoZWQgLSBiZCk7XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICB2YXIgbCA9IGNoaWxkLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICBpZiAoYmQgPiBzdW0gKyBsKSB7XHJcbiAgICAgICAgICAgIGNoaWxkLmJlZ2lubmluZyA9IDE7XHJcbiAgICAgICAgICAgIGNoaWxkLmVuZGluZyA9IDE7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGVkIDwgc3VtKSB7XHJcbiAgICAgICAgICAgIGNoaWxkLmJlZ2lubmluZyA9IDA7XHJcbiAgICAgICAgICAgIGNoaWxkLmVuZGluZyA9IDA7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGJkID4gc3VtICYmIGJkIDwgc3VtICsgbCkge1xyXG4gICAgICAgICAgICBjaGlsZC5iZWdpbm5pbmcgPSAoYmQgLSBzdW0pIC8gbDtcclxuICAgICAgICAgICAgY2hpbGQuZW5kaW5nID0gMTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoZWQgPiBzdW0gJiYgZWQgPCBzdW0gKyBsKSB7XHJcbiAgICAgICAgICAgIGNoaWxkLmJlZ2lubmluZyA9IDA7XHJcbiAgICAgICAgICAgIGNoaWxkLmVuZGluZyA9IChlZCAtIHN1bSkgLyBsO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2hpbGQuYmVnaW5uaW5nID0gMDtcclxuICAgICAgICAgICAgY2hpbGQuZW5kaW5nID0gMTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzdW0gKz0gbDtcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIFR3by5TaGFwZS5wcm90b3R5cGUuX3VwZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjZmxhZ1Jlc2V0XHJcbiAgICAgKiBAZnVuY3Rpb25cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIGludGVybmFsbHkgdG8gcmVzZXQgYWxsIGZsYWdzLiBFbnN1cmVzIHRoYXQgb25seSBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIGFyZSB1cGRhdGVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSByZW5kZXJlci5cclxuICAgICAqL1xyXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9mbGFnQWRkaXRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5hZGRpdGlvbnMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl9mbGFnQWRkaXRpb25zID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLl9mbGFnU3VidHJhY3Rpb25zKSB7XHJcbiAgICAgICAgdGhpcy5zdWJ0cmFjdGlvbnMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl9mbGFnU3VidHJhY3Rpb25zID0gZmFsc2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX2ZsYWdPcmRlciA9IHRoaXMuX2ZsYWdNYXNrID0gdGhpcy5fZmxhZ09wYWNpdHkgPVxyXG4gICAgICAgIHRoaXMuX2ZsYWdCZWdpbm5pbmcgPSB0aGlzLl9mbGFnRW5kaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICBUd28uU2hhcGUucHJvdG90eXBlLmZsYWdSZXNldC5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbiAgR3JvdXAuTWFrZU9ic2VydmFibGUoR3JvdXAucHJvdG90eXBlKTtcclxuXHJcbiAgLy8gLyoqXHJcbiAgLy8gICogSGVscGVyIGZ1bmN0aW9uIHVzZWQgdG8gc3luYyBwYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwIHdpdGhpbiB0aGVcclxuICAvLyAgKiBgVHdvLkdyb3VwLmNoaWxkcmVuYCBvYmplY3QuXHJcbiAgLy8gICpcclxuICAvLyAgKiBTZXQgdGhlIHBhcmVudCBvZiB0aGUgcGFzc2VkIG9iamVjdCB0byBhbm90aGVyIG9iamVjdFxyXG4gIC8vICAqIGFuZCB1cGRhdGVzIHBhcmVudC1jaGlsZCByZWxhdGlvbnNoaXBzXHJcbiAgLy8gICogQ2FsbGluZyB3aXRoIG9uZSBhcmd1bWVudHMgd2lsbCBzaW1wbHkgcmVtb3ZlIHRoZSBwYXJlbnRpbmdcclxuICAvLyAgKi9cclxuICBmdW5jdGlvbiByZXBsYWNlUGFyZW50KGNoaWxkLCBuZXdQYXJlbnQpIHtcclxuXHJcbiAgICB2YXIgcGFyZW50ID0gY2hpbGQucGFyZW50O1xyXG4gICAgdmFyIGluZGV4O1xyXG5cclxuICAgIGlmIChwYXJlbnQgPT09IG5ld1BhcmVudCkge1xyXG4gICAgICBhZGQoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LmNoaWxkcmVuLmlkc1tjaGlsZC5pZF0pIHtcclxuXHJcbiAgICAgIGluZGV4ID0gXy5pbmRleE9mKHBhcmVudC5jaGlsZHJlbiwgY2hpbGQpO1xyXG4gICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICAgIHNwbGljZSgpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBpZiAobmV3UGFyZW50KSB7XHJcbiAgICAgIGFkZCgpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgc3BsaWNlKCk7XHJcblxyXG4gICAgaWYgKHBhcmVudC5fZmxhZ0FkZGl0aW9ucyAmJiBwYXJlbnQuYWRkaXRpb25zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBwYXJlbnQuX2ZsYWdBZGRpdGlvbnMgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChwYXJlbnQuX2ZsYWdTdWJ0cmFjdGlvbnMgJiYgcGFyZW50LnN1YnRyYWN0aW9ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcGFyZW50Ll9mbGFnU3VidHJhY3Rpb25zID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlIGNoaWxkLnBhcmVudDtcclxuXHJcbiAgICBmdW5jdGlvbiBhZGQoKSB7XHJcblxyXG4gICAgICBpZiAobmV3UGFyZW50LnN1YnRyYWN0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgaW5kZXggPSBfLmluZGV4T2YobmV3UGFyZW50LnN1YnRyYWN0aW9ucywgY2hpbGQpO1xyXG5cclxuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgbmV3UGFyZW50LnN1YnRyYWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG5ld1BhcmVudC5hZGRpdGlvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGluZGV4ID0gXy5pbmRleE9mKG5ld1BhcmVudC5hZGRpdGlvbnMsIGNoaWxkKTtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICAgIG5ld1BhcmVudC5hZGRpdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNoaWxkLnBhcmVudCA9IG5ld1BhcmVudDtcclxuICAgICAgbmV3UGFyZW50LmFkZGl0aW9ucy5wdXNoKGNoaWxkKTtcclxuICAgICAgbmV3UGFyZW50Ll9mbGFnQWRkaXRpb25zID0gdHJ1ZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3BsaWNlKCkge1xyXG5cclxuICAgICAgaW5kZXggPSBfLmluZGV4T2YocGFyZW50LmFkZGl0aW9ucywgY2hpbGQpO1xyXG5cclxuICAgICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICBwYXJlbnQuYWRkaXRpb25zLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGluZGV4ID0gXy5pbmRleE9mKHBhcmVudC5zdWJ0cmFjdGlvbnMsIGNoaWxkKTtcclxuXHJcbiAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICBwYXJlbnQuc3VidHJhY3Rpb25zLnB1c2goY2hpbGQpO1xyXG4gICAgICAgIHBhcmVudC5fZmxhZ1N1YnRyYWN0aW9ucyA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcbn0pKCh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6ICh0aGlzIHx8IHNlbGYgfHwgd2luZG93KSkuVHdvKTtcclxuXG5cclxuZXhwb3J0IGRlZmF1bHQgKHRoaXMgfHwgd2luZG93KS5Ud287XHJcbiIsIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsTW9kdWxlKSB7XG5cdGlmICghb3JpZ2luYWxNb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0dmFyIG1vZHVsZSA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxNb2R1bGUpO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImV4cG9ydHNcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiaW1wb3J0IHsgQm91bmRpbmdCb3ggfSBmcm9tICdub24tbGF5ZXJlZC10aWR5LXRyZWUtbGF5b3V0J1xuaW1wb3J0IExheW91dCBmcm9tICcuL2xheW91dCdcbmltcG9ydCBIb3Jpem9udGFsTGF5b3V0IGZyb20gJy4vaG9yaXpvbnRhbC1sYXlvdXQnXG5cblxuZnVuY3Rpb24gYXV0b0xheW91dChyb290LCBpc0hvcml6b250YWwpIHtcbiAgY29uc3QgYmIgPSBuZXcgQm91bmRpbmdCb3goMCwgMClcbiAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgIGNvbnN0IGxheW91dCA9IG5ldyBIb3Jpem9udGFsTGF5b3V0KGJiKVxuICAgIGxheW91dC5sYXlvdXQocm9vdClcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsYXlvdXQgPSBuZXcgTGF5b3V0KGJiKVxuICAgIGxheW91dC5sYXlvdXQocm9vdClcbiAgfVxuXG4gIHJldHVybiByb290XG59XG5cbmV4cG9ydCBkZWZhdWx0IGF1dG9MYXlvdXRcbiIsImltcG9ydCB7IFRyZWUgfSBmcm9tICdub24tbGF5ZXJlZC10aWR5LXRyZWUtbGF5b3V0J1xuaW1wb3J0IExheW91dCBmcm9tICcuL2xheW91dCdcblxuY2xhc3MgSG9yaXpvbnRhbExheW91dCBleHRlbmRzIExheW91dCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBUcmVlIHRvIGxheW91dCwgd2l0aCBib3VuZGluZyBib3hlcyBhZGRlZCB0byBlYWNoIG5vZGUuXG4gICAgICovXG4gICAgY29udmVydCh0cmVlRGF0YSwgeCA9IDApIHtcbiAgICAgICAgaWYgKHRyZWVEYXRhID09PSBudWxsKSByZXR1cm4gbnVsbFxuXG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5iYi5hZGRCb3VuZGluZ0JveChcbiAgICAgICAgICAgIHRyZWVEYXRhLmhlaWdodCxcbiAgICAgICAgICAgIHRyZWVEYXRhLndpZHRoXG4gICAgICAgIClcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW11cbiAgICAgICAgaWYgKHRyZWVEYXRhLmNoaWxkcmVuICYmIHRyZWVEYXRhLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlRGF0YS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldID0gdGhpcy5jb252ZXJ0KHRyZWVEYXRhLmNoaWxkcmVuW2ldLCB4ICsgaGVpZ2h0KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHdpZHRoLCBoZWlnaHQsIHgsIGNoaWxkcmVuKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbiBsYXlvdXQgdHJlZSB4LCB5IGNvb3JkaW5hdGVzIGJhY2sgdG8gdHJlZURhdGEsXG4gICAgICogd2l0aCBib3VuZGluZyBib3hlcyByZW1vdmVkLlxuICAgICAqL1xuICAgIGFzc2lnbkNvb3JkaW5hdGVzKHRyZWUsIHRyZWVEYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5iYi5yZW1vdmVCb3VuZGluZ0JveCh0cmVlLngsIHRyZWUueSlcbiAgICAgICAgdHJlZURhdGEueCA9IHlcbiAgICAgICAgdHJlZURhdGEueSA9IHhcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlLmMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYXNzaWduQ29vcmRpbmF0ZXModHJlZS5jW2ldLCB0cmVlRGF0YS5jaGlsZHJlbltpXSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJlZURhdGFcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEhvcml6b250YWxMYXlvdXQiLCJpbXBvcnQgeyBUcmVlLCBsYXlvdXQgfSBmcm9tIFwibm9uLWxheWVyZWQtdGlkeS10cmVlLWxheW91dFwiO1xuXG5jbGFzcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcihib3VuZGluZ0JveCkge1xuICAgIHRoaXMuYmIgPSBib3VuZGluZ0JveDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMYXlvdXQgdHJlZURhdGEuXG4gICAqIFJldHVybiBtb2RpZmllZCB0cmVlRGF0YSBhbmQgdGhlIGJvdW5kaW5nIGJveCBlbmNvbXBhc3NpbmcgYWxsIHRoZSBub2Rlcy5cbiAgICpcbiAgICogU2VlIGdldFNpemUoKSBmb3IgbW9yZSBleHBsYW5hdGlvbi5cbiAgICovXG4gIGxheW91dCh0cmVlRGF0YSkge1xuICAgIGNvbnN0IHRyZWUgPSB0aGlzLmNvbnZlcnQodHJlZURhdGEpO1xuICAgIGxheW91dCh0cmVlKTtcbiAgICBjb25zdCB7IGJvdW5kaW5nQm94LCByZXN1bHQgfSA9IHRoaXMuYXNzaWduTGF5b3V0KHRyZWUsIHRyZWVEYXRhKTtcblxuICAgIHJldHVybiB7IHJlc3VsdCwgYm91bmRpbmdCb3ggfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIFRyZWUgdG8gbGF5b3V0LCB3aXRoIGJvdW5kaW5nIGJveGVzIGFkZGVkIHRvIGVhY2ggbm9kZS5cbiAgICovXG4gIGNvbnZlcnQodHJlZURhdGEsIHkgPSAwKSB7XG4gICAgaWYgKHRyZWVEYXRhID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5iYi5hZGRCb3VuZGluZ0JveChcbiAgICAgIHRyZWVEYXRhLndpZHRoLFxuICAgICAgdHJlZURhdGEuaGVpZ2h0XG4gICAgKTtcbiAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICBpZiAodHJlZURhdGEuY2hpbGRyZW4gJiYgdHJlZURhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWVEYXRhLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkcmVuW2ldID0gdGhpcy5jb252ZXJ0KHRyZWVEYXRhLmNoaWxkcmVuW2ldLCB5ICsgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRyZWUod2lkdGgsIGhlaWdodCwgeSwgY2hpbGRyZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbiBsYXlvdXQgdHJlZSB4LCB5IGNvb3JkaW5hdGVzIGJhY2sgdG8gdHJlZURhdGEsXG4gICAqIHdpdGggYm91bmRpbmcgYm94ZXMgcmVtb3ZlZC5cbiAgICovXG4gIGFzc2lnbkNvb3JkaW5hdGVzKHRyZWUsIHRyZWVEYXRhKSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLmJiLnJlbW92ZUJvdW5kaW5nQm94KHRyZWUueCwgdHJlZS55KTtcbiAgICB0cmVlRGF0YS54ID0geDtcbiAgICB0cmVlRGF0YS55ID0geTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUuYy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5hc3NpZ25Db29yZGluYXRlcyh0cmVlLmNbaV0sIHRyZWVEYXRhLmNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyZWVEYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gZG9lcyBhc3NpZ25Db29yZGluYXRlcyBhbmQgZ2V0U2l6ZSBpbiBvbmUgcGFzcy5cbiAgICovXG4gIGFzc2lnbkxheW91dCh0cmVlLCB0cmVlRGF0YSwgYm94ID0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IHRoaXMuYXNzaWduQ29vcmRpbmF0ZXModHJlZSwgdHJlZURhdGEpLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGF5b3V0O1xuIiwiaW1wb3J0IFZpZXdlciBmcm9tIFwiLi92aWV3ZXJcIjtcbmltcG9ydCBNaW5kTWFwIGZyb20gXCIuL21pbmRtYXBcIjtcbmltcG9ydCBNaW5kbWFwTGF5b3V0cyBmcm9tIFwiLi9sYXlvdXRzXCI7XG5pbXBvcnQgKiBhcyBQYXJzZXJzIGZyb20gXCIuL3BhcnNlclwiO1xuXG5leHBvcnQgeyBWaWV3ZXIsIE1pbmRNYXAsIE1pbmRtYXBMYXlvdXRzLCBQYXJzZXJzIH07XG4iLCJpbXBvcnQgTGF5b3V0IGZyb20gJy4vbGF5b3V0J1xuaW1wb3J0IGF1dG9MYXlvdXQgZnJvbSAnLi4vYWxnb3JpdGhtcy9hdXRvLWxheW91dCdcblxuY2xhc3MgRG93bndhcmRPcmdhbml6YXRpb25hbCBleHRlbmRzIExheW91dCB7XG4gIGRvTGF5b3V0KCkge1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLnJvb3RcbiAgICByZXR1cm4gYXV0b0xheW91dChyb290LCBmYWxzZSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEb3dud2FyZE9yZ2FuaXphdGlvbmFsXG4iLCJpbXBvcnQgUmlnaHRMb2dpY2FsIGZyb20gJy4vcmlnaHQtbG9naWNhbCdcbmltcG9ydCBEb3dud2FyZE9yZ2FuaXphdGlvbmFsIGZyb20gJy4vZG93bndhcmQtb3JnYW5pemF0aW9uYWwnXG5pbXBvcnQgVXB3YXJkT3JnYW5pemF0aW9uYWwgZnJvbSAnLi91cHdhcmQtb3JnYW5pemF0aW9uYWwnXG5pbXBvcnQgTGVmdExvZ2ljYWwgZnJvbSAnLi9sZWZ0LWxvZ2ljYWwnXG5pbXBvcnQgU3RhbmRhcmQgZnJvbSAnLi9zdGFuZGFyZCdcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgUmlnaHRMb2dpY2FsLFxuICAgIERvd253YXJkT3JnYW5pemF0aW9uYWwsXG4gICAgVXB3YXJkT3JnYW5pemF0aW9uYWwsXG4gICAgTGVmdExvZ2ljYWwsXG4gICAgU3RhbmRhcmRcbn0iLCJpbXBvcnQgTm9kZSBmcm9tICcuLi9zdHJ1Y3R1cmUvbm9kZSdcblxuXG5jbGFzcyBMYXlvdXQge1xuICBjb25zdHJ1Y3Rvcihyb290Tm9kZSwgb3B0aW9ucyA9IHt9LCBleHRyYUVkZ2VzID0gW10pIHtcbiAgICBjb25zdCBtZSA9IHRoaXNcbiAgICBtZS5yb290ID0gcm9vdE5vZGVcbiAgICBtZS5vcHRpb25zID0gb3B0aW9uc1xuICAgIG1lLmV4dHJhRWRnZXMgPSBleHRyYUVkZ2VzXG4gIH1cblxuICBpc0hvcml6b250YWwoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBkb0xheW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BsZWFzZSBvdmVycmlkZSB0aGlzIG1ldGhvZCcpXG4gIH1cblxuICBnZXROb2RlcygpIHtcbiAgICBjb25zdCByb290ID0gdGhpcy5yb290XG4gICAgY29uc3Qgbm9kZXMgPSBbXVxuICAgIGxldCBjb3VudEJ5RGVwdGggPSB7fVxuICAgIHJvb3QuZWFjaE5vZGUobm9kZSA9PiB7XG4gICAgICBjb3VudEJ5RGVwdGhbbm9kZS5kZXB0aF0gPSBjb3VudEJ5RGVwdGhbbm9kZS5kZXB0aF0gfHwgMFxuICAgICAgY291bnRCeURlcHRoW25vZGUuZGVwdGhdKytcbiAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAvLyBvcmlnaW4gZGF0YVxuICAgICAgICBkYXRhOiBub2RlLmRhdGEsXG4gICAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgICAvLyBwb3NpdGlvblxuICAgICAgICB4OiBub2RlLngsXG4gICAgICAgIHk6IG5vZGUueSxcbiAgICAgICAgY2VudFg6IG5vZGUueCArIG5vZGUud2lkdGggLyAyLFxuICAgICAgICBjZW50WTogbm9kZS55ICsgbm9kZS5oZWlnaHQgLyAyLFxuICAgICAgICAvLyBzaXplXG4gICAgICAgIGhnYXA6IG5vZGUuaGdhcCxcbiAgICAgICAgdmdhcDogbm9kZS52Z2FwLFxuICAgICAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0LFxuICAgICAgICB3aWR0aDogbm9kZS53aWR0aCxcbiAgICAgICAgYWN0dWFsSGVpZ2h0OiBub2RlLmhlaWdodCAtIG5vZGUudmdhcCAqIDIsXG4gICAgICAgIGFjdHVhbFdpZHRoOiBub2RlLndpZHRoIC0gbm9kZS5oZ2FwICogMixcbiAgICAgICAgLy8gZGVwdGhcbiAgICAgICAgZGVwdGg6IG5vZGUuZGVwdGhcbiAgICAgIH0pXG4gICAgfSlcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxuXG4gIGdldEVkZ2VzKCkge1xuICAgIGNvbnN0IG1lID0gdGhpc1xuICAgIGNvbnN0IGV4dHJhRWRnZXMgPSBtZS5leHRyYUVkZ2VzXG4gICAgY29uc3Qgcm9vdCA9IHRoaXMucm9vdFxuICAgIGNvbnN0IGVkZ2VzID0gW11cbiAgICByb290LmVhY2hOb2RlKG5vZGUgPT4ge1xuICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgZWRnZXMucHVzaCh7XG4gICAgICAgICAgc291cmNlOiBub2RlLmlkLFxuICAgICAgICAgIHRhcmdldDogY2hpbGQuaWRcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgICBlZGdlcy5jb25jYXQoZXh0cmFFZGdlcylcbiAgICByZXR1cm4gZWRnZXNcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBMYXlvdXQgXG4iLCJpbXBvcnQgTGF5b3V0IGZyb20gJy4vbGF5b3V0J1xuaW1wb3J0IGF1dG9MYXlvdXQgZnJvbSAnLi4vYWxnb3JpdGhtcy9hdXRvLWxheW91dCdcblxuY2xhc3MgTGVmdExvZ2ljYWwgZXh0ZW5kcyBMYXlvdXQge1xuICBpc0hvcml6b250YWwoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGRvTGF5b3V0KCkge1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLnJvb3RcbiAgICBhdXRvTGF5b3V0KHJvb3QsIHRydWUpXG4gICAgcm9vdC5yaWdodDJsZWZ0KClcbiAgICByZXR1cm4gcm9vdFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExlZnRMb2dpY2FsXG4iLCJpbXBvcnQgTGF5b3V0IGZyb20gJy4vbGF5b3V0J1xuaW1wb3J0IGF1dG9MYXlvdXQgZnJvbSAnLi4vYWxnb3JpdGhtcy9hdXRvLWxheW91dCdcblxuY2xhc3MgUmlnaHRMb2dpY2FsIGV4dGVuZHMgTGF5b3V0IHtcbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBkb0xheW91dCgpIHtcbiAgICBjb25zdCByb290ID0gdGhpcy5yb290XG4gICAgcmV0dXJuIGF1dG9MYXlvdXQocm9vdCwgdHJ1ZSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSaWdodExvZ2ljYWxcbiIsImltcG9ydCBMYXlvdXQgZnJvbSBcIi4vbGF5b3V0XCI7XG5pbXBvcnQgTm9kZSBmcm9tIFwiLi4vc3RydWN0dXJlL25vZGVcIjtcbmltcG9ydCBhdXRvTGF5b3V0IGZyb20gXCIuLi9hbGdvcml0aG1zL2F1dG8tbGF5b3V0XCI7XG5cbmNsYXNzIFN0YW5kYXJkIGV4dGVuZHMgTGF5b3V0IHtcbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZG9MYXlvdXQoKSB7XG4gICAgY29uc3QgbWUgPSB0aGlzO1xuICAgIGNvbnN0IHJvb3QgPSBtZS5yb290O1xuICAgIGNvbnN0IG9wdGlvbnMgPSBtZS5vcHRpb25zO1xuICAgIC8vIHNlcGFyYXRlIGludG8gbGVmdCBhbmQgcmlnaHQgdHJlZXNcbiAgICBjb25zdCBsZWZ0VHJlZSA9IG5ldyBOb2RlKHJvb3QuZGF0YSwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgY29uc3QgcmlnaHRUcmVlID0gbmV3IE5vZGUocm9vdC5kYXRhLCBvcHRpb25zLCB0cnVlKTtcbiAgICBjb25zdCB0cmVlU2l6ZSA9IHJvb3QuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGNvbnN0IHJpZ2h0VHJlZVNpemUgPSBNYXRoLnJvdW5kKHRyZWVTaXplIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlU2l6ZTsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IHJvb3QuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaSA8IHJpZ2h0VHJlZVNpemUpIHtcbiAgICAgICAgcmlnaHRUcmVlLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdFRyZWUuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGVmdFRyZWUuY2hpbGRyZW4ucmV2ZXJzZSgpO1xuICAgIC8vIGRvIGxheW91dCBmb3IgbGVmdCBhbmQgcmlnaHQgdHJlZXNcbiAgICBhdXRvTGF5b3V0KHJpZ2h0VHJlZSwgdHJ1ZSk7XG4gICAgYXV0b0xheW91dChsZWZ0VHJlZSwgdHJ1ZSk7XG4gICAgbGVmdFRyZWUucmlnaHQybGVmdCgpO1xuICAgIC8vIGNvbWJpbmUgbGVmdCBhbmQgcmlnaHQgdHJlZXNcbiAgICByaWdodFRyZWUudHJhbnNsYXRlKGxlZnRUcmVlLnggLSByaWdodFRyZWUueCwgbGVmdFRyZWUueSAtIHJpZ2h0VHJlZS55KTtcbiAgICAvLyB0cmFuc2xhdGUgcm9vdFxuICAgIHJvb3QueCA9IGxlZnRUcmVlLng7XG4gICAgcm9vdC55ID0gcmlnaHRUcmVlLnk7XG4gICAgY29uc3QgYmIgPSByb290LmdldEJvdW5kaW5nQm94KCk7XG4gICAgaWYgKGJiLnRvcCA8IDApIHtcbiAgICAgIHJvb3QudHJhbnNsYXRlKDAsIC1iYi50b3ApO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdDtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdGFuZGFyZDtcbiIsImltcG9ydCBMYXlvdXQgZnJvbSAnLi9sYXlvdXQnXG5pbXBvcnQgYXV0b0xheW91dCBmcm9tICcuLi9hbGdvcml0aG1zL2F1dG8tbGF5b3V0J1xuXG5jbGFzcyBVcHdhcmRPcmdhbml6YXRpb25hbCBleHRlbmRzIExheW91dCB7XG4gIGRvTGF5b3V0KCkge1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLnJvb3RcbiAgICBhdXRvTGF5b3V0KHJvb3QsIGZhbHNlKVxuICAgIHJvb3QuZG93bjJ1cCgpXG4gICAgcmV0dXJuIHJvb3RcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBVcHdhcmRPcmdhbml6YXRpb25hbFxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnLi9zdHJ1Y3R1cmUvbm9kZSdcbmltcG9ydCBUaGVtZSBmcm9tICcuL3N0cnVjdHVyZS90aGVtZSdcblxuXG5jbGFzcyBNaW5kTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBsYXlvdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YVxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG4gICAgICAgIHRoaXMudGhlbWUgPSBvcHRpb25zW1widGhlbWVcIl0gfHwgbmV3IFRoZW1lKGRhdGFbXCJ0aGVtZVwiXSlcbiAgICAgICAgb3B0aW9uc1tcInRoZW1lXCJdID0gdGhpcy50aGVtZVxuICAgICAgICB0aGlzLnJvb3ROb2RlID0gbmV3IE5vZGUoZGF0YSwgb3B0aW9ucylcbiAgICAgICAgdGhpcy5sYXlvdXQgPSBuZXcgbGF5b3V0KHRoaXMucm9vdE5vZGUsIG9wdGlvbnMpXG4gICAgfVxuXG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5kb0xheW91dCgpXG4gICAgfVxuXG4gICAgZ2V0Um9vdE5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3ROb2RlXG4gICAgfVxuXG4gICAgaXNIb3Jpem9udGFsTGF5b3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuaXNIb3Jpem9udGFsKClcbiAgICB9XG5cbiAgICBnZXRCb3VuZGluZ0JveCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdE5vZGUuZ2V0Qm91bmRpbmdCb3goKVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWluZE1hcCIsImltcG9ydCBUZXh0UGFyc2VyIGZyb20gJy4vdGV4dC1wYXJzZXInXG5cbmV4cG9ydCB7XG4gICAgVGV4dFBhcnNlclxufSIsIlxuXG5mdW5jdGlvbiBwYXJzZSh0ZXh0KSB7XG4gICAgbGV0IGxpbmVzID0gdGV4dC5tYXRjaCgvW15cXHJcXG5dKy9nKTtcbiAgICBsZXQgcm9vdCA9IG51bGxcbiAgICBsZXQgbGV2ZWxTdGFjayA9IFtdXG4gICAgbGV0IGN1cnJlbnRMZXZlbCA9IDBcblxuICAgIGZvciAobGV0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgaWYgKHJvb3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcm9vdCA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBnZXRDb250ZW50KGxpbmUpLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV2ZWxTdGFjay5wdXNoKHsgbm9kZTogcm9vdCwgbGV2ZWw6IDAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gZ2V0Q29udGVudChsaW5lKVxuICAgICAgICAgICAgbGV0IGxldmVsID0gZ2V0TGV2ZWwobGluZSlcbiAgICAgICAgICAgIGxldCBub2RlID0ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZXZlbCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGxhc3RJbmRleCA9IGxldmVsU3RhY2subGVuZ3RoIC0gMVxuXG4gICAgICAgICAgICB3aGlsZSAobGV2ZWxTdGFja1tsZXZlbFN0YWNrLmxlbmd0aCAtIDFdLmxldmVsID4gbGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBsZXZlbFN0YWNrLnBvcCgpXG4gICAgICAgICAgICAgICAgY3VycmVudExldmVsIC09IDFcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxldmVsICE9IGN1cnJlbnRMZXZlbCkge1xuICAgICAgICAgICAgICAgIGxldmVsU3RhY2tbbGV2ZWxTdGFjay5sZW5ndGggLSAxXS5ub2RlLmNoaWxkcmVuLnB1c2gobm9kZSlcbiAgICAgICAgICAgICAgICBsZXZlbFN0YWNrLnB1c2goeyBub2RlOiBub2RlLCBsZXZlbDogbGV2ZWwgfSlcbiAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXZlbFN0YWNrLnBvcCgpXG4gICAgICAgICAgICAgICAgbGV2ZWxTdGFja1tsZXZlbFN0YWNrLmxlbmd0aCAtIDFdLm5vZGUuY2hpbGRyZW4ucHVzaChub2RlKVxuICAgICAgICAgICAgICAgIGxldmVsU3RhY2sucHVzaCh7IG5vZGU6IG5vZGUsIGxldmVsOiBsZXZlbCB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKHJvb3QpXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9vdFxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0TGV2ZWwobGluZSkge1xuICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoL1xcdC8sIFwiICAgIFwiKVxuICAgIGxldCBsZWFkaW5nV3MgPSBsaW5lLm1hdGNoKC9eXFxzKi8pXG4gICAgbGVhZGluZ1dzID0gbGVhZGluZ1dzWzBdIHx8IFwiXCJcbiAgICByZXR1cm4gTWF0aC5yb3VuZChsZWFkaW5nV3MubGVuZ3RoIC8gNClcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGVudChsaW5lKSB7XG4gICAgbGluZSA9IGxpbmUudHJpbSgpXG4gICAgbGluZSA9IGxpbmUucmVwbGFjZSgvXlsrXFwtXypdXFxzKi8sIFwiXCIpXG4gICAgcmV0dXJuIGxpbmVcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBwYXJzZTogcGFyc2UgfSIsImltcG9ydCBUd28gZnJvbSBcInR3by5qc1wiXG5cbmNvbnN0IGxpbmVDb2xvciA9ICcjOTk5J1xuXG5mdW5jdGlvbiBkcmF3TGluZShhLCBiLCB0d28sIGlzSG9yaXpvbnRhbCA9IGZhbHNlKSB7XG4gIGlmICghaXNIb3Jpem9udGFsKSB7XG4gICAgcmV0dXJuIGRyYXdWZXJ0aWNhbExpbmsoYSwgYiwgdHdvKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBkcmF3SG9yaXpvbnRhbExpbmsoYSwgYiwgdHdvKVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdWZXJ0aWNhbExpbmsoYSwgYiwgdHdvKSB7XG4gIGxldCBiZWdpbk5vZGUgPSBhXG4gIGxldCBlbmROb2RlID0gYlxuICBsZXQgc3RhcnRQb2ludCwgZW5kUG9pbnRcblxuXG4gIGlmIChhLnkgPiBiLnkpIHtcbiAgICBiZWdpbk5vZGUgPSBiXG4gICAgZW5kTm9kZSA9IGFcbiAgfVxuICBzdGFydFBvaW50ID0gYmVnaW5Ob2RlLmdldExpbmtpbmdQb2ludHMoKS5ib3R0b21cbiAgZW5kUG9pbnQgPSBlbmROb2RlLmdldExpbmtpbmdQb2ludHMoKS50b3BcblxuXG4gIGlmIChiZWdpbk5vZGUuaXNSb290KCkpIHtcbiAgICBzdGFydFBvaW50ID0gYmVnaW5Ob2RlLmdldENlbnRlcigpXG4gIH1cbiAgaWYgKGVuZE5vZGUuaXNSb290KCkpIHtcbiAgICBlbmRQb2ludCA9IGVuZE5vZGUuZ2V0Q2VudGVyKClcbiAgfVxuXG4gIGRyYXdTTGluZShlbmRQb2ludCwgc3RhcnRQb2ludCwgZmFsc2UsIHR3bywgYSlcbn1cblxuZnVuY3Rpb24gZHJhd0hvcml6b250YWxMaW5rKGEsIGIsIHR3bykge1xuICBsZXQgYmVnaW5Ob2RlID0gYVxuICBsZXQgZW5kTm9kZSA9IGJcbiAgbGV0IHN0YXJ0UG9pbnQsIGVuZFBvaW50XG5cblxuICBpZiAoYS54ID4gYi54KSB7XG4gICAgYmVnaW5Ob2RlID0gYlxuICAgIGVuZE5vZGUgPSBhXG4gIH1cbiAgc3RhcnRQb2ludCA9IGJlZ2luTm9kZS5nZXRMaW5raW5nUG9pbnRzKCkucmlnaHRcbiAgZW5kUG9pbnQgPSBlbmROb2RlLmdldExpbmtpbmdQb2ludHMoKS5sZWZ0XG5cblxuICBpZiAoYmVnaW5Ob2RlLmlzUm9vdCgpKSB7XG4gICAgc3RhcnRQb2ludCA9IGJlZ2luTm9kZS5nZXRDZW50ZXIoKVxuICB9XG4gIGlmIChlbmROb2RlLmlzUm9vdCgpKSB7XG4gICAgZW5kUG9pbnQgPSBlbmROb2RlLmdldENlbnRlcigpXG4gIH1cblxuICBkcmF3U0xpbmUoZW5kUG9pbnQsIHN0YXJ0UG9pbnQsIHRydWUsIHR3bywgYSlcbn1cblxuZnVuY3Rpb24gZHJhd1NMaW5lKHN0YXJ0UG9pbnQsIGVuZFBvaW50LCBpc0hvcml6b250YWwsIHR3bywgc3R5bGUpIHtcbiAgbGV0IGFuY2hvcnMgPSBbXVxuICBsZXQgc3RhcnRBbmNob3IsIGVuZEFuY2hvclxuXG4gIGlmIChpc0hvcml6b250YWwpIHtcbiAgICBzdGFydEFuY2hvciA9IHsgeDogTWF0aC5yb3VuZCgoZW5kUG9pbnQueCAtIHN0YXJ0UG9pbnQueCkgLyAyKSwgeTogMCB9XG4gICAgZW5kQW5jaG9yID0geyB4OiBNYXRoLnJvdW5kKChzdGFydFBvaW50LnggLSBlbmRQb2ludC54KSAvIDIpLCB5OiAwIH1cbiAgfSBlbHNlIHtcbiAgICBzdGFydEFuY2hvciA9IHsgeDogMCwgeTogTWF0aC5yb3VuZCgoZW5kUG9pbnQueSAtIHN0YXJ0UG9pbnQueSkgLyAyKSB9XG4gICAgZW5kQW5jaG9yID0geyB4OiAwLCB5OiBNYXRoLnJvdW5kKChzdGFydFBvaW50LnkgLSBlbmRQb2ludC55KSAvIDIpIH1cbiAgfVxuXG4gIGFuY2hvcnMucHVzaChuZXcgVHdvLkFuY2hvcihzdGFydFBvaW50LngsIHN0YXJ0UG9pbnQueSwgMCwgMCwgc3RhcnRBbmNob3IueCwgc3RhcnRBbmNob3IueSkpXG4gIGFuY2hvcnMucHVzaChuZXcgVHdvLkFuY2hvcihlbmRQb2ludC54LCBlbmRQb2ludC55LCBlbmRBbmNob3IueCwgZW5kQW5jaG9yLnksIDAsIDApKVxuXG4gIGxldCBwYXRoID0gbmV3IFR3by5QYXRoKGFuY2hvcnMsIGZhbHNlLCB0cnVlKVxuICBwYXRoLnN0cm9rZSA9IHN0eWxlLmdldFN0eWxlKFwibGluZS1jb2xvclwiKVxuICBwYXRoLmxpbmV3aWR0aCA9IHN0eWxlLmdldFN0eWxlKFwibGluZS13aWR0aFwiKVxuICBwYXRoLm5vRmlsbCgpXG4gIHR3by5hZGQocGF0aClcbn1cblxuXG5cbmZ1bmN0aW9uIGRyYXdQb2ludCh7IHgsIHkgfSwgdHdvKSB7XG4gIHR3by5tYWtlQ2lyY2xlKHgsIHksIDUpLmZpbGwgPSAncmdiKDAsIDIwMCwgMjU1KSc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRyYXdMaW5lXG5cbiIsImltcG9ydCByYW5kb21Db2xvciBmcm9tICcuLi9zYW1wbGUvcmFuZG9tLWNvbG9yJ1xuXG5mdW5jdGlvbiBkcmF3Tm9kZShub2RlLCBjdHgpIHtcbiAgZHJhd1NoYXBlKG5vZGUsIGN0eClcbiAgZHJhd1RleHQobm9kZSwgY3R4KVxufVxuXG5mdW5jdGlvbiBkcmF3U2hhcGUobm9kZSwgY3R4KSB7XG4gIHN3aXRjaCAobm9kZS5nZXRTdHlsZShcInNoYXBlXCIpKSB7XG4gICAgY2FzZSBcImxpbmVcIjpcbiAgICAgIGRyYXdMaW5lKG5vZGUsIGN0eClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGRyYXdSb3VuZGVkUmVjdChub2RlLCBjdHgpXG5cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3Um91bmRlZFJlY3Qobm9kZSwgY3R4KSB7XG4gIGxldCB7IHdpZHRoLCBoZWlnaHQgfSA9IG5vZGUuZ2V0Qm94KClcbiAgbGV0IHsgeCwgeSB9ID0gbm9kZS5nZXRDZW50ZXIoKVxuICBsZXQgcmVjdCA9IGN0eC5tYWtlUm91bmRlZFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCAzKVxuICByZWN0LnN0cm9rZSA9IG5vZGUuZ2V0U3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIpXG4gIHJlY3QuZmlsbCA9IG5vZGUuZ2V0U3R5bGUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIpXG59XG5cbmZ1bmN0aW9uIGRyYXdMaW5lKG5vZGUsIGN0eCkge1xuICBsZXQgbGlua2luZ1BvaW50cyA9IG5vZGUuZ2V0TGlua2luZ1BvaW50cygpXG4gIGxldCBsaW5lID0gY3R4Lm1ha2VMaW5lKGxpbmtpbmdQb2ludHMubGVmdC54LCBsaW5raW5nUG9pbnRzLmxlZnQueSwgbGlua2luZ1BvaW50cy5yaWdodC54LCBsaW5raW5nUG9pbnRzLnJpZ2h0LnkpXG4gIGxldCBwYXJlbnQgPSBub2RlLnBhcmVudCB8fCBub2RlXG4gIGxpbmUuc3Ryb2tlID0gcGFyZW50LmdldFN0eWxlKFwibGluZS1jb2xvclwiKVxuICBsaW5lLmxpbmV3aWR0aCA9IHBhcmVudC5nZXRTdHlsZShcImxpbmUtd2lkdGhcIilcbn1cblxuZnVuY3Rpb24gZHJhd1RleHQobm9kZSwgY3R4KSB7XG4gIGxldCB7IHgsIHkgfSA9IG5vZGUuZ2V0Q2VudGVyKClcblxuICB2YXIgdGV4dCA9IG5ldyBUd28uVGV4dChub2RlLmNvbnRlbnQsIHgsIHkpO1xuICB0ZXh0LmNvbG9yID0gbm9kZS5nZXRTdHlsZShcImNvbG9yXCIpXG4gIHRleHQuc2l6ZSA9IG5vZGUuZ2V0U3R5bGUoXCJmb250LXNpemVcIilcbiAgY3R4LmFkZCh0ZXh0KVxufVxuXG5leHBvcnQgZGVmYXVsdCBkcmF3Tm9kZVxuXG4iLCJpbXBvcnQgZHJhd0xpbmsgZnJvbSAnLi9kcmF3LWxpbmsuanMnXG5pbXBvcnQgZHJhd05vZGUgZnJvbSAnLi9kcmF3LW5vZGUuanMnXG5pbXBvcnQgVHdvIGZyb20gJ3R3by5qcydcblxuLypcbnsgd2lkdGg6IDUwMCwgaGVpZ2h0OiA1MDAgfVxuKi9cbmNsYXNzIFJlbmRlcmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0d29DdHgsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy50d28gPSB0d29DdHhcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIH1cblxuICAgIHJlbmRlcihtaW5kTWFwKSB7XG4gICAgICAgIHRoaXMudHdvLmNsZWFyKClcbiAgICAgICAgbWluZE1hcFxuICAgICAgICAgICAgLmdldFJvb3ROb2RlKClcbiAgICAgICAgICAgIC5lYWNoTm9kZShub2RlID0+IHtcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkcmF3TGluayhub2RlLCBjaGlsZCwgdGhpcy50d28sIG1pbmRNYXAuaXNIb3Jpem9udGFsTGF5b3V0KCkpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBkcmF3Tm9kZShub2RlLCB0aGlzLnR3bywgMSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIHRoaXMudHdvLnVwZGF0ZSgpXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBSZW5kZXJlciIsIlxuY29uc3QgY29sb3JzID0gW1wiI0ZGQzMxMlwiLCBcIiNDNEU1MzhcIiwgXCIjMTJDQkM0XCIsIFwiI0ZEQTdERlwiLCBcIiNFRDRDNjdcIiwgXCIjRjc5RjFGXCIsIFwiI0EzQ0IzOFwiLCBcIiMxMjg5QTdcIixcbiAgXCIjRDk4MEZBXCIsIFwiI0I1MzQ3MVwiLCBcIiM4MzM0NzFcIiwgXCIjOTk4MEZBXCIsIFwiIzA2NTJERFwiLCBcIiMwMDk0MzJcIiwgXCIjRUU1QTI0XCIsIFwiI0VBMjAyN1wiLCBcIiMwMDYyNjZcIiwgXCIjNTc1OEJCXCIsIFwiIzZGMUU1MVwiXTtcblxuZnVuY3Rpb24gcmFuZG9tSW50KG1heCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KTtcbn1cbmV4cG9ydCBkZWZhdWx0ICgpID0+IHtcbiAgbGV0IGluZGV4ID0gcmFuZG9tSW50KGNvbG9ycy5sZW5ndGgpO1xuICByZXR1cm4gY29sb3JzW2luZGV4XTtcbn1cbiIsImltcG9ydCBUd28gZnJvbSAndHdvLmpzJ1xuaW1wb3J0IFN0eWxlIGZyb20gJy4vc3R5bGUnXG5cbmNvbnN0IFBFTSA9IDE4XG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgaG9yaXpvbnRhbF9nYXA6IFBFTSxcbiAgdmVydGljYWxfZ2FwOiBQRU1cbn1cblxuXG5jbGFzcyBOb2RlIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgb3B0aW9ucyA9IHt9LCBpc29sYXRlZCwgcGFyZW50KSB7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBOb2RlKSByZXR1cm4gZGF0YVxuXG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucylcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG5cbiAgICB0aGlzLmlkID0gZGF0YS5pZFxuICAgIHRoaXMuZGF0YSA9IGRhdGFcbiAgICB0aGlzLmNvbnRlbnQgPSBkYXRhLm5hbWUgfHwgZGF0YS5jb250ZW50XG4gICAgdGhpcy52Z2FwID0gdGhpcy5oZ2FwID0gMFxuICAgIHRoaXMueCA9IHRoaXMueSA9IDBcblxuICAgIC8qIE5leHQgbWlsZXN0b25lICovXG4gICAgdGhpcy5zdHlsZSA9IGRhdGFbXCJzdHlsZVwiXSAmJiBuZXcgU3R5bGUoZGF0YVtcInN0eWxlXCJdKVxuICAgIHRoaXMuc2hhcGUgPSBudWxsXG4gICAgdGhpcy50eXBlID0gbnVsbCAvLyBib3ggfCBsaW5lXG4gICAgLyogZW5kICovXG5cbiAgICB0aGlzLmRlcHRoID0gcGFyZW50ID09IG51bGwgPyAwIDogcGFyZW50LmRlcHRoICsgMVxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdXG4gICAgdGhpcy5jbGFzc05hbWUgPSBcIlwiXG4gICAgdGhpcy5kZWNpZGVDbGFzc05hbWUoKVxuXG4gICAgdGhpcy53aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKVxuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKVxuICAgIHRoaXMuYWRkR2FwKG9wdGlvbnMuaG9yaXpvbnRhbF9nYXAsIG9wdGlvbnMudmVydGljYWxfZ2FwKVxuXG4gICAgaWYgKCFpc29sYXRlZCAmJiAhZGF0YS5pc0NvbGxhcHNlZCkge1xuICAgICAgaWYgKCF0aGlzLmRhdGEuaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmRhdGEuY2hpbGRyZW4gfHwgW11cbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBuZXcgTm9kZShpdGVtLCBvcHRpb25zLCBmYWxzZSwgdGhpcylcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpXG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlY2lkZUNsYXNzTmFtZSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuZGVwdGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcInJvb3RcIlxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwibWFpbi1icmFuY2hcIlxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSBcInN1Yi1icmFuY2hcIlxuICAgIH1cbiAgfVxuXG4gIGdldFN0eWxlKGF0dHJpYnV0ZSkge1xuICAgIGxldCBzdHlsZSA9IHRoaXMuZ2V0U3R5bGVPYmplY3QoKVxuICAgIGxldCB2YWx1ZSA9IHN0eWxlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpXG5cbiAgICBpZiAoKHZhbHVlID09IFwiaW5oZXJpdFwiIHx8IHZhbHVlID09IG51bGwpICYmIHRoaXMucGFyZW50ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRTdHlsZShhdHRyaWJ1dGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgfVxuXG4gIGdldFN0eWxlT2JqZWN0KCkge1xuICAgIGlmICh0aGlzLnN0eWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHlsZS5tZXJnZU1pc3NpbmdBdHRyaWJ1dGUodGhpcy5nZXRDbGFzc1N0eWxlKCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldENsYXNzU3R5bGUoKVxuICAgIH1cblxuICB9XG5cbiAgZ2V0Q2xhc3NTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRoZW1lLmdldENsYXNzKHRoaXMuY2xhc3NOYW1lKVxuICB9XG5cbiAgY2xlYXJTdHlsZSgpIHtcbiAgICB0aGlzLnN0eWxlID0gbnVsbFxuICB9XG5cbiAgaXNSb290KCkge1xuICAgIHJldHVybiAodGhpcy5kZXB0aCA9PT0gMClcbiAgfVxuXG4gIGFkZEdhcChoZ2FwLCB2Z2FwKSB7XG4gICAgdGhpcy5oZ2FwICs9IGhnYXBcbiAgICB0aGlzLnZnYXAgKz0gdmdhcFxuICAgIHRoaXMud2lkdGggKz0gMiAqIGhnYXBcbiAgICB0aGlzLmhlaWdodCArPSAyICogdmdhcFxuICB9XG5cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIGlmICh0aGlzLmlzUm9vdCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdHlsZShcImZvbnQtc2l6ZVwiKSAqIDIuNFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRTdHlsZShcImZvbnQtc2l6ZVwiKSAqIDEuNlxuICB9XG5cbiAgZ2V0V2lkdGgoKSB7XG4gICAgdmFyIHRleHQgPSBuZXcgVHdvLlRleHQodGhpcy5jb250ZW50LCAwLCAwKVxuICAgIHRleHQuc2l6ZSA9IHRoaXMuZ2V0U3R5bGUoXCJmb250LXNpemVcIilcblxuICAgIGlmICh0aGlzLmlzUm9vdCgpKSB7XG4gICAgICByZXR1cm4gdGV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAqIDEuNSArIHRoaXMuZ2V0U3R5bGUoXCJmb250LXNpemVcIikgKiAxLjZcbiAgICB9XG4gICAgcmV0dXJuIHRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKyB0aGlzLmdldFN0eWxlKFwiZm9udC1zaXplXCIpICogMS42XG4gIH1cblxuXG5cblxuICBlYWNoTm9kZShjYWxsYmFjaykge1xuXG4gICAgbGV0IG5vZGVzID0gW3RoaXNdXG4gICAgbGV0IGN1cnJlbnQgPSBudWxsXG4gICAgd2hpbGUgKGN1cnJlbnQgPSBub2Rlcy5wb3AoKSkge1xuICAgICAgY2FsbGJhY2soY3VycmVudClcbiAgICAgIG5vZGVzID0gbm9kZXMuY29uY2F0KGN1cnJlbnQuY2hpbGRyZW4pXG4gICAgfVxuICB9XG5cbiAgZ2V0Qm94KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogTWF0aC5mbG9vcih0aGlzLndpZHRoIC0gdGhpcy5oZ2FwICogMiksXG4gICAgICBoZWlnaHQ6IE1hdGguZmxvb3IodGhpcy5oZWlnaHQgLSB0aGlzLnZnYXAgKiAyKSxcbiAgICAgIHg6IE1hdGguZmxvb3IodGhpcy54ICsgdGhpcy5oZ2FwKSxcbiAgICAgIHk6IE1hdGguZmxvb3IodGhpcy55IC0gdGhpcy52Z2FwKVxuICAgIH1cbiAgfVxuXG4gIGdldENlbnRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy54ICsgdGhpcy53aWR0aCAvIDIsXG4gICAgICB5OiB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDJcbiAgICB9XG4gIH1cblxuICBnZXRMaW5raW5nUG9pbnRzKCkge1xuICAgIGxldCB7IHgsIHkgfSA9IHRoaXMuZ2V0Q2VudGVyKClcbiAgICBsZXQgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLmdldEJveCgpXG5cbiAgICBsZXQgZGF0YSA9IHtcbiAgICAgIHRvcDoge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiBNYXRoLnJvdW5kKHkgLSBoZWlnaHQgLyAyKSxcbiAgICAgIH0sXG4gICAgICByaWdodDoge1xuICAgICAgICB4OiBNYXRoLnJvdW5kKHggKyB3aWR0aCAvIDIpLFxuICAgICAgICB5OiB5XG4gICAgICB9LFxuICAgICAgYm90dG9tOiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IE1hdGgucm91bmQoeSArIGhlaWdodCAvIDIpLFxuICAgICAgfSxcbiAgICAgIGxlZnQ6IHtcbiAgICAgICAgeDogTWF0aC5yb3VuZCh4IC0gd2lkdGggLyAyKSxcbiAgICAgICAgeTogeVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmdldFN0eWxlKFwic2hhcGVcIikgPT0gXCJsaW5lXCIpIHtcbiAgICAgIGxldCB0bXAgPSB7XG4gICAgICAgIHJpZ2h0OiB7XG4gICAgICAgICAgeDogTWF0aC5yb3VuZCh4ICsgd2lkdGggLyAyKSxcbiAgICAgICAgICB5OiBNYXRoLnJvdW5kKHkgKyBoZWlnaHQgLyAyKVxuICAgICAgICB9LFxuICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgeDogTWF0aC5yb3VuZCh4IC0gd2lkdGggLyAyKSxcbiAgICAgICAgICB5OiBNYXRoLnJvdW5kKHkgKyBoZWlnaHQgLyAyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YSwgdG1wKVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICBnZXRCb3VuZGluZ0JveCgpIHtcbiAgICBjb25zdCBiYiA9IHtcbiAgICAgIGxlZnQ6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICB0b3A6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH1cbiAgICB0aGlzLmVhY2hOb2RlKG5vZGUgPT4ge1xuICAgICAgYmIubGVmdCA9IE1hdGgubWluKGJiLmxlZnQsIG5vZGUueClcbiAgICAgIGJiLnRvcCA9IE1hdGgubWluKGJiLnRvcCwgbm9kZS55KVxuICAgICAgYmIud2lkdGggPSBNYXRoLm1heChiYi53aWR0aCwgbm9kZS54ICsgbm9kZS53aWR0aClcbiAgICAgIGJiLmhlaWdodCA9IE1hdGgubWF4KGJiLmhlaWdodCwgbm9kZS55ICsgbm9kZS5oZWlnaHQpXG4gICAgfSlcbiAgICByZXR1cm4gYmJcbiAgfVxuXG4gIHRyYW5zbGF0ZSh0eCA9IDAsIHR5ID0gMCkge1xuICAgIHRoaXMuZWFjaE5vZGUobm9kZSA9PiB7XG4gICAgICBub2RlLnggKz0gdHhcbiAgICAgIG5vZGUueSArPSB0eVxuICAgIH0pXG4gIH1cblxuICByaWdodDJsZWZ0KCkge1xuICAgIGNvbnN0IGJiID0gdGhpcy5nZXRCb3VuZGluZ0JveCgpXG4gICAgdGhpcy5lYWNoTm9kZShub2RlID0+IHtcbiAgICAgIG5vZGUueCA9IG5vZGUueCAtIChub2RlLnggLSBiYi5sZWZ0KSAqIDIgLSBub2RlLndpZHRoXG4gICAgfSlcbiAgICB0aGlzLnRyYW5zbGF0ZShiYi53aWR0aCwgMClcbiAgfVxuXG4gIGRvd24ydXAoKSB7XG4gICAgY29uc3QgYmIgPSB0aGlzLmdldEJvdW5kaW5nQm94KClcbiAgICB0aGlzLmVhY2hOb2RlKG5vZGUgPT4ge1xuICAgICAgbm9kZS55ID0gbm9kZS55IC0gKG5vZGUueSAtIGJiLnRvcCkgKiAyIC0gbm9kZS5oZWlnaHRcbiAgICB9KVxuICAgIHRoaXMudHJhbnNsYXRlKDAsIGJiLmhlaWdodClcbiAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IE5vZGUgIFxuIiwiXG5jb25zdCBERUZBVUxUX1NUWUxFID0ge1xuICAgIC8vIFwic2hhcGVcIjogXCJyb3VuZGVkLXJlY3RhbmdsZVwiLFxuICAgIC8vIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIiNhYWFhYWFcIixcbiAgICAvLyBcImNvbG9yXCI6IFwiIzY2NjY2NlwiLFxuICAgIC8vIFwiZm9udC1zaXplXCI6IDEzLFxuICAgIC8vIFwiZm9udC13ZWlnaHRcIjogNDAwLFxuICAgIC8vIFwiZm9udC1zdHlsZVwiOiBcIm5vcm1hbFwiLFxuICAgIC8vIFwibGluZS1jb2xvclwiOiBcImluaGVyaXRcIixcbiAgICAvLyBcImxpbmUtd2lkdGhcIjogMlxufVxuXG5cbmNvbnN0IHNuYWtlVG9DYW1lbCA9IChzdHIpID0+IHN0ci5yZXBsYWNlKFxuICAgIC8oWy1fXVthLXpdKS9nLFxuICAgIChncm91cCkgPT4gZ3JvdXAudG9VcHBlckNhc2UoKVxuICAgICAgICAucmVwbGFjZSgnLScsICcnKVxuICAgICAgICAucmVwbGFjZSgnXycsICcnKVxuKTtcblxuXG5jbGFzcyBTdHlsZSB7XG4gICAgY29uc3RydWN0b3Ioc3R5bGUpIHtcbiAgICAgICAgc3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NUWUxFLCBzdHlsZSB8fCB7fSlcbiAgICAgICAgdGhpcy5zaGFwZSA9IHN0eWxlW1wic2hhcGVcIl1cbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBzdHlsZVtcImJhY2tncm91bmQtY29sb3JcIl1cblxuICAgICAgICB0aGlzLmZvbnRTaXplID0gc3R5bGVbXCJmb250LXNpemVcIl1cbiAgICAgICAgdGhpcy5mb250RmFtaWx5ID0gc3R5bGVbXCJmb250LXNpemVcIl1cbiAgICAgICAgdGhpcy5mb250V2VpZ2h0ID0gc3R5bGVbXCJmb250LXdlaWdodFwiXVxuICAgICAgICB0aGlzLmZvbnRTdHlsZSA9IHN0eWxlW1wiZm9udC1zdHlsZVwiXVxuICAgICAgICB0aGlzLmNvbG9yID0gc3R5bGVbXCJjb2xvclwiXVxuXG4gICAgICAgIHRoaXMubGluZUNvbG9yID0gc3R5bGVbXCJsaW5lLWNvbG9yXCJdXG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gc3R5bGVbXCJsaW5lLXdpZHRoXCJdXG4gICAgfVxuXG4gICAgbWVyZ2VNaXNzaW5nQXR0cmlidXRlKG90aGVyU3R5bGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBhdHQgaW4gdGhpcykge1xuICAgICAgICAgICAgaWYgKGF0dCBpbiBvdGhlclN0eWxlICYmIHRoaXNbYXR0XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpc1thdHRdID0gb3RoZXJTdHlsZVthdHRdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBnZXRBdHRyaWJ1dGUobmFtZSkge1xuICAgICAgICBuYW1lID0gc25ha2VUb0NhbWVsKG5hbWUpXG4gICAgICAgIHJldHVybiB0aGlzW25hbWVdXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdHlsZSIsImltcG9ydCBTdHlsZSBmcm9tIFwiLi9zdHlsZVwiXG5cbmNvbnN0IERFRkFVTFRfVEhFTUUgPSB7XG4gICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwiI2ZmZlwiLFxuICAgIFwiY2xhc3Nlc1wiOiB7XG4gICAgICAgIFwicm9vdFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwicm91bmRlZF9yZWN0YW5nbGVcIixcbiAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIiNGNjIxMkRcIixcbiAgICAgICAgICAgIFwiZm9udC1zaXplXCI6IDI4LFxuICAgICAgICAgICAgXCJmb250LWZhbWlseVwiOiBcIkFyaWFsXCIsXG4gICAgICAgICAgICBcImNvbG9yXCI6IFwiI2ZmZlwiLFxuICAgICAgICAgICAgXCJsaW5lLWNvbG9yXCI6IFwiIzMzMzMzM1wiLFxuICAgICAgICAgICAgXCJsaW5lLXdpZHRoXCI6IDRcbiAgICAgICAgfSxcbiAgICAgICAgXCJtYWluLWJyYW5jaFwiOiB7XG4gICAgICAgICAgICBcInNoYXBlXCI6IFwicm91bmRlZF9yZWN0YW5nbGVcIixcbiAgICAgICAgICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIiMwMjg4RDFcIixcbiAgICAgICAgICAgIFwiZm9udC1zaXplXCI6IDIwLFxuICAgICAgICAgICAgXCJmb250LWZhbWlseVwiOiBcIkFyaWFsXCIsXG4gICAgICAgICAgICBcImNvbG9yXCI6IFwiIzMzM1wiLFxuICAgICAgICAgICAgXCJsaW5lLWNvbG9yXCI6IFwiaW5oZXJpdFwiLFxuICAgICAgICAgICAgXCJsaW5lLXdpZHRoXCI6IDJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzdWItYnJhbmNoXCI6IHtcbiAgICAgICAgICAgIFwic2hhcGVcIjogXCJyb3VuZGVkX3JlY3RhbmdsZVwiLFxuICAgICAgICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwibm9uZVwiLFxuICAgICAgICAgICAgXCJmb250LXNpemVcIjogMTQsXG4gICAgICAgICAgICBcImZvbnQtZmFtaWx5XCI6IFwiQXJpYWxcIixcbiAgICAgICAgICAgIFwiY29sb3JcIjogXCIjMzMzXCJcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgVGhlbWUge1xuICAgIGNvbnN0cnVjdG9yKHRoZW1lT2JqZWN0KSB7XG4gICAgICAgIGxldCB0aGVtZSA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfVEhFTUUsIHRoZW1lT2JqZWN0IHx8IHt9KVxuICAgICAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKHRoZW1lKVxuICAgICAgICB0aGlzLmNsYXNzZXMgPSB7fVxuXG4gICAgICAgIGZvciAoY29uc3QgY2xhc3NOYW1lIGluIHRoZW1lW1wiY2xhc3Nlc1wiXSkge1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzW2NsYXNzTmFtZV0gPSBuZXcgU3R5bGUodGhlbWUuY2xhc3Nlc1tjbGFzc05hbWVdKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Q2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzZXNbY2xhc3NOYW1lXVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVGhlbWUiLCJpbXBvcnQgVHdvIGZyb20gXCJ0d28uanNcIjtcbmltcG9ydCBSZW5kZXJlciBmcm9tIFwiLi9yZW5kZXJlclwiO1xuXG4vKlxueyB3aWR0aDogNTAwLCBoZWlnaHQ6IDUwMCB9XG4qL1xuY2xhc3MgTWluZG1hcFZpZXdlciB7XG4gIGNvbnN0cnVjdG9yKHNlbGVjdG9yLCBvcHRpb25zKSB7XG4gICAgbGV0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgaWYgKGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiSW52YWxpZCBzZWxlY3RvclwiO1xuICAgIH1cblxuICAgIHRoaXMuY29udGFpbmVyID0gZWw7XG4gICAgdGhpcy53aWR0aCA9IGVsLm9mZnNldFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gZWwub2Zmc2V0SGVpZ2h0O1xuICAgIHRoaXMudHdvID0gbmV3IFR3byh7IHdpZHRoOiB0aGlzLndpZHRoLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0IH0pLmFwcGVuZFRvKGVsKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKHRoaXMudHdvLCBvcHRpb25zKTtcblxuICAgIHRoaXMuc2NhbGUgPSAxO1xuICAgIHRoaXMuY2VudGVyID0ge1xuICAgICAgeDogdGhpcy5vZmZzZXRXaWR0aCAvIDIsXG4gICAgICB5OiB0aGlzLm9mZnNldEhlaWdodCAvIDIsXG4gICAgfTtcbiAgICB0aGlzLmJpbmRNb3VzZUV2ZW50KCk7XG4gICAgdGhpcy5iaW5kTW91c2VEcmFnKCk7XG4gICAgdGhpcy5taW5kTWFwID0gbnVsbDtcbiAgfVxuXG4gIHNldFNjYWxlKHNjYWxlKSB7XG4gICAgaWYgKHNjYWxlIDw9IDApIHtcbiAgICAgIHJhaXNlKFwiU2NhbGUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgICAgdGhpcy50d28uc2NlbmUuc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgdGhpcy50d28udXBkYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKG1pbmRNYXApIHtcbiAgICB0aGlzLm1pbmRNYXAgPSBtaW5kTWFwO1xuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG1pbmRNYXAudGhlbWUuc3R5bGUuZ2V0QXR0cmlidXRlKFxuICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAgICApO1xuICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKG1pbmRNYXApO1xuICB9XG5cbiAgem9vbUluKHBlcmNlbnQsIHggPSAwLCB5ID0gMCkge1xuICAgIHRoaXMuem9vbUJ5KHBlcmNlbnQsIHgsIHkpO1xuICB9XG5cbiAgem9vbU91dChwZXJjZW50LCB4ID0gMCwgeSA9IDApIHtcbiAgICB0aGlzLnpvb21CeSgtcGVyY2VudCk7XG4gIH1cblxuICB6b29tQnkocGVyY2VudCwgeCA9IDAsIHkgPSAwKSB7XG4gICAgbGV0IGR4ID0geCAqICh0aGlzLnNjYWxlICsgcGVyY2VudCkgLSB4ICogdGhpcy5zY2FsZTtcbiAgICBsZXQgZHkgPSB5ICogKHRoaXMuc2NhbGUgKyBwZXJjZW50KSAtIHkgKiB0aGlzLnNjYWxlO1xuICAgIHRoaXMudHdvLnNjZW5lLnNjYWxlID0gdGhpcy5zY2FsZSA9IHRoaXMuc2NhbGUgKyBwZXJjZW50O1xuXG4gICAgdGhpcy50cmFuc2xhdGVCeSgtZHgsIC1keSk7XG4gICAgdGhpcy50d28udXBkYXRlKCk7XG4gIH1cblxuICBjZW50ZXJWaWV3KCkge1xuICAgIGxldCBjbGllbnRSZWN0ID0gdGhpcy5taW5kTWFwLmdldEJvdW5kaW5nQm94KCk7XG4gICAgbGV0IGNlbnRlclggPSAoY2xpZW50UmVjdC5sZWZ0ICsgY2xpZW50UmVjdC53aWR0aCAvIDIpICogdGhpcy5zY2FsZTtcbiAgICBsZXQgY2VudGVyWSA9IChjbGllbnRSZWN0LnRvcCArIGNsaWVudFJlY3QuaGVpZ2h0IC8gMikgKiB0aGlzLnNjYWxlO1xuICAgIGxldCBjbGllbnRDZW50ZXJYID0gdGhpcy53aWR0aCAvIDI7XG4gICAgbGV0IGNsaWVudENlbnRlclkgPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgbGV0IGR4ID0gY2xpZW50Q2VudGVyWCAtIGNlbnRlclg7XG4gICAgbGV0IGR5ID0gY2xpZW50Q2VudGVyWSAtIGNlbnRlclk7XG5cbiAgICB0aGlzLnR3by5zY2VuZS50cmFuc2xhdGlvbi5zZXQoMCwgMCk7XG4gICAgdGhpcy50d28uc2NlbmUudHJhbnNsYXRpb24uc2V0KGR4LCBkeSk7XG4gIH1cblxuICBmaXRWaWV3KCkge1xuICAgIGxldCBjbGllbnRSZWN0ID0gdGhpcy5taW5kTWFwLmdldEJvdW5kaW5nQm94KCk7XG4gICAgbGV0IHNjYWxlWCA9IHRoaXMud2lkdGggLyBjbGllbnRSZWN0LndpZHRoO1xuICAgIGxldCBzY2FsZVkgPSB0aGlzLmhlaWdodCAvIGNsaWVudFJlY3QuaGVpZ2h0O1xuICAgIHRoaXMuc2NhbGUgPSBNYXRoLm1pbihzY2FsZVgsIHNjYWxlWSk7XG4gICAgdGhpcy50d28uc2NlbmUuc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgIHRoaXMuY2VudGVyVmlldygpO1xuICAgIHRoaXMudHdvLnVwZGF0ZSgpO1xuICB9XG5cbiAgdHJhbnNsYXRlQnkoZHgsIGR5KSB7XG4gICAgdGhpcy50d28uc2NlbmUudHJhbnNsYXRpb24uYWRkKGR4LCBkeSk7XG4gICAgdGhpcy50d28udXBkYXRlKCk7XG4gIH1cblxuICBiaW5kTW91c2VFdmVudCgpIHtcbiAgICB2YXIgc3RhZ2UgPSB0aGlzLnR3by5yZW5kZXJlci5kb21FbGVtZW50O1xuICAgIHN0YWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCAoZSkgPT4ge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIGR5ID0gZS5kZWx0YVkgLyAxMDA7XG4gICAgICB0aGlzLnpvb21CeShkeSwgZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgIH0pO1xuICB9XG5cbiAgYmluZE1vdXNlRHJhZygpIHtcbiAgICB2YXIgc3RhZ2UgPSB0aGlzLnR3by5yZW5kZXJlci5kb21FbGVtZW50O1xuXG4gICAgdmFyIG9uRHJhZyA9IChlKSA9PiB7XG4gICAgICBsZXQgZHggPSBlLm1vdmVtZW50WDtcbiAgICAgIGxldCBkeSA9IGUubW92ZW1lbnRZO1xuICAgICAgdGhpcy50cmFuc2xhdGVCeShkeCwgZHkpO1xuICAgIH07XG5cbiAgICB2YXIgb25EcmFnRW5kID0gKGUpID0+IHtcbiAgICAgIHN0YWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25EcmFnKTtcbiAgICAgIHN0YWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uRHJhZ0VuZCk7XG4gICAgfTtcblxuICAgIHN0YWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzdGFnZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uRHJhZyk7XG4gICAgICBzdGFnZS5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbkRyYWdFbmQpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0U3ZnRGF0YSgpIHtcbiAgICBsZXQgc3ZnVGV4dCA9IHRoaXMuY29udGFpbmVyLmlubmVySFRNTDtcbiAgICBpZiAoIXN2Z1RleHQubWF0Y2goL3htbG5zPVxcXCIvaW0pKSB7XG4gICAgICBzdmdUZXh0ID0gc3ZnVGV4dC5yZXBsYWNlKFxuICAgICAgICBcIjxzdmcgXCIsXG4gICAgICAgICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAnXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBzdmdUZXh0O1xuICB9XG5cbiAgZG93bmxvYWREYXRhQXNGaWxlKGRhdGEsIGZpbGVuYW1lKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImhyZWZcIiwgZGF0YSk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkb3dubG9hZFwiLCBmaWxlbmFtZSk7XG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICBlbGVtZW50LmNsaWNrKCk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgfVxuXG4gIGV4cG9ydFN2ZyhmaWxlbmFtZSA9IFwibWluZG1hcC5zdmdcIikge1xuICAgIHRoaXMuZG93bmxvYWREYXRhQXNGaWxlKFxuICAgICAgXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCxcIiArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmdldFN2Z0RhdGEoKSksXG4gICAgICBmaWxlbmFtZVxuICAgICk7XG4gIH1cblxuICBleHBvcnRQbmcoZmlsZW5hbWUgPSBcIm1pbmRtYXAucG5nXCIpIHtcbiAgICBsZXQgYmIgPSB0aGlzLm1pbmRNYXAuZ2V0Qm91bmRpbmdCb3goKTtcblxuICAgIC8vIGJhY2t1cCBjdXJyZW50IHZhbHVlXG4gICAgbGV0IHNjYWxlID0gdGhpcy50d28uc2NlbmUuc2NhbGU7XG4gICAgbGV0IHRyYW5zbGF0aW9uID0gdGhpcy50d28uc2NlbmUudHJhbnNsYXRpb24uY2xvbmUoKTtcblxuICAgIC8vIHNldCBzdmcgZnVsbCBzaXplXG4gICAgdGhpcy50d28uc2NlbmUuc2NhbGUgPSAxO1xuICAgIHRoaXMudHdvLnNjZW5lLnRyYW5zbGF0aW9uLnNldCgwLCAwKTtcbiAgICB0aGlzLnR3by53aWR0aCA9IGJiLndpZHRoO1xuICAgIHRoaXMudHdvLmhlaWdodCA9IGJiLmhlaWdodDtcblxuICAgIC8vIGdldCBzdmcgZGF0YVxuICAgIHRoaXMudHdvLnVwZGF0ZSgpO1xuICAgIGxldCBzdmdUZXh0ID0gdGhpcy5nZXRTdmdEYXRhKCk7XG5cbiAgICAvLyByZXN0b3JlIG9yaWdpbmFsIHNpemVcbiAgICB0aGlzLnR3by53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgdGhpcy50d28uaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy50d28uc2NlbmUuc2NhbGUgPSBzY2FsZTtcbiAgICB0aGlzLnR3by5zY2VuZS50cmFuc2xhdGlvbi5jb3B5KHRyYW5zbGF0aW9uKTtcbiAgICB0aGlzLnR3by51cGRhdGUoKTtcblxuICAgIGxldCBmaWxsID0gdGhpcy5taW5kTWFwLnRoZW1lLnN0eWxlLmdldEF0dHJpYnV0ZShcImJhY2tncm91bmQtY29sb3JcIik7XG4gICAgdGhpcy5zdmdUb1BuZyhzdmdUZXh0LCAwLCBmaWxsKS50aGVuKChkYXRhKSA9PlxuICAgICAgdGhpcy5kb3dubG9hZERhdGFBc0ZpbGUoZGF0YSwgZmlsZW5hbWUpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHNoYW1lbGVzc2x5IGNvcHkgZnJvbSBodHRwczovL3NpdGVzLmdvb2dsZS5jb20vYS9tY3BoZXIuY29tL3NoYXJlL0hvbWUvZXhjZWxxdWlya3MvZ2Fzc25pcHMvc3ZndG9wbmdcbiAgICogY29udmVydHMgYW4gc3ZnIHN0cmluZyB0byBiYXNlNjQgcG5nIHVzaW5nIHRoZSBkb21VcmxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN2Z1RleHQgdGhlIHN2Z3RleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttYXJnaW49MF0gdGhlIHdpZHRoIG9mIHRoZSBib3JkZXIgLSB0aGUgaW1hZ2Ugc2l6ZSB3aWxsIGJlIGhlaWdodCttYXJnaW4gYnkgd2lkdGgrbWFyZ2luXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZmlsbF0gb3B0aW9uYWxseSBiYWNrZ3J1bmQgY2FudmFzIGZpbGxcbiAgICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRvIHRoZSBiYXM2NCBwbmcgaW1hZ2VcbiAgICovXG4gIHN2Z1RvUG5nKHN2Z1RleHQsIG1hcmdpbiA9IDAsIGZpbGwgPSBudWxsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIGNvbnZlcnQgYW4gc3ZnIHRleHQgdG8gcG5nIHVzaW5nIHRoZSBicm93c2VyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIGNhbiB1c2UgdGhlIGRvbVVybCBmdW5jdGlvbiBmcm9tIHRoZSBicm93c2VyXG4gICAgICAgIHZhciBkb21VcmwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwgfHwgd2luZG93O1xuICAgICAgICBpZiAoIWRvbVVybCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIihicm93c2VyIGRvZXNudCBzdXBwb3J0IHRoaXMpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IG9yaWdpbmFsIHNpemVcbiAgICAgICAgdmFyIG1hdGNoID0gc3ZnVGV4dC5tYXRjaCgvaGVpZ2h0PVxcXCIoXFxkKykvbSk7XG4gICAgICAgIHZhciBoZWlnaHQgPSBtYXRjaCAmJiBtYXRjaFsxXSA/IHBhcnNlSW50KG1hdGNoWzFdLCAxMCkgOiAyMDA7XG4gICAgICAgIHZhciBtYXRjaCA9IHN2Z1RleHQubWF0Y2goL3dpZHRoPVxcXCIoXFxkKykvbSk7XG4gICAgICAgIHZhciB3aWR0aCA9IG1hdGNoICYmIG1hdGNoWzFdID8gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSA6IDIwMDtcblxuICAgICAgICAvLyBpdCBuZWVkcyBhIG5hbWVzcGFjZVxuICAgICAgICBpZiAoIXN2Z1RleHQubWF0Y2goL3htbG5zPVxcXCIvaW0pKSB7XG4gICAgICAgICAgc3ZnVGV4dCA9IHN2Z1RleHQucmVwbGFjZShcbiAgICAgICAgICAgIFwiPHN2ZyBcIixcbiAgICAgICAgICAgICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhIGNhbnZhcyBlbGVtZW50IHRvIHBhc3MgdGhyb3VnaFxuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGggKyBtYXJnaW4gKiAyO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICsgbWFyZ2luICogMjtcbiAgICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgLy8gbWFrZSBhIGJsb2IgZnJvbSB0aGUgc3ZnXG4gICAgICAgIHZhciBzdmcgPSBuZXcgQmxvYihbc3ZnVGV4dF0sIHtcbiAgICAgICAgICB0eXBlOiBcImltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOFwiLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjcmVhdGUgYSBkb20gb2JqZWN0IGZvciB0aGF0IGltYWdlXG4gICAgICAgIHZhciB1cmwgPSBkb21VcmwuY3JlYXRlT2JqZWN0VVJMKHN2Zyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IGltYWdlIHRvIGhvbGQgaXQgdGhlIGNvbnZlcnRlZCB0eXBlXG4gICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICAvLyB3aGVuIHRoZSBpbWFnZSBpcyBsb2FkZWQgd2UgY2FuIGdldCBpdCBhcyBiYXNlNjQgdXJsXG4gICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gZHJhdyBpdCB0byB0aGUgY2FudmFzXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLCBtYXJnaW4sIG1hcmdpbik7XG5cbiAgICAgICAgICAvLyBpZiBpdCBuZWVkcyBzb21lIHN0eWxpbmcsIHdlIG5lZWQgYSBuZXcgY2FudmFzXG4gICAgICAgICAgY29uc29sZS5sb2coZmlsbCk7XG4gICAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgc3R5bGVkLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgc3R5bGVkLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgc3R5bGVkQ3R4ID0gc3R5bGVkLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgIHN0eWxlZEN0eC5zYXZlKCk7XG4gICAgICAgICAgICBzdHlsZWRDdHguZmlsbFN0eWxlID0gZmlsbDtcbiAgICAgICAgICAgIHN0eWxlZEN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgc3R5bGVkQ3R4LnN0cm9rZVJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIHN0eWxlZEN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICBzdHlsZWRDdHguZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG4gICAgICAgICAgICBjYW52YXMgPSBzdHlsZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdGhlIG9yaWdpbmFsIGFueSBtb3JlXG4gICAgICAgICAgZG9tVXJsLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgICAgICAgIC8vIG5vdyB3ZSBjYW4gcmVzb2x2ZSB0aGUgcHJvbWlzZSwgcGFzc2luZyB0aGUgYmFzZTY0IHVybFxuICAgICAgICAgIHJlc29sdmUoY2FudmFzLnRvRGF0YVVSTCgpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBsb2FkIHRoZSBpbWFnZVxuICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChcImZhaWxlZCB0byBjb252ZXJ0IHN2ZyB0byBwbmcgXCIgKyBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBNaW5kbWFwVmlld2VyO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==